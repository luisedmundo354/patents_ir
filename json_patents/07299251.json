{
    "title": "Adaptive filter",
    "abstract": "An adaptive filter is implemented by a computer (",
    "inventors": [
        "Skidmore",
        "Proudler"
    ],
    "document_number": "07299251",
    "publication_date": "20071120",
    "assignees": [
        "Qinetiq Limited"
    ],
    "claims": [
        {
            "claim_number": "CLM-00001",
            "preamble": "1. An adaptive filter implemented by means of filter weights, the filter including means for providing a sequence of signal samples for application to the filter and means for updating the filter weights by means of a gain vector derived from interpolation residuals of the sequence of signal samples applied to the filter.",
            "components": []
        },
        {
            "claim_number": "CLM-00002",
            "preamble": "2. A method for adaptive filtering with filter weights comprising the steps of:",
            "components": [
                {
                    "component": "a) deriving interpolation residuals from a sequence of signal samples provided as data for filtering, and",
                    "subcomponents": []
                },
                {
                    "component": "b) updating the filter weights with a gain vector derived from the interpolation residuals.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00003",
            "preamble": "3. A method according to claim 2 wherein the gain vector is a Kalman gain vector.",
            "components": []
        },
        {
            "claim_number": "CLM-00004",
            "preamble": "4. A method for adaptive filtering including:",
            "components": [
                {
                    "component": "a) processing an input sequence of signal samples to derive prediction residuals;",
                    "subcomponents": []
                },
                {
                    "component": "b) converting prediction residuals to interpolation residuals;",
                    "subcomponents": []
                },
                {
                    "component": "c) deriving elements of a gain vector from the interpolation residuals; and",
                    "subcomponents": []
                },
                {
                    "component": "d) combining the gain vector with input and reference signals and update the filter coefficients or weights as required to provide adaptive filtering.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00005",
            "preamble": "5. A method according",
            "components": []
        },
        {
            "claim_number": "CLM-00006",
            "preamble": "6. A method according to claim 5 for obtaining prediction residuals by processing a sequence of signal samples using a recursive least squares lattice (RLSL) algorithm.",
            "components": []
        },
        {
            "claim_number": "CLM-00007",
            "preamble": "7. A method according to claim 4 including converting prediction residuals to interpolation residuals corresponding to gain vector elements by an iterative approach in which each iteration changes an index of a residual or of an intermediate quantity derived therefrom.",
            "components": []
        },
        {
            "claim_number": "CLM-00008",
            "preamble": "8. A method according to claim 7 wherein the iterative approach is a divide and conquer approach which treats prediction residuals as interpolation residuals and changes the index appropriately to convert the prediction residual to an interpolation residual providing an clement of the gain vector in un-normalised form.",
            "components": []
        },
        {
            "claim_number": "CLM-00009",
            "preamble": "9. A method according to claim 8 wherein the prediction residuals are least squares prediction residuals and the iterative approach treats the prediction residuals as interpolation residuals with zero values for one of two indices corresponding to absence of succeeding and preceding time series signal samples respectively and changes the zero index in each case sufficiently to convert the forward or backward residual to an interpolation residual which is also an element of the gain vector in un-normalised form.",
            "components": []
        },
        {
            "claim_number": "CLM-00010",
            "preamble": "10. A method according to claim 7 wherein the iterative approach also treats as an intermediate result an iteration in a sequence thereof leading to an element of the gain vector and changes an index of the intermediate result sufficiently to convert such result to an interpolation residual corresponding to an element of the gain vector.",
            "components": []
        },
        {
            "claim_number": "CLM-00011",
            "preamble": "11. A method according to claim 10 implementing a digital filter of order N where N is equal to 2",
            "components": [
                {
                    "component": "e) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or",
                    "subcomponents": []
                },
                {
                    "component": "f) one of which is an interpolation residual and the other a starting point for an earlier iteration, or",
                    "subcomponents": []
                },
                {
                    "component": "g) which are respectively starting and end points for an earlier iteration.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00012",
            "preamble": "12. A method according to claim 10 implementing a digital filter of order N where N is equal to a sum of integers each of which is a power of two, wherein the iterative approach involves treating the filter as a combination of filters each of order a respective power of two.",
            "components": []
        },
        {
            "claim_number": "CLM-00013",
            "preamble": "13. A method according to claim 12 including iteration in a sequence to generate an un-normalised element of the gain vector, the iteration beginning with use of one of two residuals immediately adjacent and on opposite sides of a halfway point the residual of use being that having a relatively higher value of an index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two sequence, and the relevant halfway point being halfway between two quantities:",
            "components": [
                {
                    "component": "h) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or",
                    "subcomponents": []
                },
                {
                    "component": "i) one of which is an interpolation residual and the other a starting point for an earlier iteration, or",
                    "subcomponents": []
                },
                {
                    "component": "j) which are respectively starting and end points for an earlier iteration.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00014",
            "preamble": "14. A method according to Claim",
            "components": [
                {
                    "component": "k) \u03b6(i)=\u03c8(i)+k(i)\u03be(i) are solved for \u03b6(i) and k(i) given \u03c8(i) and \u03be(i) subject to a constraint that in so doing there is minimisation of a sum of squares of \u03c8(j)+k(i)\u03be(j) obtained for different sample indexes j, where \u03b6(i) is an a posteriori interpolation residual, \u03c8(i) and \u03be(i) are a posteriori modified prediction and interpolation residuals respectively, and k(i) is a coefficient to be determined;",
                    "subcomponents": []
                },
                {
                    "component": "l) \u03c8(i)=\u03b6(i) \u2212k(i)\u03be(i) are solved for \u03c8(i) and \u03be(i) k(i) given \u03b6(i) and \u03be(i) subject to a constraint that in so doing the value of k(i) that is obtained is substantially that which would be obtained in solving \u03b6(i)=\u03c8(i)+k(i)\u03be(i) for \u03b6and k(i).",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00015",
            "preamble": "15. A method according to claim 14 wherein the QR decomposition employs square root free equivalents of sine and cosine rotation parameters.",
            "components": []
        },
        {
            "claim_number": "CLM-00016",
            "preamble": "16. A computer software product comprising a computer readable medium containing computer readable instructions for controlling operation of computer apparatus to implement an adaptive filter, wherein the computer readable instructions provide a means for controlling the computer apparatus to input a sequence of signal samples as data for filtering, and the computer readable instructions also provide a means for controlling the computer apparatus to generate updated filter weights by means of a gain vector derived from interpolation residuals of sequence of signal samples.",
            "components": []
        },
        {
            "claim_number": "CLM-00017",
            "preamble": "17. A computer software product according to claim 16 wherein the gain vector is a Kalman gain vector.",
            "components": []
        },
        {
            "claim_number": "CLM-00018",
            "preamble": "18. A computer software product comprising readable medium containing computer readable instructions for controlling operation of computer apparatus to implement an adaptive filter wherein the computer readable instructions provide a means for controlling the computer apparatus to:",
            "components": [
                {
                    "component": "m) process an input sequence of signal samples to derive prediction residuals;",
                    "subcomponents": []
                },
                {
                    "component": "n) convert prediction residuals to interpolation residuals corresponding to elements of a gain vector; and",
                    "subcomponents": []
                },
                {
                    "component": "o) derive elements of a gain vector from the interpolation residuals; and",
                    "subcomponents": []
                },
                {
                    "component": "p) combine the gain vector with input and reference signals and update the filter coefficients or weights as required to provide adaptive filtering.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00019",
            "preamble": "19. A computer software product according to claim 18 wherein the prediction residuals are least squares prediction residuals.",
            "components": []
        },
        {
            "claim_number": "CLM-00020",
            "preamble": "20. A computer software product according to claim 18 wherein the computer readable instructions provide a means for controlling the computer apparatus to obtain prediction residuals by processing a sequence of signal samples using a recursive least squares lattice (RLSL) algorithm.",
            "components": []
        },
        {
            "claim_number": "CLM-00021",
            "preamble": "21. A computer software product according to claim 18 wherein the computer readable instructions provide a means for controlling the computer apparatus to convert prediction residuals to interpolation residuals corresponding to gain vector elements by an iterative approach in which each iteration changes an index of a residual or of an intermediate quantity derived therefrom.",
            "components": []
        },
        {
            "claim_number": "CLM-00022",
            "preamble": "22. A computer software product according to claim 21 wherein the computer readable instructions provide a means for controlling the computer apparatus to implement the iterative approach by a divide and conquer approach which treats prediction residuals as interpolation residuals, and by proceeding with iteration until the index is changed appropriately to convert the prediction residual to an interpolation residual providing an element of the gain vector in un-normalised form.",
            "components": []
        },
        {
            "claim_number": "CLM-00023",
            "preamble": "23. A computer software product according to claim 22 wherein the prediction residuals are least squares prediction residuals and the computer readable instructions provide a means for controlling the computer apparatus to implement the iterative approach by treating the prediction residuals as interpolation residuals with zero values for one of two indices corresponding to absence of succeeding and preceding time series signal samples respectively, and by proceeding with iteration until the zero index in each ease is changed sufficiently to convert the forward or backward residual to an interpolation residual which is also an element of the gain vector in un-normalised form.",
            "components": []
        },
        {
            "claim_number": "CLM-00024",
            "preamble": "24. A computer software program according to claim 21 wherein the computer readable instructions provide a means for controlling the computer apparatus to implement the iterative approach by treating as an intermediate result an iteration in a sequence thereof leading to an element of the gain vector, and by proceeding with iteration until an index of the intermediate result is changed sufficiently to convert such result to an interpolation residual corresponding to an element of the gain vector.",
            "components": []
        },
        {
            "claim_number": "CLM-00025",
            "preamble": "25. A computer software product according to claim 24 for use in implementing a digital filter of order N where N is equal to 2",
            "components": [
                {
                    "component": "q) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or",
                    "subcomponents": []
                },
                {
                    "component": "r) one of which is an interpolation residual and the other a starting point for an earlier iteration, or",
                    "subcomponents": []
                },
                {
                    "component": "s) which are respectively starting and end points for an earlier iteration.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00026",
            "preamble": "26. A computer software product according to claim 24 for use in implementing a digital filter of order N where N is equal to a sum of integers each of which is a power of two, wherein the computer readable instructions provide a means for controlling the computer apparatus to implement the iterative approach by treating the filter as a combination of filters each of order a respective power of two.",
            "components": []
        },
        {
            "claim_number": "CLM-00027",
            "preamble": "27. A computer software product according to claim 26 wherein the computer readable instructions provide a means for controlling the computer apparatus to implement iteration in a sequence to generate an un-normalised element of the gain vector beginning with use of one of two residuals immediately adjacent and on opposite sides of a halfway point, the residual of use being that having a relatively higher value of an index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two quantities:",
            "components": [
                {
                    "component": "t) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or",
                    "subcomponents": []
                },
                {
                    "component": "u) one of which is an interpolation residual and the other a starting point for an earlier iteration, or",
                    "subcomponents": []
                },
                {
                    "component": "v) which are respectively staring and end points for an earlier iteration.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00028",
            "preamble": "28. A computer software product according to claim 18 wherein the computer readable instructions provide a means for controlling the computer apparatus to convert prediction residuals to interpolation residuals corresponding to elements of a gain vector by a QR decomposition approach in which equations of the form:",
            "components": [
                {
                    "component": "w) \u03b6(i)=\u03c8(i)+k(i)\u03be(i) are solved for \u03b6(i) and k(i) given \u03c8(i) and \u03be(i) subject to a constraint that in so doing there is minimization of a sum of squares of \u03c8(j)+k(i)\u03be(j) obtained for different sample indexes j, where \u03b6(i) is an a posteriori interpolation residual, \u03c8(i) and \u03be(i) are a posteriori modified prediction and interpolation residuals respectively, and k(i) is a coefficient to be determined; and",
                    "subcomponents": []
                },
                {
                    "component": "x) \u03c8(i)=\u03b6(i) \u2212k(i)\u03be(i) are solved for \u03c8(i) and \u03be(i) k(i) given \u03b6(i) and \u03be(i) subject to a constraint that in so doing the value of k(i) that is obtained is substantially that which would be obtained in solving \u03b6(i)=\u03c8(i)+k(i)\u03be(i) for \u03b6and k(i).",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00029",
            "preamble": "29. A computer software product according to claim 28 wherein the QR decomposition employs square root free equivalents of sine and cosine rotation parameters.",
            "components": []
        }
    ],
    "description": [
        "This invention relates to an adaptive filter and to a method and a computer program for implementing it.",
        "Filtering is one of the most common procedures in signal processing. A filter processes a signal or signals at its input to produce an output signal having certain desirable characteristics. The exact form which these characteristics take is determined by the values taken by certain filter parameters. In a linear filter, the output is a weighted linear combination of the input signals and delayed versions thereof as generated by a tapped delay-line. The filter has controllable parameters which are weights used to weight this linear combination.",
        "One known form of filter is a time-series filter (or transversal filter, which might be adaptive) with only one input signal. The filter forms a linear combination of delayed versions of the signal. The filter weights may be chosen to select or reject different frequency components of the input signal. Another form of filter is a phased array radar beamformer: in receive mode such a beamformer receives signals from an array of spatially separated sensors, the signals being generated in response to reception of radar waves reflected from a scene. The filter weights may be chosen, for example, to select or reject components of the sensor array signals depending on the radar wave direction of arrival at the sensors: such a beamformer is said to be a spatial filter because of its spatially selective properties. A sonar array beamformer is a related example of a spatial filter: here in receive mode signals from an array of sonar transducers and delayed versions of these signals constitute the input to the filter. By varying the filter weights, the sonar beamformer can select or reject signals based on both direction of arrival and frequency. Radar and sonar beamformers are also operative in a transmit mode in which filter techniques may be used to configure the transmitted beam.",
        "A finite impulse response (FIR) filter, or transversal filter, is a known form of filter which may be implemented in hardware as a tapped delay line comprising a series-connected set of clock-activated registers each associated with a respective multiplier and multiplicative coefficient. Increasingly though FIR filters are implemented equivalently in software running on a computer system and accepting data from a sensor after conversion from analogue to digital electronic form. In a delay line version, a sequence of data elements x(i), where i denotes a clock cycle index, is clocked along the line, each register holding one element at a time. The total number m of data elements is very much larger than the number N of registers, so only N successive elements occupy the line at any time. The line is occupied by data elements x(1) to x(N) on the Nth clock cycle. Clocking the line advances the sequence by one register, so that the leading element leaves one end of the line and a new element is introduced at the other. On the pth clock cycle the line is occupied by data elements x(p\u2212N+1) to x(p). On each clock cycle the data element in each register is multiplied by the respective filter coefficient in the associated multiplier in each case (wi for the ith register, i=1 to N), and the resulting products are added to form a result which is ZN(p) for the pth cycle.I.e.:",
        "z\n            N\n          \n          \u2061\n          \n            (\n            p\n            )\n          \n        \n        =\n        \n          \n            \u2211\n            \n              i\n              =\n              1\n            \n            N\n          \n          \u2062\n          \n            \n              w\n              i\n            \n            \u2062\n            \n              x\n              \u2061\n              \n                (\n                \n                  p\n                  -\n                  i\n                  +\n                  1\n                \n                )\n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        1\n        )",
        "Equation (1) may alternatively be expressed as the scalar (dot) product of a weight vector w having elements w1 to wN (the transversal filter coefficients or weights) and a data vector xN(p) having elements x(p) to x(p\u2212N+1):\n\nzN(p)=wTxN(p)\u2003\u2003(2)\n\nwhere the superscript index T indicates a vector transpose.",
        "It is a common requirement to obtain meaningful information from a set of data containing unwanted noise or other corrupting components in addition to a useful signal, and it is known to use linear filtering for this to improve signal to noise ratio. However, the choice of filter is difficult if not impossible if noise and signal characteristics are unknown: it then becomes desirable to use an adaptive filter with characteristics which are modifiable in response to data input to the system: in this regard filter adaptivity is important so that the filter properties will be determined from input data to be filtered, instead of a priori from making an estimate or assumption regarding the data characteristics. Filter adaptivity is realised by an adaptive filter with coefficients and therefore also properties which can be changed.",
        "Adaptive filters have applications in fields such as radar and sonar as mentioned above, and also in communications and processing of images and speech. They can be used inter alia to perform channel equalisation, signal detection (i.e. matched filtering), acoustic echo cancellation and adaptive noise cancellation.",
        "A typical example of an adaptive filter is that of an echo canceller in a \u2018hands-free\u2019 telephone system. Here a telephone microphone picks up not only speech from a person making the call, but also that of a recipient of the call whose speech is output by the telephone's loudspeaker. If no corrective action is taken the recipient's speech is also sent to the recipient and appears as an echo. If the recipient is using a hands-free telephone then the reply may be returned to the caller and positive feedback or \u2018howl around\u2019 may result.",
        "The echo may be removed by an adaptive filter. The telephone's loudspeaker is driven by a speech signal x(t) which becomes an input signal to the filter, and a reference signal y(t) is picked up by the telephone's microphone. The filter coefficients are adjusted adaptively to cancel the echo signal in y(t). Once the echo is removed, the residual signal, which contains only the caller's speech, is transmitted to the telephone call recipient. This residual signal may be termed an error signal eN(t), and it is used in adjusting the filter coefficients as will be described later.",
        "There has been considerable work on the development of digital signal processing algorithms for adaptive filtering. There are two broad classes of algorithm: block-based algorithms and recursive algorithms. The former are used to process data in finite length blocks and the latter are used for processing a continuous data stream. The choice of algorithm depends on the intended field of use but for many problems recursive algorithms are more attractive.",
        "For many years only two types of recursive adaptive filtering algorithms were known: Stochastic Gradient Descent (SGD) algorithms and Recursive Least Squares (RLS) algorithms. More recently recursive adaptive filtering algorithms of a new type have been introduced, and can be viewed as being hybrids of SGD and RLS algorithms.",
        "An SGD algorithm (as typified by the well known Least Mean Squares (LMS) algorithm) requires very few mathematical operations per time instant and is robust to finite precision numerical effects, i.e. large fractional errors in small digital quantities; unfortunately the LMS algorithm is, in most cases, very slow to converge to an optimum solution.",
        "RLS algorithms on the other hand are very quick to converge. However they require more mathematical operations per unit time, and this can make them completely impractical. For example, a filter for a hands-free telephone would require 4,000,000 floating-point arithmetic operations (flops) in one clock cycle of 100 \u03bcsec, equivalent to 4\u00d71010 flops/sec, which is not currently achievable using a single computer processor.",
        "Furthermore RLS algorithms may exhibit mathematical instability; i.e. they may fail to operate properly due finite precision numerical effects, such as division by small inaccurate quantities: e.g. an eight-bit number may be inaccurate as regards the value of the least significant bit; if all bits of this number of other than the least significant bit are zero, i.e. the number is 00000001, then inaccuracy can lead to it becoming 00000000: the calculation may then involve division by zero.",
        "A further consideration is that some RLS algorithms do not calculate the required filter coefficients explicitly but instead related quantities which are less useful for some applications.",
        "A new class of hybrid algorithm was introduced in order to address the conflicting problems of convergence speed and computational burden. Examples are the Affine Projection algorithm and the Fast Newton algorithm. Here an LMS-type algorithm and an RLS algorithm work together to solve the adaptive filtering problem. The RLS algorithm is used to solve a problem that is much smaller than the original adaptive filter problem and hence does not present too much additional computational load. Together the LMS and RLS algorithms allow the adaptive filter to converge more quickly than the LMS on its own but usually not as fast as a proper RLS-based adaptive filter. These algorithms suffer from the fact that the RLS component to the algorithm can become numerically unstable.",
        "At present there are three classes of RLS algorithms: quadratic RLS algorithms, fast transversal filter algorithms and RLS lattice algorithms. Quadratic RLS algorithms can be numerically stable but they have the disadvantage that, for a problem with N unknown coefficients to be determined, they require a number of mathematical operations per clock cycle that is proportional to N2. For applications with large N (e.g. the acoustic echo cancellation problem where typically N=2000) this results in expensive hardware or is even impractical given current technology.",
        "Fast transversal filter algorithms and RLS lattice algorithms on the other hand only require a number of mathematical operation per clock cycle that is proportional to N (termed \u2018fast\u2019 algorithms). Unfortunately, fast transversal filter algorithms are virtually unusable for large problems, due their numerical instability, i.e. sensitivity to finite precision numerical effects arising from inaccuracies and rounding errors in calculations. Moreover, although it is possible for RLS lattice algorithms to be numerically stable, they do not produce the most desirable parameters (the filter coefficients) directly.",
        "In summary, RLS algorithms have optimal performance to the extent that they calculate the optimal set of filter coefficients (or related quantities) at all times. For a single channel problem of order N, i.e. having a number N of quantities to be determined, RLS algorithms fall into three categories:\n\n    \n    \n        O(N2) algorithms: computationally expensive\u2014prohibitively so for large values of N;\n        O(N) LS Lattice algorithms: computationally inexpensive (fast) but transversal filter weights are difficult to extract;\n        O(N) Fast Transversal Filter algorithms: computationally inexpensive (fast) but numerically unstable;\n\nhere \u201cO\u201d indicates the order of magnitude (N or N2) of the number of calculations to be performed per clock cycle as being that in the associated parentheses in each case.",
        "Regardless of the field of application, most adaptive filtering applications demand the use of an algorithm with as high a performance but as low a complexity as possible. However, it is a prerequisite that the algorithm be numerically stable at least for all practical intents. Furthermore, many adaptive filtering applications require the actual filter weights themselves, not some other related parameters. In the prior art there is no RLS algorithm for an adaptive filter with these properties when the input to the filter consists of, in part or whole, delayed versions of one or more signals.",
        "It is an object of this invention to provide an alternative form of adaptive filter.",
        "The present invention provides an adaptive filter characterised in that it is arranged to update filter weights by means of a gain vector derived from interpolation residuals of a sequence of signal samples applied to the filter.",
        "In this connection, a \u2018Kalman\u2019 gain vector is known in the prior art for the purposes of updating adaptive filter weights or coefficients, although not its derivation from interpolation residuals. An interpolation residual is one kind of prediction residual: a prediction residual is the difference between a directly obtained data element and a prediction of that element extrapolated from other data associated with it. An interpolation residual is obtained using data both preceding and following the data element. There are also forward and backward prediction residuals obtained using forward and backward extrapolation respectively from a directly obtained element.",
        "The invention provides a number of advantages: it is an alternative form of adaptive filter; unlike prior art filters based on RLS lattice algorithms, the required filter weights are derived directly, not some other related parameters, and the invention can be implemented with an RLS algorithm or an algorithm with reduced computational load based on a simplifying assumption regarding the characteristics of the signal samples. There are also good theoretical reasons indicating that the invention is expected to provide results that are more numerically robust than alternative approaches.",
        "In a preferred embodiment, the present invention also provides an adaptive filter characterised in that it is arranged to:\n\n    \n    \n        a) process an input sequence of signal samples to derive prediction residuals;\n        b) convert prediction residuals to interpolation residuals,\n        c) derive elements of a gain vector from the interpolation residuals; and\n        d) combine the gain vector with input and reference signals and update the filter coefficients or weights as required to provide adaptive filtering.",
        "The gain vector may be a Kalman gain vector. The prediction residuals may be least squares prediction residuals, and these may be obtained by processing a sequence of signal samples using a recursive least squares lattice algorithm.",
        "Prediction residuals may be converted to interpolation residuals corresponding to gain vector elements by an iterative approach in which each iteration changes an index (to be defined later) of a residual or of an intermediate quantity derived therefrom. The iterative approach may be a divide and conquer approach implemented by treating prediction residuals as interpolation residuals, iteration being arranged to proceed until the index is changed appropriately to convert the prediction residual to an interpolation residual providing an element of the gain vector in un-normalised form.",
        "The iterative approach may be implemented by treating prediction residuals as interpolation residuals with zero values for one of two indices: this corresponds to an absence of succeeding or preceding time series signal samples. The iterations are arranged to proceed until the zero index in each case is changed sufficiently to convert the forward or backward residual to an interpolation residual which is also an element of the gain vector in un-normalised form. It may also involve treating as an intermediate result an iteration in a sequence thereof leading to an element of the un-normalised gain vector, iteration being arranged to proceed until an index of the intermediate result is changed sufficiently to convert such result to an interpolation residual corresponding to an element of the gain vector.",
        "For an adaptive filter of order N where N is equal to 2x and x is a positive integer, iteration in a sequence to generate an un-normalised element of the gain vector may begin with use of one of two residuals immediately adjacent and on opposite sides of a halfway point, the residual of use being that having a relatively higher value of the index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two quantities:\n\n    \n    \n        a) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or\n        b) one of which is an interpolation residual and the other a starting point for an earlier iteration, or\n        c) which are respectively starting and end points for an earlier iteration.",
        "For an adaptive filter of order N where N is not a power of two, the iterative approach may still be used but will involve treating the filter weight vector as a combination of weight vectors of non-equal orders e.g. if N is equal to a sum of integers each of which is a power of two, the filter can be treated as a combination of filters each of order a respective power of two.",
        "Iteration in a sequence to generate an un-normalised element of a gain vector may begin with use of one of two residuals immediately adjacent and on opposite sides of a halfway point, the residual of use being that having a relatively higher value of the index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two quantities:\n\n    \n    \n        a) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or\n        b) one of which is an interpolation residual and the other a starting point for an earlier iteration, or\n        c) which are respectively starting and end points for an earlier iteration.",
        "The filter of the invention may arranged to convert prediction residuals to interpolation residuals corresponding to elements of a gain vector by a QR decomposition approach in which equations of the form:\n\n    \n    \n        a) \u03b6(i)=\u03c8(i)+k(i)\u03be(i) are solved for \u03b6(i) and k(i) given \u03c8(i) and \u03be(i) subject to a constraint that in so doing there is minimisation of a sum of squares of \u03c8(j)+k(i)\u03be(j) obtained for different sample indexes j; and\n        b) \u03c8(i)=\u03b6(i)\u2212k(i)\u03be(i) are solved for \u03c8(i) and k(i) given \u03b6(i) and \u03be(i) subject to a constraint that in so doing the value of k(i) that is obtained is substantially that which would be obtained in solving \u03b6(i)=\u03c8(i)+k(i)\u03be(i) for \u03b6(i) and k(i).",
        "QR decomposition may be arranged to employ square root free equivalents of sine and cosine rotation parameters.",
        "In an alternative aspect, the present invention provides a method for adaptive filtering characterised in that it includes updating filter weights with a gain vector derived from interpolation residuals of a sequence of signal samples provided as data for filtering.",
        "In a preferred embodiment, the method of the invention includes:\n\n    \n    \n        a) processing an input sequence of signal samples to derive prediction residuals;\n        b) converting prediction residuals to interpolation residuals;\n        c) deriving elements of a gain vector from the interpolation residuals; and\n        d) combining the gain vector with input and reference signals and update the filter coefficients or weights as required to provide adaptive filtering.",
        "The prediction residuals may be least squares prediction residuals obtained by processing a sequence of signal samples using a recursive least squares lattice algorithm.",
        "Prediction residuals may be converted to interpolation residuals corresponding to gain vector elements by an iterative approach in which each iteration changes an index (to be defined later) of a residual or of an intermediate quantity derived therefrom. The iterative approach may be a divide and conquer approach which treats prediction residuals as interpolation residuals and changes the index appropriately to convert the prediction residual to an interpolation residual providing an element of the gain vector in un-normalised form. It may treat prediction residuals as interpolation residuals with zero values for one of two indices: this corresponds to absence of succeeding or preceding time series signal samples, and changes the zero index in each case sufficiently to convert the forward or backward residual to an interpolation residual which is also an element of the gain vector in un-normalised form",
        "The iterative approach may also treat as an intermediate result an iteration in a sequence thereof leading to an element of the gain vector and changes an index of the intermediate result sufficiently to convert such result to an interpolation residual corresponding to an element of the gain vector.",
        "The filtering method may implement filtering of order N where N is equal to 2x and x is a positive integer, characterised in that it includes iteration in a sequence to generate an un-normalised element of the gain vector, the iteration beginning with use of one of two residuals immediately adjacent and on opposite sides of a halfway point, the residual of use being that having a relatively higher value of an index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two quantities:\n\n    \n    \n        a) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or\n        b) one of which is an interpolation residual and the other a starting point for an earlier iteration, or\n        c) which are respectively starting and end points for an earlier iteration.",
        "The filtering method may implement filtering of order N where N is not a power of two, characterised in that the iterative approach involves treating the filter as a combination of weight vectors each of order a respective power of two. It may include iteration in a sequence to generate an un-normalised element of the gain vector, the iteration beginning with use of one of two residuals immediately adjacent and on opposite sides of a halfway point, the residual of use being that having a relatively higher value of an index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two quantities:\n\n    \n    \n        a) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or\n        b) one of which is an interpolation residual and the other a starting point for an earlier iteration, or\n        c) which are respectively starting and end points for an earlier iteration.",
        "Prediction residuals may be converted to interpolation residuals corresponding to elements of a gain vector by a QR decomposition approach in which equations of the form:\n\n    \n    \n        a) \u03b6(i)=\u03c8(i)+k(i)\u03be(i) are solved for \u03b6(i) and k(i) given \u03c8(i) and \u03be(i) subject to a constraint that in so doing there is minimisation of a sum of squares of \u03c8(j)+k(i)\u03be(j) obtained for different sample indexes j; and\n        b) \u03c8(i)=\u03b6(i)\u2212k(i)\u03be(i) are solved for \u03c8(i) and k(i) given \u03b6(i) and \u03be(i) subject to a constraint that in so doing the value of k(i) that is obtained is substantially that which would be obtained in solving \u03b6(i)=\u03c8(i)+k(i)\u03be(i) for \u03b6(i) and k(i).",
        "QR decomposition may employ square root free equivalents of sine and cosine rotation parameters.",
        "In a further aspect, the present invention provides a computer program for implementing an adaptive filter characterised in that it is arranged to generate updated filter weights by means of a gain vector derived from interpolation residuals of a sequence of signal samples provided as data for filtering.",
        "In a preferred embodiment, the present invention provides a computer program for implementing an adaptive filter characterised in that it is arranged to:\n\n    \n    \n        a) process an input sequence of signal samples to derive prediction residuals;\n        b) convert prediction residuals to interpolation residuals;\n        c) derive elements of a gain vector from the interpolation residuals; and\n        d) combine the gain vector with input and reference signals and update the filter coefficients or weights as required to provide adaptive filtering.",
        "The computer program may be arranged to convert prediction residuals to interpolation residuals corresponding to gain vector elements by an iterative approach in which each iteration changes an index, to be defined later, of a residual or of an intermediate quantity derived therefrom. The iterative approach may be a divide and conquer approach implemented by treating prediction residuals as interpolation residuals, and wherein iteration is arranged to proceed until the index is changed appropriately to convert the prediction residual to an interpolation residual providing an element of the gain vector in un-normalised form. It may be implemented by treating the prediction residuals as interpolation residuals with zero values for one of two indices. This corresponds to absence of succeeding or preceding time series signal samples, and wherein iteration is arranged to proceed until the zero index in each case is changed sufficiently to convert the forward or backward residual to an interpolation residual which is also an element of the gain vector in un-normalised form.",
        "The iterative approach may also involve treating as an intermediate result an iteration in a sequence thereof leading to an element of the gain vector, wherein iteration is also arranged to proceed until an index of the intermediate result is changed sufficiently to convert such result to an interpolation residual corresponding to an element of the gain vector.",
        "The computer program may implement a adaptive filter of order N where N is equal to 2x and x is a positive integer, characterised in that iteration in a sequence to generate an un-normalised element of the gain vector begins with use of one of two residuals immediately adjacent and on opposite sides of a halfway point, the residual of use being that having a relatively higher value of an index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two quantities:\n\n    \n    \n        a) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or\n        b) one of which is an interpolation residual and the other a starting point for an earlier iteration, or\n        c) which are respectively starting and end points for an earlier iteration.",
        "The computer program may implement a adaptive filter of order N where N is not a power of two, characterised in that the iterative approach involves treating the weight vector as a combination of weight vectors each of order a respective power of two.",
        "Iteration in a sequence to generate an un-normalised element of the gain vector may begin with use of one of two residuals immediately adjacent and on opposite sides of a halfway point, the residual of use being that having a relatively higher value of an index not to be altered in the iteration sequence, and the relevant halfway point being halfway between two quantities:\n\n    \n    \n        a) one of which is an interpolation residual and the other a member of the relevant time series for which the gain vector is generated, or\n        b) one of which is an interpolation residual and the other a starting point for an earlier iteration, or\n        c) which are respectively starting and end points for an earlier iteration.",
        "The computer program may be arranged to convert prediction residuals to interpolation residuals corresponding to elements of a gain vector by a QR decomposition approach in which equations of the form:\n\n    \n    \n        a) \u03b6(i)=\u03c8(i)+k(i)\u03be(i) are solved for \u03b6(i) and k(i) given \u03c8(i) and \u03be(i) subject to a constraint that in so doing there is minimisation of a sum of squares of \u03c8(j)+k(i)\u03be(j) obtained for different sample indexes j; and\n        b) \u03c8(i)=\u03b6(i)\u2212k(i)\u03be(i) are solved for \u03c8(i) and k(i) given \u03b6(i) and \u03be(i) subject to a constraint that in so doing the value of k(i) that is obtained is substantially that which would be obtained in solving \u03b6(i)=\u03c8(i)+k(i)\u03be(i) for \u03b6(i) ad \u03b6(i).",
        "QR decomposition may be arranged to employ square root free equivalents of sine and cosine rotation parameters.",
        "In order that the invention might be more fully understood, an embodiment thereof will now be described, by way of example only, with reference to the accompanying drawings, in which:",
        "FIG. 1 is a block diagram of an adaptive filter of the invention;",
        "FIG. 2 shows four successive stages of a recursive least squares lattice algorithm indicated in FIG. 1;",
        "FIGS. 3 and 4 illustrate conversion of a first interpolation residual into a second such residual with a relative change of unity in an index;",
        "FIGS. 5 to 7 illustrate a \u201cdivide and conquer\u201d approach to reducing computational load in a filter of the invention; and",
        "FIG. 8 illustrates weight updating in a hardware version of the invention.",
        "In those prior art RLS algorithms which are not Lattice algorithms, what is referred to as the \u2018Kalman gain\u2019 vector kN(t) is used to update N adaptive filter coefficients on receipt of each of successive input signals forming a time series, i.e. a series of data values representing the variation of an input signal x(t) as a function of time t. Here t is in units of an interval between successive digital signal samples (clock cycles), and has integer values 1, 2 etc.",
        "Designating the vector of adaptive filter coefficients at times t and t\u22121 as wN(t) and wN(t\u22121), where N is the number of filter coefficients (the order of the filter), then an operation to update filter coefficients adaptively in response to input of a new signal sample is defined by:\n\nwN(t)=wN(t\u22121)+eN(t)kN(t)\u2003\u2003(3)\n\nwhere:\n\neN(t)=y(t)\u2212wNT(t\u22121)xN(t)\u2003\u2003(4)\n\nand is known as the a priori error, xN(t) is a vector with elements consisting of input signal values from x(t) to x(t\u2212N+1) as discussed above, superscript index T indicates a matrix transpose and y(t) is the most recent value of a reference signal detected for use in adaptive filtration as mentioned earlier in the example of a hands-free telephone system: xN(t) and y(t) are therefore known quantities. The Kalman gain vector kN(t) is conventionally defined as:",
        "k\n              _\n            \n            N\n          \n          \u2061\n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          \n            \n              M\n              XX\n              \n                -\n                1\n              \n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n          \u2062\n          \n            \n              \n                x\n                _\n              \n              N\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n        \n      \n    \n    \n      \n        (\n        5\n        )\n      \n    \n  \n\n\n\n\nwhere Mxx (t) is a covariance matrix of input signals given by:",
        "M\n              XX\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n          =\n          \n            \n              \u2211\n              \n                i\n                =\n                0\n              \n              \n                \n                  L\n                  t\n                \n                -\n                1\n              \n            \n            \u2062\n            \n              \n                \u03b2\n                1\n                \n                  2\n                  \u2062\n                  i\n                \n              \n              \u2062\n              \n                \n                  \n                    x\n                    _\n                  \n                  N\n                \n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    i\n                  \n                  )\n                \n              \n              \u2062\n              \n                \n                  \n                    x\n                    _\n                  \n                  N\n                  T\n                \n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    i\n                  \n                  )\n                \n              \n            \n          \n        \n        ,\n      \n    \n    \n      \n        (\n        6\n        )\n      \n    \n  \n\n\n\n\nxN(t\u2212i) is a N-dimensional (column) vector with elements consisting of input signal values from x(t\u2212i) to x(t\u2212i\u2212N+1) as discussed above, and xNT(t\u2212i) is its transpose (row vector). The parameter L1 determines the number of samples that are included in the summation. Sometimes L1 is chosen to be a fixed number and sometimes it is arranged to vary with time: e.g. L1=t+1 is common. The Equation (6) summation could also start from a non-zero value of i if it were decided to discard the most recent data values. The term \u03b21 is what is referred to as a \u201cforget factor\u201d: it has a value in the range 0<\u03b21\u22661, normally 0.99<\u03b21<1.0, and it decrements data elements so that the most recent data element x(t) is undecremented, that immediately preceding it is decremented once, the next twice and so on with the nth preceding it decremented n times. The effect of this is to bias the Equation (6) summation in favour of more recent data: i.e. it reduces the value of a data element each time the latter is used so that older data has progressively less influence on the solution compared to more recent data. Use of forget factors in signal processing is known, see e.g. U.S. Pat No. 4,727,503 to McWhirter.",
        "Most RLS algorithms that use the Kalman gain vector calculate it using the above formulation or something related.",
        "However, it has been discovered in accordance with the invention that the ith element kiN(t) of the Nth order Kalman gain vector kN(t) for a signal at time t is also given by:",
        "k\n            i\n            N\n          \n          \u2061\n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          \n            \n              \u025b\n              \n                \n                  N\n                  -\n                  i\n                \n                ,\n                \n                  i\n                  -\n                  1\n                \n              \n            \n            \u2061\n            \n              (\n              \n                t\n                -\n                i\n                +\n                1\n              \n              )\n            \n          \n          \n            \n              E\n              \n                \n                  N\n                  -\n                  i\n                \n                ,\n                \n                  i\n                  -\n                  1\n                \n              \n            \n            \u2061\n            \n              (\n              \n                t\n                -\n                i\n                +\n                1\n              \n              )\n            \n          \n        \n      \n    \n    \n      \n        (\n        7\n        )",
        "where \u03b5N\u2212i,i\u22121(t\u2212i+1) is what is referred to as an a posteriori least squares interpolation residual whose definition and derivation is described later. EN\u2212i,i\u22121(t\u2212i+1) is a normalisation factor (also described later) corresponding to the power of the interpolation residual \u03b5N\u2212i,i\u22121(t\u2212i+1). Equation (7) indicates that the time parameter (i.e. t\u2212i+1) of the terms on its right hand side depends on the index i of the ith element kiN(t), and therefore the time parameter varies from element to element of the Kalman gain vector kN(t).",
        "Changing indices for convenience, for a signal element x(t\u2212\u0192) in a sequence comprising a time series x(1) to x(t), a least squares interpolation residual is designated \u03b5p,\u0192(t\u2212\u0192): the indices p and \u0192indicate that p signal elements before x(t\u2212\u0192) and f signal elements after it in the time series are used in the interpolation: this interpolation residual is derived by subtracting from the element x(t\u2212\u0192) itself an estimated interpolation or prediction of it derived from the signal elements both before (a total of p) and after (a total of f) it in the time series. An interpolation for the signal element x(t\u2212\u0192) is given by a weighted linear combination or summation of p elements before it: x(t\u2212\u0192\u2212p) to x(t\u2212\u0192\u22121) inclusive, together with a second such combination of the f elements after it: x(t\u2212\u0192+1) to x(t). The least squares interpolation residual for the signal element x(t\u2212\u0192) is then the difference between the element and the interpolation,",
        "i\n          .\n          e\n          .\n          \n            \n          \n          \u2062\n          \n            \n              \u025b\n              \n                p\n                ,\n                f\n              \n            \n            \u2061\n            \n              (\n              \n                t\n                -\n                f\n              \n              )\n            \n          \n        \n        =\n        \n          \n            x\n            \u2061\n            \n              (\n              \n                t\n                -\n                f\n              \n              )\n            \n          \n          -\n          \n            \n              \u2211\n              \n                i\n                =\n                1\n              \n              f\n            \n            \u2062\n            \n              \n                \n                  \n                    w\n                    ^\n                  \n                  \n                    p\n                    ,\n                    f\n                    ,\n                    i\n                  \n                \n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    f\n                  \n                  )\n                \n              \n              \u2062\n              \n                x\n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    i\n                    +\n                    1\n                  \n                  )\n                \n              \n            \n          \n          -\n          \n            \n              \u2211\n              \n                i\n                =\n                \n                  f\n                  +\n                  1\n                \n              \n              \n                f\n                +\n                p\n              \n            \n            \u2062\n            \n              \n                \n                  \n                    w\n                    ^\n                  \n                  \n                    p\n                    ,\n                    f\n                    ,\n                    i\n                  \n                \n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    f\n                  \n                  )\n                \n              \n              \u2062\n              \n                x\n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    i\n                  \n                  )\n                \n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        8\n        )\n      \n    \n  \n\n\n\n\nwhere the vector \u0175p,\u0192(t\u2212\u0192) has (p+f) dimensions and contains adjustable coefficients \u0175p,\u0192,i(t\u2212\u0192) (i=1 to f+p) and the summation terms are the weighted linear combinations. The reference to \u201cleast squares\u201d indicates that these coefficients are those that would be produced by any least squares optimisation procedure. In a preferred embodiment of this invention, these coefficients are never calculated and the interpolation residuals are calculated via an alternative method as will be described later. Nevertheless, the least squares minimisation procedure involves determining coefficients in \u0175p,\u0192(t\u2212\u0192) in such a way as to minimise a sum of a preselected number L2 of the squares of the residuals determined up to and including the most recent residual, i.e. \u0175p,\u0192(t\u2212\u0192) is the value of the vector \u03c9 that minimises:",
        "J\n            \n              \n                p\n                .\n              \n              ,\n              f\n            \n          \n          \u2061\n          \n            (\n            \n              t\n              -\n              f\n            \n            )\n          \n        \n        =\n        \n          \n            \u2211\n            \n              n\n              =\n              0\n            \n            \n              \n                L\n                2\n              \n              -\n              1\n            \n          \n          \u2062\n          \n            \n              \n                \u03b2\n                2\n                \n                  2\n                  \u2062\n                  n\n                \n              \n              \u2061\n              \n                (\n                \n                  \n                    x\n                    \u2061\n                    \n                      (\n                      \n                        t\n                        -\n                        n\n                        -\n                        f\n                      \n                      )\n                    \n                  \n                  -\n                  \n                    \n                      \u2211\n                      \n                        i\n                        =\n                        1\n                      \n                      f\n                    \n                    \u2062\n                    \n                      \n                        \u03c9\n                        i\n                      \n                      \u2062\n                      \n                        x\n                        \u2061\n                        \n                          (\n                          \n                            t\n                            -\n                            n\n                            -\n                            i\n                            +\n                            1\n                          \n                          )\n                        \n                      \n                    \n                  \n                  -\n                  \n                    \n                      \u2211\n                      \n                        i\n                        =\n                        \n                          f\n                          +\n                          1\n                        \n                      \n                      \n                        f\n                        +\n                        p\n                      \n                    \n                    \u2062\n                    \n                      \n                        \u03c9\n                        i\n                      \n                      \u2062\n                      \n                        x\n                        \u2061\n                        \n                          (\n                          \n                            t\n                            -\n                            n\n                            -\n                            i\n                          \n                          )\n                        \n                      \n                    \n                  \n                \n                )\n              \n            \n            2\n          \n        \n      \n    \n    \n      \n        (\n        9\n        )",
        "As L1 above, L2 may be chosen to be invariant or may vary with time: \u03b22 is a \u201cforget factor\u201d like \u03b21 previously discussed.",
        "Referring to Equation (7) once more, as has been said EN\u2212i,i\u22121(t\u2212i+1) is a normalisation factor which corresponds to the power of the interpolation residual signal \u03b5N\u2212i,i\u22121(t\u2212i+1): it can be calculated from the interpolation residuals themselves. There are many ways in which this can be done such as by forming a sum of a preselected number L3 of the product of the a posteriori residuals and what are referred to as a priori residuals, which are defined below, and are determined up to including the most recent time instant, i.e.:",
        "E\n            \n              \n                N\n                -\n                i\n              \n              ,\n              \n                i\n                -\n                1\n              \n            \n          \n          \u2061\n          \n            (\n            \n              t\n              -\n              i\n              +\n              1\n            \n            )\n          \n        \n        =\n        \n          \n            \u2211\n            \n              n\n              =\n              0\n            \n            \n              \n                L\n                3\n              \n              -\n              1\n            \n          \n          \u2062\n          \n            \n              \u03b2\n              3\n              \n                2\n                \u2062\n                n\n              \n            \n            \u2062\n            \n              \n                e\n                \n                  \n                    N\n                    -\n                    i\n                  \n                  ,\n                  \n                    i\n                    -\n                    1\n                  \n                \n              \n              \u2061\n              \n                (\n                \n                  t\n                  -\n                  n\n                  -\n                  i\n                  +\n                  1\n                \n                )\n              \n            \n            \u2062\n            \n              \n                \u025b\n                \n                  \n                    N\n                    -\n                    i\n                  \n                  ,\n                  \n                    i\n                    -\n                    1\n                  \n                \n              \n              \u2061\n              \n                (\n                \n                  t\n                  -\n                  n\n                  -\n                  i\n                  +\n                  1\n                \n                )\n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        10\n        )",
        "The term eN\u2212i,i\u22121(t\u2212i+1) is what is referred to as an a priori least squares interpolation and is calculated in a manner similar to the a posteriori residual (Equation (8)) except that the weight vector used is that calculated at the previous time instant i.e.",
        "e\n            \n              p\n              ,\n              f\n            \n          \n          \u2061\n          \n            (\n            \n              t\n              -\n              f\n            \n            )\n          \n        \n        =\n        \n          \n            x\n            \u2061\n            \n              (\n              \n                t\n                -\n                f\n              \n              )\n            \n          \n          -\n          \n            \n              \u2211\n              \n                i\n                =\n                1\n              \n              f\n            \n            \u2062\n            \n              \n                \n                  \n                    w\n                    ^\n                  \n                  \n                    p\n                    ,\n                    f\n                    ,\n                    i\n                  \n                \n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    f\n                    -\n                    1\n                  \n                  )\n                \n              \n              \u2062\n              \n                x\n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    i\n                    +\n                    1\n                  \n                  )\n                \n              \n            \n          \n          -\n          \n            \n              \u2211\n              \n                i\n                =\n                \n                  f\n                  +\n                  1\n                \n              \n              \n                f\n                +\n                p\n              \n            \n            \u2062\n            \n              \n                \n                  \n                    w\n                    ^\n                  \n                  \n                    p\n                    ,\n                    f\n                    ,\n                    i\n                  \n                \n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    f\n                    -\n                    1\n                  \n                  )\n                \n              \n              \u2062\n              \n                x\n                \u2061\n                \n                  (\n                  \n                    t\n                    -\n                    i\n                  \n                  )\n                \n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        11\n        )",
        "An a priori residual is related to an a posteriori equivalent by a so-called conversion factor \u03b4p,\u0192(t\u2212\u0192) (calculation of which will be described later) as follows:\n\n\u03b5p,\u0192(t\u2212\u0192)=\u03b4p,\u0192(t\u2212\u0192)ep,\u0192(t\u2212\u0192)\u2003\u2003(12)",
        "Equations (7) to (11) demonstrate the discovery in accordance with the invention that the gain vector (in the present example the Kalman gain vector) required to update filter coefficients can be generated from interpolation residuals. In this regard Equation (7) shows that each element of the Kalman gain vector is a ratio of a respective interpolation residual to the normalisation coefficient given by Equation (10), and Equations (8) and (9) yield the residuals themselves for derivation of the normalisation coefficient and Kalman gain vector.",
        "In the present example all forget factors \u03b21 etc. are made equal: in this regard the value chosen depends on the nature of the signals being filtered. The associated number of summation terms is such that L1=L2=L4=L5=t+1, i.e. all available terms are included: NB L4 and L5 are defined in later equations.",
        "In an adaptive filter in accordance with the invention therefore, a gain vector is determined from interpolation residuals such as for example that given by:\n\n\u03b5p,\u0192(t\u2212\u0192)=x(t\u2212\u0192)\u2212\u0175p,\u0192T(t\u2212\u0192){circumflex over (x)}p+\u0192(t,t\u2212\u0192)\u2003\u2003(13)\n\nwhere x(t\u2212f) is the (t\u2212f)th data element of the time series, \u0175p,\u0192T(t\u2212f){circumflex over (x)}p+\u0192(t,t\u2212\u0192) represents an estimate of x(t\u2212\u0192) obtained by interpolation from both earlier and later elements (subject to availability) of the time series, \u0175p,\u0192T(t\u2212\u0192) is an interpolation coefficient vector and as would be obtained in a least squares minimisation procedure. As mentioned earlier, the interpolation residuals may obtained without calculating \u0175p,\u0192T(t\u2212\u0192) as described later. The quantity {circumflex over (x)}p+\u0192(t,t\u2212\u0192) is a vector consisting of p+f elements of the time series from x(t\u2212\u0192\u2212p) to x(t) inclusive except for the omission of x(t\u2212\u0192).",
        "Referring to FIG. 1, stages for calculating an updated weight vector for an adaptive filter in response to a new input signal are shown in outline. These will be described briefly initially and more detail will be given later. A computer indicated by a box 10 is programmed to carry out four generalised processing stages 12 to 18. Of the latter, stage 12 comprises processing an input signal using an RLS lattice algorithm and obtaining forward and backward least squares prediction residuals. As indicated earlier, a prediction residual is the difference between a directly obtained data element and a prediction of that element extrapolated from other data associated with it; a forward prediction residual is obtained using forward extrapolation of data elements preceding a directly obtained element, and the backward equivalent is obtained by using backward extrapolation of data following that value. Forward and backward prediction residuals are naturally generated by an RLS lattice algorithm in a fast, numerically stable manner.",
        "In stage 14, the forward and backward prediction residuals are used to generate interpolation residuals as appropriate to provide elements of an un-normalised Kalman gain vector with elements as indicated in the numerator of the right hand side of Equation (7). In the present example, a priori interpolation residuals are calculated together with conversion factors to convert them to a posteriori interpolation residuals using Equation (12). This approach is taken as it makes initialisation of various stored parameters easier than if a posteriori residuals are used.",
        "In stage 16, to produce the normalised Kalman gain vector, each a posteriori interpolation residual is normalised by division by EN\u2212i,i\u22121(t\u2212i+1) the normalisation factor: this factor is calculated as the weighted sum of products, each product being that between a priori and a posteriori interpolation residuals for a respective time instant and the summation is over such products for all time instants for which signal samples have been obtained up to and including a most recent time instant as in Equation (10).",
        "In stage 18, as indicated in Equations (3) and (4), the Kalman gain vector derived from input signal elements up to and including x(t) is combined with x(t) itself and a reference signal y(t); this produces an updated version of the filter coefficients or weights which have therefore been modified in response to both input and reference signal elements x(t) and y(t). To allow for processing delay in deriving the Kalman gain vector in stages 12 to 16, to achieve simultaneity at input to stage 18, the signal elements x(t) and y(t) are stored, or, if necessary in a real time system, delayed.",
        "The RLS lattice algorithm is implemented in stage 12 as follows. A Least Squares (LS) lattice algorithm is an efficient algorithm for calculating least squares forward and backwards prediction residuals of a sequence of signals such as a time series: a time series is a series of data values representing the variation of a signal x(t) as a function of time.",
        "An Nth order adaptive filter corresponds to a weight vector wN having N coefficients\u2014the filter coefficients. Linear prediction residuals are produced as a first step in obtaining these coefficients and are of order 1 to N\u22121 inclusive. Residuals may be a posteriori or a priori, i.e. they may be produced using either a most recently determined weight vector or such a vector determined immediately previously. The nth order a posteriori LS forward prediction residual \u03b5nF(t) for a time series of signals with a value x(t) at time t is defined as:\n\n\u03b5nF(t)=x(t)\u2212anT(t)xn(t\u22121)\u2003\u2003(14)\n\nwhere xn(t\u22121) is a data vector having elements x(t\u22121) to x(t\u2212n) inclusive, and an(t) is the forward prediction coefficient vector which is again determined in a least squares optimisation procedure described later: this vector is determined in such a way as to minimise a weighted sum JnF(t) of a preselected number (L4) of squares of residuals determined up to and including a most recent residual, i.e. an(t) is the value of the vector \u03c9 that minimises:",
        "J\n            n\n            F\n          \n          \u2061\n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          \n            \u2211\n            \n              m\n              =\n              0\n            \n            \n              \n                L\n                4\n              \n              -\n              1\n            \n          \n          \u2062\n          \n            \n              \n                \u03b2\n                4\n                \n                  2\n                  \u2062\n                  m\n                \n              \n              \u2061\n              \n                (\n                \n                  \n                    x\n                    \u2061\n                    \n                      (\n                      \n                        t\n                        -\n                        m\n                      \n                      )\n                    \n                  \n                  -\n                  \n                    \n                      \n                        \u03c9\n                        _\n                      \n                      T\n                    \n                    \u2062\n                    \n                      \n                        \n                          x\n                          _\n                        \n                        n\n                      \n                      \u2061\n                      \n                        (\n                        \n                          t\n                          -\n                          m\n                          -\n                          1\n                        \n                        )\n                      \n                    \n                  \n                \n                )\n              \n            \n            2\n          \n        \n      \n    \n    \n      \n        (\n        15\n        )\n      \n    \n  \n\n\n\n\nwhere \u03b24 is a forget factor as described earlier.",
        "Similarly, the nth order a posteriori LS backward prediction residual \u03b5nB(t) for a time series of signals with a value x(t) at time t is defined as:\n\n\u03b5nB(t)=x(t\u2212n)\u2212cnT(t)xn(t)\u2003\u2003(16)\n\nwhere cn(t) is a coefficient vector for backward prediction determined as before by a least squares optimisation procedure which minimises a weighted sum of a number L5 of squares of residuals determined up to and including the most recent residual, i.e. cn(t) is the value of the vector \u03c9 that minimises:",
        "J\n            n\n            B\n          \n          \u2061\n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          \n            \u2211\n            \n              m\n              =\n              0\n            \n            \n              \n                L\n                5\n              \n              -\n              1\n            \n          \n          \u2062\n          \n            \n              \n                \u03b2\n                5\n                \n                  2\n                  \u2062\n                  m\n                \n              \n              \u2061\n              \n                (\n                \n                  \n                    x\n                    \u2061\n                    \n                      (\n                      \n                        t\n                        -\n                        m\n                        -\n                        n\n                      \n                      )\n                    \n                  \n                  -\n                  \n                    \n                      \n                        \u03c9\n                        _\n                      \n                      T\n                    \n                    \u2062\n                    \n                      \n                        \n                          x\n                          _\n                        \n                        n\n                      \n                      \u2061\n                      \n                        (\n                        \n                          t\n                          -\n                          m\n                        \n                        )\n                      \n                    \n                  \n                \n                )\n              \n            \n            2\n          \n        \n      \n    \n    \n      \n        (\n        17\n        )\n      \n    \n  \n\n\n\n\nwhere \u03b25 is a forget factor.",
        "The corresponding a priori forward and backward LS prediction residuals enF(t) and enB(t) respectively are defined similarly as follows:\n\nenF(t)=x(t)\u2212anT(t\u22121)xn(t\u22121)\u2003\u2003(18)\n\nenB(t)=x(t\u2212n)\u2212cnT(t\u22121)xn(t)\u2003\u2003(19)",
        "Conversion factors \u03b4nF(t) and \u03b4nB(t) which relate forward and backward a priori residuals to respective a posteriori equivalents are defined as:",
        "\u03b4\n            n\n            F\n          \n          \u2061\n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          \n            \n              \u025b\n              n\n              F\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n          \n            \n              e\n              n\n              F\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n        \n      \n    \n    \n      \n        (\n        20\n        )\n      \n    \n  \n  \n    \n      \n        \n          \n            \u03b4\n            n\n            B\n          \n          \u2061\n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          \n            \n              \u025b\n              n\n              B\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n          \n            \n              e\n              n\n              B\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n        \n      \n    \n    \n      \n        (\n        21\n        )",
        "An Nth order Least Squares Lattice (LSL) algorithm generates a set of forward and backward a posteriori prediction residuals, N of each, i.e. {\u03b51\u0192(t), . . . \u03b5N\u0192(t), \u03b51b(t), . . . \u03b5Nb(t)}. Here N is used in a general sense, and is not necessarily the same value as N used elsewhere herein. The particular LSL algorithm used in the present example is a Square Root Free QR Decomposition-based Recursive Least Squares Lattice (RLSL) Algorithm. Internally it calculates not the a posteriori prediction residuals directly but instead it calculates the a priori prediction residuals and the corresponding conversion factors. The algorithm is related to recursive square root free QR decomposition as described in U.S. Pat. No. 4,727,503 to McWhirter, which describes boundary and internal cell functions for a systolic array carrying out this function using inter alia a square root free equivalent of Givens rotations. See also I K Proudler, J G McWhirter and T J Shepherd, \u201cComputationally Efficient, QR Decomposition Approach to Least Squares Adaptive Filtering\u201d, IEE Proceedings, vol.138, Pt. F, no.4, August 1991, pp.341-353.",
        "QR decomposition is a well-known procedure which is used in solving sets of linear equations by determining a matrix Q of rotation parameters which will transform a data matrix X into an upper right triangular matrix R (i.e. with all sub-diagonal elements zero) by rotation of its co-ordinate system: such an R matrix has a last row corresponding to one equation with a single unknown and allowing the equations to be solved by back substitution. Rotation parameters are sines and cosines or square root free equivalents of these.",
        "FIG. 2 is a diagram illustrating the first four successive steps of the RLSL algorithm, which are concatenated stages: the ith stage (i=1, 2, 3, or 4) includes two internal cells (squares) Iai and Ibi, two boundary cells Bai and Bbi and two delay cells Dai and Dbi. The expressions \u201cinternal cell\u201d and \u201cboundary cell\u201d are conventional in QR processing and originally distinguished above-diagonal cells from on-diagonal cells in a triangular array: they are now used to distinguish cells which apply rotation parameters from those that evaluate them.",
        "As described in U.S. Pat. No. 4,727,503, boundary cells evaluate rotation parameters from input data and cumulatively multiply cosine-like rotation parameters; internal cells apply rotation parameters to input data. Each of these cells also recomputes and stores a quantity in response to each input, and their processing functions will be described later in more detail. Each delay cell Dai and Dbi store an input signal for a single time interval and outputs an immediately preceding input signal: e.g. when Da1 receives a new input signal such as data element x(t) it outputs the preceding input signal x(t\u22121) and stores the new one until the next input signal x(t+1) is received. The ith stage provides both forward and backward prediction residuals of order i using input signals x(t) when i=1 and when i is 2 or more using residuals corresponding to outputs from stage i\u22121.",
        "At time instant t, a data element x(t) is input to the first stage of the RLSL algorithm: it passes to the first internal cell Ia1, first delay cell Da1 and second boundary cell Bb1. The first delay cell Da1 outputs x(t\u22121) to the second internal cell Ib1 and first boundary cell Ba1. The first boundary cell Ba1 and second boundary cell Bb1 also receive inputs of 1, the latter from the second delay cell Db1 (unnecessary but included for conformity between stages). The sequence of operations then flows from left to right.",
        "The cells of the first RLSL algorithm stage generate quantities and pass them as follows:\n\n    \n    \n        first boundary cell Ba1: uses x(t\u22121) to update a quantity stored within it, and it calculates square root free rotation parameters from the stored quantity and passes them to the first internal cell Ia1; it calculates the conversion factor \u03b41F(t) (as defined in Equation (20) with n=1 relating a priori and a posteriori forward prediction residuals) and passes it as an input to the second stage first boundary cell Ba2;\n        second boundary cell Bb1: uses x(t) to update a stored quantity, and it calculates square root free rotation parameters from the stored quantity and passes them to second internal cell Ib1; it calculates the conversion factor \u03b41B(t) relating a priori and a posteriori backward prediction residuals and passes it an input to the second stage second delay cell Db2, which responds by outputting \u03b41B(t\u22121) (received previously) to the second stage second boundary cell Bb2;\n        first internal cell Ia1: uses x(t) to update a stored quantity; it then calculates the a priori forward prediction residual e1F(t) (i.e. n=1 in Equation (18)) and passes it to the second stage first internal and second boundary cells Ia2 and Bb2;\n        second internal cell Ib1: uses x(t\u22121) to update a stored quantity; it then calculates the a priori backward prediction residual e1B(t) (i.e. n=1 in Equation (19)) passes it to the second stage first delay cell Da2, which responds by outputting e1B(t\u22121) (received previously) to the second stage second internal cell Ib2 and first boundary cell Ba2;",
        "The values e1(t), \u03b41F(t), e1B(t) and \u03b41B(t) are evaluated and passed on in this way by the first stage solving the first order (n=1) forward and backward linear prediction problems: the second stage solves the second order (n=2) equivalent of this, i.e. the second stage internal and boundary cells Ia2, Ba2, Ib2 and Bb2 calculate results equivalent to those of the first stage but with the subscript index 2, i.e. e2F(t), \u03b42F(t), e2B(t) and \u03b42B(t). Similarly, the third and fourth stages subsequently calculate third and fourth order equivalents with index n=3 and n=4. Nth order prediction residuals require N stages four of which are shown in FIG. 2.",
        "As has been said, the terms enF(t) and enB(t) generated as described above are a priori prediction residuals: they can be converted to a posteriori residuals \u03b5nF(t) and \u03b5nB(t) using terms \u03b4nF(t) and \u03b4nB(t) also generated by the RLSL algorithm and substituting into Equations (20) and (21) above as follows:\n\n\u03b5nF(t)=\u03b4nF(t)enF(t)\u2003\u2003(22)\n\n\u03b5nF(t)=\u03b4nB(t)enB(t).\u2003\u2003(23)",
        "Once the a posteriori prediction residuals have been calculated using Equations (22) and (23), they may be used as hereinafter described to calculate interpolation residuals that make up the un-normalised Kalman gain vector, which is the numerator of the right hand side of Equation (7). However it is advantageous for initialisation purposes as noted above to calculate the interpolation residuals in a priori form together with corresponding conversion factors. Hence in the present example Equations (22) and (23) are not implemented.",
        "FIGS. 3 and 4 show how an a priori interpolation residual such as ep,f(t\u2212f) (and the corresponding conversion factor) can be used, together with certain prediction residuals, to generate two other interpolation residuals: relative to the indices and time instant of the original interpolation residual, one of the two residuals generated from it has a p index increased by 1 and the other has an f index increased likewise and a time instant one sample interval earlier, i.e. ep+1,f(t\u2212f) and ep,f+1(t\u2212f\u22121).",
        "In FIG. 3, the a priori interpolation residual ep,f(t\u2212f) and its associated conversion factor \u03b4p,f(t\u2212f) are converted into the a priori interpolation residual ep+1,f(t\u2212f) and its associated conversion factor \u03b4p+1,f(t\u2212f). The process involves two internal cells (squares) I1 and I2 and two boundary cells B1 and B2. Boundary cells evaluate rotation parameters and, in the case of B2, cumulatively multiply cosine-like rotation parameters; internal cells apply rotation parameters to data. Each of these cells also recomputes and stores a quantity in response to each input, and their processing functions will be described next in more detail.\n\n    \n    \n        Boundary cell B1: uses the a priori interpolation residual ep,f(t\u2212\u0192) and conversion factor \u03b4p,\u0192(t\u2212\u0192) to update a quantity stored within it, and it calculates square root free rotation parameters from the stored quantity and passes them to first internal cell I1; it passes the conversion factor \u03b4p,\u0192(t\u2212\u0192), relating a priori and a posteriori residuals, at its input to the boundary cell B2;\n        internal cell I1: uses the a priori backward prediction residual ep+f+1B(t) and rotation parameters from boundary cell B1 to update a stored quantity; it then calculates the quantity \u00eap+\u0192B(t,t\u2212\u0192) and passes it to the boundary cell B2;\n        boundary cell B2: uses \u00eap+\u0192B(t,t\u2212\u0192) ep,\u0192(t\u2212\u0192) and conversion factor \u03b4p,\u0192(t\u2212\u0192) to update a stored quantity, and it calculates square root free rotation parameters from the stored quantity and passes them to internal cell I2; it calculates the conversion factor \u03b4p+1,\u0192(t\u2212\u0192) relating a priori and a posteriori residuals;\n        internal cell I2: uses ep,\u0192(t\u2212\u0192) ep+\u0192+1B(t) and rotation parameters from boundary cell B2 to update a stored quantity; it then calculates the a priori interpolation residual ep+1,f(t\u2212f);",
        "In FIG. 4, the a priori interpolation residual ep,f(t\u2212f) and its associated conversion factor \u03b4p,f(t\u2212f) are converted into the a priori interpolation residual ep,f+1(t\u2212f\u22121) and its associated conversion factor \u03b4p,\u0192+1(t\u2212\u0192\u22121). With the exception of the two delay cells (D1 and D2), the underlying operations are exactly the same as described in relation to FIG. 3 it is the use of different input signals that distinguishes the approaches described with reference to FIGS. 3 and 4.",
        "In FIG. 4, the process involves two delay cells D1 and D2, two internal cells (squares) I3 and I4 and two boundary cells B3 and B4. Each of the delay cells D1 and D2 stores an input signal for a single time interval: when it receives a new input signal h(t) it outputs the preceding input signal h(t\u22121) and stores the new one until the next input signal h(t+1) is received. Boundary cells B3 and B4 evaluate rotation parameters and, in the case of B4, cumulatively multiply cosine-like rotation parameters; internal cells apply rotation parameters to data. Each of these cells also recomputes and stores a quantity in response to each input, and their processing functions will be described later in more detail.\n\n    \n    \n        Boundary cell B3: uses the a priori interpolation residual ep,\u0192(t\u2212\u0192\u22121), output from delay cell D2, and conversion factor \u03b4p,f(t\u2212f\u22121) to update a quantity stored within it, and it calculates square root free rotation parameters from the stored quantity and passes them to first internal cell I1; it passes the conversion factor \u03b4p,\u0192(t\u2212\u0192\u22121), output from delay cell D1, relating a priori and a posteriori residuals, at its input to the boundary cell B4;\n        internal cell I3: uses the a priori forward prediction residual",
        "e\n    \n      p\n      +\n      f\n      +\n      1\n    \n    F\n  \n  \u2061\n  \n    (\n    t\n    )\n  \n\n\n\n\nand rotation parameters from boundary cell B3 to update a stored quantity; it then calculates the quantity",
        "e\n      ^\n    \n    \n      p\n      +\n      f\n    \n    F\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n        -\n        1\n      \n    \n    )\n  \n\n\n\n\nand passes it to the boundary cell B4;\n\n    \n    \n        boundary cell B4: uses",
        "e\n      ^\n    \n    \n      p\n      +\n      f\n    \n    F\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n        -\n        1\n      \n    \n    )\n  \n\n\n\n\nand conversion factor \u03b4p,\u0192(t\u2212\u0192\u22121) to update a stored quantity, and it calculates square root free rotation parameters from the stored quantity and passes them to internal cell I2; it calculates the conversion factor \u03b4p,\u0192+1(t\u2212\u0192\u22121) relating a priori and a posteriori residuals;\n\n    \n    \n        internal cell I4: uses ep,\u0192(t\u2212\u0192\u22121) and rotation parameters from boundary cell B4 to update a stored quantity; it then calculates the a priori interpolation residual ep,\u0192+1(t\u2212\u0192\u22121);",
        "The details of the function of the cells in FIGS. 3 and 4 will now be described. In IEEE Trans SP January 2000 vol 48(1) pp.70-79, \u201cQR decomposition based least squares lattice interpolators\u201d, J T Yuan shows that it is possible to use an a posteriori interpolation residual \u03b5p,\u0192(t\u2212\u0192), or a one step delayed equivalent \u03b5p,\u0192(t\u2212\u0192\u22121), to generate a posteriori interpolation residuals \u03b5p+1,\u0192(t\u2212\u0192) and \u03b5p,\u0192+1(t\u2212\u0192\u22121) as set out in Equations (24) and (25) below:",
        "\u025b\n            \n              \n                p\n                +\n                1\n              \n              ,\n              f\n            \n          \n          \u2061\n          \n            (\n            \n              t\n              -\n              f\n            \n            )\n          \n        \n        =\n        \n          \n            \n              \u025b\n              \n                p\n                ,\n                f\n              \n            \n            \u2061\n            \n              (\n              \n                t\n                -\n                f\n              \n              )\n            \n          \n          +\n          \n            \n              \n                k\n                \n                  \n                    p\n                    +\n                    1\n                  \n                  ,\n                  f\n                \n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n            \u2062\n            \n              \n                \n                  \u025b\n                  ^\n                \n                \n                  p\n                  +\n                  f\n                \n                B\n              \n              \u2061\n              \n                (\n                \n                  t\n                  ,\n                  \n                    t\n                    -\n                    f\n                  \n                \n                )\n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        24\n        )\n      \n    \n  \n  \n    \n      \n        \n          \n            \u025b\n            \n              p\n              ,\n              \n                f\n                +\n                1\n              \n            \n          \n          \u2061\n          \n            (\n            \n              t\n              -\n              f\n              -\n              1\n            \n            )\n          \n        \n        =\n        \n          \n            \n              \u025b\n              \n                p\n                ,\n                f\n              \n            \n            \u2061\n            \n              (\n              \n                t\n                -\n                f\n                -\n                1\n              \n              )\n            \n          \n          +\n          \n            \n              \n                \u03bc\n                \n                  p\n                  ,\n                  \n                    f\n                    +\n                    1\n                  \n                \n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n            \u2062\n            \n              \n                \n                  \u025b\n                  ^\n                \n                \n                  p\n                  +\n                  f\n                \n                F\n              \n              \u2061\n              \n                (\n                \n                  t\n                  ,\n                  \n                    t\n                    -\n                    f\n                    -\n                    1\n                  \n                \n                )\n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        25\n        )\n      \n    \n  \n\n\n\n\nwhere kp+1,\u0192(t) and \u03bcp,\u0192+1(t) are coefficients determined by a least squares minimisation procedure, i.e. kp+1,\u0192(t) and \u03bcp,\u0192+1(t) are set equal to the value of the coefficients \u03c91 and \u03c92 (respectively) that minimise the weighted sum of the squares of values of the terms",
        "\u025b\n      \n        p\n        ,\n        f\n      \n    \n    \u2061\n    \n      (\n      \n        t\n        -\n        f\n      \n      )\n    \n  \n  +\n  \n    \n      \u03c9\n      1\n    \n    \u2062\n    \n      \n        \n          \u025b\n          ^\n        \n        \n          p\n          +\n          f\n        \n        B\n      \n      \u2061\n      \n        (\n        \n          t\n          ,\n          \n            t\n            -\n            f\n          \n        \n        )\n      \n    \n  \n\n\n\n\nand",
        "\u025b\n      \n        p\n        ,\n        f\n      \n    \n    \u2061\n    \n      (\n      \n        t\n        -\n        f\n        -\n        1\n      \n      )\n    \n  \n  +\n  \n    \n      \u03c9\n      2\n    \n    \u2062\n    \n      \n        \n          \u025b\n          ^\n        \n        \n          p\n          +\n          f\n        \n        F\n      \n      \u2061\n      \n        (\n        \n          t\n          ,\n          \n            t\n            -\n            f\n            -\n            1\n          \n        \n        )\n      \n    \n  \n\n\n\n\n(respectively) over a succession of evaluations at different times t. The quantities",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    B\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n      \n    \n    )\n  \n\n\n\n\nand",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    F\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n        -\n        1\n      \n    \n    )\n  \n\n\n\n\nare calculated from other known quantities as will be described later. Here the circumflex symbol above \u03b5 in each case indicates that the quantities",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    B\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n      \n    \n    )\n  \n\n\n\n\nand",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    F\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n        -\n        1\n      \n    \n    )\n  \n\n\n\n\nare, respectively, not the same as the backward and forward linear prediction residuals given by Equations (16) and (14);",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    B\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n      \n    \n    )\n  \n\n\n\n\nis a backward prediction residual of order (p+\u0192) at time (t) derived with the omission of data element x(t\u2212\u0192), and",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    F\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n        -\n        1\n      \n    \n    )\n  \n\n\n\n\nis a forward prediction residual of order (p+\u0192) at time (t) derived with the omission of data element x(t\u2212\u0192\u22121).",
        "In the above analysis the time index (t\u2212\u0192) has been used for convenience, although strictly speaking it can be shown mathematically that the parameter f is superfluous.",
        "There are several well known methods for solving least squares minimisation problems. In this example such a method based on QR Decomposition (QRD) is employed: it will be described in terms of determining a coefficient k(t) in a generalised equation as follows. Each of Equations (24) and (25) is of the form:\n\n\u03b6(t)=\u03c8(t)+k(t)\u03be(t)\u2003\u2003(26)",
        "Equation (26) it is required to calculate, at time instant t, the coefficient k(t) given input data \u03be(t) and \u03c8(t) (a posteriori modified prediction and interpolation residuals respectively), and subject to the constraint that in so doing there is minimisation of a sum of squares of the quantity \u03c8(i)+\u03c9\u03be(i) calculated for certain different times i and weighted by forget factors \u03b2: i.e. k(t) is equal to the value of a parameter \u03c9 that delivers a minimum value for the expression:",
        "\u2211\n          \n            i\n            =\n            0\n          \n          L\n        \n        \u2062\n        \n          \n        \n        \u2062\n        \n          \n            \n              \u03b2\n              \n                2\n                \u2062\n                \n                  \n                \n                \u2062\n                i\n              \n            \n            \u2061\n            \n              (\n              \n                \n                  \u03c8\n                  \u2061\n                  \n                    (\n                    \n                      t\n                      -\n                      i\n                    \n                    )\n                  \n                \n                +\n                \n                  \u03c9\u03be\n                  \u2061\n                  \n                    (\n                    \n                      t\n                      -\n                      i\n                    \n                    )\n                  \n                \n              \n              )\n            \n          \n          2\n        \n      \n    \n    \n      \n        (\n        27\n        )",
        "The parameter L determines the number of past samples that are included in the summation. As mentioned earlier L may be fixed or may vary with time, and \u03b2 is a forget factor. The effect of calculating k(t) in this way is to attenuate any component of \u03be(t) which also appears in \u03c8(t). The term \u03b6(t) is an a posteriori least squares residual for the problem.",
        "In this example the preferred method for solving the least squares problem given in Equations (26) and (27) involves not the a posteriori residuals \u03be(t) and \u03c8(t) but corresponding a priori residuals, u(t) and v(t), respectively, to which a conversion factor \u03b4m(t) is applied: it might be anticipated that there is a different conversion factor for each residual, but in fact in the present example it has been found that they are the same. In addition the preferred method does not solve the least squares problem given in Equations (26) and (27) directly but instead uses a recursive procedure that calculates k(t) based on the a priori residuals u(t) and v(t) and the conversion factor \u03b4m(t) at only the current time instant and knowledge of the values of various parameters calculated at the previous time instant and stored for later use. One such stored parameter is the value of the least squares coefficient at the previous time instant i.e. k(t\u22121).",
        "By an analysis related to that of S Hammarling, \u201cA Note on Modifications to the Givens Plane Rotation\u201d, J. Inst. Maths. Applics., vol. 13, pp. 215-218, 1974, and described in U.S. Pat. No. 4,727,503 to McWhirter, it can be shown that k(t) can be calculated from the following recursions\u2014which also yield the a priori residual associated with \u03b6(t) (i.e. z(t)) and the corresponding conversion factor (\u03b4out(t)):\n\nd(t)=\u03b22d(t\u22121)+\u03b4in(t)|u(t)|2\u2003\u2003(28)",
        "s\n        =\n        \n          \n            \n              \n                \u03b4\n                \n                  i\n                  \u2062\n                  \n                    \n                  \n                  \u2062\n                  n\n                \n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n            \u2062\n            \n              u\n              \u2061\n              \n                (\n                t\n                )\n              \n            \n          \n          \n            d\n            \u2061\n            \n              (\n              t\n              )\n            \n          \n        \n      \n    \n    \n      \n        (\n        29\n        )\n      \n    \n  \n  \n    \n      \n        \n          \n            \u03b4\n            out\n          \n          \u2061\n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          \n            \n              \u03b2\n              2\n            \n            \u2062\n            \n              \u2146\n              \n                (\n                \n                  t\n                  -\n                  1\n                \n                )\n              \n            \n            \u2062\n            \n              \n                \u03b4\n                \n                  i\n                  \u2062\n                  \n                    \n                  \n                  \u2062\n                  n\n                \n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n          \n          \n            \u2146\n            \n              (\n              t\n              )\n            \n          \n        \n      \n    \n    \n      \n        (\n        30\n        )\n      \n    \n  \n\n\n\n\nz(t)=v(t)+k(t\u22121)u(t)\u2003\u2003(31)\n\nk(t)=k(t\u22121)\u2212sz(t)\u2003\u2003(32)",
        "The term d(t) is defined by Equation (28) and represents an estimate of the energy of the time series u(0) to u(t) inclusive but with more weight given to more recent samples. All terms on the right-hand side of Equation (28) are known at time t: the term d(t\u22121) was obtained in the immediately preceding time instant by calculation if t=2 or more; for t=1 the corresponding initial term d(0) is given a predefined value such as zero; the terms \u03b4in(t) and u(t) are input data. The term s is a generalised rotation parameter of the kind used in QR decomposition: it is defined by Equation (29) in terms of input data \u03b4in(t) and u(t) together with a quantity d(t) calculated for the relevant time instant using Equation (28). Equation (30) defines the conversion factor \u03b4out(t) for the residual z(t) in terms of known quantities: i.e. d(t\u22121) is known from the previous time instant and \u03b4in(t) and d(t) have been calculated for this time instant using Equation (28). Together Equations (28) to (30) inclusive represent the calculation that takes place for each time instant in the boundary cells Ba1 etc. shown in FIG. 2 and the boundary cells B2 and B4 shown in FIGS. 3 and 4.",
        "Equations (31) and (32) represent the calculation that takes place for each time instant in the internal cells Ia1 etc. in FIG. 2 and the internal cells I2 and I4 shown in FIGS. 3 and 4. Equation (31) expresses z(t) in terms of two known quantities (input data) u(t) and v(t), and a value k(t\u22121) evaluated earlier for data of time instant (t\u22121) where t=2 or more; t=1 corresponds to the term k(0) which is set equal to a predefined value such as zero. Equation (32) expresses k(t) in terms of quantities s and z(t) calculated from Equations (29) and (31) together with k(t\u22121) from the previous time instant. With the knowledge of any starting value eg k(0) it is therefore possible to generate a succession of subsequent values of z(t) and k(t) using Equations (28) to (32):",
        "Referring to Equations (24) and (25) once more, the quantities",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    B\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n      \n    \n    )\n  \n\n\n\n\nand",
        "\u025b\n      ^\n    \n    \n      p\n      +\n      f\n    \n    F\n  \n  \u2061\n  \n    (\n    \n      t\n      ,\n      \n        t\n        -\n        f\n        -\n        1\n      \n    \n    )\n  \n\n\n\n\nare required in the foregoing calculations, and they are in fact obtained from other known quantities according to:",
        "\u025b\n              ^\n            \n            \n              p\n              +\n              f\n            \n            B\n          \n          \u2061\n          \n            (\n            \n              t\n              ,\n              \n                t\n                -\n                f\n              \n            \n            )\n          \n        \n        =\n        \n          \n            \n              \u025b\n              \n                p\n                +\n                f\n                +\n                1\n              \n              B\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n          -\n          \n            \n              \n                \u03b7\n                \n                  \n                    p\n                    +\n                    1\n                  \n                  ,\n                  f\n                \n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n            \u2062\n            \n              \n                \u025b\n                pf\n              \n              \u2061\n              \n                (\n                \n                  t\n                  -\n                  f\n                \n                )\n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        33\n        )\n      \n    \n  \n  \n    \n      \n        \n          \n            \n              \u025b\n              ^\n            \n            \n              p\n              +\n              f\n            \n            F\n          \n          \u2061\n          \n            (\n            \n              t\n              ,\n              \n                t\n                -\n                f\n                -\n                1\n              \n            \n            )\n          \n        \n        =\n        \n          \n            \n              \u025b\n              \n                p\n                +\n                f\n                +\n                1\n              \n              F\n            \n            \u2061\n            \n              (\n              t\n              )\n            \n          \n          -\n          \n            \n              \n                \ud835\udccb\n                \n                  p\n                  ,\n                  \n                    f\n                    +\n                    1\n                  \n                \n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n            \u2062\n            \n              \n                \u025b\n                \n                  p\n                  ,\n                  f\n                \n              \n              \u2061\n              \n                (\n                \n                  t\n                  -\n                  f\n                  -\n                  1\n                \n                )\n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        34\n        )\n      \n    \n  \n\n\n\n\nwhere \u03b7p+1,f(t) and vp,f+1(t) are coefficients determined by a modified least squares minimisation procedure which will now be described: this procedure involves recursive least squares minimisation, and the two least squares problems in Equations (33) and (34) have the same form, i.e.:\n\n\u03c8(t)=\u03b6(t)\u2212k(t)\u03be(t)\u2003\u2003(35)\n\nwhere \u03b6(t) and \u03be(t) are known input data (a posteriori prediction and interpolation residuals respectively), and k(t) and \u03c8(t) are to be calculated. Although it is a modified procedure as compared to that associated with Expressions (26) and (27), it can be shown that this recursive least squares procedure calculates the same value for the coefficient k(t) that would have been obtained by solving the conventional least squares problem described by Expressions (26) and (27) and implemented by recursion Equations (28) to (32): the latter had \u03c8(t) and \u03be(t) as input data and yielded k(t) and \u03b6(t), but in the present case \u03c8(t) is not available. However it can be shown that k(t) can be derived without knowledge of \u03c8(t) provided k(t\u22121) and \u03b6(t) are known. This is explained below but in terms of the corresponding a priori residuals and associated conversion factors: a priori residuals (Roman symbols) z(t), u(t) and v(t) correspond respectively to a posteriori residuals (Greek symbols) \u03b6(t), \u03be(t) and \u03c8(t).",
        "Equations (28) to (32) show that k(t) can be derived from k(t\u22121) with knowledge of v(t). Furthermore the recursion produces z(t) as a by-product. For the purpose of implementing the aforementioned modified recursive least squares procedure, it can be shown that these equations can be reordered in a way such that it is possible to derive a value for k(t) from k(t\u22121) without knowledge of v(t) provided z(t) is known which is the case. Moreover, these equations, so reordered, produce v(t) as a by-product and are set out in Equations (36) to (40) below:\n\nd(t)=\u03b22d(t\u22121)+\u03b4in(t)|u(t)|2\u2003\u2003(36)",
        "s\n        =\n        \n          \n            \n              \n                \u03b4\n                \n                  i\n                  \u2062\n                  \n                    \n                  \n                  \u2062\n                  n\n                \n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n            \u2062\n            \n              u\n              \u2061\n              \n                (\n                t\n                )\n              \n            \n          \n          \n            d\n            \u2061\n            \n              (\n              t\n              )\n            \n          \n        \n      \n    \n    \n      \n        (\n        37\n        )\n      \n    \n  \n\n\n\n\n\u03b4out(t)=\u03b4in(t)\u2003\u2003(38)\n\nv(t)=z(t)\u2212k(t\u22121)u(t)\u2003\u2003(39)\n\nk(t)=k(t\u22121)\u2212s z(t)\u2003\u2003(40)",
        "It is reiterated that Equations (36) to (40) are in terms of a priori residuals (Roman symbols) z(t), u(t) and v(t), which correspond respectively to a posteriori residuals (Greek symbols) \u03b6(t), \u03be(t) and \u03c8(t).",
        "The term d(t) is defined by Equation (36) and represents an estimate of the energy of the time series u(0) to u(t) inclusive but with more weight given to more recent samples. All terms on the right-hand side of Equation (36) are known at time t: for t=2 or more, the term d(t\u22121) is known from the previous time instant; in the case of t=1 and d(0), d(0) is set equal to a predefined value such as zero; the terms \u03b4in(t) and u(t) are input data. The term s is a generalised rotation parameter: it is defined by Equation (37) in terms of input data \u03b4in(t) and u(t) and d(t) calculated using Equation (36). Equation (38) defines the conversion factor \u03b4out(t) for the residual v(t) as being equal to the known input conversion factor \u03b4in(t). Together Equations (36) to (38) inclusive represent the calculation carried out in the boundary cells B1 and B3 and described with reference to FIGS. 3 and 4.",
        "Equations (39) and (40) express the calculation carried out in the internal cells I1 and I3 shown in FIGS. 3 and 4. Equation (39) expresses v(t) in terms of known quantities, i.e. input data u(t) and z(t) together with a value k(t\u22121) evaluated earlier for data of time (t\u22121), or, in the case of k(0), set to a predefined values such as zero. Equation (40) expresses k(t) in terms of the quantities s calculated using Equation (37) and the input datum z(t) together with k(t\u22121) from the previous time instant. With the knowledge of any starting value eg k(0) it is therefore possible to generate a succession of subsequent values of v(t) and k(t) for subsequent time instants using Equations (36) to (40).",
        "Equations (24) et sequi show that an a posteriori interpolation residual such as \u03b5p,f(t\u2212f) (or equivalently an a priori interpolation residual ep,f(t\u2212f) and the corresponding conversion factor \u03b4p,f(t\u2212f)) or a one sample time interval delayed equivalent ep,f(t\u2212f\u22121) can be used, together with certain prediction residuals, to generate two other interpolation residuals: relative to the indices of the original interpolation residual, one of the two residuals generated from it has a p index increased by 1 and the other has an f index increased likewise, i.e. \u03b5p+1,f(t\u2212f) and \u03b5p,f+1(t\u2212f\u22121). This is shown in FIGS. 3 and 4 in terms of a priori interpolation residuals and the corresponding conversion factors.",
        "For convenience the vector {circumflex over (k)}N(t) is defined to be the un-normalized Kalman gain vector of order N: i.e. the ith element of {circumflex over (k)}N(t) is {circumflex over (k)}iN(t)=\u03b5N\u2212i,i\u22121(t\u2212i+1)\u2014see Equation (7). There are many possible ways of using the method described with reference to FIGS. 3 and 4 to generate the interpolation residuals which are the elements {circumflex over (k)}QN(t) (Q=1 to N) of the un-normalized Kalman gain vector {circumflex over (k)}N(t) for an Nth order adaptive filter.",
        "For economy of description, the following discussion is in terms of a posteriori residuals, whereas equivalently in the present example a priori residuals and conversion factors are in fact used. Interpolation residuals \u03b5p,0(t) and \u03b50,f(t\u2212f) have a special property. The interpolation residual \u03b5N\u2212i,0(t) has p=N\u2212i and f=0: f=0 corresponds to there being no subsequent terms in the time series. This residual is therefore calculated only from preceding terms, i.e. from the same terms in the time series and in the same way as the forward prediction residual",
        "\u025b\n    \n      N\n      -\n      i\n    \n    F\n  \n  \u2061\n  \n    (\n    t\n    )\n  \n\n\n\n\nsee Equation (14): these two residuals are therefore equal. Moreover, since the forward prediction residual can obtained using a least squares lattice processor, so also can the interpolation residual \u03b5N\u2212i,0(t).",
        "As stated there are many ways that the methods described with reference to FIGS. 3 and 4 can be utilised to generate the elements of the un-normalized Kalman gain vector {circumflex over (k)}N(t). For example, following the principle elicited above the interpolation residual \u03b5N\u2212i,0(t) could be used to generate another interpolation residual with an f index increased by 1 and corresponding to the immediately preceding or (t\u22121)th time sample, namely \u03b5N\u2212i,1(t\u22121); this procedure is repeated to produce \u03b5N\u2212i,2(t\u22122) from \u03b5N\u2212i,1(t\u22121). Iteration is repeated a total of (i\u22121) times until \u03b5N\u2212i,i\u22121(t\u2212i+1) is generated, i.e. the iteration stages are:\n\n\u03b5N\u2212i,0(t)\u03b5N\u2212i,1(t\u22121)\u03b5N\u2212i,2(t\u22122). . . \u03b5N\u2212i,i\u22121(t\u2212i+1)\u2003\u2003(41)",
        "An alternative method for generating \u03b5N\u2212i,i\u22121(t\u2212i+1) is as follows. The interpolation residual \u03b50,i\u22121(t\u2212i+1) (i.e. p=0, f=i\u22121) is the same as the (i\u22121)th backward prediction residual for time t: \u03b5i\u22121B(t)\u2014see Equation (16). Following the principle elicited above the interpolation residual \u03b50,i\u22121(t\u2212i+1) is used to generate \u03b51,i\u22121(t\u2212i+1) with a p index increased by 1; this procedure is iterated to produce \u03b52,i\u22121(t\u2212i+1) from \u03b51,i\u22121(t\u2212i+1). Iteration is repeated a total of (N\u2212i) times until \u03b5N\u2212i,i\u22121(t\u2212i+1) is generated, i.e.:\n\n\u03b50,i\u22121(t\u2212i+1)\u03b51,i\u22121(t\u2212i\u22121)\u03b52,i\u22121(t\u2212i+1). . . \u03b5N\u2212i,i\u22121(t\u2212i,i\u22121).\u2003\u2003(42)",
        "The term \u03b5N\u2212i,i\u22121(t\u2212i+1) is the ith element of the un-normalized Kalman gain vector {circumflex over (k)}iN(t).",
        "The two methods indicated by iterations (41) and (42) above require of the order of N2 (O(N2)) computations to generate all of the required interpolation residuals making up the un-normalised Kalman gain vector, where N is the order of the adaptive filter. An alternative procedure will now be described to reduce the number of computations to O(Nlog2N).",
        "For convenience of description it will be assumed that N=2x, where N is the order of the filter and x is a positive integer. As described in connection with iterations (41) and (42), an interpolation residual of the kind \u03b5p,\u0192(t\u2212\u0192) such as \u03b5M,M\u22121(t\u2212M+1) (M=N/2) can be calculated by iteration starting from an interpolation residual \u03b5M,0(t); because \u03b5M,0(t) has p=M and f=0, it is derived from M preceding but 0 (no) succeeding time series data elements: it is therefore identical to the a posteriori forward prediction residual \u03b5M\u0192(t) which is obtained from the same data elements by the same calculation. In consequence, \u03b5M,M\u22121(t\u2212M+1) is obtainable by iteration of the type shown in Equation (41) from \u03b5M\u0192(t) itself obtained as described earlier from the least squares lattice processor. Furthermore, in the process of this iteration the residuals eM,\u0192(t\u2212\u0192) with values of f between 0 and M\u22121 are calculated, i.e. f=1 to M\u22122, namely:\n\n\u03b5M,1(t\u22121), \u03b5M,2(t\u22122), \u03b5M,3(t\u22123), . . . ,\u03b5M,M\u22122(t\u2212M+2)\u2003\u2003(43)",
        "The interpolation residuals in (43) are also intermediate quantities that would be calculated using the iteration shown in Equation (42) to calculate the residuals \u03b5N\u2212i,i\u22121(t\u2212i+1) where (2\u2266i\u2266M\u22121). Hence if the intermediate quantities at (43) are stored for later reuse it is possible to avoid some of the computation involved in calculating other residuals making up the un-normalised Kalman gain vector.",
        "Similarly, the interpolation residual \u03b5M\u22121,M(t\u2212M) is obtainable by the iteration shown in Equation (42) from \u03b50,M(t\u2212M), which itself is identical to the a posteriori backward prediction residual \u03b5MB(t): this iteration also generates intermediate quantities \u03b5p,M(t\u2212M) with values of p from 1 to M\u22122.",
        "Similar savings are also possible for calculation of other terms, i.e. \u03b5N\u2212i,i\u22121(t\u2212i+1) with values of i given by (M+2\u2266i\u2266N\u22121) via iterations (41).",
        "Storing intermediate quantities whilst calculating \u03b5N\u22123P,3P\u22121(t\u22123P+1) from \u03b5N\u22123P,M(t\u2212M) (where P=N/4) gives a reduction in computation of residuals \u03b5N\u2212i,i\u22121(t\u2212i+1) with values of i given by (M+2\u2266i\u22663P\u22121) calculated via Equation (42). In total there are four such sets of computations, i.e. \u03b5N\u2212i,i\u22121(t\u2212i+1) with values of i given by (M+2\u2266i\u22663P\u22121), (3P+2\u2266i\u2266N\u22121), (2\u2266i\u2266P\u22121) and (P+2\u2266i\u2266M\u22121). Furthermore these four set of computations can then be split in to eight in a similar manner and so on doubling repeatedly until N residuals needed for the Kalman gain vector are generated.",
        "The procedure starts by calculating two elements of the un-normalised Kalman gain vector near its centre using the iteration approaches of (41) and (42). The Mth element \u03b5M,M\u22121(t\u2212M+1) is calculated via repeated use of Equation (41) starting from the forward residual eM,0(t). The (M+1)th element \u03b5M\u22121,M(t\u2212M) is calculated by repeated use of Equation (42) starting from the backward residual \u03b50,M(t\u2212M). It is not in fact essential to use these starting residuals but it is believed that they are the most economical ones to use in terms of the number of computations required.",
        "FIG. 5 graphically depicts interpolation residuals \u03b5p,\u0192(t\u2212\u0192) plotted against horizontal and vertical axes 50 and 52 in accordance with their \u0192and p index values. Each point in the triangular space 54 represents an interpolation residual. The horizontal position of a point on the diagram and the associated \u0192index value represent the number of future data samples used to generate the interpolation residual. The vertical position and the associated p index value represent the number of past data samples used to generate the interpolation residual. Values on the horizontal axis 50 are interpolation residuals with \u0192=0 to N\u22121 and p=0, and therefore they are also backward prediction residuals \u03b5\u0192B(t) obtained as previously described and for reasons given then. Similarly, values on the vertical axis 52 are interpolation residuals with \u0192=0 and p=0 to N\u22121, and therefore they are also forward prediction residuals \u03b5pF(t) obtained as before.",
        "The interpolation residuals required to be calculated are positioned on a diagonal dotted line 56 shown as line halves 56a and 56b\u2014they are as has been said the elements {circumflex over (k)}QN of the un-normalised Kalman gain vector {circumflex over (k)}N(t). The sequence of residuals generated in an iteration to calculate two residuals \u03b5M,M\u22121(t\u2212M +1) and \u03b5M\u22121,M(t\u2212M) at 58 and 60 collectively central to the diagonal 56 are shown as chain lines 62 and 64 respectively.",
        "There are now two sub-problems, identical in principle to the original problem, but of order M=N/2: they are indicated by respective line halves 56a and 56b. The next step of the procedure is to calculate two pairs of elements, each pair collectively central to a respective line half 56a or 56b. Let N/4=M2=P. The Pth element of {circumflex over (k)}N(t), i.e. \u03b53P,P\u22121(t\u2212P+1) is calculated by iteration of Equation (41) starting from the forward residual \u03b53P,0(t).",
        "The (P+1)th element of {circumflex over (k)}N(t), i.e. \u03b53P\u22121,P(t\u2212P) is calculated by iteration of Equation (42) staring from the interpolation residual \u03b5M,P(t\u2212P), which itself was calculated during the calculation of {circumflex over (k)}MN=\u03b5M,M\u22121(t\u2212M+1).",
        "The 3Pth element of {circumflex over (k)}N(t), i.e. \u03b5P,3P\u22121(t\u22123P+1) is calculated by iteration of Equation (41) starting from the residual \u03b5P,M(t\u2212M).",
        "The (3P+1)th element of {circumflex over (k)}N(t), i.e. \u03b5P\u22121,3P(t\u22123P) is calculated by iteration of Equation (42) starting from the residual \u03b50,3P(t\u22123P).",
        "The evolution of the computation to this point is illustrated in FIG. 6, in which parts equivalent to those described earlier are like-referenced: four horizontal and vertical chain lines 66 have become added to this drawing as compared to FIG. 5 indicating calculation of four additional interpolation residuals or elements of the un-normalised Kalman gain vector.",
        "FIG. 6 illustrates that there are now four sub-problems of order P, as indicated by four diagonal quarter lines such as 56c. This procedure of splitting each sub-problem into two half-sized sub-problems and evaluating two adjacent residuals at a line portion central region is continued until all elements of the un-normalised Kalman gain vector are calculated. It is referred to as a \u201cdivide and conquer\u201d approach: it reduces the number of computations required from O(N2) to O(Nlog2N) because it is not necessary to evaluate residuals indicated by spaces between lines within the drawing.",
        "For the case N=64 the set of interpolation residuals actually calculated is illustrated in FIG. 7. As indicated earlier, vertical lines such as 70 indicate residuals iterated downwards using Equation (42) and horizontal lines such as 72 indicate residuals iterated to the right using Equation (41).",
        "From inspection of FIG. 7, it is seen that the general approach is to generate two orthogonal lines of residuals, select a residual approximately half way along each line and iterate orthogonally to the direction of the line, generating a respective new line of iterations until the required value of the un-normalised Kalman gain vector is reached. This procedure is repeated using residuals approximately half way to previously selected residuals and also using residuals approximately half way along each new line of iterations.",
        "Strictly speaking, \u201chalf way along each line\u201d is inaccurate because there is no residual at the half way point: instead the half way point is midway between two values and, in the case of the original prediction residuals (upon the uppermost and leftmost axes 50 and 52 in FIG. 5), on each side of the halfway point there are N/2 residuals (thirty-two for N=64). One begins an iteration with one of the two residuals immediately adjacent to and on opposite sides of a halfway point: the residual with which one begins is that having the higher value of the index which will not be incremented in the next iteration. This is not actually essential but it is believed to result in a numerically robust procedure with the smallest the number of iterative steps. In this connection, referring back to FIG. 6 once more, to produce the un-normalised Kalman gain vector the starting point was the forward prediction residual \u03b5M,0(t) and iteration was carried out for M\u22121 steps until the second or \u0192index (initially zero) became M\u22121. One could also begin with the backward prediction residual \u03b50,M\u22121(t) and iterate until the first or p index becomes M, but this requires one more iteration and does not help the \u201cdivide and conquer\u201d process. Later iterations begin similarly with a residual immediately adjacent a halfway point and having a higher value of the index not to be incremented, and the relevant halfway point is halfway between an interpolation residual providing a value of {circumflex over (k)}QN(t) obtained earlier and a starting residual for an earlier iteration.",
        "For filters with order N not equal to an integer power of two, the divide and conquer principle described above dan still used but the problem is divided up in a different way. Splitting each problem into two equal sub-problems will no longer be wholly appropriate to give a complete solution. A problem or sub-problem can be split into two or more not necessarily equal sub-problems: e.g. N=48 could be split into sub-problems of order 32 and 16 one of which yields 32 weight vector elements and the other 16. Any integer value of N can be treated as a sum of numbers each of which is a power of two and yields a subset of the required weight vector elements: hence the problem could be solved in this way. Many other \u201cdivide and conquer\u201d schemes are possible based on the many different ways of dividing filter weight vectors with order N not equal to an integer power of two into sub-weight-vectors with unequal orders.",
        "Referring to Stage 16 of FIG. 1 the jth element of the Kalman gain vector is calculated using Equation 7: in this equation the numerator is an a posteriori interpolation residual \u03b5N\u2212j,j\u22121(t\u2212j+1) which is the jth element of the un-normalised Kalman gain vector. The a posteriori residual will have been calculated as in FIGS. 3 and 4 as an a priori residual eN\u2212j,j\u22121(t\u2212j+1) and a conversion factor \u03b4N\u2212j,j\u22121(t\u2212j+1).",
        "The a posteriori residual itself is calculated as\n\n\u03b5N\u2212j,j\u22121(t\u2212j+1)=eN\u2212j,j\u22121(t\u2212j+1)\u03b4N\u2212j,j\u22121(t\u2212j+1)\u2003\u2003(44)",
        "The denominator in Equation 7 is of the form EN\u2212j,j\u22121(t\u2212j+1) which is updated at each iteration by\n\nEN\u2212j,j\u22121(t\u2212j+1)=\u03b232EN\u2212j,j\u22121(t\u2212j)+eN\u2212j,j\u22121(t\u2212j+1)\u03b5N\u2212j,j\u22121(t\u2212j+1)\u2003\u2003(45)",
        "Referring now to FIG. 8, an Nth order adaptive filter is shown implemented electronically. It consists of a chain of delay cells 1021, to 102N\u22121 connected in series between respective pairs of connection nodes 1041, to 104N. These nodes are connected to respective amplifiers 1061, to 106N with respective amplification factors w1(t) to wN(t) and connected to an update bus 108. The amplifiers 106 provide output to a summer 110.",
        "Each delay cell 102 provides a delay equal to the time between successive values of an input signal sample x(t) input to the first node 1041, first delay cell 1021, and first amplifier 1061. Upon clock activation it outputs a signal sample input x(t\u22121) received on an immediately preceding clock cycle and inputs a new signal sample x(t). In consequence, when x(t) is input to the first cell 1021 and first amplifier 1061, the ith (i=2 to N\u22121) cell 1021, and ith amplifier 106i (i=2 to N) receive input of x(t\u2212i+1). The amplifiers have respective gain factors which collectively apply a weight vector to the signals x(t) to x(t\u2212N+1): i.e. the ith amplifier 106i has a gain of wi(t) a time t and produces an output wi(t)x(t\u2212i+1). The summer 110 sums the amplifier outputs, i.e. its output S0 is:",
        "S\n          0\n        \n        =\n        \n          \n            \u2211\n            \n              i\n              =\n              1\n            \n            N\n          \n          \u2062\n          \n            \n              \n                w\n                i\n              \n              \u2061\n              \n                (\n                t\n                )\n              \n            \n            \u2062\n            \n              x\n              \u2061\n              \n                (\n                \n                  t\n                  -\n                  i\n                  +\n                  1\n                \n                )\n              \n            \n          \n        \n      \n    \n    \n      \n        (\n        46\n        )\n      \n    \n  \n\n\n\n\nwhich is the required adaptive filter output as in Equation (1). The weights wi(t) are updated via the update bus 108 in accordance with Equations (3) and (4) given earlier.",
        "Provided the Kalman gain vector is known, the equations given in the foregoing description can clearly be evaluated by an appropriate computer program comprising program instructions recorded on an appropriate carrier medium and running on a conventional computer system. The carrier medium may be a memory, a floppy or compact or optical disc or other hardware recordal medium, or an electrical signal. Such a program is straightforward for a skilled programmer to implement from the foregoing description without requiring invention, because it involves well known computational procedures. An outline for a program to calculate the Kalman gain vector will now be described assuming N=2x where x is a positive integer. The code is written using the rules of the MATLAB\u00ae computer program: the semicolon (;) indicates the end of an instruction, the epsis ( . . . ) indicates the instruction continues on the next line, the symbol \u2018.*\u2019 indicates element-wise multiplication of two vectors: element-wise multiplication of two vectors a and b having respective elements ai, bi is defined as forming a vector c with an ith element ci equal to the product aibi of like-indexed pairs of elements ai, bi(i=1, 2, 3, . . . etc).",
        "The Nth order un-normalised Kalman gain vector (the symbol \u2018k\u2019 below) at a given time instance is given by the four line program. The conversion of the un-normalised Kalman gain vector into the true (i.e. normalised) Kalman gain vector according to Equation (10) is straightforward for a skilled programmer to implement without requiring invention, because it involves well known computational procedures.\n\n    \n    \n        [km, deltakm, store state]=interpolate (N, fr, br, deltaf, deltab, fr, br, beta, store, state);\n        kp=[fr(N), km, br (N)];\n        deltak=[deltaf(N), deltakm, deltab(N)];\n        k=kp .* deltak;\n\nwhere the N-dimensional vectors \u2018fr\u2019 and \u2018br\u2019 contain the a priori forward and backward predictions residuals of order 0 to N\u22121 for that time instance, deltaf, deltab are N-dimensional vectors containing the corresponding conversion factors linking the a priori residuals to the a posteriori residuals (the a posteriori residual is equal to the product of the a priori residual and the conversion factor) and the variables \u2018store\u2019 and \u2018state\u2019 are used to store intermediate quantities and are arrays of dimension N\u00d7N\u00d72 and N\u00d7N\u00d74 respectively. The forward and backward prediction residuals and the conversion factors can be produced as previously described using for example a QRD-based LSL program. The intermediate quantities \u2018store\u2019 and \u2018state\u2019 need to be initialised before running the program for the first time. This will be described later.",
        "Defining n=2m and m being an integer not less than 2, the function \u2018interpolate\u2019 calculates an (n\u22122)-dimensional vector of interpolation residuals that constitute the diagonal of a triangular region in the space depicted in FIG. 4 defined by the horizontal line 50 and the vertical line 52. The two residuals near the centre of the diagonal are calculated using the recursions (41) and (42) via calls to the functions \u2018across\u2019 and \u2018down\u2019. If n is greater than 4, the remaining diagonal elements are calculated by two further (recursive) calls to the function \u2018interpolate\u2019 consisting of data of dimension n/2 (the \u201cdivide and conquer\u201d technique). The function \u2018interpolate\u2019 is:\n\n    \n    \n        function [k, deltak, store, state]=interpolate(n, v, h, deltav, deltah, fr, br, beta, store0, state0) store=store0; state=state0;\n        if (n>4)\n        \n            [v1, deltav1, state(1:n/2,n/2+1,:)]= . . . down(n/2, h(n/2+1), deltah(n/2+1), br(n/2+1:n), beta, state(1:n/2,n/2+1,:));\n            [h1, deltah1, store((n/2+1),1:(n/2),:), state((n/2+1),1:(n/2),:)]= . . . across(n/2, v(n/2+1), deltav(n/2+1), fr((n/2+1):n), beta, store((n/2+1),1:(n/2),:), . . . state((n/2+1),1:(n/2),:));\n            [ku, deltaku, store(1:n/2,n/2+1:n,:), state(1:n/2,n/2+1:n,:)]= . . . interpolate(n/2, v1, h(n/2+1:n), deltav1, deltah(n/2+1:n), fr(n/2+1:n), br(n/2+1:n), . . . beta, store(1:n/2,((n/2)+1):n,:), state(1:n/2,n/2+1:n,:));\n            [k1, deltak1, store(n/2+1:n,1:n/2,:), state(n/2+1:n,1:n/2,:)]= . . . interpolate(n/2,v(n/2+1:n),h1, deltav(n/2+1:n), deltah1, fr(n/2+1:n), br(n/2+1:n), . . . beta, store(((n/2)+1):n,1:n/2,:), state(n/2+1:n,1:n/2,:));\n            k=[k1, h1(n/2), v1(n/2), ku];\n            deltak=[deltak1, deltah1(n/2), deltav1(n/2), deltaku];\n        \n        \n        else\n        \n            [v1, deltav1, state(1:n/2,n/2+1,:)]= . . . down(n/2, h(n/2+1), deltah(n/2+1), br(n/2+1:n), beta, state(1:n/2,n/2+1,:));\n            [h1, deltah1, store(n/2+1,1:n/2,:), state(n/2+1,1:n/2,:)]= . . . across(n/2, v(n/2+1), deltav(n/2+1), fr(n/2+1:n), beta, store(n/2+1,1:n/2,:), state(n/2+1,1:n/2,:));\n            k=[h1(n/2), v1(n/2)];\n            deltak=[deltah1(n/2), deltav1(n/2)];\n        \n        \n        end",
        "The function \u2018down\u2019 implements the iteration (42) i.e. starting from a residual of the form \u03b5p,f(t\u2212\u0192) (actually represented by the a priori residual h=ep,\u0192(t\u2212\u0192) and the conversion factor delta0=\u03b4p,f(t\u2212\u0192)) and produces the sequence of residuals \u03b5p+i,f(t\u2212\u0192) for i=1 to n\u22121 (again, represented by a priori residuals and conversion factors stored in v and delta1 respectively).",
        "The function \u2018update\u2019 is common to the function \u2018across\u2019 both of which are described below. The function \u2018down\u2019 is\n\n    \n    \n        function [v, delta11, state]=down (n, h, delta0, br, beta, state0) state=state0;\n        v(1)=h; delta1(1)=delta0;\n        for i=2:n,\n        \n            [v(i), delta1(i), state(i,1,:)]=update (v(i\u22121), delta1(i\u22121), br(i), beta, state(i,1,:));\n        \n        \n        end",
        "The function \u2018across\u2019 implements iteration (41) i.e. starting from a residual of the form \u03b5p,f(t\u2212\u0192) (actually represented by the a priori residual v=ep,f(t\u2212\u0192) and the conversion factor delta0=\u03b4p,f(t\u2212\u0192)) and produces the sequence of residuals \u03b5p,f+i(t\u2212\u0192\u2212i) for i=1 to n\u22121 (again, represented by a priori residuals and conversion factors stored in h and delta1 respectively). Extra storage is needed compared to the function \u2018down\u2019 in order to implement the change in time index. The function \u2018update\u2019 is common to the function \u2018down\u2019 and is described below. The function \u2018across\u2019 is\n\n    \n    \n        function [h, delta1, store, state]=across(n, v, delta0, fr, beta, store0, state0) state=state0; store=store0;\n        h(1)=v; delta1(1)=delta0;\n        \n            for i=2:n,\n            [h(i), delta1(i), state(1,i,:)]=update (store(1,i,1), store(1,i,2), fr(i), beta, state(1,i,:));\n            store(1,i,:)=[h(i\u22121), delta1(i\u22121)];\n        \n        \n        end",
        "The function \u2018update\u2019 takes a residual \u03b5p,f(t\u2212\u0192) (actually represented by the a priori residual x=ep,f(t\u2212\u0192) and the conversion factor delta=\u03b4p,f(t\u2212\u0192)) and increases either the index \u2018f\u2019 or the index \u2018p\u2019 by one depending upon the value of the input \u2018r\u2019. No \u2018switching\u2019 is required: if \u2018r\u2019 is the appropriate backward prediction residual then the index \u2018p\u2019 is increased (see Equations (24) and (33)); conversely if \u2018r\u2019 is the appropriate forward prediction residual then the index \u2018f\u2019 is increased (see equations (25) and (34)). As described earlier this requires that an RLS and a modified RLS problem be solved This is done in the functions \u2018rls\u2019 and \u2018mrls\u2019 respectively. The function \u2018update\u2019 is\n\n    \n    \n        function [y, delta1, state1]=update (x, delta, r, beta, state)\n        \n            d=state(1); k=state(2);\n            dm=state(3); km=state(4);\n            [z,dm1,km1]=mris (x, r, delta,dm,beta,km);\n            [y,delta1,d1,k1]=ris (z, x,delta,d,beta,k);\n            state1(1)=d1; state1(2)=k1;\n            state1(3)=dm1; state1(4)=km1;",
        "The function \u2018rls\u2019 solves a RLS problem as described in Equations (28) to (32) inclusive. The function \u2018rls\u2019 is\n\n    \n    \n        function [z,delta1,d1,k1]=ris (x, y,delta,d,beta,k)\n        \n            if ((x==0)|(delta==0))\n            d1=beta^2*d;\n            s=0;\n            delta1=delta;\n        \n        \n        else\n        \n            d1=beta^2*d+delta*abs(x)^2;\n            s=delta*x/d1;\n            delta1=beta^2*delta*d/d1;\n        \n        \n        end\n        z=y+k*x;\n        k1=k\u2212s*z;",
        "The function \u2018mrls\u2019 solves a modified RLS problem as described in Equations (36) to (40) inclusive. The function \u2018mrls\u2019 is\n\n    \n    \n        function [y,d1,k1]=mris (x, z,delta,d,beta,k)\n        if ((x==0)|(delta==0))\n        \n            d1beta^2*d;\n            s=0;\n        \n        \n        else\n        \n            d1=beta^2*d+delta*abs(x)^2;\n            s=delta*x/d1;\n        \n        \n        end\n        y=z\u2212k*x;\n        k1=k\u2212s*z;",
        "In the above program listing and in the description of the associated mathematics, there are certain quantities that are updated from time instance to time instance e.g. k(t\u22121)\u2192k(t). Hence an initial value must be specified. An example of a way to perform this initialisation is as follows: Firstly, all stored variables involved in the computation are set to zero with the exception of the stored conversion factors which are set to unity. Then the program or hardware instantiation, up to but not including the normalisation stage, is arranged to process an initialising input time series consisting of a one followed by N zeros, where as before N is the order of the digital filter. This procedure gives appropriate initial values as required, after which a real time series can be processed.",
        "In recent years a new type of algorithm (termed a \u2018Fast Newton\u2019 algorithm) has appeared in the academic literature: see e.g.\n\n    \n    \n        M. Moonen and I. K. Proudler, \u201cUsing a Lattice Algorithm to Estimate the Kalman Gain Vector in Fast Newton-type Adaptive Filtering\u201d, Proc. ICASSP'97, Munich, April 1997\n        G. V. Moustakides & S. Theodoridis, \u201cFast Newton Transversal Filters\u2014A New Class of Adaptive Estimation Algorithms\u201d, IEEE trans. SP-39(6); pp. 2184-2193. 1991.\n        D. K. Phillips and C. F. N. Cowan, \u201cZero-Phase Signal Conditioning for Improved NLMS Performance\u201d, 13th Int. Conf. on DSP, 2-4 Jul. 1997, Santorini, Greece, pp.37-39.\n        K. Maouche and D. T. M. Slock, \u201cA Fast Instrumental Variable Affine Projection Algorithm\u201d, Proc. ICASSP'98, Seattle, Wash., USA, pp. 1481-4.",
        "Fast Newton algorithms are based on RLS algorithms and on an assumption that the input signal to be filtered can be modelled as a low order autoregressive (AR) process. This assumption allows some of the computation in the RLS algorithm to be ignored with potentially very little loss in convergence performance but a large saving in computation. In accordance with the invention it has been discovered that in order for this approach to be viable it is necessary for the RLS algorithm in use to be of a type that produces filter coefficients explicitly\u2014which excludes the use of RLS lattice algorithms known before this invention.",
        "It is also advantageous, especially in acoustic applications, for the algorithm to be convertible into a Fast Newton (U) algorithm in order to be able to take advantage of any autoregressive nature in the input signal. It can be shown that the present invention is suitable for implementation using an FN approach.",
        "The invention is suitable for use in a variety of applications: such applications for adaptive filters are given by S Haykin, Adaptive Filter Theory, 2nd Edition, Prentice-Hall, Englewood Cliffs, N.J., USA, 1991. One such is system identification\u2014here the requirement is to observe a real system and generate a computer model of its operation. The model can be used for many things such as health monitoring, developing a control system or to design a distortion compensation processor (e.g. for manipulating the acoustic character of rooms). System identification is achieved by monitoring the input and output of the system and feeding these signals as input data in digital electronic form to the adaptive filter implemented on a computer system. Although not strictly necessary, having the filter weights rather than some other parameterisation of the system is usually considered desirable as they are easier to interpret and manipulate.",
        "Adaptive filters are also applicable to communications channel equalisation: in modem digital communication systems a high data rate is often a requirement, where \u2018high\u2019 means high having regard to the maximum data rate of the communications channel in use. Individual data bits in the system may be sent so close together that their signal wave forms merge due characteristics of the communications channel. This adversely affects the ability of a receiver in the system to recover the information correctly. The standard approach is to \u2018equalise\u2019 the channel. This can be done either via a channel equalisation filter (an adaptive filter) or via Maximum Likelihood Sequence Estimation (usually implemented using the Viterbi algorithm). Such equalisation is needed, for example, in the GSM mobile telephone system, digital TV transmissions over cable networks, and data modems for telephone lines.",
        "One of the most effective equalisation filter structures is the \u2018Decision Feedback Equaliser\u2019. It uses previous decoding decisions (assumed to be correct) to counteract communications channel effects. It requires the ability to filter received signals independently of any updating mechanism for filter weights. Obtaining the filter weights rather than some other parameterisation of the filter makes this task easier to implement.",
        "Maximum Likelihood Sequence Estimation is a very powerful means of equalising a communications channel and is used in the GSM mobile telephone system. Unlike channel equalisation filtering, it works by directly estimating a transmitted information signal in a communications channel: to achieve this an estimate of the distortion introduced by the channel is required and can be provided by an adaptive filter (cf. system identification above). Again it is desirable to model the communications channel directly in terms of filter weights, as opposed to a less direct approach.",
        "In some applications, e.g. data modems for telephone lines, although the appropriate equalisation filter is unknown a priori and hence must be determined by an adaptive filter, once it is known it changes little with time. Here there is little point in continually updating the filter weights. The simplest alternative is to separate filtering from calculation of filter weights (sometimes called \u2018offline processing\u2019) so that the latter is, done only when required. This gives an additional advantage for high speed data, when calculation of filter weights does not need to cope with the data rate even though filtering must do so. Again, obtaining the filter weights themselves rather than some other filter parameterisation makes this approach easier to implement.",
        "In contrast to the aforementioned unknown but unchanging case, in some situations, for example HF radio communication, communication channel properties may vary with time requiring continual updating of equalisation filter weights. This may be achieved in two basic ways: by the use of either recursive or block adaptive filters. A recursive adaptive filter continually updates filter weights as new data arrives. A block adaptive filter partitions data into blocks and processes each block independently of the others. Recursive adaptive filters may be required to process many millions of data samples, and it is therefore vital that they behave correctly even when implemented with computer arithmetic circuits. Block adaptive filters are less susceptible to this problem since each data block represents only a limited amount of data to be processed at one time. However block adaptive filters have several drawbacks such as extra storage requirements for the blocks of data and the need for smooth \u2018joining\u2019 of the resulting processed blocks of data together.",
        "Constrained adaptive filters are known. They have a variety of applications such as minimum variance spectral analysis and for processing data from antenna arrays. Here an adaptive filter is required to minimise some signal subject to a constraint on the filter weights such as zero response at a particular frequency. Such adaptive filters can be updated efficiently using the Kalman gain vector. The relevant parts of the invention described herein can thus be used in a constrained adaptive filter.",
        "In the example of the invention described with reference to FIG. 1 et sequi, the adaptive filter is shown as consisting of four blocks: RLS Lattice Algorithm 12, Interpolation Residual Calculation 14, Normalisation 16, and Weight Update 18: highly detailed examples of the blocks 12 to 18 have been described in the embodiment of the invention hereinbefore set out. However, with the benefit of the embodiment described it will be clear to those of ordinary skill in the art of filtering that there are many different ways in which the blocks 12 to 18 can be implemented.",
        "The embodiment described herein derives the Kalman gain vector itself, ignoring arithmetic inaccuracies, i.e. rounding errors. It is known that adaptive filters are realisable (possibly with reduced performance) if the Kalman gain vector is replaced by an approximation to it provided by one of a variety of alternative gain vectors: see e.g. the literature on Fast Newton Algorithms referred to above. The advantage of these alternative gain vectors is that they can be calculated with fewer operations than the Kalman gain vector.",
        "In the example of the invention, the first step of generating interpolation residuals is to generate least squares (LS) prediction residuals via a recursive LS Lattice (RLSL) algorithm. The RLSL algorithm could be replaced by any other method of generating prediction residuals. Other algorithms which could be used to generate LS prediction residuals are RLS algorithms such as the Conventional RLS algorithm, the Fast Transversal Filter FTF) algorithm or the QR RLS algorithm.",
        "One could also use Non-RLS algorithms such as the Least Mean Squares GEMS) algorithm, the Gradient Adaptive Lattice (GAL) algorithm, a Clamped LSL algorithm or a Fast Newton Transversal Filter (FNTF) algorithm. In this case (at least some of) the residuals would be approximate RLS prediction residuals. The use of a non-RLS algorithm will lead to a gain vector that is not identical to the Kalman gain vector.",
        "Prediction residuals need not be the only input to interpolation residual calculation at 14 in FIG. 1. The basis of interpolation residual calculation 14 is that iterations increase interpolation residuals' order\u2014their p and f subscripts. Prediction residuals correspond to p=0 or f=0, and hence are possible starting variables. Clearly one can begin from any suitable set of variables. For example, a set of interpolation residuals with p=1, and a set of residuals with f=1, could be calculated (or approximated) by any means, and these could then be used to generate the desired interpolation residuals which make up the un-normalised Kalman gain vector. One could use for example the recursive interpolation algorithm given by J T Yuan, \u201cQR decomposition based least squares lattice interpolators\u201d, IEEE Trans SP January 2000 vol 48(1) pages 70-79.",
        "By suitable mathematical manipulation of Equations (24) and (25), it is also possible to envisage the calculation of interpolation residuals by iterations that decrease the interpolation residuals' order\u2014their p and f subscripts. Hence the residuals that constitute the un-normalised Kalman gain vector could be obtained from many other residuals as starting variables. In particular it is possible to replace the divide and conquer structure in Stage 14 of FIG. 1 with a concatenation of processing stages which \u201czig-zag\u201d (see FIG. 5) from the first element to the last element of the un-normalised Kalman gain vector. The set of residuals generated between these two extremes can include the residuals corresponding to all other elements of the un-normalised Kalman gain vector. This method requires fewer operations than the divide and conquer process used in the preferred embodiment but has not been used therein because it has inferior numerical properties when performed using finite precision arithmetic.",
        "There are several options for generating the un-normalised Kalman gain vector other than the divide and conquer approach described above. For example the same vector could be calculated from Equation (42) starting from backwards prediction residuals. This would require O(N2) operations as opposed to the O(Nlog2N) operations of the divide and conquer method. An interpolation residual may be calculated using basic iterations (whereby the order of the interpolation residuals (the p and f subscripts) is increased by one) from an interpolation residual with lower indices via a variety of routes. If RLS iterations are used the result is substantially the same regardless of the route taken.",
        "There are therefore many potential sets of iterations which may be performed to generate the un-normalised Kalman gain vector. Furthermore, there is a whole range of other vectors which could be generated instead of the un-normalised Kalman gain vector. The Kalman gain vector is the vector used to update the filter weights in a RLS algorithm. There are many other gain vectors which could be used to update the filter weights other than the Kalman gain vector. An algorithm with a gain vector which is close to the Kalman gain vector is expected to perform similarly to a RLS algorithm.",
        "Approximations to the Kalman gain vector could be generated for example by replacing some (or all) of the iterations which increase the interpolation order by computationally cheaper iterations. For example, the iterations could be replaced by their LMS equivalents, or any other approximations. In some cases the computation could reduce to merely a time delay or nothing at all (NB this is based on the same underlying idea behind the \u2018Fast Newton\u2019 algorithm mentioned above). This is equivalent to making the approximation that a higher order interpolation residual is equal to a lower order interpolation residual.",
        "Referring to FIG. 5 once more, a second possibility is that, rather than trying to calculate the interpolation residuals on the diagonal 56a/56b, one could use instead the residuals that form a horizontal line 80 starting from the bottom-left element of the Kalman gain vector. This corresponds to a vector consisting of the elements \u03b5N\u22121,\u0192(t\u2212\u0192) with \u0192=0, . . . , N\u22121.",
        "In the example the un-normalised Kalman Gain vector is normalised by dividing each element of the vector by its power; The power of each residual which is an element of the un-normalised Kalman Gain vector is calculated via Equation (10). This quantity could be approximated for example from just the a priori residuals or the a posteriori residuals or via many other means. Alternative normalisation factors could be used to alter an algorithm's convergence characteristics: for example choosing a larger normalisation factor will slow down convergence, but it allows filter weights to become closer to their ideal values once converged.",
        "The foregoing example is based on the Kalman gain vector defined by Equation (5). In the prior art RLS algorithms are known that use the so-called \u201cdual Kalman-gain vector\u201d. This is a scaled version of the Kalman gain vector which is based on normalised a priori interpolation residuals rather than a posteriori residuals. It requires a slightly modified weight updating formula but it is also an RLS algorithm. Approximations (such as those mentioned above) to the dual Kalman-gain vector could also be used.",
        "As described above in detail, it has been discovered in accordance with the invention that a Kalman gain vector can be derived as a set of normalised interpolation residuals which can be used in an O(Nlog2N) adaptive filter. However, the Kalman gain is an integral part of one form of the ubiquitous recursive least squares (RIS) procedure. Apart from applications such as noise cancellation and communications channel equalisation which use adaptive filtering, the filtering procedure (and approximate alternatives) can be used in adaptive beamforming. It can also be used to construct multichannel adaptive filters which are sometimes used in sonar applications where they are known as broadband beamformers. The residuals that make up the Kalman gain vector are conventionally referred to in recent prior art as \u201cinterpolation residuals\u201d only if the data being processed is in the form of a time series. If data is taken from a set of spatial distributed sensors for example, corresponding residuals do not have an accepted common descriptive name even though the basic signal processing approach still holds good For the purposes of the present invention, the expression \u201cinterpolation residual\u201d shall be taken as referring to residuals obtained by interpolation from a sequence of data elements distributed over any dimension without limitation, i.e. time or space or any other.",
        "Although it is as yet unverified for all practical situations, from theoretical considerations it is believed that\u2014where filter parameters are updated using Equation (3)\u2014calculating the Kalman gain vector via interpolation residuals is numerically more robust than a conventional approach with similar computational requirements.",
        "The foregoing example used real valued data. The invention can also be applied to complex valued data such as in-phase and quadrature (I and Q) channels of data used in digital communications or radar systems.",
        "Whereas it is preferred to obtain the Kalman gain vector with a divide-and-conquer approach of O(Nlog2N) operations, it is quite possible to use some other method to obtain interpolation residuals such as one of the O(N2) methods described earlier if the resulting increase in number of operations is acceptable: The latter will still have an advantage because as indicated above for good theoretical reasons it is likely to be more numerically robust than alternative approaches."
    ],
    "citations": [
        "5353307",
        "5436928",
        "5517239",
        "5677951",
        "6445792"
    ],
    "us_classification": "708322",
    "international_classifications": [
        {
            "classification_level": "A",
            "section": "G",
            "classification_class": "06",
            "subclass": "F",
            "main_group": "17",
            "subgroup": "10"
        }
    ]
}