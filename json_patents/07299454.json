{
    "title": "Method for multi-language debugging",
    "abstract": "Software developers working on multi-language systems can utilize a multi-language debugging environment. The debugging environment can be uniform across languages, and can seamlessly perform debugging between one or more languages in a multi-language environment. Such a system can have a number of attributes intended to help developers facing debugging problems in multi-language environments.",
    "inventors": [
        "Pugh",
        "Eckels"
    ],
    "document_number": "07299454",
    "publication_date": "20071120",
    "assignees": [
        "BEA Systems, Inc."
    ],
    "claims": [
        {
            "claim_number": "CLM-00001",
            "preamble": "1. A method for debugging in more than one programming language with a multi-language debugger, comprising:",
            "components": [
                {
                    "component": "debugging a source code file which contains multiple nested languages;",
                    "subcomponents": []
                },
                {
                    "component": "interpreting multiple nested languages within a single source file and displaying each of the multiple nested languages in a debugging frame;",
                    "subcomponents": []
                },
                {
                    "component": "editing each language in a debugging frame; and",
                    "subcomponents": []
                },
                {
                    "component": "wherein the multi-language debugger uses a standardized interface for a script engine and all communications with the script engine will be through calls to a script debug controller.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00002",
            "preamble": "2. The method of claim 1 , wherein the multi-language debugger is extensible and a user can add language definitions to support additional languages.",
            "components": []
        },
        {
            "claim_number": "CLM-00003",
            "preamble": "3. The method of claim 1 , wherein if more than one language appears on a stack, a user can see a debuggable frame for each language and the user can inspect variables for each language.",
            "components": []
        },
        {
            "claim_number": "CLM-00004",
            "preamble": "4. The method of claim 1 , wherein a proxy is used between executing code being debugged and a debugger.",
            "components": []
        },
        {
            "claim_number": "CLM-00005",
            "preamble": "5. The method of claim 1 , wherein a script engine interface can be used by a debugger to communicate metadata to a proxy.",
            "components": []
        },
        {
            "claim_number": "CLM-00006",
            "preamble": "6. The method of claim 1 , wherein a debugger interacts with a runtime messaging environment.",
            "components": []
        },
        {
            "claim_number": "CLM-00007",
            "preamble": "7. The method of claim 1 , wherein debugging is performed on a server side of a runtime messaging environment.",
            "components": []
        },
        {
            "claim_number": "CLM-00008",
            "preamble": "8. The method of claim 1 , wherein a runtime messaging environment interprets language interactions and performs debugging.",
            "components": []
        },
        {
            "claim_number": "CLM-00009",
            "preamble": "9. The method of claim 1 , wherein the script engine has a static constructor load the script debug controller.",
            "components": []
        },
        {
            "claim_number": "CLM-00010",
            "preamble": "10. The method of claim 9 , wherein the script debug controller receives information from the script engine, comprising:",
            "components": [
                {
                    "component": "a) language extensions for each language;",
                    "subcomponents": []
                },
                {
                    "component": "b) classes that implement the script engine;",
                    "subcomponents": []
                },
                {
                    "component": "c) information on optional capabilities for each language; and",
                    "subcomponents": []
                },
                {
                    "component": "d) language name.",
                    "subcomponents": []
                }
            ]
        }
    ],
    "description": [
        "The present application claims the benefit of priority under 35 U.S.C. \u00a7 119(3) to:\n\n    \n    \n        U.S. Provisional Application entitled \u201cSystems and Methods for Multi-Language Debugging,\u201d patent application No. 60/450,014, filed on Feb. 26, 2003, which application is incorporated herein by reference.",
        "A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document of the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.",
        "The present invention relates to the debugging of software and software components.",
        "Most real-world software systems of any significant complexity are written in more than one programming language. For example, an environment may be implemented in JAVA\u2122 while an interpreted language may be running on top of JAVA\u2122 and need to be debugged. This situation creates significant difficulties for software developers attempting to debug these systems. This problem is complicated by the fact that there is no standardization in terms of internal structures, such as stack frames, between different programming languages. For example, it is not uncommon for a developer to see stack information not directly related to the software being debugged when encountering a stack frame for one language, when using a debugger intended for another language. As another example, when using a debugger intended for the JAVA\u2122 language, a JAVA\u2122 stack will not include the stack for XScript (a JavaScript variant with native support for extensible markup language (XML)), and can sometimes show the set of Java classes that implement the XScript engine (these are part of the environment, but not the software the developer is working on). One multi-language debugger, described in JAVA\u2122 Specification Request (JSR) 45, can only be used to debug languages that are easily transformed into Java and then compiled. This and most other multi-language debuggers won't work with languages such as XScript where the language will be run by an interpreter or the language can not be mapped directly to JAVA\u2122 because the language has a different data structure. Thus, creating debugging tools that can be applied to software applied to more than one programming language, and running in the same environment, has proved to be extremely difficult.",
        "Methods for a debugging environment that can be used by software developers working on multi-language systems. The techniques used create a debugging environment that can be uniform across languages, and can seamlessly perform debugging between one or more languages in a multi-language environment. Such a system can have a number of attributes intended to help developers facing debugging problems in multi-language environments.",
        "FIG. 1 describes an initialization process for one embodiment of the invention.",
        "Systems and methods in accordance with embodiments of the present invention provide a debugging environment that can be used by software developers working on multi-language systems. The techniques used create a debugging environment that can be uniform across languages, and can seamlessly perform debugging between one or more languages in a multi-language environment. Such a system can have a number of attributes intended to help developers facing debugging problems in multi-language environments including:\n\n    Integrate debugging between two or more languages at the same time. If more that one language appears on a stack, a developer can see the frames for each language, as well as be able to inspect variables for each language.\n    Nested language debugging. A developer can debug source code that has several nested languages within a single source file. Mixing several languages in a single source file is becoming an increasingly valuable and popular capability. For example, the emerging ECMAScript for XML languages embeds the XML languages directly in ECMAScript.\n    An extensible architecture. Support for additional languages can be added to the multi-language debugging environment. For example, using multiple language definitions, a developer can perform debugging in the JAVA\u2122 language, Xscript language, the Xquery language, and various Business Process Modeling languages, such as the Business Process Execution Language.",
        "Each language integrated into a multi-language debugger can include specific support for the stack frame structures and variable representations used in that language. Each new language added to the multi-language debugger can extend the system in at least one of 3 areas:\n\n    The Integrated Development Environment (IDE). If the debugger is associated with an IDE, this environment can contain support for the languages supported by the debugger. These extensions may include appropriate APIs to get at dialog boxes (watch, locals, stack frame, etc), as well as the debugging commands. As an example, many Business Processes Modeling languages will simply be extensions in the IDE that will map to normal JAVA\u2122 code, or code in some other complied or interpreted programming language. In these cases, the extensions may be able to simply create extensions to the IDE environment for the underling programming language.\n    The Proxy. In one embodiment of the present invention, the proxy is not required. When implemented, the proxy may be used to implement user interface (UI) commands into the underlying debugging framework requests. The proxy can be used in-process or out-of-process. In the case where a proxy is out-of-process and used as an intermediate between the environment the software is executing in and the debugger, a proxy with the correct mapping between the new language and the underling language may be used. For example, to add debugging for a new language that maps directly to JAVA\u2122 byte codes, the proxy is extended to map between the new language and JAVA\u2122.\n    Runtime messaging infrastructure. For some languages the debugger should be capable of interacting with the messaging infrastructure. For example, to debug an interpreted language, like Xscript, the debugging may be done on the server side of the messaging infrastructure. In one embodiment, the Runtime messaging infrastructure may interpret language interactions and perform debugging in JAVA\u2122 Platform Debugging Architecture (JPDA).",
        "Throughout the following discussion, an example is developed using the JAVA\u2122 language. It will be understood that the invention is equally applicable to any programming language. This example is presented for illustrative purposes only and is not meant to limit the scope, functionality or spirit of any particular embodiment of the invention.",
        "Architectural Overview",
        "Some embodiments will be comprised of one or more functional components or modules. It will be understood that any particular embodiment of the invention may not require all of the components listed, may use additional components, or may use an entirely different organization without changing the functionality, scope or spirit. Components used in some embodiments can include:\n\n    A proxy\u2014In some embodiments a proxy is used between the executing code being debugged and the debugger. In some cases, the proxy serves to improve the efficiency or reduce the overhead associated with debugging protocols. For example, many JAVA\u2122 language debuggers use the JAVA\u2122 Debugging Interface (JDI), which has a fine-grain API and therefore will create a lot of message traffic between the code under test and the debugger. In this case a proxy can consolidate the contents of some of the messages, potentially reducing messages and overhead.\n    A script engine interface\u2014A script engine can communicate with the multi-language debugger through a standardized interface. This interface can be used by the multi-language debugger to communicate metadata to the proxy (or possibly directly to the debugger), so the proxy can determine when to call into which debuggable language. As an example, for multi-language support of JavaScript, a JAVA\u2122 language debugger may define an interface, possibly called IdebuggableLanguage, which is used anytime the script engine is invoked. Typically there is an object in the JAVA\u2122 stack that implements this interface, and can translate the JAVA\u2122 stack into a JavaScript stack.\n    A debuggable frame\u2014For each language supported, the scripting engine may use a debuggable frame object, capable of retrieving the script context. As an example, a JAVA\u2122 language debugger may define such a standardized frame, possibly known as IdebuggableFrame.\n    An interface to the messaging environment\u2014This is an interface that can be implemented by a runtime-messaging environment that controls the running state of the scripting engines. As an example, a JAVA\u2122 language debugger may define a standardized interface, possibly known as IdebugScriptController.\n    Script context object\u2014For each language supported, the scripting engine can use an object to hold a script context. As an example, a JAVA\u2122 language debugger may define a standardized object, possibly known as IcontextHolder.\n    A debug commands interface\u2014For each language supported, the script engine can use a standardized interface, which the multi-language debugger uses to call into the different debuggable languages. As an example, a JAVA\u2122 language debugger may define a standardized object, possibly known as IDebugCommands.\n    A script debug controller\u2014A script engine may have a static constructor that loads a script debug controller, which may registers itself upon start-up. When the script engine registers itself, the script debug controller may get the following information from the engine: a) the language extensions for each language, b) the classes that implement the script engine, c) information on optional capabilities for the language, and d) the language name. In some cases the controller may store this information internally in a map that goes from extension to script engine. As an example, for a JAVA\u2122 language debugger the script debug controller, possibly known as ScriptDebugController, is defined in debugger.jar.\n\nProcess Overview",
        "In some embodiments, when the runtime-messaging infrastructure is started in non-production (debug) mode, a script controller for the debug process is started. This object inspects the system for script engines, and loads them and their configuration information.",
        "In some embodiments when the runtime-messaging infrastructure starts a debugging session, it will send a message to the proxy. Typically, this message includes a list of languages and language configuration information for the languages supported by the multi-language debugger. In some embodiments, when debugging begins, the debug proxy will talk to the script controller for control flow (e.g. step, continue, pause), and will operate directly on the script engines for debugging information (e.g. stack frames, variable inspection, expressions).",
        "In some embodiments, after the script engines have all registered themselves, the script debug controller waits until debugging is started. This process is depicted in FIG. 1. Once debugging commences:\n\n    1. The server can send 102 an initialization message to the proxy.\n    2. The proxy can respond 104 with a packet indicating the languages discovered.\n    3. The server can send 106 a language response packet during the boot sequence. This packet may include the information used by the script debug controller, such as: a) the language extensions for each language, b) the classes that implement the script engine, c) information on optional capabilities for the language, and d) the language name.\n    4. The proxy will now send 108 a message indicating the successful completion of the initialization to the runtime massaging server, and will then wait for events.\n\nBreakpoint Hits",
        "In some embodiments, when a breakpoint is hit, or a step is finished in communications with the script engine will be to the script debug controller. As an example, with JAVA\u2122 code, all communications with the script engines will be through JDI calls to the script debug controller.",
        "For some embodiments, the first breakpoint hit in the underling language can behave like a normal break. The following process may then occur:\n\n    1. The debugger gets the current class, line, and stack and processes the stack through a language filter. If during processing, the debugger encounters a class that implements a script language the following steps may be take: a) if the object derives from a context holder, the debug script controller makes a method call to get the context, and b) the debug script controller will call a method to get the contents of the stack. Continuing the examples for the JAVA\u2122 language, the debug script controller will call getContext (or some other suitable named method) on the IcontextHolder object to get the context and then calls a method ScriptDebugController.getStack(LanguageLxt, Context) (or some other suitable named method) via JDI, to get a list of scriptFrames.\n    2. All script languages are processed as described above, creating a stack frame list to send back to the debugger.\n    3. The debugger proceeds to discover and inspect variables in the same way as before.\n\nCurrent Frame set to Script Frame",
        "In some embodiments, the following process may occur if the current stack frame is set to a frame controlled by a script engine:\n\n    1. Get the \u201cthis\u201d object and the frame variables and send them to the client as the list of variables.\n    2. For each object queried, call a method to get the values of the script variables. Continuing the example for the JAVA\u2122 language, a call is made to IDebuggableLanguage.getVariable() (or some other suitable named method), to get the IScriptVariable (or some other suitable named interface)value. Some possible JAVA\u2122 language examples of the results of this operation can be seen in the following table.",
        "Value\nValue\nType\n\n\n\n\nType\nDisplay\nDisplay\nIf Expanded\nIn Expression\n\n\n\n\n\n\n\nSimple\ngetValue( )\ngetType( )\n\u2014\nCall\n\n\n\n\n\n\ngetPrimativeType( ) to\n\n\n\n\n\n\ndetermine which get*\n\n\n\n\n\n\nfunction to call to get\n\n\n\n\n\n\nthe correct value.\n\n\nComplex\ngetValue( )\nGet\nCall\nUse getMember to\n\n\n\n\nType\ngetMembers( )\nget members, and\n\n\n\n\n( )\nto get the list\ncallMethod to call\n\n\n\n\n\nof members\nmethods on the\n\n\n\n\n\nto display,\nvalue.\n\n\n\n\n\nthen call\n\n\n\n\n\ngetMember( )\n\n\n\n\n\none each to\n\n\n\n\n\nget the\n\n\n\n\n\nvalues.\n\n\nArray\ngetValue( )\ngetType( )\nCreate a list\nUse getElement to\n\n\n\n\n\ngetLength( )\nlookup the values\n\n\n\n\n\nlong, and\n\n\n\n\n\npopulate it\n\n\n\n\n\nwith calls to\n\n\n\n\n\ngetElement( )\n\n\nOther\nCall into the\nCall into the\nCall into the\nCall into the\n\n\nLanguage\nScriptDebug-\nScriptDebug-\nScriptDebugController\nScriptDebugController\n\n\n\nController to\nController to\nto\nto get a resolved\n\n\n\nget a\nget a\nget a resolved\nScriptValue and use\n\n\n\nresolved\nresolved\nScriptValue\nthat.\n\n\n\nScriptValue\nScriptValue\nand use that.\n\n\n\nand use\nand use\n\n\n\nthat.\nthat.\n\n\nJava\nCall\nCall\nCall\nCall getValueObject\n\n\n\ngetValueObject\ngetValueObject\ngetValueObject\nand treat as ordinary\n\n\n\nand treat\nand treat\nand treat as\nJava Object\n\n\n\nas ordinary\nas ordinary\nordinary Java\n\n\n\nJava Object\nJava Object\nObject\n\n\n\n\n\n\n\n\n\nStepping Through Code",
        "Some embodiments can step though code using a mechanism analogous to that used in an ordinary (without multi-language support) debugger, except that the debugger will inform the script debug controller when a step is about to begin. In this way, any script engine that is started, and script engines that return from calling into the underling language (e.g. JAVA\u2122) will be able to stop appropriately. In some cases, script implementation classes are placed into the excludes-filter during a step request.",
        "Continuing",
        "In some embodiments this operation behaves like a continue in an ordinary (not multi-language) debugger.",
        "Script Breakpoint Hit",
        "In some embodiments, when a script breakpoint is hit the following actions can occur:\n\n    The script controller will call a breakpoint method, sending a message indicating the breakpoint hit to the proxy. Continuing the JAVA\u2122 language example, the controller can call into a method with a name, such as, ScriptDebugController.Break() to send the message to the proxy.\n    The Proxy can then freeze the thread, and perform any required communications. In the JAVA\u2122 example these communications can use function calls via JDI.\n    When the user decides to continue, the debugger will unfreeze the thread and send a Continue, StepIn, StepOver, StepOut, etc., packet as appropriate.\n\nIn some embodiments, if the user hits Stop instead of Continue, the thread can be un-frozen, no network packet will be sent, and the thread may be forced to throw an exception used for killing threads. Alternatively, such actions by the user can be temporarily blocked.\n\nPause",
        "In some embodiments, when the user hits Pause, the thread will be paused. The debugger can then look to see if the stack is currently in scripting or the underling language (e.g. JAVA\u2122) code. One of the following actions may then be taken:\n\n    1. If the stack is in the underling language code, the process is complete. In some cases, this situation is treated in the same way hitting a breakpoint is treated.\n    2. If the stack is in script code, a pause method is called on the script engine interface and the execution of the scripting language will continue until it hits a stopping point, when a pause method is called on the script debug controller. Continuing the JAVA\u2122 language example, when a pause() method on the IdebuggableLanguage interface is called, the scripting language will continue until it hits a stopping point, at which point the engine calls ScriptDebugController.Pause().",
        "In some embodiments, when a pause is called on a script language while it is waiting on some synchronization object, it will be treated as a normal thread in the underling language (e.g. JAVA\u2122), which can prevent deadlock scenanos.",
        "Breakpoints",
        "In some embodiments, information in breakpoint packets can use a suitable extension or other indicator to identify the language type being executed. In some cases, the absence of the extension can indicate the underling language (e.g. JAVA\u2122) is being used. If a breakpoint is not in the underling language the following actions may be taken:\n\n    1. Send a message to the script debug controller telling it to set a breakpoint.\n    2. The script debug controller will look up the proper extension or indicator and set a breakpoint using the method available for that language.\n    3. The script debug controller will then send a message indicating the success or failure of setting the breakpoint.\n\nIn some embodiments several types of breakpoints are supported, which can include:",
        "Source\nThis is the ordinary type of breakpoint that goes on a\n\n\nBreakpoints\nsource file/line number\n\n\nMethod\nThis breakpoint is hit when a certain method is called\n\n\nBreakpoint\n\n\nWatch point\nThis breakpoint is hit when a variable is either read or\n\n\n\nwritten.",
        "It should be noted, that depending on the details of the embodiment, any language may be able to support a sub-set of the available breakpoint types for any given language. Returning a true or false to a query for that type can indicate the support for a particular breakpoint type. For example, a true or false can be returned for a method, featureEnabled() (or some other suitable name), when called with a variable indicating the break point type, such as, SOURCE_BREAKPOINT_SUPPORT, METHOD_BREAKPOINT_SUPPORT, or WATCH_POINT_SUPPORT",
        "The following examples show sets of interface definitions for two embodiments, developed using the JAVA\u2122 language. It will be understood that the invention is equally applicable to any programming language. This example is presented for illustrative purposes only and is not meant to limit the scope, functionality or spirit of any particular embodiment of the invention.",
        "Interface Definition 1\n\n\n\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* The script controller will be an object that interoperates with the scripting languages\n\n\n\n* to bring you script debugging. The way this will work is each language engine will have\n\n\n\n* an instance of the <code>IScriptController</code>, and the <code>IScriptController</code>\n\n\n\n* will have list of all the <code>IDebuggableLanguage</code> interfaces.\n\n\n\n*/\n\n\n\n\n\n\n\npublic interface IScriptController\n\n\n{\n\n\n\n\n\n\n\n\n\nstatic int RESUME_CONTINUE = 0;\n\n\n\nstatic int RESUME_STEP_IN = 1;\n\n\n\nstatic int RESUME_STEP_OUT = 2;\n\n\n\nstatic int RESUME_STEP_OVER = 3;\n\n\n\nstatic int RESUME_STOP = 4;\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is what a runninq script will call when it wants to break. This is a waiting call,\n\n\n\n* that will not return until the thread has been told to continue. The frames parameter should\n\n\n\n* be a list of <code>IDebuggableLanguage$IScriptFrame</code>.\n\n\n\n*\n\n\n\n* @param frames - should be the frame list for the current script context.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what command resumed the break.\n\n\n\n*/\n\n\n\n\n\n\n\npublic int Break( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* this is what the scripting lanuguage calls when it's time to pause itself.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what command resumed the pause.\n\n\n\n*/\n\n\n\n\n\n\n\npublic int Pause(int pauseID);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is what a script engine must call when starting execution. This is how the\n\n\n\n* engine will know if the thread is currently in the middle of a step or not.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what kind of execution we are\n\n\n\n* in the middle of.\n\n\n\n*/\n\n\n\n\n\n\n\npublic int StartScript( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is what a script engine must call when resuming execution. This is how the\n\n\n\n* engine will know if the thread is currently in the middle of a step or not.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what kind of execution we are\n\n\n\n* in the middle of.\n\n\n\n*/\n\n\n\n\n\n\n\npublic int ResumeScript( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* processes the variable on script engine that created it. This will be called by a script engine that\n\n\n\n* needs to process an expression or a variable that was created in another script engine or in Java.\n\n\n\n*/\n\n\n\n\n\n\n\npublic IDebuggableLanguage.IScriptValue processScriptValue(IDebuggableLanguage.IScriptValue value);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This tells the script controller that a breakpoint that was previously un-resolvable has\n\n\n\n* now been resolved.\n\n\n\n*/\n\n\n\n\n\n\n\npublic void breakpointProcessed(IDebuggableLanguage.IBreakpointInfo bpi);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This gets the stack frames for the script language specified, using the context specified.\n\n\n\n*\n\n\n\n* @param langExt -- This is the language extension for the language we are inspecting.\n\n\n\n* @param context -- This is the language context we are investigating.\n\n\n\n*\n\n\n\n* @return an array of the stackframes this yeilds.\n\n\n\n*/\n\n\n\nIDebuggableLanguage.IScriptFrame[ ] getStack(String langExt,Object context);\n\n\n\n\n\n\n\n}\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This interface is used to get a context object for a given frame. The way this\n\n\n\n* will work is that the Proxy will go down the stack frame, looking for objects that\n\n\n\n* derive from IScriptContextHolder. When it comes across such a class, it will get the\n\n\n\n* context from the frame and pass it to the DebugScriptController. It is possible for\n\n\n\n* many script frames to all have the same context. In this case, the frame will only\n\n\n\n* get passed to the DebugScriptController once.\n\n\n\n*/\n\n\n\n\n\n\n\npublic interface IScriptContextHolder\n\n\n{\n\n\n\n\n\n\n\n\n\npublic Object getContext( );\n\n\n\n\n\n\n\n}\n\n\n/**\n\n\n\n\n\n\n\n\n\n* A scripting engine must implement this interface in order to be able to set itself up\n\n\n\n* to debug in the KNEX framework.\n\n\n\n*\n\n\n\n* NOTE: Kill will work the same way for script languages as it does for Java execution. An\n\n\n\n* exception will suddenly be thrown that should kill everything.\n\n\n\n*\n\n\n\n*/\n\n\n\n\n\n\n\npublic interface IDebuggableLanguage\n\n\n{\n\n\n\n\n\n\n\n\n\n//These are strings for each features\n\n\n\npublic static String \u2003EXPRESSION_SUPPORT=\u201cweblogic.debugging.comm.expressions\u201d;\n\n\n\npublic static String \u2003SOURCE_BREAKPOINT_SUPPORT=\u201cweblogic.debugging.comm.breakpoint\u201d;\n\n\n\npublic static String\n\n\n\n\n\n\n\nMETHOD_BREAKPOINT_SUPPORT=\u201cweblogic.debugging.comm.methodbreakpoint\u201d;\n\n\n\n\n\n\n\n\n\npublic static String \u2003WATCH_POINT_SUPPORT=\u201cweblogic.debugging.comm.watchpoint\u201d;\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This will be called on each of the debuggable languages before we get rolling.\n\n\n\n*/\n\n\n\n\n\n\n\npublic boolean init(IScriptController controller);\n\n\n/**\n\n\n* This will be called when we are ending.\n\n\n*/\n\n\npublic void exit( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the classes we should filter to prevent from showing up\n\n\n\n* in the stack. You will be able to use wild cards, such as org.mozilla.rhino.*\n\n\n\n*/\n\n\n\n\n\n\n\nString[ ] LanguageFilters( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the class instances that we can call into to get variable information, etc.\n\n\n\n* When walking through a stack trace, we will go to each of these to ask it to spit out it's stack. We will\n\n\n\n* furthermore. When a user inspects this part of the stack, we will also ask these objects for variable\n\n\n\n\n\n\n\nvalues, etc.\n\n\n\n\n\n\n\n\n\n*/\n\n\n\n\n\n\n\nString[ ] LanguageFrames( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the class instances that we can call into to get variable information, etc.\n\n\n\n* When walking through a stack trace, we will go to each of these to ask it to spit out it's stack. We will\n\n\n\n* furthermore. When a user inspects this part of the stack, we will also ask these objects for variable\n\n\n\n\n\n\n\nvalues, etc.\n\n\n\n\n\n\n\n\n\n*/\n\n\n\nString LanguageName( );\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the class instances that we can call into to get variable information, etc.\n\n\n\n* When walking through a stack trace, we will go to each of these to ask it to spit out it's stack. We will\n\n\n\n* furthermore. When a user inspects this part of the stack, we will also ask these objects for variable\n\n\n\n\n\n\n\nvalues, etc.\n\n\n\n\n\n\n\n\n\n*/\n\n\n\nString[ ] LanguageExtensions( );\n\n\n\n/**\n\n\n\n* This function is used for determining what features this debug engine supports. (\n\n\n\n*/\n\n\n\n\n\n\n\nboolean featureEnabled(String feature);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* When pause is called, it is up to the script engine to break at the next possible\n\n\n\n* place. This method can be called while the engine is in the middle of processing,\n\n\n\n* so should be treated as a synchronized.\n\n\n\n*/\n\n\n\n\n\n\n\nvoid pause(Object context, int pauseID);\n\n\n//\n\n\n//Methods for Inspecting/dealing with variables\n\n\nIScriptValue getVariable(Object context, String strVar, int stackFrame);\n\n\nIScriptValue setVariable(Object context, String strVar, int stackFrame);\n\n\nIScriptValue processExpression(Object context, String strExpr, int stackFrame);\n\n\n//Method for inspecting the current stack\n\n\nIScriptFrame[ ] getStack(Object context);\n\n\n//Breakpoints\n\n\nIBreakpointInfo setBreakpoint(IScriptBreakpoint bp);\n\n\nvoid clearBreakpoint(IScriptBreakpoint bp);\n\n\nvoid clearAllBreakpoints( );\n\n\npublic interface IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\nstatic final int SIMPLE_TYPE = 0;\n\n\n\nstatic final int COMPLEX_TYPE = 1;\n\n\n\nstatic final int SCRIPT_ARRAY_TYPE = 2;\n\n\n\nstatic final int OTHER_LANGUAGE_TYPE = 3;\n\n\n\nstatic final int JAVA_LANGUAGE_TYPE = 4;\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This gets the value we should display to the user.\n\n\n\n*/\n\n\n\n\n\n\n\nString getValue( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* If this is a language that supports types, this should return the type name of this variable.\n\n\n\n*/\n\n\n\n\n\n\n\nString getTypeName( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This determines if the variable is a complex type, simple type or other languagy type.\n\n\n\n*/\n\n\n\nint getAbstractType( );\n\n\n\n\n\n\n\n}\n\n\npublic interface ISimpleScriptValue extends IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\npublic static final int TYPE_BOOLEAN = 0;\n\n\n\npublic static final int TYPE_BYTE = 1;\n\n\n\npublic static final int TYPE_CHAR = 2;\n\n\n\npublic static final int TYPE_DOUBLE = 3;\n\n\n\npublic static final int TYPE_FLOAT = 4;\n\n\n\npublic static final int TYPE_INT = 5;\n\n\n\npublic static final int TYPE_LONG = 6;\n\n\n\npublic static final int TYPE_SHORT = 7;\n\n\n\npublic static final int TYPE_STRING = 8;\n\n\n\npublic static final int TYPE_NULL = 9;\n\n\n\npublic int \u2003getPrimativeType( );\n\n\n\npublic boolean \u2003getBoolean( );\n\n\n\npublic byte \u2003getByte( );\n\n\n\npublic char \u2003getChar( );\n\n\n\npublic double \u2003getDouble( );\n\n\n\npublic float \u2003getFloat( );\n\n\n\npublic int \u2003getInt( );\n\n\n\npublic long \u2003getLong( );\n\n\n\npublic short \u2003getShort( );\n\n\n\npublic short \u2003getString( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IScriptArrayValue extends IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\nint \u2003\u2003getLength( );\n\n\n\nIScriptValue \u2003getElement(int i);\n\n\n\n\n\n\n\n}\n\n\npublic interface IComplexScriptValue extends IScriptValue\n\n\n{\n\n\n/**\n\n\n\n\n\n\n\n\n\n* if this is a complex type, this will return a list of all it's members.\n\n\n\n*/\n\n\n\n\n\n\n\nList getMembers( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* if this is a complex type, this will return a member of it.\n\n\n\n*/\n\n\n\n\n\n\n\nIScriptValue getMember(String name);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* calls a method on the complex type. If the method is a void method, it should\n\n\n\n* return a null. Otherwise, callMethod should return a scriptValue representing the\n\n\n\n* returned value. If that value is null, this will be a ScriptValue with the value null.\n\n\n\n*/\n\n\n\nIScriptValue callMethod(String name, IScriptValue[ ] values);\n\n\n\n\n\n\n\n}\n\n\npublic interface IOtherLanguageValue extends IScriptValue\n\n\n{\n\n\n/**\n\n\n\n\n\n\n\n\n\n* script extension for this variable.\n\n\n\n*/\n\n\n\nString getScriptExtension( );\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* gets the underlying value object. The other scripting language should be able to figure out\n\n\n\n* what this is to be able to create one of the other Script values from this.\n\n\n\n*/\n\n\n\nObject getValueObject( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IJavaValue extends IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\n/**\n\n\n\n* gets the underlying java object. The proxy will be able to disect this and keep values, etc for this.\n\n\n\n*/\n\n\n\nObject getValueObject( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IScriptFrame\n\n\n{\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This will get the file extension specifying what language this is.\n\n\n\n* If a language supports more than one file extension, this will just be one.\n\n\n\n*/\n\n\n\n\n\n\n\nString getLanguageExtension( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* If this returns non-null, this string will be used to display\n\n\n\n* the stack frame to the user.\n\n\n\n*/\n\n\n\n\n\n\n\nString getDisplayFrame( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is the class name that we will derive the file from. This will be put through the\n\n\n\n* document resolution process on the ide.\n\n\n\n*/\n\n\n\n\n\n\n\nString getClassName( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is the line of execution the current frame is on.\n\n\n\n*/\n\n\n\n\n\n\n\nint getLine( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This function will return an array of all the values visible from the current stack. All the\n\n\n\n* values in the list that are returned will be of type IScriptValue.\n\n\n\n*/\n\n\n\n\n\n\n\nList getFrameVariables( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This function will return an IScriptValue if there is a <code>this</code> object, otherwise it\n\n\n\n* will return null.\n\n\n\n*/\n\n\n\nIScriptValue getThis( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IBreakpointInfo\n\n\n{\n\n\n\n\n\n\n\n\n\npublic static final String BREAKPOINT_RESOLVED \u2003\u2003= \u201c0\u201d;\n\n\n\npublic static final String BREAKPOINT_UNRESOLVED = \u201c1\u201d;\n\n\n\npublic static final String BREAKPOINT_ERROR = \u201c2\u201d;\n\n\n\npublic String \u2003getStatus( );\n\n\n\npublic int \u2003getOrigLine( );\n\n\n\npublic int \u2003getCurrLine( );\n\n\n\npublic IScriptBreakpoint getBreakpoint( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IScriptBreakpoint\n\n\n{\n\n\n}\n\n\npublic interface IScriptSourceBreakpoint extends IScriptBreakpoint\n\n\n{\n\n\n\n\n\n\n\n\n\nString getClassName( );\n\n\n\nint \u2003getLine( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IScriptMethodBreakpoint extends IScriptBreakpoint\n\n\n{\n\n\n\n\n\n\n\n\n\nString \u2003getMethod( );\n\n\n\nString[ ] getParams( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IScriptWatchpoint extends IScriptBreakpoint\n\n\n\n\n\n\n\n\n\n{\n\n\n\nIScriptValue \u2003getValue( );\n\n\n\nboolean \u2003\u2003stopOnRead( );\n\n\n\nboolean \u2003\u2003stopOnWrite( );\n\n\n\n}\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\nInterface Definition 2\n\n\n\n\n\n\n\n\n\n\n* To change template for new interface use\n\n\n* Code Style | Class Templates options (Tools | IDE Options).\n\n\n*/\n\n\npackage weblogic.debugging.comm;\n\n\nimport java.util.List;\n\n\nimport java.io.Serializable;\n\n\n/**\n\n\n\n\n\n\n\n\n\n* The script controller will be an object that interoperates with the scripting languages\n\n\n\n* to bring you script debugging. The way this will work is each language engine will have\n\n\n\n* an instance of the <code>IScriptController</code>, and the <code>IScriptController</code>\n\n\n\n* will have list of all the <code>IDebuggableLanguage</code> interfaces.\n\n\n\n*/\n\n\n\n\n\n\n\npublic interface IScriptController\n\n\n{\n\n\n\n\n\n\n\n\n\npublic static class LanguageInfo implements Serializable\n\n\n\n\n\n\n\n\n\n{\n\n\n\n\n\n\n\n\n\npublic LanguageInfo(String languageName, String[ ] languageExtensions, String[ ] languageFilters, String[ ]\n\n\n\n\n\n\n\ncontextHolders)\n\n\n\n\n\n\n\n\n\n{\n\n\n\n\n\n\n\n\n\n_languageName = languageName;\n\n\n\n_languageExtensions = languageExtensions;\n\n\n\n_languageFilters = languageFilters;\n\n\n\n_contextHolders = contextHolders;\n\n\n\n\n\n\n\n\n\n}\n\n\n\npublic final String \u2003\u2003_languageName;\n\n\n\npublic final String [ ]\u2003\u2003_languageExtensions;\n\n\n\npublic final String [ ]\u2003\u2003_languageFilters;\n\n\n\npublic final String [ ]\u2003\u2003_contextHolders;\n\n\n\ntransient public IDebuggableLanguage _lang;\n\n\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n\nstatic int RESUME_CONTINUE = 0;\n\n\nstatic int RESUME_STEP_IN = 1;\n\n\nstatic int RESUME_STEP_OUT = 2;\n\n\nstatic int RESUME_STEP_OVER = 3;\n\n\nstatic int RESUME_STOP = 4;\n\n\n/**\n\n\n\n\n\n\n\n\n\n* returns a list that contains LanguageInfo. There will\n\n\n\n* be one for each language.\n\n\n\n*/\n\n\n\n\n\n\n\nLanguageInfo[ ] getLanguages( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is what a running script will call when it wants to break. This is a waiting call,\n\n\n\n* that will not return until the thread has been told to continue. The frames parameter should\n\n\n\n* be a list of <code>IDebuggableLanguage$IScriptFrame</code>.\n\n\n\n*\n\n\n\n* @param frames - should be the frame list for the current script context.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what command resumed the break.\n\n\n\n*/\n\n\n\n\n\n\n\npublic int Break( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* this is what the scripting lanuguage calls when it's time to pause itself.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what command resumed the pause.\n\n\n\n*/\n\n\n\n\n\n\n\npublic int Pause(int pauseID);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is what a script engine must call when starting execution. This is how the\n\n\n\n* engine will know if the thread is currently in the middle of a step or not.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what kind of execution we are\n\n\n\n* in the middle of.\n\n\n\n*/\n\n\n\n\n\n\n\npublic boolean StartScript( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is what a script engine must call when resuming execution. This is how the\n\n\n\n* engine will know if the thread is currently in the middle of a step or not.\n\n\n\n*\n\n\n\n* @return the return value tells the scripting engine what kind of execution we are\n\n\n\n* in the middle of.\n\n\n\n*/\n\n\n\n\n\n\n\npublic boolean ResumeScript( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* processes an IScriptValue by passingit off to the script engine that knows about it, then it\n\n\n\n* will return a new IScritpValue that knows more about that value.\n\n\n\n*/\n\n\n\n\n\n\n\npublic IDebuggableLanguage.IScriptValue processScriptValue(IDebuggableLanguage.IScriptValue value);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This tells the script controller that a breakpoint that was previously un-resolvable has\n\n\n\n* now been resolved.\n\n\n\n*/\n\n\n\n\n\n\n\npublic void breakpointProcessed(IDebuggableLanguage.IBreakpointInfo bpi);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This gets the stack frames for the script language specified, using the context specified.\n\n\n\n*\n\n\n\n* @param lang_Ext -- This is the language extension for the language we are inspecting.\n\n\n\n* @param context -- This is the language context we are investigating.\n\n\n\n*\n\n\n\n* @return an array of the stackframes this yeilds.\n\n\n\n*/\n\n\n\nIDebuggableLanguage.IScriptFrame[ ] getStack(String langExt,Object context);\n\n\n\n\n\n\n\n}\n\n\npackage weblogic.debugging.comm;\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This interface is used to get a context object for a given frame. The way this\n\n\n\n* will work is that the Proxy will go down the stack frame, looking for objects that\n\n\n\n* derive from IScriptContextHolder. When it comes across such a class, it will get the\n\n\n\n* context from the frame and pass it to the DebugScriptController. It is possible for\n\n\n\n* many script frames to all have the same context. In this case, the frame will only\n\n\n\n* get passed to the DebugScriptController once.\n\n\n\n*/\n\n\n\n\n\n\n\npublic interface IScriptContextHolder\n\n\n{\n\n\n\n\n\n\n\n\n\npublic Object getContextInstance( );\n\n\n\n\n\n\n\n}\n\n\npackage weblogic.debugging.comm;\n\n\nimport java.util.List;\n\n\n/**\n\n\n\n\n\n\n\n\n\n* A scripting engine must implement this interface in order to be able to set itself up\n\n\n\n* to debug in the KNEX framework.\n\n\n\n*\n\n\n\n* NOTE: Kill will work the same way for script languages as it does for Java execution. An\n\n\n\n* exception will suddenly be thrown that should kill everything. You should be careful,\n\n\n\n* that everywhere in your code, you rethrow the exception when you get it instead of get\n\n\n\n* processing it.\n\n\n\n*/\n\n\n\n\n\n\n\npublic interface IDebuggableLanguage\n\n\n{\n\n\n\n\n\n\n\n\n\n//These are strings for each features\n\n\n\npublic static String \u2003EXPRESSION_SUPPORT=\u201cweblogic.debugging.comm.expressions\u201d;\n\n\n\npublic static String \u2003SOURCE_BREAKPOINT_SUPPORT=\u201cweblogic.debugging.comm.breakpoint\u201d;\n\n\n\npublic static String \u2003METHOD_BREAKPOINT_SUPPORT=\u201cweblogic.debugging.comm.methodbreakpoint\u201d;\n\n\n\npublic static String \u2003WATCH_POINT_SUPPOPT=\u201cweblogic.debugging.comm.watchpoint\u201d;\n\n\n\npublic static int \u2003INVALID_PAUSEID = \u22121;\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This will be called when we are ending. Problem is that this will not\n\n\n\n* get called in the case of system crashes, etc.\n\n\n\n*/\n\n\n\n\n\n\n\npublic void exit( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the classes we should filter to prevent from showing up\n\n\n\n* in the stack. You will be able to use wild cards, such as org.mozilla.rhino.*\n\n\n\n*/\n\n\n\n\n\n\n\nString[ ] LanguageFilters( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the class instances that we can get a script context from.\n\n\n\n*/\n\n\n\n\n\n\n\nString[ ] ContextHolders( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the class instances that we can call into to get variable information, etc.\n\n\n\n* When walking through a stack trace, we will go to each of these to ask it to spit out it's stack. We will\n\n\n\n* furthermore. When a user inspects this part of the stack, we will also ask these objects for variable values, etc.\n\n\n\n*/\n\n\n\n\n\n\n\nString LanguageName( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is a list of the class instances that we can call into to get variable information, etc.\n\n\n\n* When walking through a stack trace, we will go to each of these to ask it to spit out it's stack. We will\n\n\n\n* furthermore. When a user inspects this part of the stack, we will also ask these objects for variable values, etc.\n\n\n\n*/\n\n\n\n\n\n\n\nString[ ] LanguageExtensions( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This function is used for determining what features this debug engine supports. (UNDONE what features should\n\n\n\n\n\n\n\nwe\n\n\n\n\n\n\n\n\n\n* allow to be disabled)\n\n\n\n*/\n\n\n\n\n\n\n\nboolean featureEnabled(String feature);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* When pause is called, it is up to the script engine to break at the next possible\n\n\n\n* place. This method can be called while the engine is in the middle of processing,\n\n\n\n* so should be treated as a synchronized.\n\n\n\n*\n\n\n\n* @returns a boolean stating whether the scripting engine has more work to do in order to pause.\n\n\n\n* if this returns true, the Proxy will resume the thread, and wait for it to send a message\n\n\n\n* saying it's done. If this returns false, the thread will be suspended as is.\n\n\n\n*/\n\n\n\n\n\n\n\nboolean pause(Object context, int pauseID);\n\n\n//\n\n\n//Methods for Inspecting/dealing with variables\n\n\nIScriptValue getVariable(Object context, String strVar, int stackFrame);\n\n\nvoid \u2003setVariable(Object context, String strVar, IScriptValue value, int stackFrame);\n\n\nIScriptValue processValue(IScriptValue value);\n\n\nIScriptValue processExpression(Object context, String strExpr, int stackFrame);\n\n\n//Method for inspecting the current stack\n\n\nIScriptFrame[ ] getStack(Object context);\n\n\n//Breakpoints\n\n\nIBreakpointInfo setSourceBreakpoint(String clazz, int line, int id);\n\n\nIBreakpointInfo setMethodBreakpoint(String clazz, String method, String[ ] params, int id);\n\n\nIBreakpointInfo setWatchpoint(String clazz, String varName, boolean fStopOnRead, boolean fStopOnWrite, int id);\n\n\nvoid clearBreakpoint(int id);\n\n\nvoid clearAllBreakpoints( );\n\n\n//UNDONE(willpugh) -- must add a getAbstractType back to this, to find out what kind of object we\n\n\n// are dealing with. For a loosly typed language you could imagine having an object that implemented all\n\n\n// these interfaces.\n\n\npublic interface IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\nstatic final int SIMPLE_TYPE = 0;\n\n\n\nstatic final int COMPLEX_TYPE = 1;\n\n\n\nstatic final int SCRIPT_ARRAY_TYPE = 2;\n\n\n\nstatic final int OTHER_LANGUAGE_TYPE = 3;\n\n\n\nstatic final int JAVA_LANGUAGE_TYPE = 4;\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This gets the value we should display to the user.\n\n\n\n*/\n\n\n\nString getValue( );\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* If this is a language that supports types, this should return the type name of this variable.\n\n\n\n*/\n\n\n\n\n\n\n\nString getTypeName( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is the value the user typed in, it's up to the script engine to turn this\n\n\n\n* into a value.\n\n\n\n*/\n\n\n\n\n\n\n\nvoid setValue(String val) throws Exception;\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This determines if the variable is a complex type, simple type or other languagy type.\n\n\n\n*/\n\n\n\n\n\n\n\nint getAbstractType( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This determines if this script value is Read Only or not.\n\n\n\n*/\n\n\n\n\n\n\n\nboolean isReadOnly( );\n\n\n}\n\n\npublic interface ISimpleScriptValue extends IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\npublic static final int TYPE_BOOLEAN = 0;\n\n\n\npublic static final int TYPE_BYTE = 1;\n\n\n\npublic static final int TYPE_CHAR = 2;\n\n\n\npublic static final int TYPE_DOUBLE = 3;\n\n\n\npublic static final int TYPE_FLOAT = 4;\n\n\n\npublic static final int TYPE_INT = 5;\n\n\n\npublic static final int TYPE_LONG = 6;\n\n\n\npublic static final int TYPE_SHORT = 7;\n\n\n\npublic static final int TYPE_STRING = 8;\n\n\n\npublic static final int TYPE_NULL = 9;\n\n\n\npublic int \u2003getPrimativeType( );\n\n\n\npublic boolean \u2003getBoolean( );\n\n\n\npublic byte \u2003getByte( );\n\n\n\npublic char \u2003getChar( );\n\n\n\npublic double \u2003getDouble( );\n\n\n\npublic float \u2003getFloat( );\n\n\n\npublic int \u2003getInt( );\n\n\n\npublic long \u2003getLong( );\n\n\n\npublic short \u2003getShort( );\n\n\n\npublic String \u2003getString( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IScriptArrayValue extends IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\nint \u2003getLength( );\n\n\n\nIScriptValue \u2003getElement(int i);\n\n\n\n\n\n\n\n}\n\n\npublic interface IComplexScriptValue extends IScriptValue\n\n\n{\n\n\n\n\n\n\n\n\n\n/**\n\n\n\n* there can be complex types that do not have children.\n\n\n\n*/\n\n\n\n\n\n\n\nboolean hasChildren( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* if this is a complex type, this will return a list of all it's members.\n\n\n\n*/\n\n\n\n\n\n\n\nList getMembers( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* if this is a complex type, this will return a member of it.\n\n\n\n*/\n\n\n\n\n\n\n\nIScriptValue getMember(String name);\n\n\n/**\n\n\n\n\n\n\n\n\n\n* if this is a complex type, this will return a member of it.\n\n\n\n*/\n\n\n\n\n\n\n\nvoid setMember(String name, IScriptValue val) throws Exception;\n\n\n/**\n\n\n\n\n\n\n\n\n\n* calls a method on the complex type. If the method is a void method, it should\n\n\n\n* return a null. Otherwise, callMethod should return a scriptValue representing the\n\n\n\n* returned value. If that value is null, this will be a ScriptValue with the value null.\n\n\n\n*/\n\n\n\n\n\n\n\nIScriptValue callMethod(String name, IScriptValue[ ] values);\n\n\n}\n\n\npublic interface IOtherLanguageValue extends IScriptValue\n\n\n{\n\n\n/**\n\n\n\n\n\n\n\n\n\n* script extension for this variable.\n\n\n\n*/\n\n\n\n\n\n\n\nString getScriptExtension( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* gets the underlying value object. The other scripting language should be able to figure out\n\n\n\n* what this is to be able to create one of the other Script values from this.\n\n\n\n*/\n\n\n\n\n\n\n\nObject getValueObject( );\n\n\n}\n\n\npublic interface IJavaValue extends IScriptValue\n\n\n{\n\n\n/**\n\n\n\n\n\n\n\n\n\n* gets the underlying java object. The proxy will be able to disect this and keep values, etc for this.\n\n\n\n*/\n\n\n\nObject getValueObject( );\n\n\n\n\n\n\n\n}\n\n\npublic interface IScriptFrame\n\n\n{\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This will get the file extension specifying what language this is.\n\n\n\n* If a language supports more than one file extension, this will just be one.\n\n\n\n*/\n\n\n\nString getLanguageExtension( );\n\n\n\n\n\n\n\n/**\n\n\n\n\n\n\n\n\n\n* If this returns non-null, this string will be used to display\n\n\n\n* the stack frame to the user.\n\n\n\n*/\n\n\n\n\n\n\n\nString getFunctionName( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is the class name that we will derive the file from. This will be put through the\n\n\n\n* document resolution process on the ide.\n\n\n\n*/\n\n\n\n\n\n\n\nString getClassName( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is the class name that we will derive the file from. This will be put through the\n\n\n\n* document resolution process on the ide.\n\n\n\n*/\n\n\n\n\n\n\n\nString getFileName( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This is the line of execution the current frame is on.\n\n\n\n*/\n\n\n\n\n\n\n\nint getLine( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This function will return an array of all the values visible from the current stack. All the\n\n\n\n* values in the list that are returned will be of type Strong. To get a value, you will want\n\n\n\n* to call IDebuggableLanguage.getVariable\n\n\n\n*/\n\n\n\n\n\n\n\nList getFrameVariables( );\n\n\n/**\n\n\n\n\n\n\n\n\n\n* This function will return an IScriptValue if there is a <code>this</code> object, otherwise it\n\n\n\n* will return null.\n\n\n\n*/\n\n\n\n\n\n\n\nIScriptValue getThis( );\n\n\n}\n\n\npublic interface IBreakpointInfo\n\n\n{\n\n\n\n\n\n\n\n\n\npublic static final String BREAKPOINT_RESOLVED = \u201c0\u201d;\n\n\n\npublic static final String BREAKPOINT_UNRESOLVED = \u201c1\u201d;\n\n\n\npublic static final String BREAKPOINT_ERROR = \u201c2\u201d;\n\n\n\npublic String \u2003getStatus( );\n\n\n\npublic int \u2003getOrigLine( );\n\n\n\npublic int \u2003getCurrLine( );\n\n\n\npublic int \u2003getId( );\n\n\n\n\n\n\n\n}\n\n\n}",
        "Message\nSender\nMeaning\nParameters\n\n\n\n\n\n\n\nSetBreakpoint\nProxy\nTrying to set a\nFile - File\n\n\n\n\nscript breakpoint.\nname\n\n\n\n\n\nLine - Line number\n\n\n\n\n\nLanguage Ext - Language\n\n\n\n\n\nExtension\n\n\nSetMethodBreakpoint\nProxy\nTrying to set a\nClass - Class name (or file\n\n\n\n\nbreakpoint on a\nname is language doesn't\n\n\n\n\nmethod\nhave classes)\n\n\n\n\n\nMethod - Name of the\n\n\n\n\n\nmethod to set a breakpoint\n\n\n\n\n\non\n\n\n\n\n\nParameters - The\n\n\n\n\n\nparameters for the method\n\n\n\n\n\nto set a breakpoint on.\n\n\n\n\n\nThis disambiguates in the\n\n\n\n\n\ncase of multiple methods\n\n\n\n\n\nwith the same name but\n\n\n\n\n\ndifferent parameters\n\n\n\n\n\nLanguage Ext - Language\n\n\n\n\n\nExtensions\n\n\nBreakpointSet\nRuntime-\nBreakpoint is set\nStatus - Did the breakpoint\n\n\n\nmessaging\n\nget set\n\n\n\nenvironment\n\nError - Error message if it\n\n\n\n\n\nfailed\n\n\nBreakHit\nRuntime-\nA Script hit a\nFile - the file name\n\n\n\nmessaging\nbreakpoint\nLine - the line number\n\n\n\nenvironment\n\n\nContinue\nProxy\nA script should\nContinueType - whether\n\n\n\n\nresume\nthis should continue with a\n\n\n\n\n\nstep or a continue\n\n\nPause\nRuntime-\nTells the proxy a\nPauseID - This is the ID\n\n\n\nmessaging\nscript has gotten to\nwe use to map a pause the\n\n\n\nenvironment\na safe place and\nthread it was requested on.\n\n\n\n\npaused",
        "The foregoing description of preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to one of ordinary skill in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence."
    ],
    "citations": [
        "5321841",
        "5469562",
        "5604860",
        "5630131",
        "5748975",
        "5801958",
        "5835769",
        "5836014",
        "5845121",
        "5867822",
        "5944794",
        "5961593",
        "5966535",
        "6012083",
        "6016495",
        "6018730",
        "6023578",
        "6028997",
        "6029000",
        "6044217",
        "6067623",
        "6070184",
        "6092102",
        "6119149",
        "6141701",
        "6212546",
        "6222533",
        "6226675",
        "6230287",
        "6243737",
        "6292932",
        "6330569",
        "6334114",
        "6338064",
        "6343265",
        "6353923",
        "6360358",
        "6377939",
        "6408311",
        "6411698",
        "6445711",
        "6470364",
        "6560769",
        "6567738",
        "6584454",
        "6594693",
        "6594700",
        "6604198",
        "6609115",
        "6615258",
        "6636491",
        "6637020",
        "6643652",
        "6654932",
        "6678518",
        "6687702",
        "6687848",
        "6721779",
        "6732237",
        "6748420",
        "6757689",
        "6789054",
        "6795967",
        "6802000",
        "6804686",
        "6823495",
        "6832238",
        "6847981",
        "6850979",
        "6889244",
        "6915519",
        "6918084",
        "6950872",
        "6959307",
        "6963914",
        "6976086",
        "7017146",
        "7051072",
        "7051316",
        "7054858",
        "7062718",
        "7072934",
        "7076772",
        "7096422",
        "7107578",
        "7111243",
        "7117504",
        "7127704",
        "7143186",
        "2002/0004848",
        "2002/0010781",
        "2002/0010803",
        "2002/0016759",
        "2002/0035604",
        "2002/0078365",
        "2002/0083075",
        "2002/0111922",
        "2002/0120685",
        "2002/0143960",
        "2002/0152106",
        "2002/0161826",
        "2002/0165936",
        "2002/0174178",
        "2002/0174241",
        "2002/0184610",
        "2002/0194244",
        "2002/0194267",
        "2002/0194495",
        "2003/0004746",
        "2003/0005181",
        "2003/0014439",
        "2003/0018661",
        "2003/0018665",
        "2003/0018832",
        "2003/0028579",
        "2003/0041198",
        "2003/0043191",
        "2003/0046591",
        "2003/0051066",
        "2003/0055868",
        "2003/0055878",
        "2003/0074217",
        "2003/0079029",
        "2003/0084203",
        "2003/0110117",
        "2003/0110446",
        "2003/0126136",
        "2003/0149791",
        "2003/0167358",
        "2003/0196168",
        "2004/0019645",
        "2004/0078373",
        "2004/0133660",
        "2004/0148336",
        "2004/0204976",
        "2004/0216086",
        "2004/0225995",
        "2004/0260715",
        "2005/0050068",
        "2005/0278585",
        "2006/0064677",
        "2006/0206856",
        "2006/0234678",
        "2007/0038500",
        "WO 99/23558"
    ],
    "us_classification": "717125",
    "international_classifications": [
        {
            "classification_level": "A",
            "section": "G",
            "classification_class": "06",
            "subclass": "F",
            "main_group": "9",
            "subgroup": "44"
        }
    ]
}