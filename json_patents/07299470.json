{
    "title": "Method and system for regulating communication traffic using a limiter thread",
    "abstract": "A methodology for using multiple execution threads to regulate message traffic is presented. An application thread spawns a limiter thread, and each have access in shared memory to a message count that reflects a number of messages that are transmitted by the application thread within a regulated time period. The limiter thread cycles by entering a sleep state for the regulated time period, resetting the message count upon awakening, and then reentering a sleep state. The application thread executes a loop that compares the message count against a maximum number of messages for the regulated time period; if the comparison is favorable, then another message is transmitted and the message count is adjusted. If the comparison is not favorable, then the application thread enters a sleep state; after awakening, it repeats the comparison, and depending on the result, it transmits a message or reenters a sleep state.",
    "inventors": [
        "Curtis"
    ],
    "document_number": "07299470",
    "publication_date": "20071120",
    "assignees": [
        "International Business Machines Corporation"
    ],
    "claims": [
        {
            "claim_number": "CLM-00001",
            "preamble": "1. A method in a data processing system for regulating an amount of generated communication traffic using multiple execution threads or processes in a data processing system, the method comprising:",
            "components": [
                {
                    "component": "starting a first thread or process and a second thread or process, wherein the first thread or process and the second thread or process access a message count variable in shared memory, wherein the message count variable represents a number of messages that are transmitted by the first thread or process within a first time unit;",
                    "subcomponents": []
                },
                {
                    "component": "sleeping the second thread or process for the first time unit;",
                    "subcomponents": []
                },
                {
                    "component": "in response to an awakening of the second thread or process, resetting the message count variable by the second thread or process and re-sleeping the second thread or process for the first time unit;",
                    "subcomponents": []
                },
                {
                    "component": "comparing the message count variable with a predetermined count value on the first thread or process;",
                    "subcomponents": [
                        "in response to a first comparative result, sleeping the first thread or process for a second time unit;",
                        "in response to an awakening of the first thread or process, repeating the comparison step on the first thread or process; and",
                        "in response to a second comparative result, adjusting the message count variable and transmitting a message on the first thread or process."
                    ]
                },
                {
                    "component": "in response to a first comparative result, sleeping the first thread or process for a second time unit;",
                    "subcomponents": []
                },
                {
                    "component": "in response to an awakening of the first thread or process, repeating the comparison step on the first thread or process; and",
                    "subcomponents": []
                },
                {
                    "component": "in response to a second comparative result, adjusting the message count variable and transmitting a message on the first thread or process.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00002",
            "preamble": "2. The method of claim 1 further comprising:",
            "components": [
                {
                    "component": "stopping the second thread or process after the first thread or process has completed its transmission of messages.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00003",
            "preamble": "3. The method of claim 1 wherein the second time unit is shorter than the first time unit.",
            "components": []
        },
        {
            "claim_number": "CLM-00004",
            "preamble": "4. The method of claim 1 wherein the second thread or process resets the message count variable to zero and the first thread or process adjusts the message count variable by incrementing the message count variable.",
            "components": []
        },
        {
            "claim_number": "CLM-00005",
            "preamble": "5. The method of claim 1 wherein the second thread or process resets the message count variable to a non-zero number and the first thread or process adjusts the message count variable by decrementing the message count variable.",
            "components": []
        },
        {
            "claim_number": "CLM-00006",
            "preamble": "6. An apparatus for regulating an amount of generated communication traffic using multiple execution threads, the apparatus comprising:",
            "components": [
                {
                    "component": "means for starting a first thread and a second thread, wherein the first thread and the second thread access a message count variable in shared memory, wherein the message count variable represents a number of messages that are transmitted by the first thread within a first time unit;",
                    "subcomponents": []
                },
                {
                    "component": "means for comparing the message count variable with a predetermined count value on the first thread;",
                    "subcomponents": []
                },
                {
                    "component": "means for sleeping the first thread for a second time unit in response to a first comparative result;",
                    "subcomponents": []
                },
                {
                    "component": "means for repeating the comparison step on the first thread in response to an awakening of the first thread or process;",
                    "subcomponents": []
                },
                {
                    "component": "means for adjusting the message count variable in response to a second comparative result; and",
                    "subcomponents": []
                },
                {
                    "component": "means for transmitting a message on the first thread in response to a second comparative result.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00007",
            "preamble": "7. The apparatus of claim 6 further comprising:",
            "components": [
                {
                    "component": "means for sleeping the second thread for the first time unit;",
                    "subcomponents": []
                },
                {
                    "component": "means for resetting the message count variable by the second thread in response to an awakening of the second thread; and",
                    "subcomponents": []
                },
                {
                    "component": "means for re-sleeping the second thread for the first time unit in response to an awakening of the second thread.",
                    "subcomponents": []
                }
            ]
        }
    ],
    "description": [
        "1. Field of the Invention",
        "The present invention relates to an improved data processing system and, in particular, to a method and apparatus for input/output processing. Still more particularly, the present invention provides a method and apparatus for implementing a mechanism for transferred data counting.",
        "2. Description of Related Art",
        "In many computing environments, a client-server arrangement enables clients and servers to have specialized duties. By limiting the variety of computational tasks with which a client or a server is burdened, the client or the server can focus its resources on performing its tasks more efficiently. In particular, servers are usually configured to process large numbers of client transactions or to manage storage on behalf of many clients within a network. Although efficient computational management increases the maximum possible load on a server, its computational resources are not limitless, and typically the load on the server is limited in some manner.",
        "For a variety of reasons, it is often desirable to be able to control the amount of traffic that is initiated by a client application to a server. For example, in order to determine the load performance of a Web server, the Web server may be tested by bombarding it with a large number of Web-based requests over a period of time. The requests can originate from a predetermined number of client processes that simulate the data traffic that the Web server would experience from a large number of Web browser applications. In this scenario, it is important to be able to accurately control the rate of requests that are sent to the Web server, thereby controlling the load that is experienced by the Web server, in order to obtain numerically accurate and meaningful measurements that can be used to predict Web server load characteristics under varying, real-life conditions.",
        "As another example, a communication service provider may sell communication services on a subscription basis in which different charges apply to different subscription service levels. Each subscription service level may limit the number of requests from a subscriber's data device to the communication service provider's server below a certain number of requests per time unit, e.g., one hundred requests per second or one thousand requests per minute, even though the available bandwidth may be much greater. In order to provide accurate service, the communication service provider needs to be able to accurately limit the rate of requests that are transmitted by a subscriber.",
        "Therefore, it would be advantageous to have a methodology for accurately limiting the rate of requests that are transmitted from a client to a server.",
        "A method, a system, an apparatus, and a computer program product are presented for using multiple execution threads in a data processing system to regulate an amount of communication traffic that is generated by an application. An application thread generates data packets or messages to be transmitted, such as client requests to a server. The application thread spawns a limiter thread, and the application thread and the limiter thread have access to a message count variable in shared memory. The message count variable reflects a number of messages that are transmitted by the application thread within a specific time period, e.g., one second; the message count variable can be initially set to zero and subsequently incremented to show the number of messages that have been sent within the specific time period, or the message count variable can be set to a non-zero number and subsequently decremented to show the number of messages that remain to be sent within the specific time period.",
        "After the limiter thread has been spawned, it executes independent of the application thread except for the coordination between the threads through the message count variable. The limiter thread executes in a permanent loop in which it enters a sleep state for a previously specified time period, resets the message count variable upon awakening, and then reenters a sleep state. The limiter thread preferably sleeps for a time period that is equal to a regulated time period; for example, if one hundred messages may be sent in seven seconds, then the limiter thread would sleep for seven seconds. The limiter thread executes until it is killed by the application thread after the application thread has completed a phase in which it is attempting to transmit messages in a regulated fashion.",
        "While the limiter thread is cycling, the application thread is also executing a loop in which it is attempting to transmit messages. The application thread adjusts the message count variable for each message that is transmitted.",
        "However, before a message is transmitted, the application thread checks whether it is allowed to transmit another message by comparing the message count variable with a predetermined value that represents the maximum number of messages that may be sent within the predetermined regulated time period. If the comparison is favorable for transmitting another message, then the application thread transmits another message.",
        "If the comparison is not favorable for transmitting another message, then the application thread waits to transmit another message by entering a sleep state. The application thread preferably sleeps for a time period that is substantially shorter than the regulated time period. When the application thread awakens, it repeats the comparison of the message count variable and the maximum value. Depending on the result of the comparison, the application thread again performs the appropriate action.",
        "The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, further objectives, and advantages thereof, will be best understood by reference to the following detailed description when read in conjunction with the accompanying drawings, wherein:",
        "FIG. 1A is a block diagram that depicts a typical distributed data processing system in which the present invention may be implemented;",
        "FIG. 1B is a block diagram that depicts a typical computer architecture that may be used within a data processing system in which the present invention may be implemented;",
        "FIG. 2 is a flowchart that depicts a methodology for implementing a communication traffic limiter that regulates the rate of transmission of messages from an application in accordance with the present invention;",
        "FIG. 3 is a set of timelines that depict the manner in which an application thread and a limiter thread interoperate through the message count variable in shared memory to establish a limiter mechanism in accordance with the present invention;",
        "FIG. 4 is a set of Java language statements that depict an example of a Limiter class that may be used to implement a limiter mechanism in accordance with an embodiment of the present invention; and",
        "FIG. 5 depicts a set of Java language statements that show the use of a limiter mechanism in accordance with an embodiment of the present invention.",
        "The present invention is directed to a system and a methodology for controlling the rate of communication traffic from an application to another application or system. As background, a typical organization of hardware and software components within a distributed data processing system is described prior to describing the present invention in more detail.",
        "With reference now to the figures, FIG. 1A depicts a typical network of data processing systems, each of which may contain and/or operate the present invention. Distributed data processing system 100 contains network 101, which is a medium that may be used to provide communications links between various devices and computers connected together within distributed data processing system 100. Network 101 may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone or wireless communications. In the depicted example, server 102 and server 103 are connected to network 101 along with storage unit 104. In addition, clients 105-107 also are connected to network 101. Clients 105-107 and servers 102-103 may be represented by a variety of computing devices, such as mainframes, personal computers, personal digital assistants (PDAs), etc. Distributed data processing system 100 may include additional servers, clients, routers, other devices, and peer-to-peer architectures that are not shown.",
        "In the depicted example, distributed data processing system 100 may include the Internet with network 101 representing a worldwide collection of networks and gateways that use various protocols to communicate with one another, such as Lightweight Directory Access Protocol (LDAP), Transport Control Protocol/Internet Protocol (TCP/IP), Hypertext Transport Protocol (HTTP), Wireless Application Protocol (WAP), etc. Of course, distributed data processing system 100 may also include a number of different types of networks, such as, for example, an intranet, a local area network (LAN), or a wide area network (WAN). For example, server 102 directly supports client 109 and network 110, which incorporates wireless communication links. Network-enabled phone 111 connects to network 110 through wireless link 112, and PDA 113 connects to network 110 through wireless link 114. Phone 111 and PDA 113 can also directly transfer data between themselves across wireless link 115 using an appropriate technology, such as Bluetooth\u2122 wireless technology, to create so-called personal area networks (PAN) or personal ad-hoc networks. In a similar manner, PDA 113 can transfer data to PDA 107 via wireless communication link 116.",
        "The present invention could be implemented on a variety of hardware platforms; FIG. 1A is intended as an example of a heterogeneous computing environment and not as an architectural limitation for the present invention.",
        "With reference now to FIG. 1B, a diagram depicts a typical computer architecture of a data processing system, such as those shown in FIG. 1A, in which the present invention may be implemented. Data processing system 120 contains one or more central processing units (CPUs) 122 connected to internal system bus 123, which interconnects random access memory (RAM) 124, read-only memory 126, and input/output adapter 128, which supports various I/O devices, such as printer 130, disk units 132, or other devices not shown, such as a audio output system, etc. system bus 123 also connects communication adapter 134 that provides access to communication link 136. User interface adapter 148 connects various user devices, such as keyboard 140 and mouse 142, or other devices not shown, such as a touch screen, stylus, microphone, etc. Display adapter 144 connects system bus 123 to display device 146.",
        "Those of ordinary skill in the art will appreciate that the hardware in FIG. 1B may vary depending on the system implementation. For example, the system may have one or more processors, including a digital signal processor (DSP) and other types of special purpose processors, and one or more types of volatile and non-volatile memory. Other peripheral devices may be used in addition to or in place of the hardware depicted in FIG. 1B. The depicted examples are not meant to imply architectural limitations with respect to the present invention.",
        "In addition to being able to be implemented on a variety of hardware platforms, the present invention may be implemented in a variety of software environments. A typical operating system may be used to control program execution within each data processing system. For example, one device may run a Unix\u00ae operating system, while another device may contain a simple Java\u00ae runtime environment. A representative computer platform may include a browser, which is a well known software application for accessing hypertext documents in a variety of formats, such as graphic files, word processing files, Extensible Markup Language (XML), Hypertext Markup Language (HTML), Handheld Device Markup Language (HDML), Wireless Markup Language (WML), and various other formats and types of files.",
        "The present invention may be implemented on a variety of hardware and software platforms, as described above. More specifically, though, the present invention is directed to a system and a methodology for controlling the rate of communication traffic that is transmitted by an application, as described in more detail below. In the following examples, an application is shown that generates a series or sequence of messages for one or more different purposes. The application can be understood to be a general-purpose application, but it should also be understood that the application may be constructed specifically for communication tasks. For example, the application could be specifically configured for simulating the transmission of requests from a Web browser application that is operating on a client device to a server that responds to the requests, in which case the limiter mechanism of the present invention could be employed in conjunction with the application to precisely control the rate of requests from the application. In another example, the application may be a Web browser application, and the limiter mechanism of the present invention may be employed in conjunction with the Web browser application as required by a communication service provider to control the rate of requests from the Web browser application in accordance with a subscribed level of service provided by the communication service provider to the Web browser's user.",
        "Messages from the application may be formatted in a proprietary manner or in accordance with well-known standards, e.g., HTTP Request messages. More generally, a message may be a simple data packet or a coordinated set of data packets that are transmitted by the application.",
        "The described application that uses the present invention operates in a computational environment that supports multiple threads of execution, multiple processes, or multiple tasks. For simplicity of discussion, the following examples are directed to a discussion of multiple threads, but it should be understood that the present invention may also be implemented in an operational environment with process management or task management. The application may comprise an application thread that generates message traffic, and the limiter mechanism of the present invention operates in conjunction with the application thread. Moreover, the present application may be implemented in an environment in which an operating system and/or a central processing unit (CPU) allow multiple simultaneous execution paths without regard to thread or process management.",
        "Alternatively, the application may comprise multiple threads of execution, a plurality of which generate message traffic, and multiple instances of the limited mechanism of the present invention could be implemented in conjunction with multiple application threads of execution. For simplicity of presentation, the following examples depict only a single application thread.",
        "With reference now to FIG. 2, a flowchart depicts a methodology for implementing a communication traffic limiter that regulates the rate of transmission of messages from an application in accordance with the present invention. The flowchart shown in FIG. 2 differs from typical flowcharts in that two simultaneous processes are potentially executing during a given time period. The operations that are shown in FIG. 2 center on an application thread that generates data packets or messages to be transmitted, such as client requests to a server. As shown in FIG. 2, it is possible that the application thread has already been executing for some period of time, including a period of time in which the application thread has already transmitting some number of messages in a regulated fashion.",
        "The application thread spawns a limiter thread (step 202), after which the application thread and the limiter thread have access to a message count variable in shared memory. The message count variable reflects a number of messages that have been transmitted by the application thread within a specific time period, e.g., one second. Alternatively, the message count variable reflects a number of messages that remain to be transmitted by the application thread within a specific time period. In other words, the message count variable can be initially set to zero and subsequently incremented to show the number of messages that have been sent within the specific time period, or the message count variable can be set to a maximum, non-zero number and subsequently decremented to show the number of messages that remain to be sent within the specific time period. In the following examples, it is assumed that the message count variable is incremented and then compared to a maximum value.",
        "The limiter mechanism of the present invention limits an application's message traffic based on its rate of transmission, i.e. number of messages per unit of time. The specific time value that is used as the regulated period may be statically or dynamically determined or adjusted based on configuration parameters, operating conditions, user input, or other considerations. For simplicity of presentation, the following examples assume that the regulated time period is one second.",
        "The maximum number of messages that may be transmitted per time unit may be statically or dynamically determined or adjusted based on configuration parameters, operating conditions, user input, or other considerations. For simplicity of presentation, the following examples assume that the maximum number of messages per time unit has been previously determined and is static during the time period of interest.",
        "After the limiter thread has been spawned, it executes independent of the application thread except for the coordination between the threads through the message count variable. The limiter thread executes in a permanent loop in which it enters a sleep state for a previously specified time period (step 204), resets the message count variable upon awakening (step 206), and then reenters a sleep state. The limiter thread preferably sleeps for a time period that is equal to a regulated time period; for example, if ten messages may be sent in one second, then the limiter thread would sleep for one second. The limiter thread executes until it is killed by the application thread after the application thread has completed a phase in which it is attempting to transmit messages in a regulated fashion.",
        "After an optional phase in which the application performs some type of initialization for the next round of message transmission (step 208), the application thread is also executing a loop in which it is attempting to transmit messages while the limiter thread is cycling. The application thread adjusts the message count variable for each message that is transmitted. In FIG. 2, the message count variable is incremented prior to transmitting a message (step 210); alternatively, the message count variable may be incremented after a message is transmitted.",
        "However, before a message is transmitted, the application thread checks whether it is allowed to transmit another message by comparing the message count variable with a predetermined value that represents the maximum number of messages that may be sent within the predetermined regulated time period (step 212). If the comparison is favorable for transmitting another message, which in the example of FIG. 2 means that the number of transmitted messages is less than the maximum threshold, then the application thread transmits another message (step 214).",
        "If the comparison is not favorable for transmitting another message, then the application thread waits to transmit another message by entering a sleep state (step 216). The application thread preferably sleeps for a time period that is substantially shorter than the regulated time period, i.e. a relatively short time period. For example, if the regulated time period is one second, then the application thread may sleep for one millisecond. When the application thread awakens, it repeats the comparison of the message count variable and the maximum value by looping back to step 212. Depending on the result of the comparison, the application thread again performs the appropriate action.",
        "After transmitting a message at step 214, a determination is made as to whether or not the application thread should continue to transmit messages (step 218). For example, the application thread may have been tasked to transmit messages for a particular period of time, e.g. one hour, and the application thread could check a timer condition to determine whether it has exceeded the time period. As another example, the application thread may have been tasked to send a particular number of messages, and the application thread could check some type of counter condition to determine whether it has exceeded this number. Other conditions for limiting the operation of the application thread may be employed, and these conditions may be statically or dynamically determined or adjusted based on configuration parameters, operating conditions, user input, or other considerations.",
        "If the application thread should continue to send messages, then it branches back to step 210 to send at least one more message. If the application thread should not continue to send messages, then the application thread kills the limiter thread that it previously spawned (step 220), and the process is complete.",
        "As mentioned briefly above, the examples herein depict only a single application thread. However, it should also be understood that the application thread and the limiter thread should not be restricted to being interpreted as existing in the execution space of a single process or of a single application. For example, in the embodiment described above, an application thread spawns a limiter thread so that the application may use the limiter mechanism of the present invention. In an alternative embodiment, the limiter thread may be spawned by an application or process other than the application that is using the limiter mechanism of the present invention. In this alternative scenario, a separate process may control one or more limiter threads for the use of applications that need a limiter mechanism. In this alternative embodiment, the application that is using the limiter mechanism can discover or be provided with the address of its message count variable in shared memory by the application or process that is controlling the limiter thread, thereby implying that the controlling application communicates or coordinates with the using application in some manner. In this manner, the application thread and the limiter thread may exist in different process spaces, and the message count variable may be interpreted as existing in shared memory that is accessible system-wide and not merely within a single process space.",
        "With reference now to FIG. 3, a set of timelines depict the manner in which an application thread and a limiter thread interoperate through the message count variable in shared memory to establish a limiter mechanism in accordance with the present invention. FIG. 3 depicts some of the results of the actions that were described above with respect to FIG. 2 by showing the application thread, the limiter thread, and the message count variable over a period of time; time increases from the top of FIG. 3 to the bottom of FIG. 3. It should be noted that the timelines are not shown to scale.",
        "Message count 302 shows the values that the message count variable in shared memory may have over a period of time. In this example, the maximum number of messages that may be sent per time unit is \u201cN\u201d, and the limiter mechanism increments the message count variable. Hence, the message count begins at zero and increases to \u201cN+1\u201d, which is held for some period of time during which the transmission of messages ceases. After the transmission of messages resumes, then the incremental increase of the message count begins anew.",
        "The execution of application thread 304 is separated into two sets of time periods in accordance with a specific implementation of the present invention. In this example, it is assumed that generator/transmitter 306 of the application is responsible for the generation and transmission of messages 310-316, whereas counter/delayer 320 is responsible for tracking the number of messages that have been transmitted while also delaying the further transmission of messages if the number of messages for the current time period would exceed the allowable threshold value. FIGS. 4-5 show Java language statements that may be used to implement the present invention in accordance with the generator/transmitter and counter/delayer configuration shown in FIG. 3.",
        "During time period 322, generator/transmitter 306 calls a routine in counter/delayer 320 that initializes the message count variable in shared memory while also spawning limiter thread 324. In a fashion similar to that described with respect to FIG. 2, limiter thread 324 enters its loop of execution in which relatively long periods of thread sleep, such as thread sleep periods 326 and 328, are interrupted by short periods of execution in which the limiter thread resets the message count variable, such as write action 330. In this manner, the message count variable can be accurately reset at the end or beginning of every regulated time period.",
        "Meanwhile, application thread 304 attempts to send messages without violating its specified rate of transmission. Prior to sending a message, the generator/transmitter checks with the counter/delay, which increments the message count variable, e.g., represented by write action 332. As long as the message count has not exceeded the maximum threshold \u201cN\u201d during the given time period that is being tracked by the limiter thread, then the counter/delayer does not insert any delays into the transmission process, and the generator/transmitter can generate and transmit another message, such as message 314.",
        "However, after write action 334, the counter/delayer discovers that the message count has reached \u201cN+1\u201d, i.e. that another message transmission would violate the specified threshold \u201cN\u201d. Hence, the counter/delayer inserts a delay into the generation/transmission process by entering a relatively short thread sleep 336 that holds the operation of the generator/transmitter.",
        "Upon awakening of the application thread, the counter/delayer again checks the message count variable, and because the limiter thread has not yet reset the message count variable, the counter/delayer again enters another thread sleep period, shown as thread sleep 338. The counter/delayer continues this cycle until the limiter thread has reset the message count with write action 330.",
        "Write action 330 essentially indicates that the previous time period has ended and the application has entered a new time period to be considered as the current time period. Hence, upon awakening after write action 330, the counter/delayer finds that the message count is not greater than the maximum message count for the current time period, and the counter/delayer does not enter a thread sleep. The counter/delayer returns execution control to the generator/transmitter, which is then free to generate and transmit message 315. This cycling process may continue until the application thread determines that no further messages should be transmitted, as explained with respect to FIG. 2.",
        "With reference now to FIG. 4, a set of Java language statements depicts an example of a Limiter class that may be used to implement a limiter mechanism in accordance with an embodiment of the present invention. Statement 402 declares the Limiter class; Limiter objects of this class are shown in use in FIG. 5, which is described in more detail further below. The statements shown in FIG. 4 merely illustrate some of the functionality that could be incorporated into a Limiter class, which may comprise additional attributes and methods other than those shown in FIG. 4.",
        "Statement 404 declares a \u201climiterThread\u201d attribute for referencing the child thread to be spawned by the application thread. Statement 406 declares a \u201cmaxMessagesPerTimeUnit\u201d attribute that reflects the maximum number of messages that can be transmitted by the application in a given period of time, i.e. the maximum allowable rate. Statement 408 declares a \u201cmessagecounter\u201d variable that stores the number of messages that have been sent by the application; the \u201cstatic\u201d keyword ensures that the message count variable is a class variable, i.e. there is only one copy of the variable associated with the class rather than many copies of the variable associated with each instance of the class.",
        "Statement 410 defines a method for setting the maximum number of messages that can be transmitted by the application in a given period of time. Statement 412 defines a method to be called by the generator/transmitter portion of the code when it desires to spawn the limiter thread and start the limiter mechanism, whereas statement 414 defines a method to be called to kill the limiter thread and stop the limiter mechanism.",
        "Statement 416 defines a \u201ccounterDelayer\u201d method for counting and delaying message transmission. Statement 418 increments the message count variable, whereas statement 420 determines if the message counter exceeds the maximum threshold for the current time period. If the threshold has been exceeded, then statement 422 causes the thread to enter a one millisecond sleep period.",
        "Statement 424 defines the \u201crun( )\u201d method for the Limiter class. Statement 402 declares that the Limiter class implements the \u201cRunnable\u201d interface. To create a thread, one can pass a \u201cRunnable\u201d object, i.e. an object that implements the \u201cRunnable\u201d interface by defining a \u201crun( )\u201d method, to the \u201cThread\u201d constructor. A \u201crun( )\u201d method of a \u201cRunnable\u201d object is the \u201cbody\u201d of the thread; it begins executing when the \u201cstart( )\u201d method of the \u201cThread\u201d object is called and continues to run until it returns or until the \u201cstop( )\u201d method of its \u201cThread\u201d object is called. Statement 426 ensures that the \u201crun( )\u201d method enters an infinite \u201cwhile\u201d loop and does not return; hence, the method can only be halted by calling \u201cstop( )\u201d on the thread instance. Within this loop, statement 428 causes the \u201cThread\u201d object to enter a one second (one thousand milliseconds) thread sleep; after exiting the thread sleep, statement 430 resets the message counter variable to zero.",
        "With reference now to FIG. 5, a set of Java language statements depicts the use of a limiter mechanism in accordance with an embodiment of the present invention. FIG. 5 shows the use of a limiter mechanism as implemented in the Limiter class shown in FIG. 4.",
        "An application that implements the present invention uses at least two threads of execution: an application thread and a limiter thread. As mentioned briefly with respect to FIG. 3, with respect to execution flow, the application thread can be considered to be divided into a message generator/transmitter and a counter/delayer. As shown in FIG. 4, most of the functionality with respect to the limiter mechanism of the present invention can be embodied into a single limiter class: the functionality for the counter/delayer; the functionality for spawning a limiter thread; and the functionality for the body of the limiter thread.",
        "After an optional initialization phase or possibly a prior message transmission phase in the application, statement 502 instantiates a new Limiter object, and statement 504 calls its \u201cstart( )\u201d method, which spawns the limiter thread. At this point, the application now has a distinct application thread and a distinct limiter thread, and the limiter thread is executing the its \u201crun( )\u201d method.",
        "The application thread continues execution with statement 506, which sets the maximum number of messages that may be transmitted in a given time period.",
        "The application thread then enters an execution loop that can be considered to be the generator/transmitter portion of the application thread. Statement 508 checks a \u201cdone\u201d variable to determine whether the application should cease generating and transmitting messages; as explained with respect to FIG. 2, there may be many conditions that are placed on the application as to the manner in which message transmission is controlled in a greater sense. Within this execution loop, statement 510 calls the routine within the limiter object created by statement 502. The call to the \u201ccounterDelayer( )\u201d method essentially notifies the method that another message needs to be transmitted, thereby allowing the \u201ccounterDelayer( )\u201d method to increment the message count variable and to determine whether it should stall the transmission of messages by entering a series of short thread sleeps. When statement 512 is reached, the application has no restrictions on its message transmission ability, so the next message is generated and transmitted.",
        "Statement 514 can be used to catch an exception that could be thrown by the \u201ccounterDelayer( )\u201d routine; for example, the \u201ccounterDelayer( )\u201d method could be alternatively written to throw an exception when the expiration of an additional, relatively long timer indicates a condition in which the application has stalled for too long while waiting for the limiter thread to reset the message count variable. Other potential error conditions may also be considered within the Limiter object.",
        "At some point in time, the application thread will exit the execution loop controlled by statement 508, at which point the limiter thread is no longer needed. Statement 516 kills the limiter thread by calling the \u201cstop( )\u201d method of the limiter object.",
        "The advantages of the present invention should be apparent in view of the detailed description of the invention that is provided above. The present invention allows the message traffic from a client to be regulated by controlling the rate of requests, i.e. the number of requests per time unit, that are issued by a client application. The number of requests per time unit is controlled by a limiter thread that is separate from the application thread that is generating the communication traffic. The two threads may spend a majority of their existence in a sleep state, thereby conserving execution time for other processes.",
        "The regulator mechanism of the present invention can be implemented in scenarios for which there is a desire to limit communication traffic at the application level, whether between two applications or between two systems. In one example scenario, a Web-server-load-test application can be constructed by employing a plurality of Web browser simulators, each of which generate and send requests to a server, and the rate of requests from each simulator can be accurately controlled by the limiter of the present invention. By increasing the accuracy of the simulation of client communication traffic, the accuracy of the entire load-test simulation can be increased.",
        "It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that some of the processes associated with the present invention are capable of being distributed in the form of instructions in a computer readable medium and a variety of other forms, regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include media such as EPROM, ROM, tape, paper, floppy disc, hard disk drive, RAM, and CD-ROMs and transmission-type media, such as digital and analog communications links.",
        "The description of the present invention has been presented for purposes of illustration but is not intended to be exhaustive or limited to the disclosed embodiments. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiments were chosen to explain the principles of the invention and its practical applications and to enable others of ordinary skill in the art to understand the invention in order to implement various embodiments with various modifications as might be suited to other contemplated uses."
    ],
    "citations": [
        "4930122",
        "5649103",
        "5815727",
        "5907675",
        "5951653",
        "5991286",
        "5999538",
        "6055578",
        "6078591",
        "6088363",
        "6128644",
        "6154769",
        "6178177",
        "6381649",
        "6434651",
        "6631462",
        "10-224356"
    ],
    "us_classification": "718107",
    "international_classifications": [
        {
            "classification_level": "A",
            "section": "G",
            "classification_class": "06",
            "subclass": "F",
            "main_group": "9",
            "subgroup": "00"
        }
    ]
}