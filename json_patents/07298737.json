{
    "title": "Parity exchange",
    "abstract": "A switch of a network for switching data. The switch includes a fabric for switching the data. The switch includes a parity fabric. The switch includes a connection mechanism connected to the fabric for providing data to and from the fabric and connected to the parity fabric for providing parity data to and from the parity fabric. The switch includes a first port card which receives data at a first rate from the network or sends data at the first rate to the network, performs first parity calculations on the data received at the first port card, produces first parity data from the first parity calculations or sends data at the first rate to the network. The switch includes a second port card which receives data at a second rate from the network or sends data at the second rate to the network, performs second parity calculations on the data received at the second port card, produces second parity data from the second parity calculations or sends data at the second rate to the network.",
    "inventors": [
        "Schulz"
    ],
    "document_number": "07298737",
    "publication_date": "20071120",
    "assignees": [
        "Ericsson A.B."
    ],
    "claims": [
        {
            "claim_number": "CLM-00001",
            "preamble": "1. A switch of a network for switching data comprising:",
            "components": [
                {
                    "component": "a fabric for switching the data;",
                    "subcomponents": []
                },
                {
                    "component": "a parity fabric;",
                    "subcomponents": []
                },
                {
                    "component": "a connection mechanism connected to the fabric for providing data to and from the fabric and connected to the parity fabric for providing parity data to and from the parity fabric;",
                    "subcomponents": []
                },
                {
                    "component": "a first port card which receives data at a first rate from the network or sends data at the first rate to the network, performs first parity calculations on the data received at the first port card, produces first parity data from the first parity calculations or sends data at the first rate to the network, the first port card connected to the connection mechanism to send data to or receive the data from the fabric at a connection rate and to send the first parity data to or receive the data from the parity fabric at the connection rate; and",
                    "subcomponents": []
                },
                {
                    "component": "a second port card which receives data at a second rate different from the first rate from the network or sends data at the second rate to the network performs second parity calculations on the data received at the second port card, produces second parity data from the second parity calculations or sends data at the second rate to the network, the second port card connected to the connection mechanism to send data to or receive the data from the fabric at the connection rate and to send the second parity data to or receive the data from the parity fabric at the connection rate, the second port card separating the data received at the second rate into streams of data that together equal the data received at the second port card that are sent concurrently at the connection rate to the fabric and combine the data streams received at the connection rate into data that is sent at the second rate to the network, the connection rate equals the first rate and the second rate is equal to N times the first rate, where N is an integer greater than or equal to 2, and there are N streams.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00002",
            "preamble": "2. A switch as described in claim 1 wherein the connection mechanism includes a backplane bus that connects the first port card and the second port card to the fabric.",
            "components": []
        },
        {
            "claim_number": "CLM-00003",
            "preamble": "3. A switch as described in claim 2 wherein the first port card has a first striper which takes the first parity data it receives and sends it on the backplane bus as an OC48 data pipe to the parity fabric, and the second port card has a second striper which takes the second parity data it receives and sends it as an OC48 data pipe to the parity fabric.",
            "components": []
        },
        {
            "claim_number": "CLM-00004",
            "preamble": "4. A switch as described in claim 3 wherein the first port card has a first unstriper which receives the first parity data from the parity fabric on an OC48 data pipe and the second port card has a second unstriper which receives the second parity data from the parity fabric on an OC48 data pipe.",
            "components": []
        },
        {
            "claim_number": "CLM-00005",
            "preamble": "5. A switch as described in claim 4 wherein the first and second striper stripe the first and second parity data respectively, they receive on a 48 bit basis to the parity fabric.",
            "components": []
        },
        {
            "claim_number": "CLM-00006",
            "preamble": "6. A switch as described in claim 5 wherein the first and second stripers stripe the first and second parity data, respectively, so the first and second parity data does not exceed a 12 bit boundary.",
            "components": []
        },
        {
            "claim_number": "CLM-00007",
            "preamble": "7. A switch as described in claim 6 wherein the parity fabric has an aggregator which receives the first and second parity data from the first and second stripers, respectively, and a separator which sends parity data from the parity fabric to the first unstriper and the second unstriper.",
            "components": []
        },
        {
            "claim_number": "CLM-00008",
            "preamble": "8. A method for switching data in a network comprising the steps of:",
            "components": [
                {
                    "component": "receiving data at a first rate from the network at a first port card of a switch;",
                    "subcomponents": []
                },
                {
                    "component": "receiving data at a second rate different from the first rate from the network at a second port card of the switch;",
                    "subcomponents": []
                },
                {
                    "component": "performing parity calculations on the data at the first rate by the first port card to produce first parity data and on the data at the second rate by the second port card to produce second parity data;",
                    "subcomponents": []
                },
                {
                    "component": "sending the first parity data from the first port card to a parity fabric of the switch through a connection mechanism of the switch at a connection rate, which equals the first rate and the second rate is equal to N times the first rate, where N is an integer greater than or equal to 2, and there are N streams;",
                    "subcomponents": []
                },
                {
                    "component": "separating the data received at the second rate at the second port card into streams of data that together equal the data received at the second port card;",
                    "subcomponents": []
                },
                {
                    "component": "sending the second parity data from the second port card to the parity fabric of the switch through the connection mechanism of the switch at the connection rate; and",
                    "subcomponents": []
                },
                {
                    "component": "sending concurrently at the connection rate to the fabric from the second port card the streams of data along the connection mechanism.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00009",
            "preamble": "9. A method as described in claim 8 wherein the connection mechanism includes a backplane bus that connects the first port card and the second port card to the fabric.",
            "components": []
        },
        {
            "claim_number": "CLM-00010",
            "preamble": "10. A method as described in claim 9 wherein the first port card has a first striper and the second port card has a second striper, and wherein the sending data from the first port card step includes the step of sending the first parity data on the backplane bus with the first striper as an OC48 data pipe to the parity fabric and the sending data from the second port card step includes the step of sending the second parity data on the backplane bus with the second striper as an OC48 data pipe to the parity fabric.",
            "components": []
        },
        {
            "claim_number": "CLM-00011",
            "preamble": "11. A method as described in claim 10 wherein the first port card has a first unstriper and the second port card has a second unstriper, and including after the sending the second parity data by the second striper step, there are the steps of receiving the first parity data from the parity fabric on an OC48 data pipe at the first port card, and receiving the second parity data from the parity fabric on an OC48 data pipe at the second port card.",
            "components": []
        },
        {
            "claim_number": "CLM-00012",
            "preamble": "12. A method as described in claim 11 wherein the first port card sending step includes the step of striping the first parity data with the first striper on a 48 bit basis to the parity fabric, and the second port card sending step includes the step of striping parity data with the second striper on a 48 bit basis to the parity fabric through the bus.",
            "components": []
        },
        {
            "claim_number": "CLM-00013",
            "preamble": "13. A method as described in claim 12 wherein the first striper sending step includes the step of striping the first parity data to the parity fabric through the bus so the first parity data does not exceed a 12 bit boundary, and the second striper sending step includes the step of striping the second parity data to the parity fabric through the bus so the second parity data does not exceed a 12 bit boundary.",
            "components": []
        }
    ],
    "description": [
        "U.S. patent application Ser. Nos. 09/609,307 titled \u201cBackplane Synchronization in a Distributed System with Clock Drift and Transport Delay\u201d; Ser. No. 09/609,497 titled \u201cQueue Resynch: Synchronous Real-Time Upgrade of a Distributed Switching System\u201d; 09/627,924 titled \u201cSynchronous Dynamic Register Updating Across a Distributed System\u201d; Ser. No. 09/293,563 titled \u201cVery Wide Memory TDM Switching System\u201d; Ser. No. 09/333,450 titled \u201cData Striping Based Switching System\u201d; and contemporaneously filed U.S. patent application Ser. No. 09/686,768 titled \u201cDual Optimality for Different Data Rate Backplane Transfers\u201d all of which are incorporated by reference herein.",
        "The present invention is related to the transfer of parity regarding data connections at various rates across a same backplane of a switch to a parity fabric. More specifically, the present invention is related to the transfer of parity data regarding connections at various rates across the same backplane of the switch by transferring the parity data associated with higher data rate connections into data pipes having the same rate as the data pipes formed from parity data associated with the lower rate connections.",
        "The BFS chipset of Fore Systems stripes data across multiple fabrics. The striping function is identical for both OC48 and OC192 ports. The parity generation function (calculation of the data bits for the spare fabric) requires data from multiple stripers. The derivation of the parity functions has been defined to optimize the chip to chip communication required for both encoding and decoding of the parity information on the BFS port cards and to allow for traffic to be sent between OC48 and OC192 ports.",
        "The present invention allows a design to support both OC48 and OC192 link speed with minimal overhead in the function which calculates parity and does not require knowledge of all bits for OC192 operation. This allows the striping function to be implemented in a smaller, cheaper package. Additionally, it allows chip placement to be varied in optimizing the board level wiring between the striper function and the backplane, which is necessary to make the system implementable.",
        "The present invention pertains to a switch of a network for switching data. The switch comprises a fabric for switching the data. The switch comprises a parity fabric. The switch comprises a connection mechanism connected to the fabric for providing data to and from the fabric and connected to the parity fabric for providing parity data to and from the parity fabric. The switch comprises a first port card which receives data at a first rate from the network or sends data at the first rate to the network, performs first parity calculations on the data received at the first port card, produces first parity data from the first parity calculations or sends data at the first rate to the network. The first port card is connected to the connection mechanism to send data to or receive the data from the fabric at a connection rate and to send the first parity data to or receive the data from the parity fabric at the connection rate. The switch comprises a second port card which receives data at a second rate from the network or sends data at the second rate to the network performs second parity calculations on the data received at the second port card, produces second parity data from the second parity calculations or sends data at the second rate to the network. The second port card is connected to the connection mechanism to send data to or receive the data from the fabric at the connection rate and to send the second parity data to or receive the data from the parity fabric at the connection rate. The second port card separating the data received at the second rate into streams of data that together equal the data received at the second port card that are sent concurrently at the connection rate to the fabric and combine the data streams received at the connection rate into data that is sent at the second rate to the network.",
        "The present invention pertains to a method for switching data in a network. The method comprises the steps of receiving data at a first rate from the network at a first port card of a switch. Then there is the step of receiving data at a second rate from the network at a second port card of the switch. Next there is the step of performing parity calculations on the data at the first rate by the first port card to produce first parity data and on the data at the second rate by the second port card to produce second parity data. Then there is the step of sending the first parity data from the first port card to a parity fabric of the switch through a connection mechanism of the switch at a connection rate. Next there is the step of separating the data received at the second rate at the second port card into streams of data that together equal the data received at the second port card. Then there is the step of sending the second parity data from the second port card to the parity fabric of the switch through the connection mechanism of the switch at a connection rate. Next there is the step of sending concurrently at the connection rate to the fabric from the second port card the streams of data along the connection mechanism.",
        "In the accompanying drawings, the preferred embodiment of the invention and preferred methods of practicing the invention are illustrated in which:",
        "FIG. 1 is a schematic representation of the switch of the present invention.",
        "FIG. 2 is a schematic representation of the striper of the present invention.",
        "FIG. 3 is a schematic representation of the unstriper of the present invention.",
        "Referring now to the drawings wherein like reference numerals refer to similar or identical parts throughout the several views, and more specifically to FIG. 1 thereof, there is shown a switch 10 of a network 12 for switching data. The switch 10 comprises a fabric 14 for switching the data. The switch 10 comprises a parity fabric 15. The switch 10 comprises a connection mechanism 16 connected to the fabric 14 for providing data to and from the fabric 14 and connected to the parity fabric 15 for providing parity data to and from the parity fabric 15. The switch 10 comprises a first port card 18 which receives data at a first rate from the network 12 or sends data at the first rate to the network 12, performs first parity calculations on the data received at the first port card 18, produces first parity data from the first parity calculations or sends data at the first rate to the network 12. The first port card 18 is connected to the connection mechanism 16 to send data to or receive the data from the fabric 14 at a connection rate and to send the first parity data to or receive the data from the parity fabric 15 at the connection rate. The switch 10 comprises a second port card 20 which receives data at a second rate from the network 12 or sends data at the second rate to the network 12 performs second parity calculations on the data received at the second port card 20, produces second parity data from the second parity calculations or sends data at the second rate to the network 12. The second port card 20 is connected to the connection mechanism 16 to send data to or receive the data from the fabric 14 at the connection rate and to send the second parity data to or receive the data from the parity fabric 15 at the connection rate. The second port card 20 separating the data received at the second rate into streams of data that together equal the data received at the second port card 20 that are sent concurrently at the connection rate to the fabric 14 and combine the data streams received at the connection rate into data that is sent at the second rate to the network 12.",
        "Preferably, the connection rate equals the first rate and the second rate is equal to N times the first rate, where N is an integer greater than or equal to 2, and there are N streams. The connection mechanism 16 preferably includes a backplane bus 22 that connects the first port card 18 and the second port card 20 to the fabric 14. Preferably, the first port card 18 has a first striper 24 which takes the first parity data it receives and sends it on the backplane bus 22 as an OC48 data pipe to the parity fabric 15, and the second port card 20 has a second striper 26 which takes the second parity data it receives and sends it as an OC48 data pipe to the parity fabric 15.",
        "The first port card 18 preferably has a first unstriper 28 which receives the first parity data from a separator 34 of the parity fabric 15 on an OC48 data pipe and the second port card 20 has a second unstriper 30 which receives the second parity data from the parity fabric 15 on an OC48 data pipe. Preferably, the first and second striper 26 stripe the first and second parity data respectively, they receive on a 48 bit basis to the parity fabric 15. The first and second striper 26s preferably stripe the first and second parity data, respectively, so the first and second parity data does not exceed a 12 bit boundary. Preferably, the parity fabric 15 has an aggregator 32 which receives the first and second parity data from the first and second striper 26s, respectively, and a separator 34 which sends parity data from the parity fabric 15 to the first unstriper 28 and the second unstriper 30.",
        "The present invention pertains to a method for switching data in a network 12. The method comprises the steps of receiving data at a first rate from the network 12 at a first port card 18 of a switch 10. Then there is the step of receiving data at a second rate from the network 12 at a second port card 20 of the switch 10. Next there is the step of performing parity calculations on the data at the first rate by the first port card 18 to produce first parity data and on the data at the second rate by the second port card 20 to produce second parity data. Then there is the step of sending the first parity data from the first port card 18 to a parity fabric 15 of the switch 10 through a connection mechanism 16 of the switch 10 at a connection rate. Next there is the step of separating the data received at the second rate at the second port card 20 into streams of data that together equal the data received at the second port card 20. Then there is the step of sending the second parity data from the second port card 20 to the parity fabric 15 of the switch 10 through the connection mechanism 16 of the switch 10 at a connection rate. Next there is the step of sending concurrently at the connection rate to the fabric 14 from the second port card 20 the streams of data along the connection mechanism 16.",
        "Preferably, the connection rate equals the first rate and the second rate is equal to N times the first rate, where N is an integer greater than or equal to 2, and there are N streams. The connection mechanism 16 preferably includes a backplane bus 22 that connects the first port card 18 and the second port card 20 to the fabric 14.",
        "Preferably, the first port card 18 has a first striper 24 and the second port card 20 has a second striper 26, and wherein the sending data from the first port card 18 step includes the step of sending the first parity data on the backplane bus 22 with the first striper 24 as an OC48 data pipe to the parity fabric 15 and the sending data from the second port card 20 step includes the step of sending the second parity data on the backplane bus 22 with the second striper 26 as an OC48 data pipe to the parity fabric 15. The first port card 18 preferably has a first unstriper 28 and the second port card 20 has a second unstriper 30, and including after the sending the second parity data by the second striper 26 step, there are the steps of receiving the first parity data from the parity fabric 15 on an OC48 data pipe at the first port card 18, and receiving the second parity data from the parity fabric 15 on an OC48 data pipe at the second port card 20.",
        "Preferably, the first port card 18 sending step includes the step of striping the first parity data with the first striper 24 on a 48 bit basis to the parity fabric 15, and the second port card 20 sending step includes the step of striping parity data with the second striper 26 on a 48 bit basis to the parity fabric 15 through the bus 22. The first striper 24 preferably sending step includes the step of striping the first parity data to the parity fabric 15 through the bus 22 so the first parity data does not exceed a 12 bit boundary, and the second striper 26 sending step includes the step of striping the second parity data to the parity fabric 15 through the bus 22 so the second parity data does not exceed a 12 bit boundary.",
        "In the operation of the preferred embodiment, for striping in the switch 10, striping is defined across a 48 bit window. The 48 bit window is broken into 4 12 bit pieces for OC48 operation. The calculation of parity bits must be maintained within the 12 bit windows to allow for proper operation at OC48 speeds. The parity functions must operate as much as possible within a mod 4=constant bit stream for OC192 operation when each striper gets only every fourth bit.",
        "Parity bits were calculated in the following fashion.\n\n    \n    \n        A. First parity bits within a 12 bit frame mod 4=constant were used. Depending on how the data was striped, the distribution of the bits varies across fabrics and the number of parity bits generated varies. For some striping configurations, this was able to cover the assignment of all parity bits (3 fabric and 1 fabric striping require no mod 4 to mod 4 communication).\n        B. Remaining bits were then assigned with a preference of grouping 12 bit frame mod 4=0 and 1 together and grouping 2 and 3 together.\n        C. Communication between chips not connected by B (mod 4=0 and mod 4=2, 0 and 3, 1 and 2, 1 and 3)",
        "For both B and C, if multiple bits needed to be communicated the XOR of the bits is actually communicated rather than the raw bits to reduce the number of I/O required.",
        "This results in a chip/chip communication which only uses 20 I/O on each striper to communicate parity information for OC192 support. The interconnection pattern is shown in the table below.",
        "These busses are interconnected in the following fashion.",
        "Input Interface\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOutput\nSt 0\nSt 0\nSt 0\nSt 1\nSt 1\nSt 1\nSt 2\nSt 2\nSt 2\nSt 3\nSt 3\nSt 3\n\n\nInterfaces\nD4\nE2\nF2\nD4\nE2\nF2\nD4\nE2\nF2\nD4\nE2\nF2\n\n\n\n\n\nStriper 0\n\n\n\nA4\n\n\n\nB2\n\n\n\nC2\n\n\noutput\n\n\nStriper 1\nA4\n\n\n\n\n\n\n\nB2\n\nC2\n\n\noutput\n\n\nStriper 2\n\nC2\n\n\n\nB2\n\n\n\nA4\n\n\noutput\n\n\nStriper 3\n\n\nC2\n\nB2\n\nA4\n\n\noutputs",
        "The structure of the striper is shown in FIG. 2.",
        "The Input Pipeline is the interface to the Switch Input Bus (BIB). In OC192c mode the connection number is resolved so that each Striper has a copy of the connection number when it is not provided by the external connection number bus 22.",
        "The Data FIFO is written at the BIB clock rate and read at the Striped Input Bus (SIB) clock rate. This FIFO is 1536\u00d732-bits. The purpose of this FIFO is to hold the BIB data until it can be transmitted.",
        "The Connection Number FIFO is written at the BIB clock rate and read at the SIB clock rate. This FIFO is 128\u00d726-bits. This FIFO contains the 26 bit connection number that was either provided through the BIB data bus or the External Connection Number bus.",
        "The EOP FIFO is a special FIFO of 128\u00d711-bits. The purpose of this block is to store information about each received cell and packet that is then used to format the data for transmission. The EOP FIFO is also where large packets are split into fragments to allow the buffer to be emptied without having to wait for the entire packet to be received.",
        "The Transfer FSM is responsible for moving the data from the Data FIFO to the Output Pipeline. The Transfer FSM is the point where Internal Cell Buffer (ICB) transmission occurs. The Transfer FSM does the conversion of 4-byte data to two (2) 12-bit busses. Two busses are used to increase the bandwidth of the backplane from 125 MHz to 250 MHz. The Transfer FSM also converts packets that are shorter than the minimum transfer size into a Short Packet.",
        "The Checksum Generation block calculates the CRC-16 checksum for the entire cell or packet.",
        "The Checksum Insertion block inserts the checksum as the last two bytes of a cell or packet. If the packet was fragmented the checksum is only inserted at the end of the last fragment.",
        "The Parity Calculation block generates the per cycle parity. The parity calculation is based on the number of fabrics that are being used. In OC192c mode parity calculations may require the exchange of either data or parity bits in order to be successfully generated. This block will ensure the parity exchanged is relevant to the appropriate cycle of data.",
        "The Fabric Mapping (Striping) block maps the data onto each fabric in the switch 10. Fabric mapping changes can only occur on cell/packet boundaries.",
        "The Transmitter Mapping block puts the striped data onto transmitters according to the number of fabrics configured.",
        "The Register Control block manages the registers and their side-effects within the Striper ASIC.",
        "The Address/Data Bus block implements the external interface to the AD bus 22. This block is common to all ASICs in the Switch 10 and is provided.",
        "The Global Synchronization block calculates the number of clock cycles of lockdown necessary for the chip to compensate for clock drift. This block is common to all ASICs in the switch 10 and is provided.",
        "The following table gives the I/O definition for the chip. The DIR column indicates a port is either an input (I), output (O), bidirect (B\u2014multi-source), or input/output (I/O\u2014depends on striper Id in OC192c mode).",
        "Name\nDir\nPins\nFunction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBIB_CLK\nI\n1\nInput clock\n\n\nBIB_Data\nI\n32\nOutput data to DIN bus\n\n\nBIB_EOP\nI\n5\nTag bits for input words.\n\n\nBIB_CELL_PKT\nI\n1\nIndicates cell or packet\n\n\n\n\n\ntransfer.\n\n\nBIB_SOC\nI\n2\nEOP for DIN bus.\n\n\nBIB_CONN\nI/O\n26\nEither input connection num-\n\n\n\n\n\nber for BIB or internal\n\n\n\n\n\nconnection number exchange\n\n\nBIB_CONN_EN\nI\n1\nEnable use of external\n\n\n\n\n\nconnection number bus\n\n\nBIB_BP\nO\n1\nBIB backpreassure signal\n\n\n\n\n\nfrom striper\n\n\nBIB_valid\nI\n1\nInput indicating BIB data\n\n\n\n\n\nis valid.\n\n\nBP_XMIT0\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT1\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT2\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT3\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT4\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT5\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT6\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT7\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT8\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT9\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT10\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT11\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT12\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBP_XMIT13\nO\n10\nOutput data to Gigabit serial-\n\n\n\n\n\nizer Channel 0\n\n\nBoard_active_I\nI\n1\nSignal to enable/terminate\n\n\n\n\n\nbackplane transfers\n\n\nAD_DATA\nB\n8\nSeparate AD bus data bus\n\n\nAD_RDY_L\nO\n1\nIndicates transaction complete\n\n\nAD_SEL_L\nI\n1\nAD bus chip select\n\n\nAD_CLK\nI\n1\nAD bus clock\n\n\nAD_RW\nI\n1\nAD bus read/write select.\n\n\nCLOCK125\nI\n1\nClock used by internal opera-\n\n\n\n\n\ntions (125 MHz)\n\n\nRESET_L\nI\n1\nResets the chip-asynch signal\n\n\nPLL\n\n5\nI/O for internal PLL\n\n\nChip_mode\nI\n3\nMode (oc48/oc192) and\n\n\n\n\n\nchipid for OC192\n\n\nJTDO\nO\n1\nJTAG test data out\n\n\nJTDI\nI\n1\nJTAD test data in\n\n\nJTMS\nI\n1\nJTAG test mode select\n\n\nJTCLK\nI\n1\nJTAG test clock\n\n\nJTRST\nI\n1\nJTAG test reset\n\n\nGlobal_sync\nI\n1\n\n\nMASTER_lockdown_valid\nI/O\n1\nIndicates OC192c master\n\n\n\n\n\ncontrolled lockdown\n\n\nMASTER_synch_valid\nI/O\n1\nIndicates OC192c master\n\n\n\n\n\ncontrolled sync cycle\n\n\nOC192 parity exchange in\nI\n14\nParity data received from\n\n\n\n\n\nother Stripers\n\n\nOC192 parity exchange out\nO\n14\nParity data sent to other\n\n\n\n\n\nStripers\n\n\nOC192 SOP/#fab/end\nI/O\n5\ncontrols sequencing of\n\n\n\n\n\nOC192 ops\n\n\nSYNC_CONTROL\nI/O\n2\nControls lockdown to the\n\n\n\n\n\nslave Stripers\n\n\nICB_CONTROL\nI/O\n2\nControls the ICB trap/transmit\n\n\n\n\n\nof the slave Stripers\n\n\nINT_L\nO\n1\nInterrupt\n\n\nUNS_BP\nI\n1\nUnstriper backpressure\n\n\nSCAN_EN_L\nI\n0\nscan enable pin\n\n\nTotal\n\n280\n\n\n\n\n\n\n\n\n\nChip mode is a 3-bit bus. It has the following signals.",
        "Chip mode\n\n\n\n\nbit\nLabel\nFunction\n\n\n\n\n\n\n\n2\nMode\nTie to a one for OC192, zero for an OC48.\n\n\n1:0\nChip_id\nFor OC192, connect to the starting bit number.\n\n\n\n\nNote that chip_id = \u201c00\u201d is the\n\n\n\n\nmaster controller for OC192. For OC48,\n\n\n\n\nthese pins should be tied high.",
        "The board active signal is an active low LVTTL input signal which should be low during all board operations. If a board active signal is withdrawn, the striper should terminate the current backplane transfer legally by indicating an end of transfer, non-final segment and should stop transmitting data onto the backplane. The board active signal will be debounced before it gets to the striper.",
        "When the BIB_CONN_EN signal is asserted the BIB_CONN bus is used to provide the Striper with a Connection Number (the Double-Routeword Configuration). This means that the BIB_CONN is configured to be input only. If this BIB_CONN_EN signal is not asserted then the Stiper is in the Single-Routeword configuration and the BIB_CONN bus is useable for connection number exchange in OC192c mode.",
        "The striper runs with 3 main clock regions:",
        "1. 125 MHz board clock",
        "2. Up to 100 MHz Switch Input Bus (BIB) clock",
        "3. 33 MHz AD Bus clock",
        "The 125 MHz clock is used for most internal operations.",
        "The AD bus clocks and BIB clocks are both assumed to be asynchronous with respect to all other clocks.",
        "The following spreadsheet shows the internal RAM utilization for the part.",
        "Function\nWords\nWidth\n# of bits\nWR freq\nRD freq\ntype\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData FIFO\n1536\n32\n49152\n100\n125\n2 port\n\n\nEOC/P/frag\n128\n10\n1280\n100\n125\n2 port\n\n\nFIFO\n\n\nConnection\n128\n26\n3328\n100\n125\n2 port\n\n\nnumber FIFO",
        "The 1536\u00d732 Data FIFO stores the raw data received on the data portion of the BIB. No alignment is done on the writing of data into the FIFO. The 1536-word depth is sized to allow for 119 fragments. This FIFO depth also constrains the maximum number of packets less than 52 bytes that can be received before backpressure is asserted. Note the FIFO is large enough to allow for approximately 64K worth of back-to-back data before the FIFO fills when the FIFO has 4K free bytes at the start of a transfer.",
        "The 256\u00d710 fragment FIFO gives the ending position of data in the FIFO and flags that the data is either the end of packet/cell or a 54 byte fragment. Note that the EOP/fragment indication is used to indicate if a valid start exists in the FIFO.",
        "The 128\u00d726 Connection Number FIFO is used to store the connection for each cell/packet.",
        "In OC192c each Striper only receives one fourth of egress routeword bits that are required to construct the connection number. Therefore, it is necessary for the Stripers to exchange their portion of the connection number with the other Stripers. This operation is supported with the BIB_CONN bus.",
        "When the BIB_CONN_EN signal is asserted the Striper is in the Double Routeword Configuration and the BIB_CONN is strictly used as an input bus 22.",
        "To reduce the overall storage requirements the Striper utilizes fragmentation to allow it to start emptying the buffer before an entire packet is received. Fragments are constructed such that there is always enough data to transmit the minimum length Fabric Routeword (36 bits). This means that all but the last fragment of a long packet only require the minimum length routeword.",
        "When a packet is received that is shorter than that which is required to transmit the minimum length routeword then it is referred to as a Short Packet. A Short Packet is the original packet padded to the minimum transfer size with the original packet length stored as the last pad byte.\n\n    \n    \n        1. The incoming bit stream is separated into 4 separate bit streams based on the bit number mod 4=a constant. Each bit stream will have an independent checking function implemented. This bit stream includes all data received, including the routeword (connection number bits 25:0).\n        2. A 16-bit CRC is calculated over the data using the following a standard 16-bit CRC function (X16+X12+X5+1) for each of the 4 data streams independently. This calculation will assume that the polynomial has been preset at the start of the calculation.\n        3. Four bits are selected from each of the 4 CRCs and concatenated together to form the final checksum. Each slice will use ((bit_number mod 4)*4+3 to (bit number mod 4)*4.",
        "For an input stream to pass, all four of its CRC functions must pass. Data checking is defined in this way to ensure that OC192c can be supported with minimal overhead. Any CRC over all the data would require the exchange of up to 13 CRC terms per OC192c cell/packet time (2 clock cycles). Since data checking is separate for each slice, the information which needs to be collected at the end is the pass/fail data from each of the 13 CRC functions in all 4 chips and then a final pass/fail can be constructed.",
        "Data arrives at the Striper 4 bytes per cycle and leaves the Striper 3 bytes per cycle. The 3-byte output is actually composed of two 12-bit busses referred to as bus A and bus B. In order to use all available bandwidth, reducing pad bits, a fragment/cell can begin on either bus A or bus B.",
        "The assignment of data bits to fabrics is done in the context of a bit stream view of the data. For OC192c the data is viewed as being broken into blocks of 48 bits and assignment of data bits to fabrics is done within the 48-bit blocks. A start of packet always starts a new 48-bit block. Striping is defined as the mechanism that assigns bit streams of equal width to each of the fabrics. The width of the fabric 14 is inversely proportional to the number of fabrics. To ensure each fabric 14 receives the same number of bits the bits streams are padded.",
        "Striping is defined to meet the following criteria:",
        "1. OC48 data cannot have more than 8 bits of pad required on the backplane bus 22. A bit assignment which has all groups of 12 bits transmitted on the same clock cycle will satisfy this property.\n        2. OC192 data cannot have more than 40 bits of pad required for the backplane bus 22. Note that this is actually a subset of the first criteria since this requires that all groups of 48 are transmitted on the same clock cycle for the backplane bus 22.\n        3. The striping definition must not require chip-to-chip communication for data in OC192c operation and the backplane busses must exist largely unchanged for both OC192c and OC48. The assignment of bits to the stripers must allow for the same number of bits to go to each fabric 14 from each striper in OC192c mode.\n        4. On all fabrics it must be possible to have exactly the same bits going to the memory controllers for either an OC48 or OC192c input port. On the output side, the same bits leave the memory controller and must be convertible into the backplane bus 22 required for either an OC48 or an OC192c output port.",
        "The striping function will be defined by constructing an OC192c solution and modifying OC48 behavior to match the OC192c solution.",
        "For each of the striping configurations, a table has been constructed which gives the bit assignments for each striping. Each table has a row that represents the bits that are connected to the stripers in OC192c mode. Each set of 3 columns in the table represent the bits sent during one cycle of OC48 operation. The following properties will be true for each table:\n\n    \n    \n        1. The tables will view the data in blocks of 48 bits. Each 12-bit sub-block will have the same number of bits going to each fabric 14, which will satisfy criteria 1 and 2. The 12-bit sub-block is composed of blocks of data from 3-column groups of all four rows. In order to satisfy the 12 bit sub-block having the same number of bits to each fabric 14, the destination fabric 14 for the first bit from different stripers must rotate among the fabrics present in the switch 10.\n        2. The bits used for OC48 striping and OC192c striping will be the same. This allows the aggregator 32 to convert the streams to one universal stream for the use on the fabric 14.",
        "The following give assignments for each of the fabric 14 configurations which satisfy these properties.",
        "The parity data which is transmitted is documented in the context of a 96 bit frame. This is to allow for parity exchange between the chips at 125 MHz.",
        "The following table gives the fabric assignments for each block of 48 bits and the output bus 22 assignments for OC192c operation.",
        "Bit\n0\n4\n8\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF0a(1)\nF0a(2)\nF0a(3)\nF0a(4)\nF0a(5)\nF0a(6)\nF0a(7)\nF0a(8)\nF0a(9)\nF0a(10)\nF0a(11)\n\n\nBit\n1\n5\n9\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF0b(0)\nF0b(1)\nF0b(2)\nF0b(3)\nF0b(4)\nF0b(5)\nF0b(6)\nF0b(7)\nF0b(8)\nF0b(9)\nF0b(10)\nF0b(11)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF0c(0)\nF0c(1)\nF0c(2)\nF0c(3)\nF0c(4)\nF0c(5)\nF0c(6)\nF0c(7)\nF0c(8)\nF0c(9)\nF0c(10)\nF0c(11)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF0d(0)\nF0d(1)\nF0d(2)\nF0d(3)\nF0d(4)\nF0d(5)\nF0d(6)\nF0d(7)\nF0d(8)\nF0d(9)\nF0d(10)\nF0d(11)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\ncycle 0 + 1212\ncycle 0 + 2424\ncycle 0 + 3636\n\n\nF0(1)\n1\n13\n25\n37\n\n\nF0(2)\n2\n14\n26\n38\n\n\nF0(3)\n3\n15\n27\n39\n\n\nF0(4)\n4\n16\n28\n40\n\n\nF0(5)\n5\n17\n29\n41\n\n\nF0(6)\n6\n18\n30\n42\n\n\nF0(7)\n7\n19\n31\n43\n\n\nF0(8)\n8\n20\n32\n44\n\n\nF0(9)\n9\n21\n33\n45\n\n\nF0(10)\n10\n22\n34\n46\n\n\nF0(11)\n11\n23\n35\n47",
        "The following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n8\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF0a(1)\nF1a(1)\nF0a(2)\nF1a(2)\nF0a(3)\nF1a(3)\nF0a(4)\nF1a(4)\nF0a(5)\nF1a(5)\n\n\nBit\n1\n5\n9\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF1b(0)\nF0b(0)\nF1b(1)\nF0b(1)\nF1b(2)\nF0b(2)\nF1b(3)\nF0b(3)\nF1b(4)\nF0b(4)\nF1b(5)\nF0b(5)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF0c(0)\nF1c(0)\nF0c(1)\nF1c(1)\nF0c(2)\nF1c(2)\nF0c(3)\nF1c(3)\nF0c(4)\nF1c(4)\nF0c(5)\nF1c(5)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF1d(0)\nF0d(0)\nF1d(1)\nF0d(1)\nF1d(2)\nF0d(2)\nF1d(3)\nF0d(3)\nF1d(4)\nF0d(4)\nF1d(5)\nF0d(5)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n13\n+24 to cycle 0\n+24 to cycle 1\n\n\nF0(1)\n2\n15\n\n\nF0(2)\n5\n16\n\n\nF0(3)\n7\n18\n\n\nF0(4)\n8\n21\n\n\nF0(5)\n10\n23\n\n\nF1(0)\n1\n12\n\n\nF1(1)\n3\n14\n\n\nF1(2)\n4\n17\n\n\nF1(3)\n6\n19\n\n\nF1(4)\n9\n20\n\n\nF1(5)\n11\n22\n\n\n\n\n\n\n\n\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n8\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(30)\nF1a(30)\nF2a(30)\nF0a(21)\nF1a(21)\nF2a(21)\nF0a(12)\nF1a(12)\nF2a(12)\nF0a(03)\nF1a(03)\nF2a(03)\n\n\nBit\n1\n5\n9\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF2b(30)\nF0b(30)\nF1b(03)\nF2b(12)\nF0b(12)\nF1b(12)\nF2b(21)\nF0b(21)\nF1b(21)\nF2b(30)\nF0b(30)\nF1b(30)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF1c(30)\nF2c(03)\nF0c(30)\nF1c(12)\nF2c(12)\nF0c(12)\nF1c(21)\nF2c(21)\nF0c(21)\nF1c(30)\nF2c(30)\nF0c(30)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF0d(03)\nF1d(30)\nF2d(03)\nF0d(12)\nF1d(12)\nF2d(12)\nF0d(21)\nF1d(21)\nF2d(21)\nF0d(30)\nF1d(30)\nF2d(30)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(30)\n0\ncycle\n+24 to cycle\n+24 to cycle\n\n\n\n\n0 + 1215\n0 + 24\n0 + 361\n\n\nF0(21)\n3\n17\n\n\nF0(12)\n5\n22\n\n\nF0(03)\n10\n13\n\n\nF1(30)\n2\n14\n\n\nF1(21)\n4\n16\n\n\nF1(12)\n7\n19\n\n\nF1(03)\n9\n21\n\n\nF2(30)\n1\n13\n\n\nF2(21)\n6\n18\n\n\nF2(12)\n8\n20\n\n\nF2(03)\n11\n23",
        "The following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n8\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF3a(0)\nF0a(1)\nF1a(1)\nF2a(1)\nF3a(1)\nF0a(2)\nF1a(2)\nF2a(2)\nF3a(2)\n\n\nBit\n1\n5\n9\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF3b(0)\nF0b(0)\nF1b(0)\nF2b(0)\nF3b(1)\nF0b(1)\nF1b(1)\nF2b(2)\nF3b(2)\nF0b(2)\nF1b(2)\nF2b(2)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF2c(0)\nF3c(0)\nF0c(0)\nF1c(0)\nF2c(1)\nF3c(1)\nF0c(1)\nF1c(1)\nF2c(2)\nF3c(2)\nF0c(2)\nF1c(2)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF1d(0)\nF2d(0)\nF3d(0)\nF0d(0)\nF1d(1)\nF2d(1)\nF3d(1)\nF0d(1)\nF1d(2)\nF2d(2)\nF3d(2)\nF0d(2)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n15\n26\n37\n\n\nF0(1)\n5\n16\n31\n42\n\n\nF0(2)\n10\n21\n32\n47\n\n\nF1(0)\n3\n14\n25\n36\n\n\nF1(1)\n4\n19\n30\n41\n\n\nF1(2)\n9\n20\n35\n46\n\n\nF2(0)\n2\n13\n24\n39\n\n\nF2(1)\n7\n18\n29\n40\n\n\nF2(2)\n8\n23\n34\n45\n\n\nF3(0)\n1\n12\n27\n38\n\n\nF3(1)\n6\n17\n28\n43\n\n\nF3(0)\n11\n22\n33\n44\n\n\n\n\n\n\n\n\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF3a(0)\nF4a(0)\nF5a(0)\nF0a(1)\nF1a(1)\nF2a(1)\nF3a(1)\nF4a(1)\nF5a(1)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF1b(0)\nF2b(0)\nF3b(0)\nF4b(0)\nF5b(0)\nF0b(0)\nF1b(1)\nF2b(1)\nF3b(1)\nF4b(1)\nF5b(1)\nF0b(1)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF3c(0)\nF4c(0)\nF5c(0)\nF0c(0)\nF1c(0)\nF2c(0)\nF3c(1)\nF4c(1)\nF5c(1)\nF0c(1)\nF1c(1)\nF2c(1)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF4d(0)\nF5d(0)\nF0d(0)\nF1d(0)\nF2d(0)\nF3d(0)\nF4d(1)\nF5d(1)\nF0d(1)\nF1d(1)\nF2d(1)\nF3d(1)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Output\nFabric\n\n\n\n\n\n\nBit\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11\nF0(0)\n0\n14\n+24 cycle 0\n+24 cycle 1\n\n\n10\nF0(1)\n11\n21\n\n\n9\nF1(0)\n1\n15\n\n\n8\nF1(1)\n4\n18\n\n\n7\nF2(0)\n5\n19\n\n\n6\nF2(1)\n8\n22\n\n\n5\nF3(0)\n2\n12\n\n\n4\nF3(1)\n9\n23\n\n\n3\nF4(0)\n3\n13\n\n\n2\nF4(1)\n6\n16\n\n\n1\nF5(0)\n7\n17\n\n\n0\nF5(1)\n10\n20\n\n\n\n\n\n\n\n\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF3a(0)\nF4a(0)\nF5a(0)\nF0a(1)\nF1a(1)\nF2a(1)\nF3a(1)\nF4a(1)\nF5a(1)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF3b(0)\nF4b(0)\nF5b(0)\nF0b(0)\nF1b(0)\nF2b(0)\nF3b(1)\nF4b(1)\nF5b(1)\nF0b(1)\nF1b(1)\nF2b(1)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF0c(0)\nF1c(0)\nF2c(0)\nF3c(0)\nF4c(0)\nF5c(0)\nF0c(1)\nF1c(1)\nF2c(1)\nF3c(1)\nF4c(1)\nF5c(1)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF3d(0)\nF4d(0)\nF5d(0)\nF0d(0)\nF1d(0)\nF2d(0)\nF3d(1)\nF4d(1)\nF5d(1)\nF0d(1)\nF1d(1)\nF2d(1)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n15\ncycle 0 + 24\ncycle 1 + 24\n\n\nF0(1)\n2\n13\n\n\nF1(0)\n4\n19\n\n\nF1(1)\n6\n17\n\n\nF2(0)\n8\n23\n\n\nF2(1)\n10\n21\n\n\nF3(0)\n1\n14\n\n\nF3(1)\n3\n12\n\n\nF4(0)\n5\n18\n\n\nF4(1)\n7\n16\n\n\nF5(0)\n9\n22\n\n\nF5(1)\n11\n20\n\n\n\n\n\n\n\n\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF3a(0)\nF4a(0)\nF5a(0)\nF6a(0)\nF7a(0)\nF8a(0)\nF9a(0)\nF10a(0)\nF11a(0)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF3b(0)\nF4b(0)\nF5b(0)\nF6b(0)\nF7b(0)\nF8b(0)\nF9b(0)\nF10b(0)\nF11b(0)\nF0b(0)\nF1b(0)\nF2b(0)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF6c(0)\nF7c(0)\nF8c(0)\nF9c(0)\nF10c(0)\nF11c(0)\nF0c(0)\nF1c(0)\nF2c(0)\nF3C(0)\nF4c(0)\nF5c(0)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF9d(0)\nF10d(0)\nF11d(0)\nF0d(0)\nF1d(0)\nF2d(0)\nF3d(0)\nF4d(0)\nF5d(0)\nF6d(0)\nF7d(0)\nF8d(0)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n15\n26\n37\n\n\nF1(0)\n4\n19\n30\n41\n\n\nF2(0)\n8\n23\n34\n45\n\n\nF3(0)\n1\n12\n27\n38\n\n\nF4(0)\n5\n16\n31\n42\n\n\nF5(0)\n9\n20\n35\n46\n\n\nF6(0)\n2\n13\n24\n39\n\n\nF7(0)\n6\n17\n28\n43\n\n\nF8(0)\n10\n21\n32\n47\n\n\nF9(0)\n3\n14\n25\n36\n\n\nF10(0)\n7\n18\n29\n40\n\n\nF11(0)\n11\n22\n33\n44",
        "The data for each fabric 14 is assigned to transceivers based on the number of fabrics configured.",
        "The Fabric Routeword is constructed based on the length of the out-going fragment and the configuration that was present when it was striped. The constructed Fabric Routeword is transmitted on bits 2 (bus A routeword bit) and 3 (bus B routeword bit) of the first transceiver allocated to a fabric 14.",
        "The parity data is identical to the transmit data.",
        "The parity calculation uses the following formulas and the following aggregator 32 read order",
        "Transmit\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\nP0\n0\n\u20020,4\n\n\nP1\n2\n\u20022,6\n\n\nP2\n1\n\u20021,5\n\n\nP3\n3\n\u20023,7\n\n\nP4\n0\n\u20028,9\n\n\nP5\n2\n10,11\n\n\nP6\n1\n13,17\n\n\nP7\n3\n15,19\n\n\nP8\n0\n16,12\n\n\nP9\n2\n18,14\n\n\nP10\u2002\n1\n20,21\n\n\nP11\u2002\n3\n22,23\n\n\n\n\n\n\n\n\n\nNote that parity bits P12-P24 repeat the pattern of P0-P11 . . .\n\nFor generation of parity, 2 bits are exchanged between S0\u2192S1 and S2\u2192S3 for each 24 bit word, one bit in either direction. The following table shows the bits transmitted on each output parity bus.",
        "Striper\nBus\nFunction (96 bits)\n\n\n\n\n\n\n\n\n\nA\nA4\n20,44,64,92 (20 + I * 24)\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\nB\nA4\n9,33,57,81\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\nC\nA4\n22,46,66,94\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\nD\nA4\n11,35,59,83\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\n\n\n\n\n\n\n\nThe parity calculation uses the following formulas: and the following aggregator 32 read order",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\nP0\n0\n0,4,8\n\n\n\nP1\n3\n3,7,11\n\n\n\nP2\n1\n1,5,9\n\n\n\nP3\n2\n2,6,10\n\n\n\nP4\n0\n12,16,20\n\n\n\nP5\n3\n15,19,23\n\n\n\nP6\n1\n13,17,21\n\n\n\nP7\n2\n14,18,22\n\n\n\n\n\n\n\n\n\n\nNote that parity bits P8-P15 repeat the pattern of P0-P11.\n\nParity generation requires no exchange of bits for OC192c.\n\nThe parity calculation uses the following formulas and the following aggregator 32 read order",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\nP0\nSt0\n0,4,8,11\n\n\n\nP1\nSt1\n1,5,9,7\n\n\n\nP2\nSt2\n2,3,6,10\n\n\n\nP3\nSt3\n15,19,22,23\n\n\n\nP4\nSt0\n12,16,18,20\n\n\n\nP5\nSt1\n21,13,14,17\n\n\n\nP6\nSt2\n26,30,33,34\n\n\n\nP7\nSt3\n27,29,31,35\n\n\n\nP8\nSt0\n24,25,28,32\n\n\n\nP9\nSt1\n37,41,44,45\n\n\n\nP10\u2002\nSt2\n38,40,42,46\n\n\n\nP11\u2002\nSt3\n36,39,43,47\n\n\n\n\n\n\n\n\n\n\nGeneration of parity for OC192c requires each striping giving every other striper 1 bit/48 bits of data. The following table shows the bits transmitted on each output parity bus.",
        "Striper\nBus\nFunction (96 bits)\n\n\n\n\n\n\n\n\n\nA\nA4\n\u201c00\u201d & 44,92\n\n\n\n\nB2\n40,88\n\n\n\n\nC2\n36,84\n\n\n\nB\nA4\n\u201c00\u201d & 25,73\n\n\n\n\nB2\n33,81\n\n\n\n\nC2\n29,77\n\n\n\nC\nA4\n22,70\n\n\n\n\nB2\n14,62\n\n\n\n\nC2\n18,66\n\n\n\nD\nA4\n\u201c00\u201d & 7,55\n\n\n\n\nB2\n3,51\n\n\n\n\nC2\n11,59\n\n\n\n\n\n\n\n\n\n\nThe parity calculation uses the following:",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nP0\n0\n0, 4, 8, 1, 5, 9\n\n\n\nP1\n2\n2, 6, 10, 3, 7, 11\n\n\n\nP2\n1\n13, 17, 21, 12, 16, 20\n\n\n\nP3\n3\n15, 19, 23, 14, 18, 22\n\n\n\n\n\n\n\n\n\n\nNote that parity bits P4-P8 repeat the pattern of P0-P3+24. The following table shows the bits transmitted on each output parity bus.",
        "Striper\nBus\nFunction (96 bits)\n\n\n\n\n\n\n\n\n\nA\nA4\n(12 \u00d7 16 \u00d7 20), (36 \u00d7 40 \u00d7 44),\n\n\n\n\n\n(60 \u00d7 64 \u00d7 68), (84 \u00d7 88 \u00d7 92)\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\nB\nA4\n(1 \u00d7 5 \u00d7 9), (25 \u00d7 29 \u00d7 33),\n\n\n\n\n\n(49 \u00d7 53 \u00d7 57), (73 \u00d7 77 \u00d7 81)\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\nC\nA4\n(14 \u00d7 18 \u00d7 22), (38 \u00d7 42 \u00d7 46),\n\n\n\n\n\n(62 \u00d7 66 \u00d7 70), (86 \u00d7 90 \u00d7 94)\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\nD\nA4\n(3 \u00d7 7 \u00d7 11), (27 \u00d7 31 \u00d7 35),\n\n\n\n\n\n(51 \u00d7 55 \u00d7 59), (75 \u00d7 79 \u00d7 83)\n\n\n\n\nB2\n\u201c00\u201d\n\n\n\n\nC2\n\u201c00\u201d\n\n\n\n\n\n\n\n\n\n\nThe parity calculation uses the following formulas and the following aggregator 32 read order:",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\nP0\nSt0\n\u20020-11\n\n\n\nP1\nSt1\n12-23\n\n\n\nP2\nSt2\n24-35\n\n\n\nP3\nSt3\n36-47\n\n\n\n\n\n\n\n\n\n\nThe following table shows the bits transmitted on each output parity bus.",
        "Striper\nBus\nFunction (96 bits)\n\n\n\n\n\n\n\n\n\nA\nA4\n\u201c00\u201d & (12 \u00d7 16 \u00d7 20) &\n\n\n\n\n\n(48 \u00d7 52 \u00d7 56)\n\n\n\n\nB2\n(24 \u00d7 28 \u00d7 32) & (48 \u00d7 52 \u00d7 56)\n\n\n\n\nC2\n(36 \u00d7 40 \u00d7 44) & (84 \u00d7 88 \u00d7 92)\n\n\n\nB\nA4\n\u201c00\u201d & (1 \u00d7 5 \u00d7 9) &\n\n\n\n\n\n(49 \u00d7 53 \u00d7 57)\n\n\n\n\nB2\n(25 \u00d7 29 \u00d7 33) & (49 \u00d7 53 \u00d7 57)\n\n\n\n\nC2\n(37 \u00d7 41 \u00d7 45) & (85 \u00d7 89 \u00d7 91)\n\n\n\nC\nA4\n\u201c00\u201d & (38 \u00d7 42 \u00d7 46) &\n\n\n\n\n\n(86 \u00d7 90 \u00d7 94)\n\n\n\n\nB2\n(14 \u00d7 18 \u00d7 22) & (62 \u00d7 66 \u00d7 70)\n\n\n\n\nC2\n(2 \u00d7 6 \u00d7 10) & (50 \u00d7 54 \u00d7 58)\n\n\n\nD\nA4\n\u201c00\u201d & (27 \u00d7 31 \u00d7 35) & (51 \u00d7 55 \u00d7 59)\n\n\n\n\nB2\n(15 \u00d7 19 \u00d7 23) & (63 \u00d7 67 \u00d7 71)\n\n\n\n\nC2\n(3 \u00d7 7 \u00d7 11) & (51 \u00d7 55 \u00d7 59)",
        "The striper generates backpressure for the BIB bus based on FIFO utiliziation. Backpressure should be asserted if the number of free fragments in the EOP FIFO falls to less than the programmed backpressure fragment count. This fragment count will be programmed to generated backpressure with a FIFO pad of 2-3 fragments.",
        "Data can be read from the FIFO when either an EOP is seen at the head of the FIFO (a cell/packet is only a single fragment long) or when a fragment has been read and another fragment follows. If another fragment does not follow, it is EOP and in general the EOP must be read in concert with a previous fragment since it can be less than 54 bytes.",
        "When the head of the FIFO is a cell that has a fabric routeword that matches the value in the unsplit routeword register then the reading of the cell is delayed if necessary until the second cell has been stored in the FIFO. The two cells will then be read and unsplit to form a single cell to be transmitted.",
        "Cell synchronization uses the standard switch sync mechanism. The transmitter behavior is utilized in this chip. When configured in OC192c mode the master striper will assert the MASTER_lockdown_valid signal to all slave stripers when its own lockdown_valid signal is asserted. The master striper will also assert the MASTER_sync_valid signal to all slave stripers when its sync_valid signal is asserted. This master-controlled synchronization is necessary to ensure that all stripers start transmitting valid data the same number of cycles after transmitting the SYNC character.",
        "One striper will decide when to transmit data to the backplane. It will communicate that information to the other three stripers across a bus 22. Four clock cycles after the start of the operation, the stripers will start to exchange parity data on every clock cycle while the transfer is running.",
        "The master striper will transmit the following signals to all slaves which will sequence reads for OC192c appropriately.",
        "Label\nDirection\nFunction\n\n\n\n\n\n\n\nStart\nMaster-O\nDriven to a zero to indicate start of\n\n\n\n\nnext fragment, one for non-start of\n\n\n\n\npacket.\n\n\nNumb_fab\nMaster-O, slave-I\nDriven by the master to indicate the\n\n\n\n\nnumber of fabrics the current packet\n\n\n\n\nshould be driven to.\n\n\nStop\nMaster-O\nDriven to a zero to indicate the last\n\n\n\n\nfragment to be transmitted with the\n\n\n\n\nrouteward transmitted with start. FS\n\n\n\n\nbits will be figured out using internal\n\n\n\n\ninformation in each slave.\n\n\nSS_CLK\nMaster-O\n3 clocks, one for each receiver. Used\n\n\n\n\nas the bus clock for the start, numb_\n\n\n\n\nfab, and stop fields.\n\n\nIB_EN\nMaster-O\nInput bus enable. If this signal is a\n\n\n\n\nzero, all slaves will discard all data\n\n\n\n\nfrom the FIFOs. This signal is set to a\n\n\n\n\none to indicate the start bit is valid.\n\n\n\n\n\n\n\n\n\nFour clock cycles after a start has been signaled, the parity exchange bus starts working on the current packet. Each striper has a 10 bit input bus and a 10 bit output bus which are used to connect the chips together for exchange of parity information for each 96 bits of backplane data. Each chip produces a 4-bit bus and two 2-bit busses (A4, B2 and C2). Additionally, each chip accepts a 4-bit bus and two 2-bit busses (D4, E2, F2). The number of bits utilized for each bus varies based on the striping configuration.\n\nThese busses are interconnected in the following fashion.",
        "Output\nInput Interface\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInter-\nSt 0\nSt 0\nSt 0\nSt 1\nSt 1\nSt 1\nSt 2\nSt 2\nSt 2\nSt 3\nSt 3\nSt 3\n\n\nfaces\nD4\nE2\nF2\nD4\nE2\nF2\nD4\nE2\nF2\nD4\nE2\nF2\n\n\n\n\n\nStriper 0\n\n\n\nA4\n\n\n\nB2\n\n\n\nC2\n\n\noutput\n\n\nStriper 1\nA4\n\n\n\n\n\n\n\nB2\n\nC2\n\n\noutput\n\n\nStriper 2\n\nC2\n\n\n\nB2\n\n\n\nA4\n\n\noutput\n\n\nStriper 3\n\n\nC2\n\nB2\n\nA4\n\n\noutputs\n\n\n\n\n\nNote that each output bus and input bus carry a SOF bit to indicate the start of a fragment and a clock bit. The SOF bit is multi-dropped from one chip to all 3 receivers, but 3 clock signals are formed. This gives a total output bus of 8 bits of data, 1 SOF and 3 clocks (12 bits). The receive side is 8 bits of data, 3 SOF, and 3 clocks (14 bits). Each chip will drive the SOF with its parity. 8 clock cycles of delay will be inserted in the master, 4 in each of the slaves to allow for sufficient time for parity data to be exchanged.\n\n\n\n\n\n\nThe version number register is a read only register which identifies the chip revision.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:16\nUnused\n\n\n\n15:12\nVersion number\nGives the version number of the ASIC. Starting\n\n\n\n\nversion number is 0001.\n\n\n11:0\nChip ID\nGives the chip ID of the striper.\n\n\n\n\n\n\n\n\n\nThe main control register controls the configuration of the chip.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n31:19\n0\nN/A\nunused\n\n\n\n18\nN/A\nR\nBIB_CONN\nSet this bit to enable the\n\n\n\n\n\nenabled\nuse of the BIB_CONN\n\n\n\n\n\n\ninput bus to obtain the\n\n\n\n\n\n\nfabric connection number\n\n\n\n\n\n\nrather than finding it in the\n\n\n\n\n\n\nfirst four bytes of data.\n\n\n17:10\n16#00#\nR/W\nEgress rw sub field\nData field used with the\n\n\n\n\n\n\negress rw sub enable bit.\n\n\n\u20029\n0\nR/W\nEgress rw sub\nSet this bit to a one to\n\n\n\n\n\nenable\nsubstitute egress RW sub\n\n\n\n\n\n\nfield into the upper 8 bits\n\n\n\n\n\n\nof the connection ID for\n\n\n\n\n\n\nthe egress RW for the\n\n\n\n\n\n\nsplit RW.\n\n\n\u20028\n0\nR/W\nBIB_BP_polarity\nSet this bit to a one to\n\n\n\n\n\n\nindicate the BIB_BP\n\n\n\n\n\n\nsignal should be active\n\n\n\n\n\n\nhigh, set to a zero for\n\n\n\n\n\n\nactive low.\n\n\n\u20027\n0\nR/W\nBIB_SOP/Eop\nSet this bit to a one to\n\n\n\n\n\npolarity\nindicate BIB SOP/EOP are\n\n\n\n\n\n\nactive high signals, set\n\n\n\n\n\n\nto a zero for active low\n\n\n\n\n\n\nsignals.\n\n\n\u20026:5\nN/A\nR\nOC192c chip id\nReturns the value of chip\n\n\n\n\n\n\nid set on the input pins.\n\n\n\u20024\nN/A\nR\nOC192c\nReturns the value present\n\n\n\n\n\n\non the OC48/oc192 pin.\n\n\n\n\n\n\nOne indicates an OC192,\n\n\n\n\n\n\nzero an OC48.\n\n\n\u20023\n0\nR/W\nInput bus enable\nSet this bit to a one to\n\n\n\n\n\n\nenable receiving data on\n\n\n\n\n\n\nthe input bus.\n\n\n\u20022:0\n2#000#\nR/W\nNumber of fabrics\nSpecifies the number of\n\n\n\n\n\n\nfabrics which are used in\n\n\n\n\n\n\nthe current striping con-\n\n\n\n\n\n\nfiguration. These values\n\n\n\n\n\n\nare encoded as follows:\n\n\n\n\n\n\n000-One fabric\n\n\n\n\n\n\n001-Two fabrics\n\n\n\n\n\n\n010-Three fabrics\n\n\n\n\n\n\n011-Four fabrics\n\n\n\n\n\n\n100-Six fabrics\n\n\n\n\n\n\n101-twelve fabrics.\n\n\n\n\n\n\nNote this field is only used\n\n\n\n\n\n\nby the master chip in a\n\n\n\n\n\n\nOC192c configuration.\n\n\n\n\n\n\nChanging the striping con-\n\n\n\n\n\n\nfiguration becomes effec-\n\n\n\n\n\n\ntive on the next start of\n\n\n\n\n\n\npacket. Any fragmented\n\n\n\n\n\n\npacket will have every\n\n\n\n\n\n\npacket fragment support\n\n\n\n\n\n\nthe same striping\n\n\n\n\n\n\nconfiguration.\n\n\n\n\n\n\n\n\n\nThis register contains a status information to report errors. All bits are cleabed on read.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n3\n0\nR/C\npe_sync_error\nParity exchange sync error\n\n\n2\n0\nR/C\nloss_of_sync\nLoss of global sync\n\n\n1\n0\nR/C\npacket_dropped\nThis bit is set to a one if a packet\n\n\n\n\n\n\ndrop has occurred. Note that this\n\n\n\n\n\n\nshould only happen in hardware\n\n\n\n\n\n\nerror situations (ignoring\n\n\n\n\n\n\nbackpressure signal), so no drop\n\n\n\n\n\n\ncounter is provided.\n\n\n0\n0\nR/C\nICB_valid\nThis bit is a one when the ICB has\n\n\n\n\n\n\na valid packet or cell.\n\n\n\n\n\n\n\n\n\nThe interrupt mask enables the interrupt for the given bit in the main status register. A mask bit must be set to \u20181\u2019 in order to enable the interrupt.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n3\n0\nR/C\npe_sync_error\nParity exchange sync error\n\n\n\n\n\n\ninterrupt enable\n\n\n2\n0\nR/C\nloss_of_sync\nLoss of global sync error\n\n\n\n\n\n\ninterrupt enable\n\n\n1\n0\nR/C\npacket_dropped\nPacket dropped interrupt enable\n\n\n0\n0\nR/C\nICB_valid\nICB valid interrupt enable\n\n\n\n\n\n\n\n\n\nThe output enable register controls the ports enabled for the first output busses on the device. This bit must be a one and the fabric presence bit must be asserted to enable the drivers to a fabric.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n12:0\n16#00#\nR/W\nOutput Enable\nSet each bit to a one to enable\n\n\n\n\n\n\nthe same numbered output bus.\n\n\n\n\n\n\nBit 12 is the output enable for\n\n\n\n\n\n\nparity, bits 0-11 are for outputs\n\n\n\n\n\n\nto fabrics 0-11 respectively.\n\n\n\n\n\n\n\n\n\nThe BIB backpressure control register controls when the striper asserts the backpressure signal. Whenever the number of available blocks (54 byte chunks) in memory falls below this value, backpressure is asserted. This register should be set equal to Max_packet_size/64K*75\u22124.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n7:0\n16#00#\nR/W\ncount\nSet to the number calculated above. To\n\n\n\n\n\n\ndisable backpressure, program to zero.\n\n\n\n\n\n\n\n\n\nThe striper provides a software interface to a cell storage location. This location can either store an ATM cell or a fragment up to 64 bytes long.\n\nTo read a cell/fragment from the FIFO, perform the following actions:\n\n    \n    \n        1. Initialize the Output Enable/Trap enable register to trap a cell on the desired condition.\n        2. Wait for the Trap Valid bit to be set in the main status register.\n        3. The data is now available in the ICB data registers.\n\nTo write a cell/packet, perform the following actions Disable all traps into the ICB using the ICB trap/tx enable register.\n\nWrite the data to the Data FIFO first data registers. The first four bytes of data are used to form the fabric routeword. The next four bytes are used as memory controller routeword. The remaining bytes are used as cell/packet data.\n\nWrite to the ICB trap/tx enable register to send the data.\n\nThis register is used to control the storage of cells to the ICB.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n11:6\n16#00#\nR/W\nByte_count\nSet these bits to the number of\n\n\n\n\n\n\nbytes to transmit from the ICB.\n\n\n\u20025:3\n2#000#\nR/W\nTrap_mux_sel\nSelects the point in the output\n\n\n\n\n\n\npipeline where the data will be\n\n\n\n\n\n\ntrapped.\n\n\n2\n0\nR/W\nTransmit\nSet this bit to a one to force the\n\n\n\n\n\n\ntransmit of the ICB cell onto the\n\n\n\n\n\n\nbackplane. After transmission,\n\n\n\n\n\n\nthis bit is cleared\n\n\n\n\n\n\nautomatically by the hardware.\n\n\n1\n0\nR/W\nDIN_recent\nSet this bit to a one to trap the\n\n\n\n\n\n\nmost recent cell (or first 52 bytes\n\n\n\n\n\n\nof data for a packet) into the\n\n\n\n\n\n\nICB.\n\n\n0\n0\nR/W\nDIN_first\nSet this bit to a one to trap the\n\n\n\n\n\n\nfirst cell (or first 52 bytes of data\n\n\n\n\n\n\nfor a packet) into the ICB.\n\n\n\n\n\n\n\n\n\nThis register reads and write the location used for the fabric routeword. If a cell is captured, this is the fabric routeword which was input to the chip.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n29\n0\nR/W\nPkt_cell\nSelects the packet/cell\n\n\n\n\n\n\nindication bit.\n\n\n28:26\n2#000#\nR/W\nStripe_amount\nGives the stripe amount\n\n\n\n\n\n\nfor the cell/packet. This\n\n\n\n\n\n\nvalue is encoded as\n\n\n\n\n\n\nfollows:\n\n\n\n\n\n\n000-One fabric\n\n\n\n\n\n\n001-Two fabrics\n\n\n\n\n\n\n010-Three fabrics\n\n\n\n\n\n\n011-Four fabrics\n\n\n\n\n\n\n100-Six fabrics\n\n\n\n\n\n\n101-twelve fabrics.\n\n\n25\n0\nR/W\nUc_mc\nSelects the UC/MC bit for\n\n\n\n\n\n\nthe fabric.\n\n\n24:0\n16#0_0000#\nR/W\nconn\nGives the connection\n\n\n\n\n\n\nnumber used by the\n\n\n\n\n\n\nfabric.\n\n\n\n\n\n\n\n\n\nThis register reads the byte at the head of the data FIFO.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n31:0\n16#0000_0000#\nR/W\nRouteword\nGives the value of the\n\n\n\n\n\n\nmemory controller\n\n\n\n\n\n\nrouteword.\n\n\n\n\n\n\n\n\n\nThese registers correspond to one 32 bit value in the ICB.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n31:0\n16#0000_0000#\nR/W\nData\nGives the value of the\n\n\n\n\n\n\ncorresponding packet/cell\n\n\n\n\n\n\ndata.\n\n\n\n\n\n\n\n\n\nNote that bytes are transmitted counting ICB memory controller routeword and starting with ICB data 0 until bthe bytes count is exhausted. Non-32 bit byte count values will treat bits 7:0 as the first byte, bits 15:8 as the second, bits 23:16 as the third and bits 31:24 as the fourth.\n\nThe synch delay register controls configuration of the counters used for synchronization.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\n16#0000#\nR/W\nTick\nNumber of clock cycles before the\n\n\n\n\n\nLength\nmaster sequence counter is in-\n\n\n\n\n\n\ncremented. The tick length controls\n\n\n\n\n\n\nthe time duration which one sequence\n\n\n\n\n\n\nvalue is transmitted. Dividing the\n\n\n\n\n\n\nprogrammed value by either 36\n\n\n\n\n\n\n(OC48) or 9 (OC192) gives the\n\n\n\n\n\n\nmaximum number of packets which\n\n\n\n\n\n\ncan be transmitted. Due to FIFO\n\n\n\n\n\n\nlimitations, this value should be\n\n\n\n\n\n\nprogrammed to a value less than or\n\n\n\n\n\n\nequal to 1024.\n\n\n\n\n\n\n\n\n\nNote that the synch_debug register should be read after updating the synch delay register to flush out any stale data in the synch debug register.\n\nThe synch debug register is used to monitor the state of the synchronization logic.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n7:0\n16#00#\nR\nClk_diff\nThe clock speed difference register is\n\n\n\n\n\n\nused as a rough heartbeat for the\n\n\n\n\n\n\nsynch logic. It counts the number of\n\n\n\n\n\n\nclocks in the last pause due to resynch.\n\n\n\n\n\n\nA negative value is represented by a\n\n\n\n\n\n\n\u20181\u2019 in the MSB of the register.\n\n\n\n\n\n\n\n\n\nThe striper supports unsplitting for the control port. Unsplitting is taking multiple back to back cells, treating it as one AAL5 frame and transporting the AAL5 data as the raw data for the backplane. In general, there is no hardware dependancy on the number of cells which can be split or unsplit, but the prime intention is to utilize two cells to encapsulate 60 bytes of data. Cells to be unsplit in the striper are identified by an incoming routeword match on the memory controller routeword.\n\nThe bits used for the fabric routeword are formatted as shown in the following table.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n28\n0\nR/W\nPck/cell\nSelects the packet/cell\n\n\n\n\n\n\nindication bit.\n\n\n27:25\n2#000#\nR/W\nStripe_amount\nGives the stripe amount for\n\n\n\n\n\n\nthe cell/packet. This value\n\n\n\n\n\n\nis encoded as follows:\n\n\n\n\n\n\n000-One fabric\n\n\n\n\n\n\n001-Two fabrics\n\n\n\n\n\n\n010-Three fabrics\n\n\n\n\n\n\n011-Four fabrics\n\n\n\n\n\n\n100-Six fabrics\n\n\n\n\n\n\n101-twelve fabrics.\n\n\n24\n0\nR/W\nUC/MC\nSelects the UC/MC bit for\n\n\n\n\n\nindication\nthe fabric.\n\n\n23:0\u2002\n16#0_0000#\nR/W\nFab conn numb\nGives the connection\n\n\n\n\n\n\nnumber used by the fabric.\n\n\n\n\n\n\n\n\n\nThis register is used to identify cells which need to be put through the unsplitter. Any cell which has a memory controller routeword match this register is unsplit. It is assumed that all cells to be unsplit will be received back to back.",
        "Reset\n\n\n\n\n\nBit\nValue\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n31:0\n16#0000_0000#\nR/W\nRW value\nGives the required value of\n\n\n\n\n\n\nthe memory controller\n\n\n\n\n\n\nrouteword for unsplitting.\n\n\n\n\n\n\n\n\n\nThe following table gives the timing constraints used for timing analysis. Any designs which meet these constraints should work across any respins. The columns have the following meanings:",
        "CLK\nGives the reference clock for the timing. All timing values\n\n\n\nare given in reference to the clock signal arriving at the\n\n\n\nassocatiated clock pin on striper.\n\n\nMin_time\nThis gives the minimum amount of time before an output\n\n\n\nsignal transitions. This can be used to calculate hold time.\n\n\nMax_time\nThis gives the maximum amount of time until an output\n\n\n\nsignal is stable.\n\n\nOutput Load\nLoad used for max_time. Other loads can be used, greater\n\n\n\nloads increase time, smaller loads decrease time.\n\n\nDrive\nType of drive book.\n\n\nComments\nAny comments (primarely on the derrivation of output\n\n\n\nload).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClkM\n\n\n\n\n\n\n\n\nin\nMax\nOutput\n\n\n\nPin\nTime\nTime\nLoad\nDrive\nComments\n\n\n\n\n\n\n\nTDO\nTCK\n\n\n10 pF\n\n\n\n\n\n\n\n\n\n\nThe following table gives the input timing. The columns have the following meanings:",
        "CLK\nGives the reference clock for the timing. A value of N/A\n\n\n\neither means the signal is not speced for transition or that the\n\n\n\nsignal is not assumed to asynchronous wrt all input clocks.\n\n\nSetup/hold\nsame thing they mean everywhere else.\n\n\nPin cap\nPin capacitince presented by the receiver or bidi.\n\n\nComments\nAny comments (primarely on the derrivation of output load).\n\n\n\n\n\n\n\n\n\nThe chip was timed assuming the following arrival times for clocks:",
        "Supported\n\n\n\nClock\nClock\nSkew\nNotes\n\n\n\n\n\n\n\nAD_CLK\nany\nAny\nAD_CLK is asynchronous with rest of\n\n\n\n\n\nchip. Unstriper supports speeds from 20\n\n\n\n\n\nMHz to 33 MHz on AD_CLK. The speed\n\n\n\n\n\nlimit on the AD clock is primarely I/O\n\n\n\n\n\ntiming releated, chip internals run up to\n\n\n\n\n\n40. Any applications which desire above\n\n\n\n\n\n33 MHz should talk to the design team.",
        "The structure of the Unstriper is shown in FIG. 3.",
        "The Synchronizer de-skews SOB data based on information obtained during global synchronization. Valid received data is sent to the RW/Data Separator 34.",
        "The route word data separator 34 takes the current switch 10 configuration and separates route words and data into separate paths. Route words are passed to the Routeword Voter. Data is written into the Data Delay FIFO.",
        "The Routeword Voter detects differences in the routeword stream and passes the error vector downstream. In OC192c mode, the Routeword Voter utilizes the Routeword Exchange bus to communicate routeword and End-of-Packet (EOP) information across the four Unstripers.",
        "The Data Delay FIFO stores raw incoming receiver data until a valid number-of-fabrics (NF) has been extracted from the valid routeword. The NF is used to extract the fabric data from the received data for the Fragment FSM.",
        "The Fragment FSM receives data from the Data Delay FIFO and constructs 48-bit cycles of data that are then passed to the Parity Check+Fabric Data Regeneration block. This step is necessary for 40, 80 and 240-slow bandwidth configuration modes as they do not provide a full 48-bits of data per cycle.",
        "Parity Check+Data Regeneration will form up to thirteen (twelve fabrics plus one parity) data streams that will be checked for parity errors. Each generated data stream will be output to a checksum checker. In OC192c mode the Parity Exchange bus is used to compute the parity across all of the fabric data.",
        "The checksum checkers perform an error check on the incoming data. There is one checksum for each of the thirteen regenerated data streams coming out of Parity Check+Data Regeneration. The checksum checkers support two logical contexts and can switch between them. One logical context is used to support unicast (UC) traffic coming from the fabrics and one to support multicast (MC) traffic coming from the fabrics.",
        "Output Data Select finds an output combination with valid routewords and a passing checksum (if one exists). If so, the valid output select is passed to the Output Data Formatter block, which then reads the data from the Fabric Data FIFO substituting regenerated data for up to one fabric if necessary. In OC192c mode, the Error Exchange bus is used by each slave Unstriper to send its error information to the master Unstriper. The master Unstriper uses all of the error information received plus its own error information to determine the valid combination inputs, if any, and sends the determination back to each slave Unstriper.",
        "These buffers defragment and store the received data and the regenerated data during the checksum checking and while it is waiting to go out the output interface. These buffers are sized sufficiently large to hold one 64K packet for UC traffic and one 64K packet for MC traffic.",
        "The Output Data Formatter select forwards the data from the Reassembly Buffers to the BOB FIFO for the output mapping indicated by the Output Select FIFO. The mapping given in the output selection word is assumed to be valid for the entire packet/cell.",
        "The BOB FIFO (one for each context) buffers data during periods of backpressure from the BOB interface or while the other context is actively using the BOB I/F. All packets stored into these FIFOs start on 64-bit boundaries.",
        "The output of the BOB FIFO is where the data crosses from the core clock domain to the BOB clock domain.",
        "The BOB I/F forwards data to the Segmenter from the UC and MC BOB Data FIFOs based on order of arrival of packets to those FIFOs. In OC192c mode the Packet Length Exchange bus is used so that each Unstriper can properly shorten minimum length packets (>=52 bytes) that represent short packets (<52 bytes). Byte 52 of the minimum length packet contains the actual length of the short packet. In OC192c mode each Unstriper receives two bits of this length which must then be sent to the other Unstripers to reconstruct the entire 8-bit value.",
        "The packet length exchange occurs at this point in the flow because it is the first place where this is only one context and the data is valid.",
        "The Segmenter divides packets into AAL5 encapsulated ATM cells. The Segmenter has a BOB-style interface with the Unstriper to support its development as a separate effort.",
        "The following table gives the I/O definition for the chip. The DIR column indicates an output is either an input (I), output (O) or bidir (B).",
        "Chip mode is a 3 bit bus. It has the following signals.",
        "Chip\n\n\n\n\nMode\nLabel\nFunction\n\n\n\n\n\n\n\n2\nMode\nTie to a one for OC192, zero for an OC48.\n\n\n1:0\nChip_id\nFor OC192, connect to the starting bit number. Note\n\n\n\n\nthat chip_id = \u201c00\u201d is the master controller for\n\n\n\n\nOC192. For OC48, these pins should be tied high.",
        "Function\nWords\nWidth\n# of bits\nWR freq\nRD freq\nType\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nValid Routeword FIFO\n128\n66\n8448\n125\n125\n2 port-RA\n\n\nData Delay FIFO\n256\n92\n23552\n125\n125\n2 port-SRAM\n\n\nIncoming Data FIFO-UC\n5632\n96\n540672\n125\n125\n1 port-SRAM\n\n\nIncoming Data FIFO-MC\n5632\n96\n540672\n125\n125\n1 port-SRAM\n\n\nRegen'd Data FIFO-UC\n5632\n96\n540672\n125\n125\n1 port-SRAM\n\n\nRegen'd Data FIFO-MC\n5632\n96\n540672\n125\n125\n1 port-SRAM\n\n\nOutput Select FIFO\n3072\n28\n86016\n125\n125\n2 port-SRAM\n\n\nBOB Data FIFO-UC\n4096\n128\n524288\n125\n125\n1 port-SRAM\n\n\nBOB Data FIFO-MC\n4096\n128\n524288\n125\n125\n1 port-SRAM\n\n\nTerminated Cell FIFO\n256\n38\n9728\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 0\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 1\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 2\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 3\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 4\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 5\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 6\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 7\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 8\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 9\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 10\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 11\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 12\n256\n10\n2560\n125\n125\n2 port-RA\n\n\nSync FIFO-Rcvr 13\n256\n10\n2560\n125\n125\n2 port-RA\n\n\n\n\n\n35840\n\n\nTotal\n\n\n3374848",
        "SOB synchronization uses the standard Switch Global Synchronization mechanism. The Unstriper implements the receiver portion of the synchronization logic.",
        "All received routewords (as determined by the contents of the Input Enables register) are compared against the routeword immediately below it (where below is over the routewords 0 to N\u22121 for a switch with N fabrics). Any single mismatch will have two adjacent zeros and the rest ones. A double mismatch will result in more than one region of zeros or a region with more than two adjacent zeros. In the single error case, the first location with a mismatch is the erroneous location (a lane is considered correct if its comparison output is a one or if the next comparison output is a one). The voting results are maintained during the processing of a single routeword so that fabrics that mismatch will continue to mismatch. The lowest numbered fabric which matched every cycle is passed forward to the Data Delay FIFO along with a vector of mismatches.",
        "The voter becomes out-of-sync if before reaching the end of a routeword all fabrics have a mismatch. The voter requires an IDLE on the SOB to re-sync to the incoming routeword stream as it provides a known packet boundary. The Data Delay FIFO must also flush all data received since the end of the last successfully voted routeword.",
        "In OC192c, each Unstriper receives the same route word bits after routeword exchange, so it can perform local comparison of route word data.",
        "In OC192c mode each Unstriper only receivers a portion of the switch 10 routeword. In order to properly determine needed values including the locatoin of the last valid byte each Unstriper exchanges its portion of the routeword with the other Unstripers.",
        "All fields within the switch 10 routword are relevant except the EOP field. In particular the SOP field occurring as the first non-zero even-numbered bit signals the start of a Switch Routeword. The PT field designates whether the transfer is a packet or a cell. This is only significant when transmitting the received data on the BOB. The CONN field is only important for Path Error Cell identification (bit 0 non-zero and bit 25 zero) and for Unicast/Multicast context identification (bit 25). The NF field indicates the number of fabrics over which the transfer was sriped which is absolutely necessary for unstriping the transfer. Finally the Stop/Final variable length encoding which is used to determine the length of the transfer and whether it is a final fragment or not.",
        "One of the most important characteristics of the Switch Routeword is that it encodes the length of the transfer in bytes. The parser determines the length and transmits it with the fully parsed routeword to the Data Delay FIFO.",
        "The Switch Routeword contains a parity bit which respresents the odd parity computed over the first 32 bits of the routeword. If the value parsed from the routeword is not the same as the value obtained by applying the parity function to the first 32 bits received then a Routeword Parity Error is signaled causing the Routeword Parity Error Count register to be incremented. Transfers are not dropped immediately if there is a routeword parity error. The transfer is allowed to proceed but the error is sent with the transfer to ensure that it is eventually dropped.",
        "The NF field of the routeword has to be consistent with the configuration of the Unstriper if this isn't the case then an error is signaled causing the Routeword NF Error Count register to be incremented for each such routeword received.",
        "The Unstriper takes the NF field from the switch routeword and the parity bits (fabric 0) and forms NF+1 output streams with the N input streams of data based on each of the input data streams potentially having a problem. Each resulting data stream is passed to a dedicated checksum verifier that checks whether the data stream is valid.",
        "The data checking function will also form a routeword valid bit for each of the data streams by ORing all of the routeword valid bits for all utilized input streams.",
        "Data checking is performed over an entire packet with errors being reported only once for the affected packet.",
        "The data for any single fabric 14 may be regenerated by replacing the fabric 14 data with the parity fabric 14 data and computing a new parity fabric 14 value. The newly computed parity fabric 14 value should be identical to the original fabric 14 data that is being regenerated. If this is not the case then either the fabric 14 data is erroneous or some other fabric 14 (including the parity) is erroneous. The parity check compares the original data with the regenerated data and if there's a difference a parity error is signaled for the affected packet.",
        "The data checking function forms a 16-bit checksum using the following algorithm.\n\n    \n    \n        1. The incoming bit stream is separated into 4 bit streams based on the bit number mod 4=a constant. Each bit stream will have an independent checking function implemented. This bit stream includes all data received for a packet or cell except the 16-bit checksum at the end of the final fragment.\n        2. A standard 16-bit CRC function (X16+X12+X5+1) is applied to each of the 4 data streams. The CRC is preset at the beginning of each packet or cell.\n        3. Four bits are selected from each of the resulting 4 CRCs and concatenated together to form the final 16-bit checksum. Each slice will use ((bit_number mod 4)*4+3 to (bit_number mod 4)*4.",
        "For an input stream to pass the checksum as computed above must match the checksum extracted from the end of the packet/cell. The checksum algorithnm is defined in this way to ensure that OC192c can be supported with minimal overhead. Any CRC over all the data would require the exchange of up to 13 CRC terms per OC192c cell/packet time (which is 2 clock cycles). Since data checking is separate for each slice, the information which needs to be collected at the end is the pass/fail data from each of the 13 CRC functions in all 4 chips and then a final pass/fail can be constructed.",
        "The output stream used will be the first output stream found which has a valid routeword and a valid checksum at the end of the packet or cell. Note that this will default to not using parity if the non-parity data is correct.",
        "Routeword and data errors may both be present. If a routeword error occurs it invalidates the input stream on which it occurred even if that stream passes all other tests. Any input combination that uses such a stream is also erroneous.",
        "If the Data Delay FIFO is being backpressured by the Reassembly Buffers then the valid routewords obtained from the Routeword Voter have to be stored until the Data Delay FIFO is released. The Valid Routeword FIFO stores up to 128 routewords corresponding to the number of minimum length fragments that may be stored in the Data Delay FIFO in OC192c mode.",
        "Until a complete fragment has been received it is necessary to retain all of the data associated with the routeword. The Data Delay FIFO stores the raw data from the transceivers until the stripe amount of the fragment has been determined from the routeword. If no valid routeword was received then the data in the Data Delay FIFO following the last valid routeword has to be skipped.",
        "The Reassembly Buffer is where fragmented packets are reassembled prior to being reformatted for transmission on the BOB. There is a separate Reassembly Buffer for unicast and for multicast traffic since fragments from each context may be received interleaved. Each Reassembly Buffer must be large enough to store a single 64 KB packet plus additional storage to compensate for the Output Select latency following the Checksum Check.",
        "The Output Select FIFO is sized to allow for one 64K packet followed by a stream of ATM cells or smallest possible packet size packets. The data stored in this FIFO is the combination of input data lanes to use in reconstructing the data. This FIFO is sized as 64K/52 bytes=1261 entries. Each entry has two fields: (1) a port select field and (2) a byte count. The port select field is 13 bits wide and indicates that the selected input ports to be used. The only values written with non-zero data will be for valid entries, so the output data select will first count ones and use that to figure out the width of each selected interface. The second field is a 16 bit byte count is stored in the FIFO to track packet size. (The actual needed size on this FIFO should actually be (64K-8K)/52 bytes or 1102 entries.) Actual grown size will probably be 1280 words (1K+256).",
        "After the input combination is selected, the data for either a unicast or multicast context is converted from 3-byte to 4-byte cycles and stored in the BOB Data FIFO for the same context. The order in which the packet was selected determines the order in which it is transmitted on the BOB. This orders the packets by the arrival of their final fragments.",
        "In OC192c mode, four Unstripers will get data in parallel. The four Unstripers will exchange routeword information on the cell receipt and also exchange end of packet information. After CRC checks, the pass/fail information will be passed from each slave Unstriper to the master Unstriper which will then make a decision on which lane is accepted across all chips and transmit that decision to each slave Unstriper.",
        "Routeword exchange is used so that all four Unstripers have the complete routeword. Bits are voted locally in each Unstriper to see if they match. The resulting bits out of routeword voting are passed to all Unstripers on a clock cycle by clock cycle basis. Each Unstriper starts transmitting and flagging routeword exchange at the receipt of a synch pulse on the backplane and data is exchanged every clock cycle thereafter until the next resynch event.",
        "After routeword exchange, all four Unstripers have the entire fabric routeword.",
        "Number\n\n\n\n\nof\n\n\nPin Name\ncopies\nFunction\n\n\n\n\n\n\n\nRW_SYNC_in(2:0)\n1\n1 cycle pulse to indicate a synch pulse.\n\n\n\n\nAll sync pulses are lined up to form\n\n\n\n\nvalid routewords.\n\n\nRW_SYNC_out\n1\nGives indication that a sync pulse was\n\n\n\n\nreceived and routeword data will start\n\n\n\n\nto follow.\n\n\nRW_out(3:0)\n1\nRouteword data output to each\n\n\n\n\nUnstriper\n\n\nRW_in(3:0)\n3\nGives the incoming routeword data\n\n\n\n\nfrom the each of the other Unstripers.\n\n\nRW_CLK_in(2:0)\n1\nClock for the routeword/sync in bits\n\n\n\n\nfrom each Unstriper.\n\n\nRW_CLK_out\n3\nClock for outgoing routeword/sync\n\n\n\n\nindication.",
        "The parity exchange bus is used to communicate parity information between the Unstripers. For certain stripe amounts, the parity exchange bus must communciate certain data bits (or the exclusive-or of certain data bits) between Unstripers. The Parity Exchange bus enables each Unstriper to send 8-bits of data to each of the other Unstripers each clock cycle.",
        "Number\n\n\n\n\nof\n\n\nPin Name\ncopies\nFunction\n\n\n\n\n\n\n\nPE_SOP(2:0)\n1\n1 cycle pulse to indicate to advance to\n\n\n\n\nthe next cell/packet.\n\n\nPE_CLK_in(2:0)\n1\nEach chip receives a clock for the\n\n\n\n\nassocicated SOP signal. Note that the\n\n\n\n\nSOP is multidropped, the clock is not.\n\n\n\n\n(Each chip drives 3 copies of its clock,\n\n\n\n\nso it has 3 outputs and 3 inputs).\n\n\nPE_CLK_out\n3\nClock sent out with each lane of data to\n\n\n\n\nthe other Unstripers.\n\n\nPE_VALID_in(2:0)\n1\nWhen asserted indicates that the other\n\n\n\n\ninputs contain valid data.\n\n\nPE_VALID_out\n1\nAsserted to indicate that the other\n\n\n\n\noutputs contain valid data.\n\n\nPE_DATA_out(15:0)\n3\nExchanges the bits necessary for parity\n\n\n\n\ncalculation. Exact exchange depends on\n\n\n\n\nthe number of fabrics. Each chip has an\n\n\n\n\noutput 16-bit data bus for every other\n\n\n\n\nUnstriper. The exact data exchanged on\n\n\n\n\nthese busses depends on the stripe\n\n\n\n\namount. Each Unstriper will start\n\n\n\n\ndriving data at the same time as\n\n\n\n\nPE_SOP.\n\n\nPE_DATA_in(15:0)\n3\nReceived parity data from each Un-\n\n\n\n\nstriper. This data is synchronous with\n\n\n\n\nthe corresponding PE_CLK_in.",
        "The error exchange bus allows three chips to communicate to a master the individual pass/fail results of the thirteen CRCs run by the chip and an indication of a parity error in the incoming data. The master combines the results of all of the chips together into one passing lane and signals the passing lane on the CRC selection pins. Note that there are only two valid passing configurations for any given packet. Either one CRC can pass and all others fail or all CRCs can pass.",
        "The individual fields of this bus are given in the table below.",
        "Label\nDirection\nFunction\n\n\n\n\n\n\n\nEE_Parity\nSlave-1 bit output\nDriven low to indicate a parity\n\n\n\nMaster-3 bit input\nerror. Valid at the same time as\n\n\n\n\nCRC results.\n\n\nEE_CRC (3:0)\nSlave-4 bit output\nSlave-drives:\n\n\n\nMaster-12 bit input\n\u201c1111\u201d = idle\n\n\n\n\n\u201c1110\u201d = all CRCs pass\n\n\n\n\n\u201c1101\u201d = drop\n\n\n\n\n\u201c0000\u201d-\u201c1100\u201d = passing\n\n\n\n\ninput combination\n\n\n\n\nNote that no drop will occur\n\n\n\n\nuntil the output select signals a\n\n\n\n\ndrop.\n\n\nEE_Valid\nSlave-1 bit output\nGives the source clock for the\n\n\n\nMaster-3 bit input/1\noutputs running between chips.\n\n\n\nbit output\nEach chip will drive its\n\n\n\n\nEE_CRC and EE_Parity bits\n\n\n\n\nbased on its local clock and then\n\n\n\n\nship all of these to the other\n\n\n\n\nsources.\n\n\nEE_OutSel(3:0)\nSlave-4 bit input\nMaster-drives:\n\n\n\nMaster-4 bit output\n\u201c1111\u201d = packet should be\n\n\n\n\ntrapped\n\n\n\n\n\u201c1110\u201d = idle\n\n\n\n\n\u201c1101\u201d = drop\n\n\n\n\n\u201c0000\u201d-\u201c1100\u201d for a valid\n\n\n\n\noutput select.\n\n\nEE_Clk\nSlave-1 bit output\nClock signal for error data or\n\n\n\nMaster-3 bit output/\noutput select.\n\n\n\n3 bit input",
        "The master/slave configuration is based on the relative chip id of the chip in the chipset. Chip 0 is treated as the master and chips 1, 2, and 3 are treated as slaves. Chip 0 is responsible for enforcing the trap condition in OC192c operation and will maintain the error counters and generate any error conditions due to interrupts exceeding thresholds.",
        "The SOP/C Synchronization Bus is provided to minimize the skew of the BOB SOP/C signals coming from each Unstriper. Each Unstriper sends its BOB_SOP_C signal to each of the other Unsripers and receives theirs. The packet is transmitted on the cycle following the receipt of all of the SOP/Cs. If all of the SOP/Cs are not received within the allotted time the SOP/C Sync Err bit is asserted in the Main Status Register. Note that these signals are not source synchronous.",
        "The Unstripers are connected in a bit interleaved fashion similar to the Stripers in OC192c mode. One pin is used to indicate from the master to the three slaves that a new packet/cell is about to be started. This signal is asserted 3 clocks before the start of the data. This signal is synchronous with the output clock domain. The signal is driven to a one to indicate the start of a packet, driven to a zero to indicate no start. Three clock cycles after it appears on the external net, the data will be driven onto the output bus to the memory controller.",
        "The Unstriper provides the capability to terminate injected cells/packets which are used to help isolate any error conditions present in the switch 10. On receipt of these special cells or packets, the Unstriper will process them conventionally, except that they are not actually passed to the output. Whenever a cell or packet is received which is identified as a path error cell, its egress routeword is trapped along with an indication if the cell was received without error or exactly where the error location was seen. Termination cells are flagged as unicast cells with bit 0 of the fabric 14 connection number equal to a one. A FIFO of the routeword data of termination cells received is maintained by the Unstriper. When the number of FIFO entries exceeds a threshold, an interrupt is generated.",
        "In addition to trapping routewords for the path error cells, the Unstriper can also optionally trap the routewords for any erroneous cells.",
        "The FIFO is constructed to be 256 entries deep. Overflows are dropped on the write side of the FIFO.",
        "The assignment of data bits to fabrics is done in the context of a bit stream view of the data. The data is viewed as being broken into blocks of 48 bits and assignment of data bits to fabrics is done within the 48-bit blocks. A start of packet always starts a new 48-bit block. Striping is defined as the mechanism that assigns the bit streams to the backplane bus bits. Striping is defined to meet the following criteria:\n\n    \n    \n        1. OC48 data cannot have more than 8 bits of pad required on the backplane bus. A bit assignment which has all groups of 12 bits transmitted on the same clock cycle will satisfy this property. For example, this states that for data bits 0:35, bits 0:11 are transmitted on cycle 1, 12:23 on cycle 2 and 24:35 on cycle 3. The other way to approach this would be to allow for shifts within a byte of data. For example bit 9 and bit 13 could shift positions because bit 9 and bit 15 are part of the same byte, so if one is used the other must also be used.\n        2. OC192 data cannot have more than 40 bits of pad required for the backplane bus. Note that this is actually a subset of #1 since this requires that all groups of 48 are transmitted on the same clock cycle for the backplane bus.\n        3. The striping definition must not require chip/chip communication for data for OC192 operation and the backplane busses must exist largely unchanged from OC192 and OC48. The assignment of bits to the stripers must allow for the same number of bits to go to each fabric 14 from each striper in OC192 mode.\n        4. All fabrics must have exactly the same bits going to the memory controllers for either an OC48 or an OC192 input port. On the output side, the same bits leave the memory controller and must be convertible into the backplane bus required for either an OC48 or an OC192 output port.\n\nThe striping function will be defined by constructing an OC192 solution and modifying OC48 behavior to match the OC192 solution. For each of the striping configurations, a table will be constructed which will give the bit assignments for striping. Each row of this table represents the bits that are connected to the stripers in OC192 mode. Each set of 3 columns in the table represent the bits sent during one cycle of OC48 operation. The following properties will be true for each table:\n\n        1. Each 12-bit sub-block will have the same number of bits going to each fabric 14, which will satisfy constraints 1 and 2. The 12-bit sub-block is composed of 3 columns of all four rows. In order to satisfy the 12 bit sub-block having the same number of bits to each fabric 14, the destination fabric 14 for the first bit from different stripers must rotate among the fabrics present in the switch 10.\n        2. Each row in the table will have the same number of bits going to each fabric 14. This will satisfy constraint number 3 and 4.\n        3. The bits used for OC48 striping and OC192 striping will be the same. This allows the aggregator 32 to convert the streams to one universal stream for the use on the fabric 14.\n\nThe following gives assignments for each of the fabric 14 configurations which satisfy these properties.\n\nThe parity data which is transmitted is documented in the context of a 96 bit frame. This is to allow for parity exchange between the chips at 125 MHz.\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF0a(1)\nF0a(2)\nF0a(3)\nF0a(4)\nF0a(5)\nF0a(6)\nF0a(7)\nF0a(8)\nF0a(9)\nF0a(10)\nF0a(11)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF0b(0)\nF0b(1)\nF0b(2)\nF0b(3)\nF0b(4)\nF0b(5)\nF0b(6)\nF0b(7)\nF0b(8)\nF0b(9)\nF0b(10)\nF0b(11)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF0c(0)\nF0c(1)\nF0c(2)\nF0c(3)\nF0c(4)\nF0c(5)\nF0c(6)\nF0c(7)\nF0c(8)\nF0c(9)\nF0c(10)\nF0c(11)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF0d(0)\nF0d(1)\nF0d(2)\nF0d(3)\nF0d(4)\nF0d(5)\nF0d(6)\nF0d(7)\nF0d(8)\nF0d(9)\nF0d(10)\nF0d(11)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\nCycle\n\n\n\n\n\n(bit)\n0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\ncycle 0 + 24\ncycle 0 + 24\ncycle 0 + 24\n\n\nF0(1)\n1\n\n\nF0(2)\n2\n\n\nF0(3)\n3\n\n\nF0(4)\n4\n\n\nF0(5)\n5\n\n\nF0(6)\n6\n\n\nF0(7)\n7\n\n\nF0(8)\n8\n\n\nF0(9)\n9\n\n\nF0(10)\n10\n\n\nF0(11)\n11\n\n\n\n\n\n\n\n\n\nThe parity data is identical to the transmit data.\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF0a(1)\nF1a(1)\nF0a(2)\nF1a(2)\nF0a(3)\nF1a(3)\nF0a(4)\nF1a(4)\nF0a(5)\nF1a(5)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF1b(0)\nF0b(0)\nF1b(1)\nF0b(1)\nF1b(2)\nF0b(2)\nF1b(3)\nF0b(3)\nF1b(4)\nF0b(4)\nF1b(5)\nF0b(5)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF0c(0)\nF1c(0)\nF0c(1)\nF1c(1)\nF0c(2)\nF1c(2)\nF0c(3)\nF1c(3)\nF0c(4)\nF1c(4)\nF0c(5)\nF1c(5)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF1d(0)\nF0d(0)\nF1d(1)\nF0d(1)\nF1d(2)\nF0d(2)\nF1d(3)\nF0d(3)\nF1d(4)\nF0d(4)\nF1d(5)\nF0d(5)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n13\ncycle 0 + 24\ncycle 1 + 24\n\n\n\nF0(1)\n2\n15\n\n\n\nF0(2)\n5\n16\n\n\n\nF0(3)\n7\n18\n\n\n\nF0(4)\n8\n21\n\n\n\nF0(5)\n10\n23\n\n\n\nF1(0)\n1\n12\n\n\n\nF1(1)\n3\n14\n\n\n\nF1(2)\n4\n17\n\n\n\nF1(3)\n6\n19\n\n\n\nF1(4)\n9\n20\n\n\n\nF1(5)\n11\n22",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\nP0\n0\n0, 4\n\n\n\nP1\n2\n2, 6\n\n\n\nP2\n1\n1, 5\n\n\n\nP3\n3\n3, 7\n\n\n\nP4\n0\n8, 9\n\n\n\nP5\n2\n10, 11\n\n\n\nP6\n1\n13, 17\n\n\n\nP7\n3\n15, 19\n\n\n\nP8\n0\n16, 12\n\n\n\nP9\n2\n18, 14\n\n\n\nP10\n1\n21, 20\n\n\n\nP11\n3\n23, 22\n\n\n\n\n\n\n\n\n\n\nNote that parity bits P12-P24 repeat the pattern of P0-P11 For generation of parity, 8 bits are exchanged between U0\u2192U1 and U2\u2192U3 for each 48 bit word, one bit in each direction. The following table shows the bits transmitted on each parity bus. Bits 8 through 15 of the exchange is obtained by adding 96 to each value below.",
        "From\nTo\nBit 7\nBit 6\nBit 5\nBit 4\nBit 3\nBit 2\nBit 1\nBit 0\n\n\n\n\n\n\n\n0\n1\n92\nP40 + 80\n68\nP28 + 56\n44\nP16 + 32\n20\nP4 + 8\u2002\n\n\n\n2\n\n\n\n3\n\n\n1\n0\nP46 + 93\n81\nP34 + 69\n57\nP22 + 45\n33\nP10 + 21\n\u20029\n\n\n\n2\n\n\n\n3\n\n\n2\n0\n\n\n\n1\n\n\n\n3\n94\nP41 + 82\n70\nP29 + 58\n46\nP17 + 34\n22\nP5 + 10\n\n\n3\n0\n\n\n\n1\n\n\n\n2\nP47 + 95\n83\nP35 + 71\n59\nP23 + 47\n35\nP11 + 23\n11\n\n\n\n\n\n\n\n\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF0a(1)\nF1a(1)\nF2a(1)\nF0a(2)\nF1a(2)\nF2a(2)\nF0a(3)\nF1a(3)\nF2a(3)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF2b(0)\nF0b(0)\nF1b(0)\nF2b(1)\nF0b(1)\nF1b(1)\nF2b(2)\nF0b(2)\nF1b(2)\nF2b(3)\nF0b(3)\nF1b(3)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF1c(0)\nF2c(0)\nF0c(0)\nF1c(1)\nF2c(1)\nF0c(1)\nF1c(2)\nF2c(2)\nF0c(2)\nF1c(3)\nF2c(3)\nF0c(3)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF0d(0)\nF1d(0)\nF2d(0)\nF0d(1)\nF1d(1)\nF2d(1)\nF0d(2)\nF1d(2)\nF2d(2)\nF0d(3)\nF1d(3)\nF2d(3)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\n\n\n\n\n\n\n(bit)\nCycle 0\nCycle 1\nCycle 2\nCycle 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\ncycle 0 + 12\ncycle 0 + 24\ncycle 0 + 36\n\n\nF0(1)\n3\n\n\nF0(2)\n5\n\n\nF0(3)\n10\n\n\nF1(0)\n2\n\n\nF1(1)\n4\n\n\nF1(2)\n7\n\n\nF1(3)\n9\n\n\nF2(0)\n1\n\n\nF2(1)\n6\n\n\nF2(2)\n8\n\n\nF2(3)\n11\n\n\n\n\n\n\n\n\n\nThe parity calculation uses the following:",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\nP0\n0\n0, 4, 8\n\n\n\nP1\n3\n3, 7, 11\n\n\n\nP2\n1\n1, 5, 9\n\n\n\nP3\n2\n2, 6, 10\n\n\n\nP4\n0\n12, 16, 20\n\n\n\nP5\n3\n15, 19, 23\n\n\n\nP6\n1\n13, 17, 21\n\n\n\nP7\n2\n14, 18, 22\n\n\n\n\n\n\n\n\n\n\nNote that parity bits P8-P15 repeat the pattern of P0-P11.\n\nParity generation requires no exchange of bits for OC192c.\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF3a(0)\nF0a(1)\nF1a(1)\nF2a(1)\nF3a(1)\nF0a(2)\nF1a(2)\nF2a(2)\nF3a(2)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF3b(0)\nF0b(0)\nF1b(0)\nF2b(0)\nF3b(1)\nF0b(1)\nF1b(1)\nF2b(2)\nF3b(2)\nF0b(2)\nF1b(2)\nF2b(2)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF2c(0)\nF3c(0)\nF0c(0)\nF1c(0)\nF2c(1)\nF3c(1)\nF0c(1)\nF1c(1)\nF2c(2)\nF3c(2)\nF0c(2)\nF1c(2)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF1d(0)\nF2d(0)\nF3d(0)\nF0d(0)\nF1d(1)\nF2d(1)\nF3d(1)\nF0d(1)\nF1d(2)\nF2d(2)\nF3d(2)\nF0d(2)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\nCycle\nCycle\nCycle\nCycle\n\n\n(bit)\n0\n1\n2\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n15\n26\n37\n\n\nF0(1)\n5\n16\n31\n42\n\n\nF0(2)\n10\n21\n32\n47\n\n\nF1(0)\n3\n14\n25\n36\n\n\nF1(1)\n4\n19\n30\n41\n\n\nF1(2)\n9\n20\n35\n46\n\n\nF2(0)\n2\n13\n24\n39\n\n\nF2(1)\n7\n18\n29\n40\n\n\nF2(2)\n8\n23\n34\n45\n\n\nF3(0)\n1\n12\n27\n38\n\n\nF3(1)\n6\n17\n28\n43\n\n\nF3(2)\n11\n22\n33\n44\n\n\n\n\n\n\n\n\n\nThe parity calculation uses the following formulas:",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\nP0\u2002\n0\n0, 4, 8, 11\n\n\n\nP1\u2002\n1\n5, 9, 7, 1\n\n\n\nP2\u2002\n2\n10, 3, 2, 6\n\n\n\nP3\u2002\n3\n15, 19, 23, 22\n\n\n\nP4\u2002\n0\n16, 20, 18, 12\n\n\n\nP5\u2002\n1\n21, 14, 13, 17\n\n\n\nP6\u2002\n2\n26, 30, 34, 33\n\n\n\nP7\u2002\n3\n31, 35, 29, 27\n\n\n\nP8\u2002\n0\n32, 25, 24, 28\n\n\n\nP9\u2002\n1\n37, 41, 45, 44\n\n\n\nP10\n2\n42, 46, 40, 38\n\n\n\nP11\n3\n47, 36, 39, 43\n\n\n\n\n\n\n\n\n\n\nThe following table shows the bits transmitted on each parity bus. Bits 8 through 15 of the parity data are obtained by adding 96 to each of the values in the table.",
        "From\nTo\nBit 7\nBit 6\nBit 5\nBit 4\nBit 3\nBit 2\nBit 1\nBit 0\n\n\n\n\n\n\n\n0\n1\n92\nP20 + 72 +\n\n\n44\nP8 + 24 + 28 + 32\n\n\n\n\n\n\n\n76 + 80\n\n\n\n2\n88\n\nP16 + 60 +\n\n40\n\nP4 + 12 + 16 + 20\n\n\n\n\n\n\n64 + 68\n\n\n\n3\n84\n\n\nP12 + 56 +\n36\n\n\nP0 + 0 + 4 + 8\u2002\n\n\n\n\n\n\n\n52 + 48\n\n\n1\n0\nP21 + 85 +\n73\n\n\nP9 + 37 + \u2002\n25\n\n\n\n\n89 + 93\n\n\n\n41 + 45\n\n\n\n2\n\n81\nP17 + 69 +\n\n\n33\nP5 + 21 + 13 + 17\n\n\n\n\n\n\n61 + 65\n\n\n\n3\n\n77\n\nP13 + 49 +\n\n29\n\nP1 + 1 + 5 + 9\u2002\n\n\n\n\n\n\n\n53 + 57\n\n\n2\n0\nP22 + 86 +\n\n66\n\nP10 + 38 +\n\n18\n\n\n\n\n90 + 94\n\n\n\n42 + 46\n\n\n\n1\n\nP18 + 74 +\n62\n\n\nP6 + 26 + 30 + 34\n14\n\n\n\n\n\n78 + 82\n\n\n\n3\n\n\n70\nP14 + 50 +\n\n\n22\nP2 + 2 + 6 + 10\n\n\n\n\n\n\n\n54 + 58\n\n\n3\n0\nP23 + 87 +\n\n\n59\nP11 + 39 +\n\n\n11\n\n\n\n\n91 + 95\n\n\n\n43 + 47\n\n\n\n1\n\nP19 + 75 +\n\n55\n\nP7 + 27 + 31 + 35\n\n\u20027\n\n\n\n\n\n79 + 83\n\n\n\n2\n\n\nP15 + 63 +\n51\n\n\nP3 + 15 + 19 + 23\n\u20023\n\n\n\n\n\n\n67 + 71\n\n\n\n\n\n\n\n\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF3a(0)\nF4a(0)\nF5a(0)\nF0a(1)\nF1a(1)\nF2a(1)\nF3a(1)\nF4a(1)\nF5a(1)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF3b(0)\nF4b(0)\nF5b(0)\nF0b(0)\nF1b(0)\nF2b(0)\nF3b(1)\nF4b(1)\nF5b(1)\nF0b(1)\nF1b(1)\nF2b(1)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF0c(0)\nF1c(0)\nF2c(0)\nF3c(0)\nF4c(0)\nF5c(0)\nF0c(0)\nF1c(1)\nF2c(1)\nF3c(1)\nF4c(1)\nF5c(1)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF3d(0)\nF4d(0)\nF5d(0)\nF0d(0)\nF1d(0)\nF2d(0)\nF3d(1)\nF4d(1)\nF5d(1)\nF0d(1)\nF1d(1)\nF2d(1)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\nCycle\nCycle\n\n\n(bit)\n0\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n13\n\n\nF0(1)\n2\n15\n\n\nF1(0)\n4\n17\n\n\nF1(1)\n6\n19\n\n\nF2(0)\n8\n21\n\n\nF2(1)\n10\n23\n\n\nF3(0)\n1\n12\n\n\nF3(1)\n3\n14\n\n\nF4(0)\n5\n16\n\n\nF4(1)\n7\n18\n\n\nF5(0)\n9\n20\n\n\nF5(1)\n11\n22\n\n\n\n\n\n\n\n\n\nThe parity calculation uses the following formulas:",
        "Transmit\n\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\n\n\nP0\n0\n0, 4, 8, 1, 5, 9\n\n\n\nP1\n2\n2, 6, 10, 3, 7, 11\n\n\n\nP2\n1\n13, 17, 21, 12, 16, 20\n\n\n\nP3\n3\n15, 19, 23, 14, 18, 22\n\n\n\n\n\n\n\n\n\n\nNote that parity bits P4-P8 repeat the pattern of P0-P3+24. The following table shows the bits on each parity bus. Bits 8 through 15 of the parity bus are obtained by adding 96 to each value in the table.",
        "From\nTo\nBit 7\nBit 6\nBit 5\nBit 4\nBit 3\nBit 2\nBit 1\nBit 0\n\n\n\n\n\n\n\n0\n1\n84 + 88 + 92\nP12 + 72 +\n60 + 64 + 68\nP8 + 48 +\n36 + 40 + 44\nP4 + 24 + 28 + 32\n12 + 16 + 20\nP0 + 0 + 4 + 8\u2002\n\n\n\n\n\n76 + 80\n\n52 + 56\n\n\n\n2\n\n\n\n3\n\n\n1\n0\nP15 + 85 +\n73 + 77 + 81\nP11 + 61 +\n49 + 53 + 57\nP7 + 37 +\n25 + 29 + 33\nP3 + 13 + 17 + 21\n1 + 5 + 9\u2002\n\n\n\n\n89 + 93\n\n65 + 69\n\n41 + 45\n\n\n\n2\n\n\n\n3\n\n\n2\n0\n\n\n\n1\n\n\n\n3\n86 + 90 + 94\nP13 + 74 +\n62 + 66 + 70\nP9 + 50 +\n38 + 42 + 46\nP5 + 26 + 30 + 34\n14 + 18 + 22\nP1 + 2 + 6 + 10\n\n\n\n\n\n78 + 82\n\n54 + 58\n\n\n3\n0\n\n\n\n1\n\n\n\n2\nP14 + 87 +\n75 + 79 + 83\nP10 + 63 +\n51 + 55 + 59\nP6 + 39 +\n27 + 31 + 35\nP2 + 15 + 19 + 23\n3 + 7 + 11\n\n\n\n\n91 + 95\n\n67 + 71\n\n43 + 47\n\n\n\n\n\n\n\n\n\nThe following table gives the fabric assignments for each block of 48 bits and the output bus assignments for OC192c operation.",
        "Bit\n0\n4\n\u20028\n12\n16\n20\n24\n28\n32\n36\n40\n44\n\n\nBP bus\nF0a(0)\nF1a(0)\nF2a(0)\nF3a(0)\nF4a(0)\nF5a(0)\nF6a(0)\nF7a(0)\nF8a(0)\nF9a(0)\nF10a(0)\nF11a(0)\n\n\nBit\n1\n5\n\u20029\n13\n17\n21\n25\n29\n33\n37\n41\n45\n\n\nBP bus\nF3b(0)\nF4b(0)\nF5b(0)\nF6b(0)\nF7b(0)\nF8b(0)\nF9b(0)\nF10b(0)\nF11b(0)\nF0b(0)\nF1b(0)\nF2b(0)\n\n\nBit\n2\n6\n10\n14\n18\n22\n26\n30\n34\n38\n42\n46\n\n\nBP bus\nF6c(0)\nF7c(0)\nF8c(0)\nF9c(0)\nF10c(0)\nF11c(0)\nF0c(0)\nF1c(0)\nF2c(0)\nF3c(0)\nF4c(0)\nF5c(0)\n\n\nBit\n3\n7\n11\n15\n19\n23\n27\n31\n35\n39\n43\n47\n\n\nBP bus\nF9d(0)\nF10d(0)\nF11d(0)\nF0d(0)\nF1d(0)\nF2d(0)\nF3d(0)\nF4d(0)\nF5d(0)\nF6d(0)\nF7d(0)\nF8d(0)\n\n\n\n\n\n\n\n\n\nThe following table shows the bit order transmitted for OC48 operation.",
        "Fabric\nCycle\nCycle\nCycle\nCycle\n\n\n\n(bit)\n0\n1\n2\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF0(0)\n0\n15\n26\n37\n\n\n\nF1(0)\n4\n19\n30\n41\n\n\n\nF2(0)\n8\n23\n34\n45\n\n\n\nF3(0)\n1\n12\n27\n38\n\n\n\nF4(0)\n5\n16\n31\n42\n\n\n\nF5(0)\n9\n20\n35\n46\n\n\n\nF6(0)\n2\n13\n24\n39\n\n\n\nF7(0)\n6\n17\n28\n43\n\n\n\nF8(0)\n10\n21\n32\n47\n\n\n\nF9(0)\n3\n14\n25\n36\n\n\n\nF10(0)\n7\n18\n29\n40\n\n\n\nF11(0)\n11\n22\n33\n44\n\n\n\n\n\n\n\n\n\n\nThe parity calculation uses the following formulas and the following aggregator 32 read order",
        "Transmit\n\n\n\nBit\nstripe\nXOR bits\n\n\n\n\n\n\n\nP0\n0\n\u20020-11\n\n\nP1\n1\n12-23\n\n\nP2\n2\n24-35\n\n\nP3\n3\n36-47\n\n\n\n\n\n\n\n\n\nThe following table shows the bits transmitted on each parity bus. Bits 8 through 15 of the parity bus are obtained by adding 96 to each value in the table.",
        "From\nTo\nBit 7\nBit 6\nBit 5\nBit 4\nBit 3\nBit 2\nBit 1\nBit 0\n\n\n\n\n\n\n\n0\n1\n84 + 88 + 92\n72 + 76 + 80\n60 + 64 + 68\nP4 + 48 + 52 + 56\n36 + 40 + 44\n24 + 28 + 32\n12 + 16 + 20\nP0 + 0 + 4 + 8\n\n\n\n2\n84 + 88 + 92\n72 + 76 + 80\n60 + 64 + 68\nP4 + 48 + 52 + 56\n36 + 40 + 44\n24 + 28 + 32\n12 + 16 + 20\nP0 + 0 + 4 + 8\n\n\n\n3\n84 + 88 + 92\n72 + 76 + 80\n60 + 64 + 68\nP4 + 48 + 52 + 56\n36 + 40 + 44\n24 + 28 + 32\n12 + 16 + 20\nP0 + 0 + 4 + 8\n\n\n1\n0\n85 + 89 + 93\n73 + 77 + 81\nP5 + 61 + 65 + 69\n49 + 53 + 57\n37 + 41 + 45\n25 + 29 + 33\nP1 + 13 + 17 + 21\n1 + 5 + 9\u2002\n\n\n\n2\n85 + 89 + 93\n73 + 77 + 81\nP5 + 61 + 65 + 69\n49 + 53 + 57\n37 + 41 + 45\n25 + 29 + 33\nP1 + 13 + 17 + 21\n1 + 5 + 9\u2002\n\n\n\n3\n85 + 89 + 93\n73 + 77 + 81\nP5 + 61 + 65 + 69\n49 + 53 + 57\n37 + 41 + 45\n25 + 29 + 33\nP1 + 13 + 17 + 21\n1 + 5 + 9\u2002\n\n\n2\n0\n86 + 90 + 94\nP6 + 74 +\n62 + 66 + 70\n50 + 54 + 58\n38 + 42 + 46\nP2 + 26 +\n14 + 18 + 22\n2 + 6 + 10\n\n\n\n\n\n78 + 82\n\n\n\n30 + 34\n\n\n\n1\n86 + 90 + 94\nP6 + 74 +\n62 + 66 + 70\n50 + 54 + 58\n38 + 42 + 46\nP2 + 26 +\n14 + 18 + 22\n2 + 6 + 10\n\n\n\n\n\n78 + 82\n\n\n\n30 + 34\n\n\n\n3\n86 + 90 + 94\nP6 + 74 +\n62 + 66 + 70\n50 + 54 + 58\n38 + 42 + 46\nP2 + 26 +\n14 + 18 + 22\n2 + 6 + 10\n\n\n\n\n\n78 + 82\n\n\n\n30 + 34\n\n\n3\n0\nP7 + 87 +\n75 + 79 + 83\n63 + 67 + 71\n51 + 55 + 59\nP3 + 39 +\n27 + 31 + 35\n15 + 19 + 23\n3 + 7 + 11\n\n\n\n\n91 + 95\n\n\n\n43 + 47\n\n\n\n1\nP7 + 87 +\n75 + 79 + 83\n63 + 67 + 71\n51 + 55 + 59\nP3 + 39 +\n27 + 31 + 35\n15 + 19 + 23\n3 + 7 + 11\n\n\n\n\n91 + 95\n\n\n\n43 + 47\n\n\n\n2\nP7 + 87 +\n75 + 79 + 83\n63 + 67 + 71\n51 + 55 + 59\nP3 + 39 +\n27 + 31 + 35\n15 + 19 + 23\n3 + 7 + 11\n\n\n\n\n91 + 95\n\n\n\n43 + 47",
        "When the Unstriper receives a Packet Abort K-character over the SOB, the Unstriper should abandon all packets that can't be completed with fragments that have already been received (in or after the Data Delay FIFO/RW Voter). No indication is provided when a packet has been dropped as a result of receiving a Packet Abort. The Unstriper expects that at least 12 Idle K-characters are received following the Packet Abort K-character as a means of allowing the Unstriper to re-sync.",
        "Given a potential mismatch between the SOB bandwidth and the BOB bandwidth and the potential for the BOB to be backpressured from downstream it is possible that all of the storage within the Unstriper is consumed. When the number of used slots in the Data Delay FIFO is greater than the contents of the Backpressure Threshold Register the Unstriper asserts the US_BP output signal. It is expected that the Separators will stop sending transfers at the next fragment boundary after receiving this signal. If any fragments are received when the Data Delay FIFO is full they are dropped. If any final fragments are lost then Unstriper will increment the FIFO Full Packet Drop Count register.",
        "Initial values of all register (reset state) is zero unless documented otherwise.",
        "The version number register is a read only register which allows software to see what the version number of the chip is.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n\n\n31:16\nUnused\n\n\n\n\n15:12\nVersion number\nVersion number of the chip\n\n\n\n11:0\nASIC ID\nASIC ID\n\n\n\n\n\n\n\n\n\n\nThe main control register controls the configuration of the chip.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:14\nUnused\n\n\n\n13\nDisable term\nSet this bit to a one to disable trapping\n\n\n\n\ntest cells into the terminate FIFO, set to a\n\n\n\n\nzero to enable trapping test cells into the\n\n\n\n\nterminate FIFO and not forwarding the cells\n\n\n\n\nto the output stage.\n\n\n12\nUnused\n\n\n11\nTrap corrupts\nSet this bit to a one to trap all corrupt cell\n\n\n\n\ninformation into the terminate FIFO, set to a\n\n\n\n\nzero to only trap test cells terminated in the\n\n\n\n\nunstriper.\n\n\n10\nBOB_valid polarity\n\u20181\u2019 = BOB_VALID is active-high.\n\n\n\n\n\u20180\u2019 = BOB_VALID is active-low.\n\n\n9\nBob packet wait\nDetermines the latency between the assertion\n\n\n\n\nof the BOB_BP_L signal and the\n\n\n\n\ndeassertion of the BOB_VALID signal\n\n\n\n\n\u20181\u2019 = BOB is idled immediately.\n\n\n\n\n\u20180\u2019 = BOB is idled at the end of the next\n\n\n\n\npacket/cell.\n\n\n8\nSOP polarity\n\u20181\u2019 = SOP is active-high.\n\n\n\n\n\u20180\u2019 = SOP is active-low.\n\n\n\n\nNote for ATM blades, this bit should be a\n\n\n\n\nzero.\n\n\n7\nUnused\n\n\n5\nOC192c enable\nReturns the value present on the\n\n\n\n\nOC48/oc192 pin.\n\n\n\n\n\u20181\u2019 = OC192c\n\n\n\n\n\u20180\u2019 = OC48\n\n\n4:3\nOC192c chip id\nReturns the value of the\n\n\n\n\nCHIP_MODE(1:0) pins.\n\n\n2:0\nNumber of Fabrics\nThe number of fabrics in the system\n\n\n\n\nconfiguration. The Unstriper can handle\n\n\n\n\ndata striped to two adjacent fabric amounts\n\n\n\n\nsimultaneously.\n\n\n\n\n\u201c000\u201d = 1/2\n\n\n\n\n\u201c001\u201d = 2/3\n\n\n\n\n\u201c010\u201d = 3/4\n\n\n\n\n\u201c011\u201d = 4/6-fast\n\n\n\n\n\u201c100\u201d = 6-fast/6-slow\n\n\n\n\n\u201c101\u201d = 6-slow/12\n\n\n\n\n\u201c110\u201d = 6-slow/12\n\n\n\n\n\n\n\n\n\nThis register contains a status information to report errors. Reading bits automatically causes them to clear. Status bits will be reasserted after the source has cleared its signal and then is reasserted.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:10\nUnused\n\n\n\n9\nRouteword exchange\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the Routeword\n\n\n\n\nExchange Bus.\n\n\n8\nParity exchange\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the Parity Exchange\n\n\n\n\nBus.\n\n\n7\nError exchange\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the Error Exchange\n\n\n\n\nBus.\n\n\n6\nBOB SOP/C Sync\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the BOB SOP/C Sync\n\n\n\n\nBus.\n\n\n5\nTransceiver error\nOne or more of the Gigabit Ethernet\n\n\n\nabove threshold\ntransceivers (SOB) error counters has\n\n\n\n\nexceeded the programmed threshold. The\n\n\n\n\nTransceiver Error Status register must be\n\n\n\n\nread to clear this bit.\n\n\n4\nTerminated FIFO\nThe number of terminated cells (used for\n\n\n\nlength above\nswitch path fault isolation) has exceeded\n\n\n\nthreshold\nthe programmed threshold.\n\n\n3\nError counter\nAn error counter has exceeded the\n\n\n\nabove threshold\nprogrammed threshold.\n\n\n2\nSynch error\nAn error in the synchronization logic\n\n\n\n\noccurred.\n\n\n1\nFIFO full\nThis bit is set to a one when a cell or\n\n\n\ndrop occurred\npacket drop has occurred due to an\n\n\n\n\ninternal FIFO being full.\n\n\n0\nCell Trapped\nThis bit is set to a one when a cell trap has\n\n\n\n\nbeen triggered. This bit is cleared by\n\n\n\n\nwriting a one back to this bit.\n\n\n\n\n\n\n\n\n\nThis register enables an interrupt to be generated when the corresponding bit in the Status Register has been set.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:12\nUnused\n\n\n\n11\nRouteword exchange\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the Routeword\n\n\n\n\nExchange Bus.\n\n\n10\nParity exchange\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the Parity Exchange\n\n\n\n\nBus.\n\n\n\u20029\nError exchange\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the Error Exchange\n\n\n\n\nBus.\n\n\n\u20028\nBOB SOP/C Sync\nA synchronization error occurred (elastic\n\n\n\nbus sync error\nbuffer overflow) on the BOB SOP/C\n\n\n\n\nSync Bus.\n\n\n\u20027\nTransceiver error\nOne or more of the Gigabit Ethernet\n\n\n\nabove threshold\ntransceivers (SOB) error counters has\n\n\n\n\nexceeded the programmed threshold. The\n\n\n\n\nTransceiver Error Status register must be\n\n\n\n\nread to clear this bit.\n\n\n\u20026\nTerminated cells\nSet this bit to a one to enable the interrupt\n\n\n\nover threshold\nassertion due to the number of terminated\n\n\n\n\ncells exceeding a threshold being held in\n\n\n\n\nthe terminated cell FIFO.\n\n\n\u20025\nParity error\nSet this bit to a one to enable the interrupt\n\n\n\n\nassertion due to a parity threshold\n\n\n\n\nexceeded condition. Set this bit to a zero\n\n\n\n\nto disable the interrupt.\n\n\n\u20024\nChecksum error\nSet this bit to a one to enable the interrupt\n\n\n\n\nassertion due to a checksum threshold\n\n\n\n\nexceeded condition. Set this bit to a zero\n\n\n\n\nto disable the interrupt.\n\n\n\u20023\nRouteword error\nSet this bit to a one to enable the interrupt\n\n\n\n\nassertion due to a routeword threshold\n\n\n\n\nexceeded condition. Set this bit to a zero\n\n\n\n\nto disable the interrupt.\n\n\n\u20022\nSynch Error\nSet to bit to a one to generate an interrupt\n\n\n\n\non the assertion of an error in the\n\n\n\n\nsynchronizer.\n\n\n\u20021\nFIFO full\nSet this bit to a one to enable an interrupt\n\n\n\n\non the dropping of traffic due to any FIFO\n\n\n\n\noverflow in the chip.\n\n\n\u20020\nCell Trapped\nSet this bit to a one to enable an interrupt\n\n\n\n\nif a cell trap executed.\n\n\n\n\n\n\n\n\n\nThe Input enable register controls the ports enabled for the input busses on the device. Note that this is used to override the normal hardware based handshaking on the interfaces.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n12:0\nInput Enable\nSet each bit x to a one to enable input bus x for\n\n\n\n\noperation. Note that bit 12 is the parity fabric,\n\n\n\n\nbits 0-11 are for fabrics 0-11.\n\n\n\n\n\n\n\n\n\nDisabling an input causes the routeword from that lane to automatically be handled as if it mismatches but disables any errors from being counted in lanes which would have used the masked data.\n\nThis register is used to control the reading of cells from the data FIFO and pushing the data out the DIN_MC bus. Based on internal error conditions, it can also be used to stop reading output based on certain error conditions to allow debugging to take place.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:5\nUnused\n\n\n\n4\nOC192c driven enables\nEnable drivers for the OC192c\n\n\n\n\nconfiguration.\n\n\n3\nTrap on parity\nSet this bit to a one to trap a cell/packet\n\n\n\n\nwhich has a parity error\n\n\n2\nTrap on header\nSet this bit to a one to trap a cell/packet\n\n\n\n\nwhich has a header error.\n\n\n1\nTrap on checksum\nSet this bit to a one to trap a cell/packet\n\n\n\n\nwhich fails checksum.\n\n\n0\nBOB_enable\nSet this bit to a one to enable writes\n\n\n\n\nto the DIN_MC bus\n\n\n\n\n\n\n\n\n\nThe Backpressure Threshold is used to determine when the Unstriper asserts UNS_BP based on the number of entries used in the Data Delay FIFO. When the threshold is exceeded the UNS_BP signal is asserted until the number of used entries is below the threshold. The Separators are expected to stop sending data at a fragment boundary.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n7:0\nThreshold\nNumber of used entries in the Data Delay FIFO before\n\n\n\n\nthe UNS_BP signal is asserted. The default value is\n\n\n\n\n220 corresponding to two minimum length packets in\n\n\n\n\n240G Slow mode.\n\n\n\n\n\n\n\n\n\nThe Unstriper provides a software interface to the data FIFO as a fault isolation aid. The usage of these registers allows for reads to be done from the FIFO head, and writes to the done to the tail of the FIFO.\n\nTo read a cell/packet from the FIFO, perform the following actions:\n\n    \n    \n        1. Initialize the Output Enable/Trap enable register to stop reads on the desired condition. This will freeze the DIN_MC interface at that start of cell/packet.\n        2. Wait for the Trap Valid bit to be set in the main status register.\n        3. Start reading. The first read should be done with the Data FIFO first read register. This will cause the data to be read from the current read pointer.\n        4. Perform subsequent reads using the data FIFO increment read. This will cause the read pointer to be incremented by one byte for each read operation and the read performed.\n\nNote that this read is not destructive and the data will be read out of the FIFO to the DIN_MC bus when the trap is cleared.",
        "This register selects the FIFO which the FIFO data registers read/write.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:2\nUnused\n\n\n\n1:0\nFIFO select\nSelects the FIFO. The following encoding is used:\n\n\n\n\n00-Data FIFO\n\n\n\n\n01-Parity FIFO\n\n\n\n\n10-output delay FIFO\n\n\n\n\n\n\n\n\n\nThis register reads the byte at the head of the data FIFO.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:9\nUnused\n\n\n\n8\nEOP\nBit is a one for EOP, zero for non-EOP.\n\n\n7:0\nRead data\nRead of this register returns the first byte from the data\n\n\n\n\nFIFO. A write to this register modifies the first address\n\n\n\n\nin the data FIFO",
        "This register is used to read/write the next byte from the FIFO. The effect of this read is to advance the processor read address in the FIFO and to read the resulting data byte. Writing to this register writes the next byte of data. Register format is identical to Data FIFO first read.",
        "The Unstriper maintains a set of error counters. These counters count the occurrences of specific errors within a programmable time window. When counter values exceed a programmed threshold for each counter type, an interrupt is generated and error bits set in the main status register. Two main event types are counted on a per lane basis: (1) header errors and (2) invalid checksums.",
        "Counter resets are done via periodic software polling. It is the intent of the design to have the software read interval reasonably high (0.5 seconds or so). In the event of an interrupt, it is the responsibility of software to find and reset the counter which caused the interrupt condition.",
        "All internal error counters are 16 bits since they are in the device for failure isolation. Counters will not overflow but will stay at 0xFFFF until they are read. Counters automatically clear on reads. It is assumed that periodically the SCP will read the unstriper error counters to maintain longer interval error counts. Interrupts are present to keep the frequency of the required counter reads low (one the order of 100 mS-1 second). The unstriper will not reset counters at all without software intervention.",
        "The error count status register summarizes the current threshold comparison for all error counts. If any of these bits are set, an associated bit is set. To clear a bit in the error count status register, write a 1 back to the location(s) to be cleared. Any bits which have a zero written back will remain unchanged.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n28\nRouteword NF\nThis bit is set when the value in the Rouetword\n\n\n\nError Count\nNF Error Count register is greater than the\n\n\n\nabove threshold\nvalue in the Routeword NF Error Threshold\n\n\n\n\nregister\n\n\n27\nRouteword Parity\nThis bit is set when the value in the Rouetword\n\n\n\nError Count\nParity Error Count register is greater than the\n\n\n\nabove threshld\nvalue in the Routeword Parity Error Threshold\n\n\n\n\nregister\n\n\n26\nParity count\nThis bit is set if the number of parity errors\n\n\n\nabove threshold\nexceeds the parity error threshold.\n\n\n25:13\nRouteword count\nEach bit of this field is set to a one if the\n\n\n\nabove threshold\nrouteword errors of one input interface has its\n\n\n\n\nerror count above the threshold for routeword\n\n\n\n\nerrors.\n\n\n12:0\nChecksum count\nEach bit of this field is set to a one if the\n\n\n\nabove threshold\nchecksum errors of one rebuilt data stream has\n\n\n\n\nits error count above the threshold for\n\n\n\n\nchecksum errors.\n\n\n\n\n\n\n\n\n\nThe Checksum Error Threshold controls the assertion of an error indication for checksum errors. When the number of checksum errors for any lane exceeds this register, an error condition is signaled in the main status register and an interrupt may be generated.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nThreshold\nThreshold value. This is a unsigned 16 bit quantity,\n\n\n\n\ncomparison is # errors > Threshold.\n\n\n\n\n\n\n\n\n\nThe Routeword Error Threshold controls the assertion of an error indication for routeword errors. When the number of routeword errors for any lane exceeds this register, an error condition is signaled in the main status register and an interrupt may be generated.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nThreshold\nThreshold value. This is a unsigned 16 bit quantity,\n\n\n\n\ncomparison is # errors > Threshold.\n\n\n\n\n\n\n\n\n\nThe Parity Error Threshold controls the assertion of an error indication for parity errors. When the number of parity errors exceeds this register, an error condition is signaled in the main status register and an interrupt may be generated.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nThreshold\nThreshold value. This is a unsigned 16 bit quantity,\n\n\n\n\ncomparison is # errors > Threshold.\n\n\n\n\n\n\n\n\n\nThe Routeword Parity Error Threshold controls the assertion of an error indication for routeword parity errors. When the number of routeword parity errors exceeds the value in this register, an error condition is signaled in the error counter status register and an interrupt may be generated.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nThreshold\nThreshold value. This is a unsigned 16 bit quantity,\n\n\n\n\ncomparison is # errors > Threshold.\n\n\n\n\n\n\n\n\n\nThe Routeword NF Error Threshold controls the assertion of an error indication for routeword NF errors. When the number of routeword NF errors exceeds the value in this register, an error condition is signaled in the Error Counter Status register and an interrupt may be generated.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nThreshold\nThreshold value. This is a unsigned 16 bit quantity,\n\n\n\n\ncomparison is # errors > Threshold.\n\n\n\n\n\n\n\n\n\nEach checksum error counter reports a count of checksum error for a specific reconstructed data lane. If any checksum error exceeds the value programmed in the checksum error threshold, an error condition is generated and flagged in the main status register. These counters will not overflow, but will hold a value of all ones until reset. Counters are incremented if a checksum error occurs. Counters reset when it is read by software.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nError count\nGives number of checksum errors seen on this\n\n\n\n\nreconstruction lane since the last counter read.\n\n\n\n\n\n\n\n\n\nEach routeword error count reports a count of routeword errors for a specific input data lane. If any checksum error exceeds the value programmed in the Routeword Error Threshold, an error condition is generated and flagged in the Main Status register. These counters will not overflow, but will hold a value of all ones until reset. Counters are incremented if a routeword error occurs. Counters reset when read by software.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nError count\nCounts the number of routeword errors on a given\n\n\n\n\ninput lane.\n\n\n\n\n\n\n\n\n\nA lane not having a routeword is treated as a routeword of zero for comparison purposes.\n\nThe parity error counter register reports a count of parity errors for the incoming data. If the parity error counter exceeds the value programmed in the parity error threshold, an error condition is generated and flagged in the main status register. This counter will not overflow, but will hold a value of all ones until reset. This counter is incremented if a parity error occurs. Counters reset when read by software.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n\n\n15:0\nError\nNumber of parity errors seen since\n\n\n\n\ncount\nlast counter read.\n\n\n\n\n\n\n\n\n\n\nThe Routeword Parity Error Count register reports a count of routeword parity errors for the voted routeword data. If the Routeword Parity Error Count exceeds the value programmed in the Routeword Parity Error Threshold, an error condition is generated and f lagged in the Error Counter Status register. This counter will not overflow, but will hold a value of all ones until reset. This counter is incremented if a routeword parity error occurs. Counters reset when read by software.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n\n\n15:0\nError\nNumber of routeword parity errors seen since\n\n\n\n\ncount\nlast counter read.\n\n\n\n\n\n\n\n\n\n\nThe routeword NF error count register reports a count of routeword NF errors for the voted routeword data. If the routeword NF error counter exceeds the value programmed in the routeword NF error threshold, an error condition is generated and flagged in the Error Counter Status register. This counter will not overflow, but will hold a value of all ones until reset. This counter is incremented if a routeword NF error occurs. Counters reset when read by software.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nError\nNumber of routeword NF consistency errors seen\n\n\n\ncount\nsince last counter read.\n\n\n\n\n\n\n\n\n\nThe Unstriper maintains a single counter for all packets dropped. The only drop conditions which can occur in the Unstriper are due to FIFO full condition or incorrect checksum results. This counter is implemented as a 32-bit counter.\n\nThis counter counts the number of packets dropped due to FIFO full conditions.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:0\nDrop_counter\nGives the number of drops. Register resets on a\n\n\n\n\nread. Writes to the register are ignored.\n\n\n\n\n\n\n\n\n\nThis counter counts the number of packets/cells dropped due to checksum failures.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:0\nDrop_counter\nGives the number of drops. Register resets on a\n\n\n\n\nread. Writes to the register are ignored.\n\n\n\n\n\n\n\n\n\nThe debug registers are intended as debug aids.\n\nThe debug select register selects which lanes of data have error information visible in the other debug registers.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:8\u2002\nUnused\n\n\n\n7:4\nQueue Select\nSelects the synchronization queue to collect statistics\n\n\n\n\non. Queue numbers follow the same convention\n\n\n\n\nused elsewhere in the Unstriper. 0-11 select the\n\n\n\n\nnumbered input interface, 12 selects the parity\n\n\n\n\ninterface.\n\n\n3:0\nCRC select\nSelects which CRC to display among the 13\n\n\n\n\nstreams. Values 0-C are valid for this field. Values\n\n\n\n\n0-11 correspond to the CRC with interface specified\n\n\n\n\nby the bit number substituted by the parity\n\n\n\n\ncalculation. Value 12 corresponds to the value\n\n\n\n\nwith no parity.\n\n\n\n\n\n\n\n\n\nThis register reads the CRC byte selects by the CRC data select register. Data is read-only. Writing to this register does not affect the CRC calculation at all.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n15:0\nCRC data\nGives the data for the CRC function.\n\n\n\n\n\n\n\n\n\nThe synch debug register is used to monitor the state of the synchronization logic. This register returns read data. Some of the fields are controlled by the Synch FIFO select register.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:24\nMin_depth\nThis register holds the minimum depth found of the\n\n\n\n\nFIFO selected by the FIFO Select Register. The\n\n\n\n\nminimum depth found since the last read of this\n\n\n\n\nregister is stored and only updated if a lower\n\n\n\n\nminimum is found or the register has just been read.\n\n\n23:16\nMax_depth\nThis register holds the maximum depth found of the\n\n\n\n\nFIFO selected by the FIFO Select Register. The\n\n\n\n\nmaximum depth found since the last read of this\n\n\n\n\nregister is stored and only updated if a higher\n\n\n\n\nmaximum is found or the register has just been read.\n\n\n15:8\u2002\n- clk_diff\nThe highest number of negative clocks corrected\n\n\n\n\nby the synchronizer logic.\n\n\n7:0\nClk_diff\nThe clock speed difference register is used as a\n\n\n\n\nrough heartbeat for the synch logic. It counts the\n\n\n\n\nnumber of clocks in the last pause due to resynch.\n\n\n\n\nA negative value is represented by a \u20181\u2019 in the MSB\n\n\n\n\nof the register.\n\n\n\n\n\n\n\n\n\nThe synch delay register controls configuration of the counters used for synchronization.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:16\nTick\nNumber of clock cycles before the master sequence\n\n\n\nLength\ncounter is incremented. The tick length controls the time\n\n\n\n\nduration which one sequence value is transmitted.\n\n\n\n\nDividing the programmed value by either 18 (OC48) or 5\n\n\n\n\n(OC192) gives the maximum number of packets which\n\n\n\n\ncan be transmitted. Due to FIFO limitations, this value\n\n\n\n\nshould be programmed to a value less than or equal\n\n\n\n\nto 1024.\n\n\n15:0\u2002\nPulse\nNumber of clock cycles that the receiver waits before\n\n\n\nDelay\nresetting the master sequence counter after receiving a\n\n\n\n\nsync pulse. This value should be set to be greater than\n\n\n\n\nthe round trip times + allowable clock drift to ensure\n\n\n\n\nthe receiver has seen data from all the transmitters.\n\n\n\n\n\n\n\n\n\nThe synchronizer status register will contain information pertaining to the status of various counts and errors in the receive synchronizer. All bits in this register are cleared on read.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n13:0\nFIFO\nA bit is set to a one to indicate a FIFO overflow con-\n\n\n\noverflow\ndition occurred.\n\n\n\n\n\n\n\n\n\nThe Unstriper provides a FIFO which stores the fabric routewords and the memory controller routeword for terminated cells.\n\nThe cell termination threshold controls the number of FIFO entries which generate an interrupt. Once the status bit is asserted, it will remain asserted until the FIFO is emptied.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:7\nUnused\n\n\n\n\u20026:0\nCount\nIf the number of fifo entries > count, the status indication\n\n\n\nvalue\nwill be set.\n\n\n\n\n\n\n\n\n\nThe egress RW read register returns the value of the current egress routeword from the FIFO. Note that the FIFO advances on the read of the Error Syndrome register, so back-to-back reads of this register will return the same data.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:24\nInput port\nGives the input port (OC48 port number) for the\n\n\n\n\ncell.\n\n\n23:0\u2002\nMem_ctrl_rw\nMemory controller connection number\n\n\n\n\n\n\n\n\n\nThe Error Syndrome register returns the value of the error state associated with the current routeword pair. Note that the FIFO advances on the read of this register, so the FIFO effectively advances all three registers to the next entry on the read of this register.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:6\u2002\nunused\n\n\n\n5:2\nFabric_id\nGives the fabric identifier of where the suspected error\n\n\n\n\noccurred. 0000-1011 indicate fabrics 0-11, 1100\n\n\n\n\nindicates the parity fabric, 1110 is reserved, and 1111\n\n\n\n\nindicates that no conclusive result was possible.\n\n\n1\nData_err\n1 indicates error seen in data for the input channel\n\n\n\n\nindicates\n\n\n0\nHdr_err\n1 indicates error seen in header for the input channel\n\n\n\n\n\n\n\n\n\nThe Transceiver Error Status register as one bit for each Transceiver Error Counter register. When one of the error counters exceeds the threshold the corresponding bit in this register is set. A bit is cleared when the corresponding counter register is read.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:14\nUnused\n\n\n\n13:0\u2002\nCounter\nBit x is set if Transceiver\n\n\n\nover\nError Counter(x) > Transceiver Error Threshold.\n\n\n\nthreshold",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:16\nUnused\n\n\n\n15:0\u2002\nThreshold\nValue that when exceeded by a Transceiver Error\n\n\n\nvalue\nCounter will cause that counter's bit in the Transceiver\n\n\n\n\nError Status register to be set.\n\n\n\n\n\n\n\n\n\nThe Transceiver Error Count Select register determines which of the 14 Gigabit Transceiver Error Count registers will be provide the value that is returned when the Transceiver Error Count register is read.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:4\u2002\nUnused\n\n\n\n3:0\nCounter\nSelects the Transceiver Error Count register that will be\n\n\n\nselect\naccessed when\n\n\n\n\n\n\n\n\n\nEach Gigabit Ethernet Transceiver has a counter that counts the number of times the status bits from that transceiver indicates that an error has occurred. When the Transceiver Error Count register is read the error count of the transceiver selected in the Transceiver Error Count Control register will be returned.",
        "Bit\nLabel\nFunction\n\n\n\n\n\n\n\n31:16\nUnused\n\n\n\n15:0\u2002\nCount\nNumber of times the status bits of the Gigabit Ethernet\n\n\n\nvalue\ntransceiver selected by the Transceiver Error Count\n\n\n\n\nControl register indicated an error since that last time this\n\n\n\n\nregister was read or reset.\n\n\n\n\n\n\n\n\n\n1. The unstriper uses 3.3 volt LVTTL signaling for all but the CLOCK125 pin\n\n2. The CLOCK125 pin uses 3.3 Volt LVDS signaling.\n\nThe following table gives the timing constraints used for timing analysis. Designs that meet these constraints should work across any respins. The columns have the following meanings:",
        "CLK\nGives the reference clock for the timing. All timing values\n\n\n\nare given in reference to the clock signal arriving at the\n\n\n\nassociated clock pin on Unstriper.\n\n\nMin_time\nThis gives the minimum amount of time between the clock\n\n\n\nsignal and the output transition. This can be used to\n\n\n\ncalculate hold time.\n\n\nMax_time\nThis gives the maximum amount of time until an output\n\n\n\nsignal is stable.\n\n\nOutput Load\nLoad used for max_time. Other loads can be used, greater\n\n\n\nloads increase time, smaller loads decrease time.\n\n\nDrive\nType of drive book.\n\n\nComments\nAny comments (primarily on the derivation of output load).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClkM\n\n\n\n\n\n\n\n\nin\nMax\nOutput\n\n\n\nPin\nTime1\nTime\nLoad\nDrive\nComments\n\n\n\n\n\n\n\nTDO\nTCK\n\n\n10 pF\n\n\n\n\n\n\n\n\n\n\nThe following table gives the input timing. The columns have the following meanings:",
        "CLK\nGives the reference clock for the timing. A value of N/A\n\n\n\neither means the signal is not speced for transition or that the\n\n\n\nsignal is not assumed to asynchronous with respect to all input\n\n\n\nclocks.\n\n\nSetup/hold\nsame thing they mean everywhere else.\n\n\nPin cap\nPin capacitance presented by the receiver or bidi.\n\n\nComments\nAny comments (primarily on the derivation of output load).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHold\n\nPin\n\n\n\nPin\nClk\nSetup\n(ns)\n5 V tol\nCap\nComments\n\n\n\n\n\nTRST\nN/A\nNA\nNA\nY\n6.8 pF\nAsync.\n\n\nRESET_L\nN/A\nNA\nNA\nY\n6.8 pF\nAsync\u2009\n\n\n\n\n\n\n\n\n\nThe chip was timed assuming the following arrival times for clocks:",
        "Supported\n\n\n\nClock\nClock\nSkew\nNotes\n\n\n\n\n\n\n\nAD_CLK\nany\nAny\nAD_CLK is asynchronous with rest of\n\n\n\n\n\nchip. Unstriper supports speeds from\n\n\n\n\n\n20 MHz to 33 MHz on AD_CLK. The\n\n\n\n\n\nspeed limit on the AD clock is primarily\n\n\n\n\n\nI/O timing related, chip internals run up to\n\n\n\n\n\n40. Any applications which desire above\n\n\n\n\n\n33 MHz should talk to the design team.",
        "Although the invention has been described in detail in the foregoing embodiments for the purpose of illustration, it is to be understood that such detail is solely for that purpose and that variations can be made therein by those skilled in the art without departing from the spirit and scope of the invention except as it may be described by the following claims."
    ],
    "citations": [
        "4908823",
        "5784369",
        "5878039",
        "6160806",
        "6359893",
        "6560229",
        "6707789"
    ],
    "us_classification": "370358",
    "international_classifications": [
        {
            "classification_level": "A",
            "section": "H",
            "classification_class": "04",
            "subclass": "L",
            "main_group": "12",
            "subgroup": "50"
        }
    ]
}