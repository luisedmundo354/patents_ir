{
    "title": "Method and system for fingerprint template matching",
    "abstract": "A method for matching templates and a system thereof. Each template includes a plurality of data chunks, each data chunk representing a minutia and comprising a location, a minutia angle and a neighborhood. The location is represented by two coordinates. In one embodiment, each coordinate and the minutia angle are quantized. The neighborhood includes positional parameters with respect to a selected minutia for a predetermined number of neighbor minutiae. In one embodiment, a neighborhood boundary is drawn around the selected minutia and neighbor minutiae are selected from the enclosed area. A reference template is compared to a measured template on a chunk-by-chunk basis. A chunk from each of the template is loaded into a random access memory (RAM). The location, minutia angle and neighborhood of the reference data chunk are compared with the location, minutia angle and neighborhood of the measured data chunk, respectively.",
    "inventors": [
        "Russo"
    ],
    "document_number": "07299360",
    "publication_date": "20071120",
    "assignees": [
        "Precise Biometrics"
    ],
    "claims": [
        {
            "claim_number": "CLM-00001",
            "preamble": "1. A fingerprint verification system, comprising:",
            "components": [
                {
                    "component": "a smart card reader including",
                    "subcomponents": [
                        "a fingerprint sensor, and",
                        "a first microprocessor generating by minutia extraction a measured template having a plurality of measured data chunks from data read by said fingerprint sensor, each measured data chunk representing a fingerprint minutia;"
                    ]
                },
                {
                    "component": "a fingerprint sensor, and",
                    "subcomponents": []
                },
                {
                    "component": "a first microprocessor generating by minutia extraction a measured template having a plurality of measured data chunks from data read by said fingerprint sensor, each measured data chunk representing a fingerprint minutia;",
                    "subcomponents": []
                },
                {
                    "component": "a smart card including",
                    "subcomponents": [
                        "a static memory storing a reference template having a plurality of reference data chunks,",
                        "a second microprocessor executing a matching algorithm for determining whether said measured template matches said reference template, and",
                        "a random access memory (RAM) storing a subset of said reference data chunks and a subset of said measured data chunks during execution of said matching algorithm; and",
                        "a communication channel between said smart card and said smart card reader,"
                    ]
                },
                {
                    "component": "a static memory storing a reference template having a plurality of reference data chunks,",
                    "subcomponents": []
                },
                {
                    "component": "a second microprocessor executing a matching algorithm for determining whether said measured template matches said reference template, and",
                    "subcomponents": []
                },
                {
                    "component": "a random access memory (RAM) storing a subset of said reference data chunks and a subset of said measured data chunks during execution of said matching algorithm; and",
                    "subcomponents": []
                },
                {
                    "component": "a communication channel between said smart card and said smart card reader,",
                    "subcomponents": []
                },
                {
                    "component": "wherein each of said measured data chunks and each of said reference data chunks comprise:",
                    "subcomponents": [
                        "a location of a minutia;",
                        "a minutia angle of said minutia; and",
                        "a neighborhood of said minutia."
                    ]
                },
                {
                    "component": "a location of a minutia;",
                    "subcomponents": []
                },
                {
                    "component": "a minutia angle of said minutia; and",
                    "subcomponents": []
                },
                {
                    "component": "a neighborhood of said minutia.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00002",
            "preamble": "2. The system of claim 1 , wherein said subset of said reference data chunks constitutes a substantially reduced version of said reference template.",
            "components": []
        },
        {
            "claim_number": "CLM-00003",
            "preamble": "3. The system of claim 1 , wherein said subset of said measured data chunks constitutes a substantially reduced version of said measured template.",
            "components": []
        },
        {
            "claim_number": "CLM-00004",
            "preamble": "4. The system of claim 1 , wherein a measured data chunk is loaded into said RAM of said smart card through said Communication channel.",
            "components": []
        },
        {
            "claim_number": "CLM-00005",
            "preamble": "5. The system of claim 1 , wherein said location comprises: a first coordinate; and a second coordinate.",
            "components": []
        },
        {
            "claim_number": "CLM-00006",
            "preamble": "6. The system of claim 5 , wherein said first coordinate is quantized.",
            "components": []
        },
        {
            "claim_number": "CLM-00007",
            "preamble": "7. The system of claim 6 , wherein said first coordinate is quantized to equal to or less than eight bits.",
            "components": []
        },
        {
            "claim_number": "CLM-00008",
            "preamble": "8. The system of claim 5 , wherein said second coordinate is quantized.",
            "components": []
        },
        {
            "claim_number": "CLM-00009",
            "preamble": "9. The system of claim 8 , wherein said second coordinate is quantized to equal to or less than eight bits.",
            "components": []
        },
        {
            "claim_number": "CLM-00010",
            "preamble": "10. The system of claim 1 , wherein said minutia angle is quantized.",
            "components": []
        },
        {
            "claim_number": "CLM-00011",
            "preamble": "11. The system of claim 10 , wherein said minutia angle is quantized to equal to or less than eight bits.",
            "components": []
        },
        {
            "claim_number": "CLM-00012",
            "preamble": "12. The system of claim 1 , wherein said neighborhood comprises positional parameters of a plurality of a predetermined number of neighbors.",
            "components": []
        },
        {
            "claim_number": "CLM-00013",
            "preamble": "13. The system of claim 12 , wherein said positional parameters comprises:",
            "components": [
                {
                    "component": "a distance between said minutia and a neighbor minutia;",
                    "subcomponents": []
                },
                {
                    "component": "a first angle between a first coordinate in a direction tangential to a ridge where said minutia is extracted and a line drawn between said minutia and said neighbor minutia; and",
                    "subcomponents": []
                },
                {
                    "component": "a second angle between said first coordinate and a second coordinate in a direction tangential to a ridge where said neighbor minutia is extracted.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00014",
            "preamble": "14. The system of claim 13 , wherein said distance is quantized.",
            "components": []
        },
        {
            "claim_number": "CLM-00015",
            "preamble": "15. The system of claim 14 , wherein said distance is quantized to equal to or less than eight bits.",
            "components": []
        },
        {
            "claim_number": "CLM-00016",
            "preamble": "16. The system of claim 13 , wherein said first angle is quantized.",
            "components": []
        },
        {
            "claim_number": "CLM-00017",
            "preamble": "17. The system of claim 16 , wherein said first angle is quantized to equal to or less than eight bits.",
            "components": []
        },
        {
            "claim_number": "CLM-00018",
            "preamble": "18. The system of claim 13 , wherein said second angle is quantized.",
            "components": []
        },
        {
            "claim_number": "CLM-00019",
            "preamble": "19. The system of claim 18 , wherein said second angle is quantized to equal to or less than eight bits.",
            "components": []
        },
        {
            "claim_number": "CLM-00020",
            "preamble": "20. The system of claim 12 , wherein said neighbors are sorted.",
            "components": []
        },
        {
            "claim_number": "CLM-00021",
            "preamble": "21. The system of claim 1 , wherein said second microprocessor is an 8-bit microprocessor.",
            "components": []
        },
        {
            "claim_number": "CLM-00022",
            "preamble": "22. The system of claim 1 , wherein said second microprocessor has a speed between approximately 1 megahertz and approximately 10 megahertz.",
            "components": []
        },
        {
            "claim_number": "CLM-00023",
            "preamble": "23. The system of claim 1 , wherein said RAM is approximately 256 kilobyte in size.",
            "components": []
        },
        {
            "claim_number": "CLM-00024",
            "preamble": "24. The system of claim 1 , wherein said reference data chunks are sorted.",
            "components": []
        },
        {
            "claim_number": "CLM-00025",
            "preamble": "25. The system of claim 1 , wherein said measured data chunks are sorted.",
            "components": []
        },
        {
            "claim_number": "CLM-00026",
            "preamble": "26. The system of claim 1 , wherein said RAM stores only one reference data chunk and only one measured data chunk during execution of said matching algorithm.",
            "components": []
        }
    ],
    "description": [
        "This application is a continuation of application Ser. No. 09/354,929, filed on Jul. 15, 1999 now U.S. Pat. No. 6,681,034.",
        "Appendix A, which is a part of the present disclosure, is a listing of software code for embodiments of components of this invention, which are described more completely below.",
        "A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever.",
        "This invention relates to fingerprint verification. More particularly, this invention relates to methods for matching fingerprint templates and structures thereof.",
        "Biometric identification is used to verify the identity of a person by digitally measuring selected features of some physical characteristic and comparing those measurements with those filed for the person in a reference database, or sometimes on a smart card carried by the person. Physical characteristics that are being used include fingerprints, voiceprints, the geometry of the hand, the pattern of blood vessels on the wrist and on the retina of the eye, the topography of the iris of the eye, facial patterns and the dynamics of writing a signature and typing on a keyboard.",
        "The fingerprint is one of the most widely used physical characteristics in biometric identification. Fingerprints are utilized as the most reliable means to identify individuals because of two outstanding characteristics; namely that they remain unchanged all through life and differ from individual to individual. Fingerprints consist of raised friction ridges of skin separated by recessed valleys of skin. Fingerprint \u201cminutiae\u201d are conventionally defined as ridge endings or ridge bifurcations where a ridge splits into two ridges.",
        "Since the matching of a fingerprint as an image can require large file capacity to store the measured and referenced features and complex computation to match measured features with reference features, fingerprint identification is carried out using the positional relationship of features or minutiae that are extracted from the fingerprint image. The minutiae representing a fingerprint image are digitized and stored in a digital memory, which may be a readonly memory, magnetic tape, or the like. A fingerprint digitized in this manner may be compared with reference fingerprints stored in the memory. For the comparison to work, the reference fingerprint and the measured fingerprint must be extracted, characterized, and digitized so that the fingerprint templates contain the same information and have the same format.",
        "One application of fingerprint identification is to use the fingerprint to unlock a smart card which often contains encrypted information. Presently, a PIN (personal identification number) is required to be entered by the user before the encrypted information can be extracted from the smart card and used. The use of a PIN has many drawbacks. For example, the accounting or card issuing organization faces significant administrative cost in handling the secret codes and the card holders have to memorize the secret codes.",
        "Some privacy laws, for example, the privacy laws in Europe, require sensitive information such as a reference fingerprint template to be stored on the smart card in a way that it cannot leave the card without first unlocking the card with a PIN. Therefore, for a fingerprint matching scheme to be practical in Europe, the fingerprint template matching algorithm must be executed by a microprocessor in the smart card. Otherwise, the smart card must be unlocked by some other mechanism, such as a PIN, before the reference fingerprint template can be read. The difficulty of executing conventional fingerprint template matching algorithm on a smart card is mainly due to the limited computational capabilities and memory of a conventional smart card. For example, a conventional smart card typically has less than 512 bytes of RAM (with 256 bytes being typical) and between 1 Kilobyte and 16 Kilobytes of memory. An 8-bit RISC (reduced instruction set computer) microprocessor has a speed between 1 MegaHertz to 10 MegaHertz which is quite slow given the magnitude of the computations required to complete a comparison between a measured fingerprint and a reference fingerprint. In effect, the hardware constraints prevent the use of fingerprint to unlock data from smart cards.",
        "In addition to hardware constraints, another important design criterion is cost. U.S. Pat. No. 4,582,985 (hereinafter, the '985 patent) entitled \u201cData Carrier\u201d, issued Apr. 15, 1986, to Bo L\u00f6fberg and hereby incorporated by reference in its entirety, describes a data carrier of a card type. According to the '985 patent, the data carrier includes a fingerprint verification device for carrying out the verification process. The verification device includes a sensor device for sensing a finger tip of the owner and obtaining the corresponding finger print line information. A specialized smart card must be used to accommodate the sensor device since a conventional smart card does not provide such accommodations. In addition, since the fingerprint template generation, storage, and comparison are done at the data carrier, the microprocessor of a conventional smart card is not adequate. Hence, a specialized smart card having a more capable processor must be used, thereby increasing cost.",
        "Therefore, what is needed are systems and fingerprint template matching algorithms that can be executed by a microprocessor with low memory and low computational capacities, thereby keeping the cost of the smart card at an acceptable level.",
        "In accordance with the present invention, a smart card verification system and a fingerprint template matching algorithm are provided. The fingerprint template matching algorithm is capable of being executed by a microprocessor with low memory and low computational capacities.",
        "In one embodiment of this invention, a reference fingerprint template and a measured fingerprint template are generated from a reference fingerprint image and a fingerprint image to be verified, respectively. Each template comprises a plurality of data chunks, each data chunk representing a minutia and comprising a location, a minutia angle and a neighborhood. In one embodiment, the location is represented by two coordinates (xj, yj), the coordinates having a center point (0,0) at the upper left hand corner. The minutia angle \u03b8j is the angle between the x-axis and a line tangential to the ridge line at the minutia. In one embodiment, each coordinate and the minutia angle are quantized to a selected number of bits. In general, the amount of quantization is a function of the available memory and the degree of accuracy desired.",
        "The neighborhood is made up of a predetermined number of neighbor minutiae which are selected for every minutia extracted from a fingerprint image. Each neighbor minutia is characterized by three positional parameters with respect to the selected minutia. The positional parameters include a distance and two angles.",
        "In one embodiment, an optional neighborhood boundary is drawn around a randomly-selected minutia. In one embodiment, if the number of neighbor minutiae within the neighborhood boundary is less than the predetermined number, all neighbor minutiae within the neighborhood boundary are selected. In another embodiment, a predetermined number of the closest neighboring minutiae are selected. In yet another embodiment, a predetermined number of neighbor minutiae giving the best spread around the randomly selected minutia are selected. In one embodiment, the minutiae having the farthest distance from each other are selected. In another embodiment, minutiae that are very close, e.g., less than approximately 10 pixels, to each other are not selected. In another embodiment, an arbitrary one of the very close minutiae is selected. In one embodiment, a quadrant is arbitrarily drawn using the randomly-selected minutia as the center point and a predetermined number of minutiae are selected from each quadrant.",
        "An x-axis is drawn in the direction of the line tangential to the ridge at the randomly selected minutia. A y-axis, perpendicular to the x-axis, is drawn. The x-axis and the y-axis intersect at the randomly-selected minutia. Hence, the randomly-selected minutia now has a position of (0,0) and is designated as the \u201ccenter minutia.\u201d A first line is drawn between the center minutia and one of its neighbor minutiae. The first line has a distance di which is one of the positional parameters representing the neighbor minutia. An angle \u03c6i between the first line and the x-axis is the second positional parameter representing the neighbor minutia. A second line is then drawn from the neighbor minutia to intersect the x-axis, in the direction of the line tangential to the ridge of neighbor minutia. The angle \u03c6i between the x-axis and the second line is the third positional parameter representing the neighbor minutia.",
        "In one embodiment, each positional parameter is quantized to a selected number of bits. For example, each angle \u03c6i and \u03c6i is quantized to six bits and the distance di is quantized to five bits.",
        "A data chunk from each fingerprint template is loaded into a random access memory (RAM) to be compared. In one embodiment, the data chunks are sorted, but such sorting is optional. In one embodiment, the data chunks are sorted in accordance to their x-coordinates. In another embodiment, the data chunks are sorted in accordance to their y-coordinates. In one embodiment, the data chunks in the reference template are sorted. In another embodiment, the data chunks in the measured template are sorted. In yet another embodiment, both the measured template and the reference template are sorted.",
        "Each of the characterization parameters, i.e., location, minutia angle, and neighborhood, of the measured data chunk to be compared is compared with its respective counterpart in the reference data chunk. The order of the comparison may be varied. For example, the location parameter in the x-coordinates of the.measured minutiae are compared first to the corresponding x-coordinates of the reference minutiae. In another embodiment, location parameter in the y-coordinates of the measured minutiae are compared first to the corresponding y-coordinates of the reference minutiae. In one embodiment, the comparison is straight subtraction. If the difference for a parameter pair is equal to or is less than a respective predetermined tolerance, the parameters match. If all of the parameters match, the data chunks match. On the other hand, if one of the parameters fail to match, the data chunks do not match and the next set of data chunks are compared.",
        "The data chunk comparison begins with the first reference data chunk and the first measured data chunk and terminates if the predetermined number of data chunk matches have been reached (i.e., the templates match) or if all of the data chunk combinations have been compared. In one embodiment, if the first reference data chunk and the first measured data chunk do not match, the next measured data chunk is loaded into the RAM to be compared with the first reference data chunk. The process continues until all the measured data chunks in the measured fingerprint template have been compared. The next reference data chunk and the first measured data chunk are then loaded into the RAM to be compared. The process continues until all the reference data chunks have been compared. In another embodiment, if the first reference data chunk does not match the first measured data chunk, the second reference data chunk is loaded into the RAM to be compared with the first measured data chunk. The process continues until all of the reference chunks have been compared. The second measured data chunk and the first reference data chunk are then loaded into the RAM to be compared. The process continues until all of the measured data chunks have been compared.",
        "In one embodiment, where the data chunks are sorted, the comparison between a reference data chunk and the remaining uncompared measured data chunks is terminated if the difference between the reference data chunk and the measured data chunk exceeds the tolerance. In one embodiment, the next comparison starts with the next reference data chunk and the first matching measured data chunk.",
        "In the alternative embodiment, the comparison between a measured data chunk and the remaining uncompared reference data chunks is terminated if the difference between the measured data chunk and the reference data chunk exceeds the tolerance. In one embodiment, the next comparison starts with the next reference data chunk and the first matching measured data chunk.",
        "In one embodiment, the neighbor minutiae in a neighborhood are sorted by distance di. The neighborhood comparison starts with the first neighbor in the reference neighborhood and the first neighbor in the measured neighborhood and terminates when the predetermined neighbor matches are reached (i.e., the neighborhoods match) or when all of the neighbor combinations have been compared. Each reference's positional parameter is compared with its corresponding measured positional parameter. In one embodiment, the comparison is done with straight subtraction. If the difference meets a predetermined tolerance, the parameters match. If all of the positional parameters in the neighbor minutia match, the neighbor minutiae match. If one of the positional parameters does not match, the neighbor minutiae do not match.",
        "In one embodiment, the reference fingerprint template is stored in a static memory in a smart card and the fingerprint template matching algorithm is executed in a microprocessor in the smart card. In one embodiment, the reference fingerprint template is generated and stored at a smart card reader.",
        "The above-described fingerprint template matching algorithm may be executed by a microprocessor with low memory and low computational capacities because the matching algorithm does not require.computational intensive operations and does not require comparisons that exceeds 8 bits.",
        "FIG. 1 shows a smart card system having a smart card reader for reading a smart card.",
        "FIG. 2A shows a reference fingerprint template divided into data chunks.",
        "FIG. 2B shows a measured-fingerprint template to be compared divided into data chunks.",
        "FIG. 3 shows how a minutia is represented.",
        "FIG. 4A shows a circular neighborhood boundary.",
        "FIG. 4B shows a square neighborhood boundary.",
        "FIG. 4C shows a method of neighbor selection. FIG. 4D shows an angle to be represented in complex domain.",
        "FIG. 4E shows an embodiment of a method of neighbor selection.",
        "FIG. 5 shows construction of positional parameters for a neighbor minutia.",
        "FIG. 6 shows two neighborhoods with errors between them.",
        "FIG. 7A shows a reference data chunk comprising location, minutia angle and neighborhood parameters.",
        "FIG. 7B shows a measured data chunk comprising location, minutia angle and neighborhood parameters.",
        "FIG. 7C shows a reference neighborhood having various positional parameters.",
        "FIG. 7D shows a measured neighborhood having various positional parameters.",
        "FIG. 8A shows a flowchart of a method of template comparison.",
        "FIG. 8B shows a flowchart of another method of template comparison.",
        "FIG. 9A shows a flowchart of a method of detailed data chunk comparison.",
        "FIG. 9B shows a flowchart of a method of detailed data chunk comparison.",
        "FIG. 9C shows a flowchart of a method of detailed data chunk comparison.",
        "FIG. 10 shows a flowchart of a method of detailed neighborhood comparison.",
        "FIG. 11A shows a flowchart of a method of detailed neighbor comparison.",
        "FIG. 11B shows a flowchart of a method of detailed neighbor comparison, with the neighbors sorted.",
        "FIG. 12 shows a flowchart of a method of fingerprint template comparison in a multiple user situation.",
        "Use of the same reference numbers in different figures indicates similar or like elements.",
        "The following description is meant to be illustrative only and not limiting. Other embodiments of this invention will be obvious in view of the following description to those skilled in the semiconductor processing arts.",
        "FIG. 1 shows one implementation of the present invention. FIG. 1 shows a smart card reader system having a smart card 100 and a smart card reader 110. Smart card 100 comprises a static memory 102 for storing a reference fingerprint template, a microprocessor 104 for executing a fingerprint template matching algorithm, and RAM (random access memory) 106. Smart card reader 110 has a RAM 112 for storing a measured fingerprint template, a microprocessor 114, and a fingerprint sensor 116. In one embodiment, fingerprint sensor 116 is a capacitive fingerprint sensor of the kind described in U.S. patent application Ser. No. 08/735,100 filed Dec. 15, 1995, and assigned to the same assignee as the present invention, which is hereby incorporated by reference in its entirety. Smart card reader 110 can be a stand-alone unit at a point-of-sale or can be embedded in an ATM, for example.",
        "When a user wishes to gain access to smart card 100, he/she inserts smart card 100 into smart card reader 110. Smart card reader 110 then prompts the user to place his/her finger on fingerprint sensor 116. The prompt can be either visual or audible. Microprocessor 114 on smart card reader 110 then digitizes the electrical signal measured at fingerprint sensor 116, creates a fingerprint image, extracts minutiae from the fingerprint image, characterizes each minutia, creates a neighborhood for each minutia, and generates a measured fingerprint template from the characterization parameters and the neighborhood. The measured fingerprint template is then stored in RAM 112. Template construction is discussed in detail below.",
        "Minutiae can be extracted from a fingerprint using any known methods. For example, ridge skeletonization technique can be used. This technique uses an iterative process to thin a ridge line by discarding pixels that do not affect the continuity of the ridge line until a single pixel line is remaining, the end point of which is the minutia. Other types of minutia extraction technique are described in, for example, U.S. Pat. No. 4,646,352 entitled \u201cMethod and Device for Matching Fingerprints with Precise Minutia Pairs Selected From Coarse Pairs\u201d issued Feb. 24, 1987 to Asai et al. and U.S. Pat. No. 4,135,147 entitled \u201cMinutiae Pattern Matcher\u201d issued Jan. 16, 1979 to Riganati et al. The minutia extraction technique is not described in detail in this application because it is not part of the invention.",
        "Smart card reader 110 then sends the measured fingerprint template to smart card 100 through a communication channel 120 at a selected speed, typically 9.6 Kilobits/second, or 9600 baud. Microprocessor 104 in smart card 100 receives the measured fingerprint template from smart card reader 110, reads the reference fingerprint template from static memory 102 into RAM 106 chunk by chunk as needed, and executes a fingerprint template matching algorithm to compare the two fingerprint templates.",
        "A collection of data chunks representing a fingerprint, either reference or measured is referred to herein as a fingerprint template. A data chunk consists information of an extracted minutia it corresponds to, including location, minutia angle and neighborhood, which will be discussed below. FIGS. 2A, 2B, 3, 4A-4E, 5, 6 and 7A-7D show in detail how a fingerprint template is constructed. FIG. 2A shows a reference fingerprint template 200 having a plurality of data chunks 201, 202, 203, etc. Typically, reference fingerprint template 200 comprises 50 chunks, i.e., typically, 50 minutiae are extracted from a fingerprint image. In one embodiment, the minimum number of minutiae required is 10. The minimum number of minutiae is generally determined by the required matching accuracy. In one embodiment, the maximum number of minutiae allowed is 128. Number 128 is chosen as the maximum number of minutiae allowed because with a typical number of 50, 128 gives a sufficient range of the number of minutiae that may be extracted from a fingerprint image. Of course, the minimum and the maximum numbers of minutiae extracted may be modified to suit a particular application. Reference fingerprint template 200 is stored, for example, in static memory 102 on smart card 100.",
        "FIG. 2B shows a measured fingerprint template 210 having a plurality of data chunks 211, 212, 213, etc. Similarly, measured fingerprint template 210 typically comprises 50 data chunks. Measured fingerprint template 210 is generated, for example, by smart card reader 110 and is stored in RAM 112 in smart card reader 110. The number of data chunks extracted from a measured fingerprint may be different from the number of data chunks extracted from a reference fingerprint due to possible false minutiae. In addition, the number of data chunks extracted from a measured fingerprint may be different from the number of data chunks extracted from a reference fingerprint because only a partial fingerprint is read. However, a match can nevertheless be had if the number of fingerprint data chunk matches satisfies a predetermined number of fingerprint data chunk matches. Therefore, the number of fingerprint data chunks in the measured fingerprint template does not need to be the same as the number of fingerprint data chunks in the reference fingerprint template.",
        "In one embodiment, all the data chunks in both reference fingerprint template 200 and measured fingerprint template 210 contain the same number of bits. A data chunk is constructed for each and every minutia extracted from a fingerprint image. Therefore, the number of data chunks making up each fingerprint template is equal to the number of minutiae extracted from a fingerprint image. For example, if eighty minutiae are extracted from a fingerprint image, the fingerprint template will contain eighty data chunks.",
        "FIG. 3 shows how each minutia is represented. An x-axis and a y-axis are constructed so that the point (0,0) is at the upper left hand corner of a fingerprint image. The x-axis and the y-axis are drawn regardless of the rotation or the translation of the fingerprint, as will be discussed later. Each minutia in a fingerprint image is characterized by location (xj, yj) and a minutia angle \u03b8j, where j is the number of minutiae extracted from a fingerprint image. Location (xj, yj) is the location of minutia j with respect to x- and y-axis. Minutia angle \u03b8j is the angle between the x-axis and a line tangential to a ridge 301 where minutia j is extracted. Of importance, the minutiae of both the reference fingerprint and the measured fingerprint must contain the same characterization parameters.",
        "A neighborhood NHj is constructed for each minutia j, as described below. FIGS. 4A-4E illustrate various ways of selecting neighbor minutiae in constructing a neighborhood NHj for minutia j. A neighborhood is constructed for each and every minutia extracted from a fingerprint image. In one embodiment, a neighborhood boundary is drawn around minutia j. For example, a circle 300 of a fixed radius r, e.g., 90 pixels, is drawn using minutia j as the center point, as shown in FIG. 4A, to provide a neighborhood boundary. In an alternative embodiment, a box 310, representing the neighborhood boundary, is drawn using minutia j as the center point, as shown in FIG. 4B. Of course, any predetermined neighborhood boundary of any shape or size can be drawn.",
        "A predetermined number of neighbor minutiae are selected from the enclosed area. In one embodiment, fifteen (15) minutiae (excluding minutia j) within the neighborhood boundary are selected as the neighbor minutiae for neighborhood NHj. If the enclosed area contains less than the predetermined number of neighbor minutiae, all of the neighbor minutiae contained in the enclosed area are selected. It is noted that neighborhood NHj contains multiple neighbor minutiae Nl-Ni where i is a predetermined number, so that there is enough information to make the neighborhood NHj unique enough to meet the accuracy requirement. The number of the neighbors, in general, depends on the uniqueness of the neighborhood NHj desired. For example, if only four neighbors Nl-N4 are selected for a neighborhood, the probability of having equivalent or matching neighborhoods is much higher than the corresponding probability associated with a neighborhood of fifteen neighbors. Similarly, a neighborhood having thirty neighbors would have a lower probability of being equivalent to other neighborhoods. The uniqueness of the neighborhood determines how often a good fingerprint is rejected (i.e., false rejection rate) and how often a bad fingerprint is accepted (i.e., false acceptance rate). The number of the neighbor minutiae also depends on the acceptable computational complexity or speed that can be satisfactorily performed by a microprocessor.",
        "In one embodiment, the neighbor minutiae are selected such as to maximize the spread around the center point, i.e., minutia j. Referring to FIG. 4C, an x-axis is drawn in the direction of the line tangential to a ridge line at minutia j. A line is drawn from minutia j to a minutia Nl, forming an angle \u03c3l, between the x-axis and the line. Similarly, a line is drawn from minutia j to each of the remaining minutiae within the enclosed area, each forming an angle \u03c3k with the x-axis, where k is the number of the minutiae within the enclosed area. A mean is calculated from all the angles \u03c3k.",
        "In one embodiment, the mean is calculated in a complex domain since mean calculation in a degree domain would be more complicated due to the cyclical nature of the angles. A complex number C can be described as a sum of its real and imaginary parts a and b, respectively, i.e., C=a+ib where i is the square root of \u22121.",
        "Referring to FIG. 4D, angles can be expressed in terms of complex numbers by the following equality:\n\nCk=cos(\u03c3k)\u2212i sin (\u03c3k)\n\nwhere\n\n\u03c3k=tan\u22121 (bk/ak)\n\nThus, the real part of angle \u03c3k is ak=cos (\u03c3k) and the imaginary part of angle \u03c3k is bk =sin (\u03c3k). To get an average of all the angles \u03c3k, each angle \u03c3k is converted to its complex equivalent. The real part \u03c3k and the imaginary part bk are then averaged separately. The averaged real part aavg and the averaged imaginary part bavg are then converted back to a real number representation \u03c3avg, for example,",
        "a\n      avg\n    \n    =\n    \n      \n        \n          \u2211\n          k\n        \n        \u2062\n        \n          \n        \n        \u2062\n        \n          (\n          \n            a\n            k\n          \n          )\n        \n      \n      k\n    \n  \n  ,\n  \n    \n  \n  \u2062\n  \n    \n      b\n      avg\n    \n    =\n    \n      \n        \n          \u2211\n          k\n        \n        \u2062\n        \n          \n        \n        \u2062\n        \n          (\n          \n            b\n            k\n          \n          )\n        \n      \n      k\n    \n  \n  ,\n\n\n\n\nand\n\n\u03c3avg=tan\u22121(bavg/aavg).",
        "In one embodiment, each angle \u03c3k is examined to determine how close it is to the average angle \u03c3avg by subtracting angle \u03c3k from average angle \u03c3avg to get a difference \u03c3kdiff. A predetermined number of minutiae that have the largest difference \u03c3kdiff are selected so that the entire neighborhood has maximum standard angular deviation. It is noted that if there is a cluster of minutiae such as cluster 301 shown in FIG. 4C, the average would be closer to cluster 301. Thus the minutiae that are within cluster 301 would be closer to the mean. In one embodiment, if the number of minutiae within the boundary is more than the predetermined number of neighbor minutiae, the minutiae within cluster 301 would not be selected. If one or more minutiae must be selected from cluster 301 to meet the predetermined number of neighbor minutiae, the minutiae are selected randomly. In other words, the minutiae within cluster 301 are less likely to be selected than the minutiae outside of cluster 301.",
        "In one embodiment, if multiple minutiae, such as minutiae N5 and N6, have the same angles, the distances between minutia N5 and minutia j and between minutia N6 and minutia j are used for a tie breaker, e.g., the shorter the distance, the more likely the minutia would be selected. In another embodiment, if a minutia, i.e., minutia N3, is too close to minutia j, e.g., 10 pixels, the minutia is not selected. In yet another embodiment, the neighbor minutiae that are furthest away (in distance) from each other are selected. In one embodiment, if two or more neighbor minutiae are very close to each other, e.g., 10 pixels, such as neighbor minutia N5 and neighbor minutia N7, either both neighbor minutiae N5 and N7 are eliminated or one of neighbor minutiae N5 and N7 is arbitrarily selected.",
        "The neighborhood boundary is optional in selecting neighbor minutiae for a neighborhood. For example, the neighbor minutiae are selected such as to maximize the spread around the center point, i.e., minutia j, as described above. However, in this embodiment, all of the minutiae extracted from the fingerprint are used to calculate the mean. All the other embodiments described above are also applicable to neighbor minutiae selection without a boundary. In an additional embodiment, a quadrant is arbitrarily drawn with minutia j as the center point and a predetermined number of neighbor minutiae are then selected from each quadrant, as shown in FIG. 4E. In general, any neighbor minutiae extraction method may be used to extract the predetermined number i of neighbor minutiae for constructing a neighborhood NHj.",
        "After the neighbor minutiae are selected, a neighborhood NHj is constructed by deriving three positional parameters for each neighbor minutia. The positional parameters are derived in reference to minutia j. These positional parameters include a distance di and two angles \u03c6i and \u03a6i, where i is the number of neighbor minutiae.",
        "FIG. 5 shows how the positional parameters are derived. An x-axis is drawn in the direction of the line tangential to a ridge line at minutia j. A y-axis perpendicular to the x-axis is then drawn, intersecting the x-axis at minutia j. Hence, minutia j has a position of (0,0) and will be designated as the \u201ccenter minutia N0.\u201d A line 500 is drawn from center minutia N0 to a neighbor minutia Ni. Line 500 has a distance di. An angle \u03c6i is created between the x-axis and line 500. Another line 501 is drawn from neighbor Ni in the direction of a line tangential to a ridge line for neighbor minutia Ni to intersect and extend through the x-axis. The angle between the extended line 501 and the x-axis is angle \u03a6i. Hence, neighbor minutia Ni may be represented by (di, \u03c6i, \u03a6i). Similarly, neighbor minutia N1 is at a distance d1 from center minutia N0. An angle \u03c61 is created between line 502 and the x-axis. Angle \u03a61 is created between line 503 and the x-axis. Neighbor minutia N2 is at a distance d2 from center minutia N0. An angle \u03c62 is created between line 504 and the x-axis. An angle \u03a62 is created between line 505 and the x-axis. The process is repeated for all i neighbor minutiae of center minutia N0. Hence, for a neighborhood having 15 neighbors (i.e., i=15) each of the 15 neighbors N1, N2, N3, . . . , N15 is represented by (di, \u03c6i, \u03a6i) Importantly, distance di and angles \u03c6i and \u03a6i are independent of any rotation or translation of a fingerprint image because these are relative positions with respect to center minutia N0. Hence, when a fingerprint image is rotated or translated, all the minutiae associated with that center minutia N0 are translated and rotated in the same fashion and amount and their relative positions with respect to the center minutia N0 remain the same.",
        "In one embodiment, each of the parameters di, \u03c6i, and \u03a6i are quantized to a selected number of bits. Quantization allows the reduction of the number of bits to represent a value. More specifically, during quantization, all the numbers that fall between two boundary values are discretized to a quantization value between the boundary numbers.",
        "There are several approaches to derive the quantization value. In linear quantization, a quantization value can be derived by, e.g., a practical approach or a centroid approach. In the practical approach, the quantization value can be calculated by rounding the quotient of an equation, e.g., x/N, where x is the unquantized value and N is the quantization interval, to the closest integer number. For example, if the unquantized value is 5 and the quantization interval is 2, the quantization value is obtained by rounding 5/2=2.5, or 3. Similarly, if the unquantized value is 5 and the quantization interval is 4, then quantization value is obtained by rounding 5/4=1.25 or 1. In a centroid approach, the quantization value is computed as",
        "C\n    =\n    \n      \n        \n          \u222b\n          i\n          j\n        \n        \u2062\n        \n          \n            xp\n            \u2061\n            \n              (\n              x\n              )\n            \n          \n          \u2062\n          \n            \n          \n          \u2062\n          \n            \u2146\n            x\n          \n        \n      \n      \n        \n          \u222b\n          i\n          j\n        \n        \u2062\n        \n          \n            p\n            \u2061\n            \n              (\n              x\n              )\n            \n          \n          \u2062\n          \n            \n          \n          \u2062\n          \n            \u2146\n            x\n          \n        \n      \n    \n  \n  ,\n\n\n\n\nwhere C is the quantization value; i and j are the boundary numbers of the interval to be quantized; and p is the probability of occurrence of each number x.",
        "In non-linear quantization, a look-up table may be created to specify the quantization value for each unquantized value. For example, the lookup table may specify for unquantized values from 0 to 1, the quantization value is 1; for unquantized valued from 1 to 3, the quantization value is 2; for unquantized values from 3 to 6, the quantization value is 5; and so on. Non-linear quantization has the advantage of setting the quantization value in accordance to the errors associated with each minutia. For example, for a given minutia, the closer the-neighbor minutia is to the given minutia, the smaller the error. Similarly, the further the neighbor minutia, the larger the error. Therefore, for neighbor minutiae closer to the given minutia, the parameters associated with the neighbor minutia needs to be quantized more finely than the neighbor minutiae that are further away.",
        "Although any amount of quantization may be used, the amount of quantization depends on the preciseness of the match desired and the memory space available. As is well known in the art, the more the quantization, the less the preciseness of the representation and the less the storage space is required. For example, for a set of unquantized values 1 through 10, 4 bits are required to represent each number. If the quantization interval is 2, then the largest quantization value needs to be represented is 10/2 or 5. Hence, all 10 numbers can be represented by 3 bits, requiring less storage space. Similarly, if the quantization interval is 5, the largest quantization value needs to be represented.is 10/5 or 2. Hence, unquantized values 1 through 10 can now be represented by 2 bits, requiring even less storage space. However, the largest error in the first example would be 1 and the largest error in the second example would be 2.5. Hence, the more the quantization, the less the storage requirement and the larger the error.",
        "In one embodiment, distance di is quantized to five bits. In another embodiment, angles \u03c6i and \u03a6i are quantized to six bits each.",
        "FIG. 6 illustrates two neighborhoods with slight errors, both rotational and translational. Reference neighborhood 510 is constructed with a center minutia N0 and two neighbor minutiae N1 and N2. Measured neighborhood 512 is constructed with a center minutia N0\u2032 and two neighbor minutiae N1\u2032 and N2\u2032. As can be seen, reference neighborhood 510 and measured neighborhood 512 show some resemblance, i.e., neighbor minutiae N1 and N2 and N1\u2032 and N2\u2032, respectively, have similar positional relationships with respect to their center minutiae N0 and N0\u2032, respectively. However, there are errors between the two neighborhoods. For example, there are slight differences in the distances as well as the angles. The slight differences may be due to the fact that a finger has a fluid surface, thus the surface of the finger stretches and varies under different conditions. Hence, these two slightly varied neighborhoods may be the fingerprint from the same finger, but created at different times. The fingerprint matching algorithm, therefore, must take these slight variations into account because if a perfect match is required, the numerous erroneous rejections will render fingerprint identification impractical.",
        "Because matching tolerances must be accepted, the errors caused by a certain amount of quantization becomes unimportant in the resulting accuracy of the comparison. For example, if the tolerance of distance di is set to 1 and the maximum error caused by quantization of distance di is also 1, if both the reference distance and the measured distance falls into the same quanta, the distances match even though the actual distances may be different. The acceptable tolerance, therefore, determines how much quantization can be done for each parameter.",
        "Another advantage for quantization is to increase the data transmission speed because the size of the data packets becomes smaller after quantization. In one embodiment, the quantized values are compressed using well-known compression method such as, but not limited to, run-length encoding or L-Z-W (Lemtel-Ziv-Welch) compression. In the run-length encoding, for example, if there are five number zero in a row, instead of storing the numbers as \u201c0 0 0 0 0,\u201d the numbers are stored as \u201c5 0.\u201d In the L-Z-W compression, a dictionary of frequently repeated groups of (8-bit) characters is built on a per-file basis in order to represents frequent character-strings as shorter bit patterns. Hence, compression allows the data to be represented by fewer bits, thus allowing the data transmission to be faster and data storage to be smaller. In one embodiment, the compressed values are transmitted from smart card reader 110 into smart card 100 and are decompressed at smart card 100.",
        "In one embodiment, the location information, i.e., (xj, yj) and the minutia angle \u03b8j are quantized to a selected number of bits. For example, each of the position measurements xj and yj is quantized to four bits and the minutia angle \u03b8j is quantized to six bits.",
        "The size of a data chunk is determined by the size of the parameters representing the location of the minutia, the minutia angle, and its neighborhood. In one embodiment, each data chunk in the fingerprint template is 34 bytes in size. In this embodiment, the fingerprint template is made of 1-byte location information (i.e., two 4-bit measurements xj and yj), 6-bit minutia angle \u03b8j information, and fifteen 17-bit (5 bits for di, 6 bits each for angles \u03c6i and \u03a6i) neighborhood information.",
        "As will be seen later, the fingerprint template matching algorithm compares the fingerprint templates on a chunk-by-chunk basis. Hence, the fingerprint template matching algorithm requires RAM 106 to be of a size large enough to store at least two data chunks, e.g., 68 bytes of data. In a conventional smart card where the typical RAM is 256 bytes in size, no additional memory is required because the required memory in accordance with this invention is within, in fact, well under, the memory confinement of a conventional smart card.",
        "FIG. 7A shows reference data chunk 201 of reference fingerprint template 200 in detail. Reference data chunk 201 includes three parameters: location 702, minutia angle 704, and neighborhood 706. Location 702 includes x- and y- coordinates. Neighborhood 706, in one embodiment, includes 15 neighbor minutiae N1 through N15. Each neighbor N1 through N15, further includes positional parameters such as distance di between the center minutia N0 and the neighbor minutia Ni and two related angles \u03c6i, \u03a6i, where i is 1 through 15, as shown in FIG. 7C.",
        "Similarly, FIG. 7B shows data chunk 211 of measured fingerprint template 210 in detail. Measured data chunk 211 includes three parameters: location 752, minutia angle 754, and neighborhood 756. Location 752 includes x- and y-coordinates xj\u2032 and yj\u2032. Neighborhood 756, in one embodiment, includes 15 neighbors Nl\u2032 through N15\u2032. Each neighbor N1\u2032 through N15\u2032 further includes positional parameters such as distance di\u2032 between the center minutia N0\u2032 and a neighbor Ni\u2032 and two related angles \u03c6i\u2032, \u03a6i\u2032, where i is 1 through 15, as shown in FIG. 7D. Although FIGS. 7A and 7B show the same number of neighbors in reference fingerprint data chunk 201 and measured fingerprint data chunk 211, it is not necessary because a neighborhood match may be found if the number of neighbor minutia matches satisfies the predetermined number of neighbor minutia matches. For example, for a certain neighborhood boundary drawn, the enclosed area at the reference fingerprint contains enough minutiae to select the predetermined number of neighbor minutiae, e.g., 15 minutiae. However, the enclosed area at the measured fingerprint only contains less than the predetermined number of neighbor minutiae, e.g., 12 minutiae. If the predetermined neighbor minutia match is 7 and there are 7 matches between the measured neighbor minutiae and the reference neighbor minutiae, there is a match between the reference neighborhood and the measured neighborhood even though neighborhood 706 contains different number of neighbors from neighborhood 756.",
        "FIG. 8A illustrates the fingerprint template matching process in a smart card application. It is noted that although a fingerprint template matching algorithm is described with respect to a smart card and a smart card reader, the fingerprint template matching algorithm described hereinafter can also be executed by, for example, a personal computer, a microprocessor system, or a palm computer.",
        "The template matching process starts with step 600. In one embodiment, the reference data chunks and the measured data chunks are sorted (step 601), but the sorting is not required. In one embodiment, the data chunks are sorted according to its location information which is represented by the x- and y-coordinates. For example, the data chunks are sorted according to increasing x-coordinate xj followed by increasing y-coordinate yj. Of course, any sorting technique can be used to sort the data chunks. In general, minutia angle \u03b8j is not used for sorting due to the cyclical nature of angle measurements. In one embodiment, either the reference data chunks or the measured data chunks are sorted. In another embodiment, both the reference data chunks and the measured data chunks are sorted. The data chunks are sorted for efficiency purpose, as will be explained below.",
        "Because the fingerprint templates are compared on a chunk-by-chunk basis and the fingerprint templates are serialized, no random access to the fingerprint templates is needed. In other words, once a data chunk has been used, that data chunk is discarded from RAM 106 and a new data chunk is read in. This allows the storage of only one data chunk from each template in RAN 106 during the comparison process.",
        "The first data chunk of measured fingerprint template 210, e.g., measured chunk 211, is loaded from, for example, RAM 112 in smart card reader 110 into RAM 106 (step 602) through communication channel 120 (also refer to FIG. 1). Also in step 602, the first data chunk of reference fingerprint template 200, e.g., reference chunk 201, is loaded from static memory 102 into RAM 106 of smart card 100. Microprocessor 104 compares the two data chunks, i.e. measured chunk 211 and reference chunk 201 in RAM 106 (step 604). How the data chunks are compared in step 604 is discussed in detail later with reference to FIGS. 9A, 9B and 9C.",
        "If the two fingerprint template data chunks, e.g., reference chunk 201 and measured chunk 211, match (step 606), a counter is incremented in step 608. If the number of fingerprint data chunk matches is equal to or greater than a predetermined number (step 610), measured fingerprint template 210 is considered to match reference fingerprint template 200 (step 612) and the fingerprint template matching process terminates in step 614. In one embodiment, more than four data chunk matches is considered a match.",
        "If the two fingerprint template data chunks, e.g., reference chunk 201 and measured chunk 211, do not match (step 606) or if the number of data chunk matches is less than the predetermined number (step 610), it is determined whether the measured chunk used for the comparison, e.g., measured chunk 211, is the last measured chunk in measured fingerprint template 200 (step 616).",
        "If the measured chunk, e.g. measured chunk 211, is not the last measured chunk in measured fingerprint template 210, the next measured chunk, e.g., measured chunk 212, in measured fingerprint template 210 is loaded into RAM 106 from RAM 112 via communication channel 120 (step 618). The newly loaded measured chunk, e.g., measured chunk 212, is compared with the reference chunk in RAM 106, e.g., reference chunk 201 (step 604). The process continues until all measured chunks in measured fingerprint template 210 have been compared or until a predetermined number of data chunk matches have been found.",
        "If the measured chunk, e.g., measured chunk 201, is the last reference chunk in measured fingerprint template 210, then it is determined whether the reference chunk in RAM 106 used for comparison, e.g., reference chunk 201, is the last data chunk in reference fingerprint template 210 (step 620).",
        "If the reference chunk, e.g., reference chunk 201, is not the last reference chunk in reference fingerprint template 200, the next reference chunk in reference fingerprint template 200, e.g., reference chunk 202, is loaded, for example, from static memory 102 into RAM 106 (step 622). Also in step 622, the first measured chunk in fingerprint template 210, e.g., measured chunk 211, is loaded into RAM 106. The newly loaded reference chunk, e.g., reference chunk 202, and first measured chunk, e.g., measured chunk 211, are then compared in step 604. The process is continued until all reference chunks in reference fingerprint template 200 are compared or until the number of data chunk matches exceeds the predetermined number.",
        "If the reference chunk, e.g., reference chunk 201, is the last reference chunk in reference fingerprint template 200, reference fingerprint template 200 and measured fingerprint template 210 do not match (step 624) and the fingerprint template matching process terminates in step 614.",
        "Alternatively, the fingerprint template matching process can be carried out in accordance with FIG. 8B. In FIG. 8B, the optional sorting is eliminated; the reference chunks are rotated first; the measured chunks are then rotated. In particular, the fingerprint template matching process starts at step 650. The first data chunk of measured fingerprint template 210, e.g., measured chunk 211, is loaded from smart card reader 110 into RAM 106 (step 652) through communication channel 120. Also in step 652, the first data chunk of reference fingerprint template 200, e.g., reference chunk 201, is loaded from static memory 102 into RAM 106 of smart card 100. Microprocessor 104 compares the two fingerprint template data chunks, e.g., measured chunk 211 and reference chunk 201 in RAM 106 (step 654). How the data chunks are compared in step 654 is discussed in detail below with reference to FIG. 9C.",
        "If the two data chunks, e.g., chunks 201 and 211, match (step 656), a counter is incremented in step 658. If the number of data chunk matches is equal to or is greater than a predetermined number (step 660), measured fingerprint template 210 matches reference fingerprint template 200 (step 662) and the process ends in step 664.",
        "On the other hand, if the two data chunks, e.g., data chunks 201 and 211 do not match (step 656) or if the number of matches of the data chunks is less than the predetermined number (step 660), it is determined whether the measured chunk used for comparison, e.g., reference chunk 201, is the last reference chunk in reference fingerprint template 20G (step 666).",
        "If the reference chunk, e.g., reference chunk 201, is not the last data chunk in reference fingerprint template 200, the next reference chunk, e.g., reference chunk 202, in reference fingerprint template 200 is loaded from static memory 102 into RAM 106 (step 668). The newly loaded reference chunk, e.g., reference chunk 202, is compared with the measured chunk in RAM 106, e.g., measured chunk 211, in step 654. The process continues.",
        "If the reference chunk, e.g., reference chunk 201, is the last reference chunk in reference fingerprint template 200, it is determined whether the measured chunk in RAM 106 used for comparison, e.g., measured chunk 211, is the last measured chunk in measured fingerprint template 210 (step 670).",
        "If the measured chunk, e.g., measured chunk 211, is not the last data chunk in measured fingerprint template 210, the next measured chunk in measured fingerprint template 210, e.g., measured chunk 212, is loaded from RAM 112 into RAM 106 of smart card 100 via communication channel 120 (step 672). The first reference chunk in fingerprint template 200, e.g., reference chunk 201, is also loaded into RAM 106 (step 672). The newly loaded measured chunk, e.g., measured chunk 212, and the first reference chunk, e.g., reference chunk 201, are then compared (step 654).",
        "If the measured chunk, e.g., measured chunk 211, is the last measured chunk in measured fingerprint template 210, measured fingerprint template 210 and reference fingerprint template 200 do not match (step 674) and the fingerprint template matching process terminates at step 664.",
        "FIG. 9A illustrates a flowchart of step 604 of how the fingerprint template data chunks are compared in detail. A reference chunk includes a positional parameter (xj, yj) where xj is the x-coordinate and yj is the y-coordinate of a reference minutia. A measured chunk includes a positional parameter of (xj\u2032, yj\u2032) where xj\u2032 is the x-coordinate and yj\u2032 is the y-coordinate of a measured minutia. In this embodiment, the measured data chunks are sorted in accordance with x-coordinates xj followed by y-coordinates yj. In one embodiment, the x-coordinates are compared by subtracting measured x-coordinate xj\u2032 from reference x-coordinate xj, i.e. xj\u2212xj\u2032=xjdiff (step 850). If the absolute value of difference xjdiff is greater than the predetermined tolerance xjtolerance (step 852), then it is determined whether the raw difference xjdiff is less than the predetermined tolerance xjtolerance (step 868). If difference xjdiff is less than xjtolerance, the rest of the measured data chunks will not be compared against the reference data chunk and it is determined whether the reference chunk used is the last reference chunk (step 620 in FIG. 8A) and the process continues. If the difference xjdiff is greater than xjtolerance, the chunks do not match (step 872) and the process continues at step 606 (FIG. 8A).",
        "If the absolute value of the difference xjdiff is less than or equal to a predetermined tolerance xjtolerance (step 852), i.e., the x-coordinates match, the y-coordinates are compared. Measured y-coordinate yj\u2032 is subtracted from reference y-coordinate yj, i.e. yj\u2212yj\u2032=yjdiff (step 854). If the absolute value of the difference yjdiff is greater than the predetermined tolerance yjtolerance (step 856), it is determined whether the raw difference yjdiff is less than yjtolerance. If difference yjdiff is less than yjtolerance, the remaining measured data chunks will not be compared against the reference data chunk and it is determined whether the reference chunk used for comparison is the last reference chunk (step 620 in FIG. 8A). If difference yjdiff is greater than yjtolerance, the chunks do not match (step 872) and the process continues at step 606 (FIG. 8A). If the absolute value of the difference yjdiff is less than or equal to a predetermined tolerance yjtolerance (step 856), i.e., the y-coordinates match, the minutia angles \u03b8j and \u03b8j\u2032 are compared.",
        "It is noted that a straight subtraction in degree domain does not work well with angles due to their cyclical nature. Measured minutia angle \u03b8j\u2032 is subtracted from reference minutia angle \u03b8j, i.e. \u03b8j\u2212\u03b8j\u2032=\u03b8jdiff (step 858). If the absolute value of the difference \u03b8jdiff is less than or equal to a predetermined tolerance \u03b8jtolerance (step 860), i.e., the minutia angles match. If the absolute value of the difference \u03b8jdiff is greater than the predetermined tolerance \u03b8jtolerance, it is determined whether the absolute value of the difference \u03b8jdiff is greater than or equal to the difference between the maximum allowable quantized minutia angle \u03b8jmax and the predetermined tolerance \u03b8jtolerance (step 861). If value |\u03b8jdiff| is greater than or equal to the difference between values \u03b8jmax and \u03b8jtolerance, the minutia angles match.",
        "An example for angle comparison is described below. In the embodiment where the angles are quantized to 6 bits, thus having values 0 to 63, 0 is the minimum value for \u03b8j (\u03b8jmin) and 63 is the maximum value for \u03b8j (\u03b8jmax). The quantized values are then subtracted, e.g., |\u03b8j\u2212\u03b8j\u2032|=\u03b8jdiff, if minutia angle \u03b8j has a quantized value of 61 while minutia angle \u03b8j\u2032 has a quantized value of 63, and the match tolerance is 2. Then |61\u221263|=2, which is within the tolerance range. Thus, there is a match between minutia angles \u03b8j and \u03b8j\u2032. In a situation where angle \u03b8j has a quantized value of 0 while minutia angle \u03b8j\u2032 has a quantized value of 63, and the match tolerance is 2. Then |0\u221263|=63, which is out of the tolerance range. However, due to the cyclical nature, the difference between 63 and 0 is actually only 1, which is within the tolerance. Therefore, in addition to checking whether |\u03b8j\u2212\u03b8j\u2032|\u2266\u03b8jtolerance, whether \u03b8jdiff\u2267\u03b8jmax\u2212\u03b8tolerance is also checked. In the above example, \u03b8jdiff\u2267\u03b8jmax\u2212\u03b8jtolerance (63\u226763\u22122) is true. Therefore, minutia angles \u03b8j and \u03b8j\u2032 match.",
        "If the minutia angles \u03b8j and \u03b8j\u2032 match, neighborhood NHj is compared with neighborhood NHj\u2032 in step 862, which is described in detail in reference to FIG. 10.",
        "If the neighborhood NHj from the reference chunk matches neighborhood NHj\u2032 from the measured chunk (step 864), the data chunks match (step 866). Conversely, if any of the parameters, i.e. x-coordinates, y-coordinates, minutia angles and neighborhoods, fail to match, the data chunks do not match (step 872). The typical value for xjtolerance and yjtolerance is 4 and the typical value for \u03b8jtolerance is 7. These typical values are derived from experimentation.",
        "Since the measured data chunks are sorted in accordance with the x-coordinates xj, the comparisons for the remaining measured data chunks can be eliminated because the remaining measured data chunks will also have x-coordinates xj\u2032 exceeding the tolerance. Hence, sorting cuts down the number of comparisons. The number of comparisons can be further reduced by sorting the data chunks by y-coordinates yj.",
        "A flag can be set so that only a subset of the measured data chunks is used for further comparisons. FIG. 9B illustrates a flowchart of step 604 of how the fingerprint template data chunks are compared in detail. The x-coordinates are compared by subtracting measured x-coordinate xj\u2032 from reference x-coordinate xj, i.e. xj\u2212xj\u2032=xjdiff (step 880). If the absolute value of the difference xjdiff is less than or equal to a predetermined tolerance xjtolerance (step 881), it is determined whether this is the first match between reference x-coordinate xj and measured x-coordinate xj\u2032 (step 885). If the match is the first match, a flag is set for the measured chunk containing the first matching x-coordinate xj\u2032 (step 886).",
        "If the absolute value of the difference xjdiff is greater than the predetermined tolerance xjtolerance (step 881), then it is determined whether the difference xjdiff is less than the predetermined tolerance xjtolerance (step 882). If difference xjdiff is less than xjtolerance, the rest of the measured data chunks will not be compared against the reference data chunk and it is determined whether the reference chunk used is the last reference chunk (step 883). If the reference chunk is not the last chunk in the reference fingerprint template, the next reference chunk and the start chunk is loaded into the RAM for comparison (step 884) and the process continues with step 880. If the reference chunk is the last chunk in the reference fingerprint template, the fingerprint templates do not match (step 624 in FIG. 8A).",
        "If the match is not the first match (step 885) or after the start chunk has been flagged (step 886), the y-coordinates are compared. Measured y-coordinate yj\u2032 is subtracted from reference y-coordinate yj, i.e. yj\u2212yj\u2032=yjdiff (step 887). If the absolute value of the difference yjdiff is greater than the predetermined tolerance yjtoleracne (step 888), it is determined whether the difference yjdiff is less than yjtolerance (step 889). If difference yjdiff is less than yjtolerance, the remaining measured data chunks will not be compared against the reference data chunk and it is determined whether the reference chunk used for comparison is the last reference chunk (step 883). If difference yjdiff is greater than yjtolerance, the chunks do not match (step 896) and the process continues at step 606 (FIG. 8A).",
        "If the absolute value of the difference yjdiff is less than or equal to a predetermined tolerance yjtolerance (step 888), the remaining steps 890 through 896 are similar to steps 858-866 described in reference to FIG. 9A.",
        "As can be seen from FIGS. 9A and 9B, x-coordinates and y-coordinates comparison filters the number of comparisons. Although the fingerprint template matching algorithm is capable of comparing a fingerprint with a rotated and/or translated same fingerprint, the algorithm can execute faster if the finger is constrained in a certain orientation. By allowing translation and rotation, none, or very few values can be eliminated because the tolerance must be sufficiently large so as not to eliminate everything during the comparison and thus generating a false rejection.",
        "FIG. 9C illustrates a flowchart of step 654 of how the fingerprint template data chunks are compared in detail, where every chunk is compared. Parameters xj and xj\u2032 are compared (step 806), e.g., by straight subtractions. If value xjdiff, i.e., |xj\u2212xj\u2032|=xjdiff, is greater than a tunable, predetermined tolerance xjtolerance, parameter xj does not match parameter xj\u2032. Therefore, the data chunks do not match (step 824) and the next data chunk is read (refer to FIG. 8B). When value xjdiff is equal to or is less than the tolerance xjtolerance (step 812), parameter xj matches parameter xj\u2032 (step 808) and parameter yj is compared with parameter yj\u2032 in step 810 with a straight subtraction.",
        "If value yjdiff, i.e. |yj\u2032\u2212yj|=yjdiff, is greater than a tunable, predetermined tolerance yjtolerance, parameter yj does not match parameter yj\u2032 (step 812) and the data chunks do not match (step 824). The next data chunk is read (see FIG. 8B). When value yjdiff is equal to or is less than the tolerance yjtolerance, parameter yj matches parameter yj\u2032 (step 812) and parameter \u03b8j is compared with parameter \u03b8j\u2032 in step 814.",
        "If minutia angle difference \u03b8jdiff is greater than a tunable, predetermined minutia angle tolerance \u03b8tolerance, parameter \u03b8j does not match parameter \u03b8j\u2032 (step 816) and the data chunks do not match (step 824) and the next data chunk is read (see FIGS. 8A and 8B). When minutia angle difference \u03b8jdiff is equal to or is less than the minutia angle tolerance jtolerance or when difference \u03b8jdiff is greater than or equal to the maximum allowable quantized minutia angle minus the predetermined tolerance \u03b8tolerance, parameter \u03b8j matches parameter \u03b8j\u2032 (step 816) and neighborhood NHj is compared with neighborhood NHj\u2032 in step 818, which is described in detail in reference to FIG. 10. If the neighborhood NHj from the reference chunk matches neighborhood NHj\u2032 from the measured chunk (step 820)., the data chunks match (step 822). Conversely, if the neighborhood NHj and neighborhood NHj\u2032 do not match, the data chunks do not match. The sequence of comparison may vary. For example, parameter yj maybe compared before comparing parameter xj; angle \u03b8j maybe compared before comparing parameter yj; and so on.",
        "FIG. 10 shows a flowchart of the neighborhood matching algorithm of steps 862, 893 and 818. In step 900, the first neighbor in an reference chunk (hereinafter reference neighbor), e.g., N1 (FIG. 7A), and the first neighbor in a measured chunk (hereinafter measured neighbor), e.g., N1\u2032 (FIG. 7B), are compared. Step 900 is described in detail below.",
        "If the neighbors match (step 902), a neighbor counter is incremented in step 904. If the counter value is equal to or is greater than a predetermined number of neighbor matches (step 906), the neighborhoods match (step 918). For example, 7 neighbor matches for a 15-neighbor neighborhood can be considered a match of the neighborhoods.",
        "If the neighbors do not match (step 902) or if the number of neighbor matches is less than the predetermined number of neighbor matches (step 906), it is determined whether the measured neighbor used in comparison is the last neighbor in the measured chunk (step 908).",
        "If the measured neighbor is not the last measured neighbor in the measured chunk, the next measured neighbor is read (step 910) and the new measured neighbor is compared with the reference neighbor already in use. If the measured neighbor is the last measured neighbor in the measured chunk, it is determined whether the reference neighbor is the last reference neighbor in the reference chunk (step 912). If the reference neighbor is not the last reference neighbor in the reference chunk, the next reference neighbor and the first measured neighbor are read (step 914) and compared (step 900). If, however, the reference neighbor is the last reference neighbor in the reference chunk, the neighborhoods do not match (step 916).",
        "FIG. 11A illustrates step 900 in FIG. 10 in detail and shows a neighbor to neighbor comparison. The distances di of an reference neighbor is compared with a distance di\u2032 of a measured neighbor in step 1000. This distance comparison is done with straight subtractions, i.e. |di\u2212di\u2032|=didiff. If the distance difference didiff meets the distance tolerance ditolerance (step 1002), angle \u03c6i is compared with angle \u03c6i\u2032 (step 1004).",
        "Angle comparison is again done in a similar manner as minutia angle comparison described above. Specifically, angle \u03c6i matches angle \u03c6i\u2032 if |\u03c6j\u2212\u03c6j\u2032|\u2266\u03c6jtolerance and \u03c6j\u2212\u03c6j\u2032\u2267\u03c6jmax\u2212\u03c6jtolerance (step 1006).",
        "Angles \u03a6i and \u03a6i\u2032 are then compared in step 1008. Similarly, angle \u03a6i matches angle \u03a6i\u2032 if |\u03a6j\u2212\u03a6j\u2032|\u2266\u03a6jtolerance and \u03a6j\u2212\u03a6j\u2032\u2267\u03a6jmax\u2212\u03a6jtolerance (step 1010). The neighbors match (step 1012) if all parameters for a neighbor, e.g., distance di and angles \u03a6i and \u03a6j, match. The typical value for ditolerance is l and the typical value for \u03a6itolerance and \u03a6itolerance is 6. These typical values are derived from experimentation.",
        "If any of the parameters, i.e., distance di or angle \u03c6i or \u03a6i, do not match, the neighbors do not match (step 1014). Again, the sequence of comparison, i.e., di, \u03c6i and \u03a6i, may be modified.",
        "FIG. 11B shows an alternative embodiment of neighbor comparison process in step 900. In this embodiment, the measured chunks are sorted in accordance with distance di\u2032. Measured distances di\u2032 is subtracted from reference distance di to derive a difference didiff (step 1050). If the distance difference didiff meets a predetermined distance tolerance ditolerance (step 1052), angle \u03c6i is compared with angle \u03c6i\u2032 (step 1054). If angles \u03c6i and \u03c6j\u2032 match (step 1056), \u03a6i and \u03a6i\u2032 are compared in step 1058. If angles \u03a6i and \u03a6i\u2032 match (step 1060), the neighbors match (step 1062).",
        "If measured distance di does not match reference distance di\u2032, it is determined whether the difference didiff is less than the predetermined tolerance ditolerance (step 1053). If the difference didiff is less than the predetermined tolerance ditolerance, the neighbors do not match and the remaining measured neighbors are not compared. The process continues with step 912 in FIG. 10. If any of the parameters, i.e., distance di or angle \u03c6i or \u03a6i, do not match, the neighbors do not match (Step 1064).",
        "In one embodiment, for multiple users where multiple reference fingerprints are stored in a database, if the measured fingerprint template does not match the first reference fingerprint template, the next reference fingerprint template is compared with the measured fingerprint template, as shown in FIG. 12. Multiple reference fingerprint template comparison starts with step 680. The first reference fingerprint template and the measured fingerprint template are loaded into the RAM (one chunk at a time) (step 682). The fingerprint.templates are compared in step 684, in accordance with the template comparison algorithm described above, with reference to FIGS. 8A and 8B. Whether there is a match between the fingerprint templates is determined in step 686. If there is a match (step 688), the process ends in step 696. If there is no match, it is determined whether the last reference fingerprint template has been used (step 690). If the last reference fingerprint template has been used, there is no match (step 692) and the process ends in step 696. However, if the last reference fingerprint template has not been used (step 690), the next reference fingerprint template is loaded to be compared with the measured fingerprint template (step 694). In general, the number of reference templates can be stored is limited by the memory capacity. For example, in a conventional smart card, the typical static memory available is 1 Kilobytes to 16 Kilobytes. Therefore, the number of reference templates can be stored is limited by that memory capacity.",
        "In another embodiment for a multi-user system, the measured fingerprint template is compared with all the reference templates in a similar manner as described above. However, in this embodiment, for each template comparison, all data chunks in both the measured fingerprint template and the reference template are compared. For example, even when a match is found for a pair of fingerprint templates, e.g., more than four data chunk matches, the remaining combinations of data chunks are compared. The number of data chunk matches for each reference fingerprint template is stored. If the measured fingerprint template matches more than one reference fingerprint templates, then the user producing the reference fingerprint template that gives the highest number of data chunk matches is identified as the user.",
        "The algorithm in accordance with the present invention may be executed in a microprocessor having minimal capabilities, such as an 8-bit microprocessor on a conventional smart card because every parameter used in the algorithm is less than 8 bits. For example, location parameters xj and yj are quantized to four bits each; minutia angle \u03b8j and angles \u03c6i and \u03a6i are quantized to six bits each; and distance di is quantized to five bits. In addition, the fingerprint template matching algorithm in accordance with the present invention does not involve computational intensive processes involving for example, floating points, multiplications, and divisions. Instead, the algorithm in accordance with the present invention only uses subtractions. Hence, the algorithm can be executed by a weak microprocessor having very low speed, e.g., between 1 and 10 MegaHertz, such as a microprocessor in a conventional smart card.",
        "Although the invention has been described with reference to particular embodiments, the description is only an example of the invention's application and should not be taken as a limitation. Various other adaptations and combinations of features of the embodiments disclosed are within the scope of the invention as defined by the following claims."
    ],
    "citations": [
        "4135147",
        "4151512",
        "4185270",
        "4438824",
        "4532508",
        "4582985",
        "4646352",
        "4783823",
        "4993068",
        "5144680",
        "5268963",
        "5280527",
        "5363453",
        "5384846",
        "5448045",
        "5450491",
        "5469506",
        "5509083",
        "5541994",
        "5546463",
        "5559504",
        "5581630",
        "5613012",
        "5613014",
        "0 050 842",
        "0 159 037",
        "0 507 319",
        "0 513 612",
        "0 791 899",
        "2 256 170",
        "WO 93/17388",
        "WO 99/26184"
    ],
    "us_classification": "713182",
    "international_classifications": [
        {
            "classification_level": "A",
            "section": "H",
            "classification_class": "04",
            "subclass": "L",
            "main_group": "9",
            "subgroup": "00"
        }
    ]
}