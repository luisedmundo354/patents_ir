{
    "title": "Methods for identifying discrete populations (e.g., clusters) of data within a flow cytometer multi-dimensional data set",
    "abstract": "Systems and methods for identifying populations of events in a multi-dimensional data set are described. The populations may, for example, be sets or clusters of data representing different white blood cell components in sample processed by a flow cytometer. The methods use a library consisting of one or more one finite mixture models, each model representing multi-dimensional Gaussian probability distributions with a density function for each population of events expected in the data set. The methods further use an expert knowledge set including one or more data transformations and one or more logical statements. The transformations and logical statements encode a priori expectations as to the populations of events in the data set. The methods further use program code by which a computer may operate on the data, a finite mixture model selected from the library, and the expert knowledge set to thereby identify populations of events in the data set.",
    "inventors": [
        "Thayer"
    ],
    "document_number": "07299135",
    "publication_date": "20071120",
    "assignees": [
        "IDEXX Laboratories, Inc."
    ],
    "claims": [
        {
            "claim_number": "CLM-00001",
            "preamble": "1. In a computing system for identifying populations of events in a multi-dimensional data set obtained from a flow cytometer, the populations associated with blood components in a sample of human or animal blood, the improvement comprising:",
            "components": [
                {
                    "component": "one or more machine readable storage media for use with the computing system, the machine readable storage media storing:",
                    "subcomponents": []
                },
                {
                    "component": "a) data representing a finite mixture model, the model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set;",
                    "subcomponents": []
                },
                {
                    "component": "b) an expert knowledge set comprising (1) one or more data transformations and (2) one or more logical statements, the transformations and logical statements encoding a priori expectations as to the populations of events in the data set; and",
                    "subcomponents": []
                },
                {
                    "component": "c) program code for the computing system comprising instructions for operating on the multi-dimensional data using the finite mixture model and the expert knowledge set to thereby identify populations of events in the multi-dimensional data set associated with said blood components.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00002",
            "preamble": "2. The improvement of claim 1 , wherein the expert knowledge set encodes a process modifying a probability estimate that an event is in one of the populations.",
            "components": []
        },
        {
            "claim_number": "CLM-00003",
            "preamble": "3. The improvement of claim 1 , wherein the program code iteratively executes an expectation operation, application of the expert knowledge set and a maximization operation to thereby adjust parameters associated with the finite mixture model.",
            "components": []
        },
        {
            "claim_number": "CLM-00004",
            "preamble": "4. The improvement of claim 1 , wherein the expert knowledge set includes at least one geometric transformation for transforming the multidimensional data set.",
            "components": []
        },
        {
            "claim_number": "CLM-00005",
            "preamble": "5. The improvement of claim 1 , wherein the program code comprises:",
            "components": [
                {
                    "component": "a pre-optimization module performing scaling of the multi-dimensional data set;",
                    "subcomponents": []
                },
                {
                    "component": "an optimization module iteratively performing (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density functions of the finite mixture model based on the application of the exert knowledge set; and",
                    "subcomponents": []
                },
                {
                    "component": "a classification module responsive to the output of the maximization operation for classifying the multidimensional data set into one or more populations.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00006",
            "preamble": "6. The improvement of claim 5 , wherein the program code further comprises a post-classification module modifying the classification of the multidimensional data set using one or more expert rules from the expert knowledge set.",
            "components": []
        },
        {
            "claim_number": "CLM-00007",
            "preamble": "7. The improvement of claim 5 , wherein the optimization module executes a transformation algorithm defining a zero point defining a true domain and a false domain and a logical operation assigning one value to an event if the event is in the true domain and a second value if the event is in the false domain.",
            "components": []
        },
        {
            "claim_number": "CLM-00008",
            "preamble": "8. The improvement of claim 7 , wherein the optimization module defines at least two zero points.",
            "components": []
        },
        {
            "claim_number": "CLM-00009",
            "preamble": "9. The improvement of claim 7 , wherein the expert knowledge set includes at least one logical statement modifying a probability estimate for an event depending on the relationship of the event to the true domain.",
            "components": []
        },
        {
            "claim_number": "CLM-00010",
            "preamble": "10. The improvement of claim 5 , wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to at least one predetermined expected population.",
            "components": []
        },
        {
            "claim_number": "CLM-00011",
            "preamble": "11. The improvement of claim 10 , wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to each expected population.",
            "components": []
        },
        {
            "claim_number": "CLM-00012",
            "preamble": "12. The improvement of claim 1 , wherein the machine readable storage media is coupled to a data processing unit associated with a flow cytometer.",
            "components": []
        },
        {
            "claim_number": "CLM-00013",
            "preamble": "13. The improvement of claim 1 , wherein the instructions further comprise instructions for presenting the identification of populations in a human perceptible form.",
            "components": []
        },
        {
            "claim_number": "CLM-00014",
            "preamble": "14. A method of identifying populations of events in a multi-dimensional data set obtained from a flow cytometer, comprising the steps of:",
            "components": [
                {
                    "component": "(a) processing a sample with flow cytometer to thereby obtain a multi-dimensional data set;",
                    "subcomponents": []
                },
                {
                    "component": "(b) storing the data set in a machine-readable memory;",
                    "subcomponents": []
                },
                {
                    "component": "(c) providing a finite mixture model, the model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set; and",
                    "subcomponents": []
                },
                {
                    "component": "(d) operating on the multi-dimensional data and the finite mixture model with the aid of an expert knowledge set to thereby identify populations of events in the multi-dimensional data set, wherein the expert knowledge set comprises one or more data transformations for operation on the multi-dimensional data set and one or more logical statements, the transformations and logical statements encoding a priori expectations as to the populations of events in the data set.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00015",
            "preamble": "15. The method of claim 14 , further comprising the step of presenting the results of the identification of populations of events in a human perceptible form.",
            "components": []
        },
        {
            "claim_number": "CLM-00016",
            "preamble": "16. The method of claim 14 , wherein the flow cytometer processes a sample of human or animal blood and the multi-dimensional data represents event data associated with the sample.",
            "components": []
        },
        {
            "claim_number": "CLM-00017",
            "preamble": "17. The method of claim 16 , wherein the populations comprise populations of blood components in the blood sample.",
            "components": []
        },
        {
            "claim_number": "CLM-00018",
            "preamble": "18. The method of claim 14 , wherein the expert knowledge set includes at least one geometric transformation for transforming the multi-dimensional data set.",
            "components": []
        },
        {
            "claim_number": "CLM-00019",
            "preamble": "19. The method of claim 14 , wherein step (d) comprises:",
            "components": [
                {
                    "component": "a pre-optimization step performing scaling of the multi-dimensional data set;",
                    "subcomponents": []
                },
                {
                    "component": "an optimization step iteratively performing (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density functions of the finite mixture model; and",
                    "subcomponents": []
                },
                {
                    "component": "a classification step responsive to the output of the maximization operation for classifying the multidimensional data set into one or more populations.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00020",
            "preamble": "20. The method of claim 14 , wherein step (d) further comprises a post-classification step modifying the classification of the multidimensional data set using one or more expert rules from the expert knowledge set.",
            "components": []
        },
        {
            "claim_number": "CLM-00021",
            "preamble": "21. The method of claim 19 , wherein the optimization module executes a transformation algorithm defining a zero point defining a true domain and a false domain, and a logical operation assigning one value to an event if the event is in the true domain relative and a second value if the event is in a false domain.",
            "components": []
        },
        {
            "claim_number": "CLM-00022",
            "preamble": "22. The method of claim 21 , wherein the optimization step defines at least two zero points.",
            "components": []
        },
        {
            "claim_number": "CLM-00023",
            "preamble": "23. The method of claim 21 , wherein the expert knowledge set includes at least one logical statement modifying a probability estimate of an event depending on the relationship of the event to the true domain.",
            "components": []
        },
        {
            "claim_number": "CLM-00024",
            "preamble": "24. The method of claim 19 , wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to at least one predetermined expected population.",
            "components": []
        },
        {
            "claim_number": "CLM-00025",
            "preamble": "25. The method of claim 24 , wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to each expected population.",
            "components": []
        },
        {
            "claim_number": "CLM-00026",
            "preamble": "26. The method of claim 14 , wherein the method further comprises performing a pre-optimization step applying a set of scaling factors to the data so as to maximize the likelihood the data arose from a specified finite mixture model selected from a library of finite mixture models.",
            "components": []
        },
        {
            "claim_number": "CLM-00027",
            "preamble": "27. The method of claim 26 , wherein the scaling factors adjust the data for machine to machine variability for machines generating the multi-dimensional data given the specified finite mixture model's parameters.",
            "components": []
        },
        {
            "claim_number": "CLM-00028",
            "preamble": "28. A flow cytometry system comprising",
            "components": [
                {
                    "component": "a flow cytometer; and",
                    "subcomponents": []
                },
                {
                    "component": "a data processing unit for processing a multidimensional data set obtained from the flow cytometer; and",
                    "subcomponents": []
                },
                {
                    "component": "a memory storing a data representing a finite mixture model, code representing an expert knowledge set comprising logical operations and data transformations for operation on the multidimensional data set, the logical operations and data transformations encoding a priori expectations as to the populations of events in the data set, and program code for execution by the processing unit for using the expert knowledge set and the finite mixture model to identify populations of events in the data set obtained from the flow cytometer.",
                    "subcomponents": []
                }
            ]
        },
        {
            "claim_number": "CLM-00029",
            "preamble": "29. The system of claim 28 , wherein the program code comprises:",
            "components": [
                {
                    "component": "a pre-optimization module performing scaling of the data set;",
                    "subcomponents": []
                },
                {
                    "component": "an optimization module iteratively performing (1) an expectation operation on at least a subset of the data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the finite mixture model; and",
                    "subcomponents": []
                },
                {
                    "component": "a classification module responsive to the output of the maximization operation for classifying the data set into one or more populations.",
                    "subcomponents": []
                }
            ]
        }
    ],
    "description": [
        "A portion of this disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.",
        "A. Field of the Invention",
        "This invention relates to the field of methods of analysis of multi-dimensional data and more particularly to methods for identifying and classifying discrete populations or clusters within such data. This invention has applications in a variety of disciplines, including the fields of biology, drug discovery and medicine, such as analysis of blood. One specific application described herein is analysis of multi-dimensional data obtained from a flow cytometer in order to identify and classify the data into discrete populations of different types of white blood cells.",
        "B. Related Art",
        "Mammalian peripheral blood usually contains three major classifications of blood cells\u2014red blood cells (\u201cRBCs\u201d), white blood cells (\u201cWBCs\u201d), and platelets (\u201cPLTs\u201d). These cells are suspended in a solution referred to as plasma, which contains many different proteins, enzymes, and ions. The functions of the plasma components include blood coagulation, osmolality maintenance, immune surveillance, and a multitude of other functions.",
        "Mammals usually have anywhere from 2-10\u00d71012 RBCs per liter. RBCs are responsible for oxygen and carbon dioxide transport within the circulatory system. In many mammals, including humans, normal mature red cells have a bi-concave cross-sectional shape and lack nuclei. RBCs can range in diameter between 4 and 9 microns, depending on the species, and have a thickness that is generally less than 2 microns. The RBCs contain high concentrations of hemoglobin, a heme-containing protein which performs the dual roles of oxygen and carbon dioxide transport. Hemoglobin is responsible for the overall red color of blood, due to the presence of iron in the heme molecule. In the present application, the terms \u201cerythrocytes\u201d, \u201cred blood cells\u201d, \u201cred cells\u201d, and \u201cRBCs\u201d are used interchangeably to refer to the hemoglobin-containing blood cells present in the circulation as described above.",
        "In addition to mature RBCs, immature forms of red blood cells can often be found in peripheral blood samples. A slightly immature RBC is referred to as a reticulocyte, and the very immature forms of RBCs are broadly classified as nucleated red blood cells (NRBCs). Higher level non-mammalian animals, such as birds, reptiles, and amphibians, have exclusively nucleated RBCs in their blood.",
        "Reticulocytes are red blood cell precursors that have completed most of the normal red cell development stages in bone marrow, and have expelled their nuclei. The last portion remaining to leave the reticulocyte before it becomes a truly mature RBC is transfer RNA. Detection of reticulocytes is important in clinical evaluation of a patient's ability to produce new red blood cells. The reticulocyte count also can be used to distinguish among different types of anemia. In anemia, red cell production may be diminished to the point where it can no longer keep up with red cell removal, and as a result the overall red blood cell count and hematocrit are low. The presence of an increased number of reticulocytes in anemic patients provides evidence that their bone marrow is functioning, and attempting to make up for the red blood cell deficit. If few or no reticulocytes are detectable in these patients, the bone marrow is not adequately responding to the red blood cell deficit.",
        "White blood cells (also called \u201cleukocytes\u201d) are the blood-borne immune system cells that destroy foreign agents, such as bacteria, viruses, and other pathogens that cause infection. WBCs exist in peripheral blood in very low concentrations as compared to red blood cells. Normal concentrations of these cells range from 5-15\u00d7109 per liter, which is about three orders of magnitude less than red blood cells. These cells are generally larger than RBCs, having diameters between 6 to 13 microns, depending on the type of white cell and the species. Unlike RBCs, there are a variety of white blood cell types that perform different functions within the body. In this application, the terms \u201cwhite blood cells\u201d, \u201cwhite cells\u201d, \u201cleukocytes\u201d, and \u201cWBCs\u201d are used interchangeably to refer to the non-hemoglobin-containing nucleated blood cells present in the circulation as described above.",
        "Measurements of the numbers of white cells in blood is important in the detection and monitoring of a variety of physiological disorders. For example, elevated numbers of abnormal white blood cells may indicate leukemia, which is an uncontrolled proliferation of a myelogenous or a lymphogenous cell. Neutrophilia, or an abnormally high concentration of neutrophils, is an indication of inflammation or tissue destruction in the body, by whatever cause.",
        "White blood cells may be broadly classified as either granular or agranular. Granular cells, or granulocytes, are further subdivided into neutrophils, eosinophils, and basophils. Agranular white cells are sometimes referred to as mononuclear cells, and are further sub-classified as either lymphocytes or monocytes. Measurements of the percentages in the blood of the two major WBC classifications (granulocytes and mononuclear cells) comprise a two-part WBC differential count (or two-part differential). Measurements of the components of these subclassifications (neutrophils, eosinophils, basophils, lymphocytes, and monocytes), produce a five-part WBC differential count (or five-part differential).",
        "Neutrophils are the most prevalent of the granulocytes and of the five major subclasses of white cells, usually making up a little over half of the total number of white blood cells. Neutrophils are so named because they contain granules within their cytoplasm which can be stained at a neutral pH. These cells have a relatively short life span, on the order of a day or less. Neutrophils attack and destroy invading bacteria and other foreign agents in the tissues or circulating blood as part of the body's immune response mechanisms.",
        "Eosinophils are the second most prevalent of the granulocytes, behind the neutrophils, but generally account for less than five percent of the total number of white blood cells. Eosinophils also contain granules within their cytoplasm which can be stained with an eosin stain. Like neutrophils, these cells are short-lived in the peripheral blood. Eosinophils play a part in the body's immune response mechanisms that are usually associated with allergies or parasitic infections.",
        "Basophils are the least common of the granulocytes, and the least common of all the five classifications of WBCs. As they are granulocytes, they contain granules within their cytoplasm which can be stained, in this case using a basic (high pH) stain. These cells also are known to play a role in the body's immune response mechanisms, but the specifics are not certain.",
        "Lymphocytes are the most prevalent of the mononuclear cell types, and generally make up between 20 and 30 percent of the total number of white blood cells. Lymphocytes specifically recognize foreign antigens and in response divide and differentiate to form effector cells. The effector cells may be B lymphocytes or T lymphocytes. B lymphocytes secrete large amounts of antibodies in response to foreign antigens. T lymphocytes exist in two main forms\u2014cytotoxic T cells, which destroy host cells infected by infectious agents, such as viruses, and helper T cells, which stimulate antibody synthesis and macrophage activation by releasing cytokines. Lymphocytes have no granules in their cytoplasm, and their nucleus occupies a large majority of the cell volume. The thin area of cytoplasm outside the nucleus of lymphocytes can be stained with a nucleic acid stain, since it contains RNA. Many lymphocytes differentiate into memory B or T cells, which are relatively long-lived and respond more quickly to foreign antigen than naive B or T cells.",
        "Monocytes are immature forms of macrophages that, in themselves, have little ability to fight infectious agents in the circulating blood. However, when there is an infection in the tissues surrounding a blood vessel, these cells leave the circulating blood and enter the surrounding tissues. The monocytes then undergo a dramatic morphological transformation to form macrophages, increasing their diameter as much as fivefold and developing large numbers of mitochondria and lysosomes in their cytoplasm. The macrophages then attack the invading foreign objects by phagocytosis and activation of other immune system cells, such as T cells. Increased numbers of macrophages are a signal that inflammation is occurring in the body.",
        "Platelets are found in all mammalian species, and are involved in blood clotting. Normal animals will generally have between 1-5\u00d71011 platelets per liter. These cellular particles are usually much smaller than RBCs, having a diameter between 1 and 3 \u03bcm. Platelets are formed as buds from the surfaces of megakarocytes, which are very large cells found in the bone marrow. The megakaryocytes do not themselves leave the marrow to enter the blood circulation; rather, buds form on the surface, pinch off and enter the circulation as platelets. Like RBCs, platelets lack nuclei and thus cannot reproduce. Functionally, platelets aggregate so as to plug or repair small holes in blood vessels. In the case of larger holes, platelet aggregation acts as an early step in clot formation. As a result, platelet count and function are clinically very important. For example, abnormally low platelet counts may be the cause of a clotting disorder.",
        "Collectively, the counting and sizing of RBCs, the counting of WBCs, and the counting of platelets is referred to as a complete blood count (\u201cCBC\u201d). The separation of white blood cells into the five major classifications (i.e., neutrophils, eosinophils, basophils, lymphocytes, and monocytes) and their quantification on a percent basis is referred to as a five-part differential. The separation of white blood cells into two major classifications, granular and agranular leukocytes, and their quantification on a percent basis is referred to as a two-part differential. The categorizing of red blood cells into two classifications, mature red blood cells and reticulated red blood cells, on a percent basis is referred to as a reticulocyte count.",
        "The determination of a CBC, with a five-part differential and a reticulocyte count, is a common diagnostic procedure performed to diagnose, track and treat an abundance of ailments. These tests make up the great majority of hematology analyses that are performed in medical and veterinary clinical laboratories around the world. These three tests have for many years been performed using a microscope, centrifuge, counting chamber, slide, and appropriate reagents. However, the skills necessary to perform these test manually are rare and require years of training. Furthermore, the time required to perform each of these tests manually is very high. As a result, significant automation via instrumentation has been pursued in this field since the early 1950's.",
        "Flow cytometry is a powerful method of analysis that is able to determine the cellular content of various types of samples, and in particular samples that contain living cells. In clinical applications, flow cytometers are useful for lymphocyte counting and classification, for immunological characterization of leukemias and lymphomas, and for cross-matching tissues for transplants. In most flow cytometry techniques, cells in a fluid solution are caused to flow individually through a light beam, usually produced by a laser light source. As light strikes each cell, the light is scattered and the resulting scattered light is analyzed to determine the type of cell. Different types of cells produce different types of scattered light. The type of scattered light produced may depend on the degree of granularity, the size of the cell, etc. Cells in a fluid solution may also be labeled with a marker linked to a fluorescent molecule, which fluoresces when light strikes it and thereby reveals the presence of the marker on the cell. In this fashion, information about the surface components of the cell can be obtained. Examples of such fluorescent molecules include FITC (fluorescein isothiocyanate), TRITC (tetramethyl rhodamine isothiocyanate), Cy3, Texas Red (sulforhodamine 101), and PE (phycoerythrin). In addition, intracellular components of the cell, such as nucleic acids, may be stained by fluorescent compounds, and subsequently detected by fluorescence. Examples of such compounds include ethidium bromide, propidium iodide, YOYO-1, YOYO-3, TOTO-1, TOTO-3, BO-PRO-1, YO-PRO-1, and TO-PRO-1. Cells may also be stained with dyes that label particular cellular components, and the absorbance of the dye bound to the cells measured.",
        "Blood cell measurements made using flow cytometry often require two separate measurements\u2014one to measure the RBCs and platelets, and the other to measure WBCs. The reason for separate measurements is that the RBCs are present in the blood at a much higher concentration than other blood cell types, and thus detection of other cell types in the presence of RBCs requires that the RBCs either be removed or large volumes of sample be measured. Alternatively, these cells may be distinguished on the basis of immunochemical staining of particular cell surface antigens and/or differential cell type staining.",
        "Light scattering measurements are widely used in flow cytometry to measure cell sizes and to distinguish among several different types of cells. It is known that incident light is scattered by cells at small angles (approximately 0.5-20 degrees) from the line traveled by the incident light that interrogates the cells, and that the intensity of the scattered light is proportional to the cell volume. The light scattered at small angles is referred to forward scattered light. Forward scattered light (also called forward light scatter, or small-angle scatter for angles of scatter between 0.5-2.0.degree.) is useful in determining cell size. The ability to measure cell size depends on the wavelength employed and the precise range of angles over which light is collected. For example, material within cells having a strong absorption at the illuminating wavelength may interfere with size determination because cells containing this material produce smaller forward scatter signals than would otherwise be expected, leading to an underestimate of cell size. In addition, differences in refractive index between the cells and the surrounding medium may also influence the small-angle scatter measurements.",
        "In addition to forward scattered light, cells having a high degree of granularity, such as granulocytes, scatter incident light at high angles to a much greater degree than cells with low granularity, such as lymphocytes. Different cell types may be distinguished on the basis of the amount of orthogonal light scatter (also referred to herein as right angle side scatter) they produce. As a result, forward and right angle side scatter measurements are commonly used to distinguish among different types of blood cells, such as red blood cells, lymphocytes, monocytes, and granulocytes.",
        "Additionally, eosinophils may be distinguished from other granulocytes and lymphocytes on the basis of polarization measurements of right angle side scatter. Normally, incident polarized light is scattered orthogonally and remains polarized. However, eosinophils cause incident polarized light scattered orthogonally to become depolarized to a greater degree than other cells. This higher degree of depolarization permits the specific identification of eosinophil populations in blood samples.",
        "Flow cytometers have been commercialized and are known in the art. IDEXX Laboratories, the assignee of this invention, has developed a commercial flow cytometer for analysis of blood which is marketed under the trademark LASERCYTE. Flow cytometers are also described in the patent literature, see for example U.S. Pat. Nos. 6,784,981 and 6,618,143, both assigned to IDEXX Laboratories, the contents of which are incorporated by reference herein. Other patents of interest include U.S. Pat. Nos. 5,380,663; 5,451,525; and 5,627,037.",
        "In conventional hematology instruments, the hemoglobin concentration is generally measured in an otherwise clear solution, and is referenced to a clear fluid. Lysis of red cells allow the hemoglobin to be measured in the same fluidic channel as the white blood cells. Alternatively, on some systems, the hemoglobin content may be measured in a separate channel.",
        "To obtain meaningful information about the numbers and types of cells in a biological sample, or of the concentration of markers on cell surfaces, the samples must be standardized with respect to the amount of light scatter, fluorescence or impedance associated with standardized populations of the cells. In addition, the flow cytometry instrument itself must be calibrated to ensure proper performance. Calibration of the instrument is typically accomplished by passing standard particles through the instrument, and measuring the resulting scatter, fluorescence, or impedance. Flow cytometers may be calibrated with either synthetic standard materials (e.g., polystyrene latex beads) or with cells or other biological material (e.g., pollen, fixed cells, or stained nuclei). These standardization materials are desirably extremely uniform in size, and contain precise amounts of fluorescent molecules to serve in calibrating the photomultiplier tubes used in detection of fluorescent probes. However, the calibration procedures are lengthy and complicated, and require extensive training to perform properly. Consequently, these calibration procedures are typically performed only once at the beginning of the analysis. Changes in the instrument or in the sample may alter the performance of the instrument.",
        "Flow cytometry techniques that took advantage of the light scattering characteristics of cells were applied beginning in the early 1970's to perform white cell differential analysis, in combination with CBC determination. Automated reticulocyte analysis was developed in the 1980's. However, these early systems did not perform a CBC or white blood cell differential. Eventually, manufacturers like Technicon (Bayer), Coulter (Beckman-Coulter) and Abbott incorporated reticulocyte counting with their automated CBC/white cell differential systems, in such high-end hematology systems as the Technicon (Bayer) H*3, Bayer Advia 120\u2122, Coulter STKS\u2122, Coulter GenS\u2122., and Abbott CellDyn 3500 and CellDyn 4000. These high-end instrument systems are capable of measuring all of the parameters for a complete hematology analysis that are clinically important for patient assessment, namely, CBC, five-part WBC differential and reticulocyte count.",
        "The WBC data generated by passing a single blood sample through a flow cytometer consists of N data points, each point captured in a separate channel. Each \u201cchannel\u201d is associated with a discrete detector built into the instrument, or, alternatively, an integration of a detector signal over some time period. Thus, the flow cytometer produces N data points in M channels for a data set totalling N\u00d7M data points, where M may be 2, 3, 4 or other integer and is equal to the number of detectors in the instrument and whether integration or other processing is used to create more channels than detectors. In the LaserCyte instrument, the instrument captures N seven dimensional data points (M=7). The dimensions are Extinction (EXT), Extinction Integrated (EXT_Int), Right Angle Scatter (RAS), Right Angle Scatter Integrated (RAS_Int), Forward Scatter Low (FSL), Forward Scatter High (FSH), and Time of Flight (TOF). See U.S. Pat. Nos. 6,784,981 and 6,618,143 for details on the geometry of these data collectors and their meanings. The terms \u201cdimensions\u201d and \u201cchannels\u201d are used interchangeably in this document. A single seven-dimensional data point is referred to as an \u201cevent\u201d.",
        "The physical properties of the different white blood cells cause light passing through them to scatter differently. For example, larger cells generally have greater EXT and EXT_Int values due to their greater light occlusion, while cells with greater internal complexity tend to produce greater light scatter and this is observed at the FSH detector.",
        "The human eye can distinguish data clumps or clusters (\u201cpopulations\u201d) amongst some two-dimensional projections of the seven-dimensional event data, e.g., a conventional 2D plotting of the N event data with the EXT value being in positive Y axis and the RAS value plotted the positive X axis. Moreover, it has been shown that on clean, well-handled samples, the percentage of observed events within each cluster typically corresponds to the relative percentages of the five different white blood cell types (neutrophils, monocytes, lymphocytes, eosinophils, and basophils). However, there is a need for quantifying such populations with some precision, preferably in an automated manner, as quantitative measurements provide a more meaningful way to measure and compare the populations and therefore use them for diagnostic or other analytical purposes.",
        "The solution provided by this disclosure is a method and apparatus for finding and classifying, in an automated fashion, event data in the midst of noise and to give estimates, in quantitative terms, on the relative frequencies of populations in a multidimensional data set, such as for example, frequencies of WBC type in a given sample of human or animal blood. This is no small feat. The sample-to-sample and machine-to-machine variability, combined with varying degrees of noise resulting from unknown cellular events, greatly complicate this classification problem. The art has lacked a robust analysis method that offers the ability to combine expert knowledge with stable unsupervised classifying and classifying algorithms for identifying discrete populations (clusters) of data within a large multidimensional data set, e.g., as obtained by a flow cytometer.",
        "The foregoing examples of the related art and limitations related therewith are intended to be illustrative and not exclusive. Other limitations of the related art will become apparent to those of skill in the art upon a reading of the specification and a study of the drawings.",
        "The following embodiments and aspects thereof are described and illustrated in conjunction with systems, tools and methods which are meant to be exemplary and illustrative, not limiting in scope. In various embodiments one or more of the above-described problems have been reduced or eliminated, while other embodiments are directed to other improvements.",
        "In a first aspect, an improvement is provided to a computing system used for identifying populations of events in a multi-dimensional data set obtained from a flow cytometer. The improvement comprises one or more machine readable storage media for use with the computing system, the machine readable storage media storing:",
        "a) data representing a finite mixture model, the model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set;",
        "b) an expert knowledge set, comprising one or more data transformations for operation on the multi-dimensional data set and one or more logical statements (\u201cexpert rules\u201d herein), the transformations and logical statements encoding a priori expectations as to the populations of events in the data set; and",
        "c) program code for the computing system comprising instructions for operating on the multi-dimensional data, the finite mixture model, and the expert knowledge set, to thereby identify populations of events in the multi-dimensional data set.",
        "The identification of populations in the multi-dimensional data set can be converted to quantitative or qualitative data presented in a human-perceptible form, such as a graph or plot of the data with color coding to identify discrete populations in the data set, or as an output in terms of numbers or percentages of data points in the data set which are associated with the populations. As another example, the identified populations can be represented as one or more files in electronic from which can be stored in memory in the computer system, or transferred over a network to a computer workstation for further analysis or display to an operator (e.g., hematologist, veterinarian, or primary care physician).",
        "The use of the expert knowledge set in combination with the finite mixture model allows for more robust and accurate methods of automatically classifying data into one or more populations. In the context of flow cytometry and blood samples, an expert hematologist approaches a given flow cytometry data set expecting to find evidence of the five WBC types and has, as a result of previous information derived from blood manipulation studies, a good idea where they fall in one or more two-dimensional projections of the seven-dimensional data. There are no necessary bounds on what might comprise an expert's a priori knowledge set, but examples can include cluster position (e.g., in a two-dimensional projection or plot of a subset of the data), geometric shape of a cluster within some two-dimensional projections, and cluster position relative to other clusters. Such relationships often correspond to, and encode, known differences between the cell types, e.g. neutrophils are larger than most lymphocytes, and eosinophils contain more dense organelles than monocytes, etc. but could also arise from instrument specific knowledge. The present inventive methods provide an automated classification system and methods that rely on similar types of information, and, importantly, code such knowledge into an expert knowledge set of data transformations and logical statements or operations, and uses such knowledge set on a data set or data derived from the data set (\u201chidden data\u201d herein) to more accurately classify the data set into populations.",
        "In one specific embodiment, the multi-dimensional data set comprises a data set obtained from a flow cytometer for one blood sample. The multi-dimensional data could of course be obtained from another analytical instrument or combination of instruments. In one further specific embodiment, the populations in the data set are associated with blood components, e.g., white blood cell components, in a sample of human or animal blood.",
        "In one specific embodiment, the expert knowledge set includes at least one geometric transformation for transforming the multidimensional data set or subset thereof. The expert knowledge may also include one or more probability transformations.",
        "The program code using the finite mixture model and the expert knowledge set can take a variety of forms and no specific structure or sequence to the programming operations is believed to be essential or critical. In one specific embodiment, the program instructions include a number of processing modules. In the specific embodiment, these modules include a pre-optimization module, an optimization module and a classification module.",
        "The pre-optimization module performs a scaling of the multi-dimensional data set. Such scaling can be performed to adjust the data for machine to machine variability given the most likely finite mixture model's parameters. The pre-optimization model may also make a selection of a finite mixture model from the library of finite mixture models, for example in the case where there are multiple models in the library and one is particularly suitable for use with the given sample.",
        "The optimization module seeks to adjust the parameters of the finite mixture model so as to best accommodate (model) the data being classified. To do so, it iteratively performs three operations: (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density functions of the selected finite mixture model.",
        "The expectation operation (1) computes an array of numbers (the array being an J\u00d7K matrix where J is equal to the number of events and K is the number of finite mixture model components) that is referred to herein as \u201chidden data\u201d, and referred to as such in the Expectation/Maximization algorithm literature. Such data is related to the probability that an event arose from each of the different density functions in the finite mixture model, and we will denote an entry in this array by Pr(Ci|xj,\u03a9). This hidden data is important to both the expectation and maximization operations and to the application of the expert knowledge set. In particular, the rules in the expert knowledge set adjusts these values preferentially based on expert knowledge about the interdependencies between the expected populations in the multi-dimensional data.",
        "The maximization operation updates each density function's parameters and the mixing coefficients based on the hidden data. From a simple perspective, if the hidden data were binary, which is to say one knew precisely which event class ought to be assigned to any event, updating the parameters would be easy since one would only include those events known to belong to a cluster and standard maximum likelihood estimate methods would suggest parameter updates. As one can observe from the maximization step description that follows, the hidden data simply serves as a weighting mechanism in the simple estimate formulas. The parameter update rules result from an algebraic solution to a gradient ascent optimization problem, in a manner known in the finite mixture model literature.",
        "The classification module is responsive to the output of the maximization operation for classifying the multi-dimensional data set into one or more populations. In one specific embodiment, the event classification step uses Bayes rule together with the parameter estimates returned from the model optimization (maximization) process. By Bayes rule, an event is then assigned to the class with the greatest class-specific posterior probability (Pr(Ci|xj,\u03a9)). These quantities incorporate changes made to each class's density function parameters during model optimization (expectation and maximization updates plus the use of expert rules from the expert knowledge set) and a final expectation step.",
        "In one specific embodiment, a post-classification module is provided which modifies the classification of the multi-dimensional data set using one or more expert rules from the expert knowledge set.",
        "In another aspect, a method is disclosed of identifying populations of events in a multi-dimensional data set. The method includes the steps of:",
        "(a) processing a sample with an analytical instrument, e.g., a flow cytometer, to thereby obtain a multi-dimensional data set;",
        "(b) storing the data set in a machine-readable memory;",
        "(c) selecting a finite mixture model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set; and",
        "(d) operating on the multi-dimensional data and the finite mixture model with the aid of an expert knowledge set to thereby identify populations of events in the multi-dimensional data set, wherein the expert knowledge set comprises one or more data transformations for operation on the multi-dimensional data set and one or more logical statements or operations, the transformations and logical statements encoding a priori expectations as to the populations of events in the data set.",
        "In one specific embodiment, the operations of step (d) include a pre-optimization step performing scaling of the multi-dimensional data set. The operations of step (d) further includes an optimization step which involves iteratively performing (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density function of the selected finite mixture model. The operations further include a classification step responsive to the output of the maximization operation for classifying the multidimensional data set into one or more populations. Optionally, post-classification steps are performed using one or more expert rules in the expert knowledge set.",
        "In still another aspect, a flow cytometry system is disclosed which comprises a flow cytometer and a data processing unit for processing data obtained from the flow cytometer. The system further includes a memory storing a finite mixture model, an expert knowledge set comprising logical operations and data transformations, and program code for execution by the processing unit for using the expert knowledge set and the finite mixture model to identify populations of events in the data obtained from the flow cytometer.",
        "In addition to the exemplary aspects and embodiments described above, further aspects and embodiments will become apparent by reference to the drawings and by study of the following detailed descriptions.",
        "Exemplary embodiments are illustrated in referenced figures of the drawings. It is intended that the embodiments and figures disclosed herein are to be considered illustrative rather than restrictive.",
        "FIG. 1 is a schematic representation of an analytical instrument and associated data processing unit in the form of a general purpose computer configured with a memory containing a library of finite mixture models, expert knowledge set and program code for implementing the methods disclosed herein for identifying populations within a multidimensional data set. In the example of FIG. 1, the data set is generated by an instrument in the form of a flow cytometer processing a human or animal blood sample.",
        "FIG. 2 is a simplified block diagram of the data processing unit of FIG. 1.",
        "FIG. 3 is a flow chart showing the major processing steps embodied in the program code to identify populations in the data set of FIG. 1.",
        "FIG. 4 is an illustration showing conceptually the operations performed by the modules in the flow chart of FIG. 3.",
        "FIG. 5 is an illustration of an input multi-dimensional data set and a library of finite mixture models for use in processing the input data in the method of shown in the flow chart of FIG. 3.",
        "FIG. 6 is an illustration of a rescaling operation performed by the pre-optimization processing step of FIG. 3.",
        "FIG. 7 is an illustration of a first aspect of an expectation step in the optimization module of FIG. 3.",
        "FIG. 8 is an illustration of a second aspect of an expectation step in the optimization module of FIG. 3.",
        "FIG. 9 is an illustration of a first aspect of the application of elements of the expert knowledge set, including transformation operations and logical statements, in the optimization module of FIG. 3.",
        "FIG. 10 is an illustration of a second aspect of the application of elements of the expert knowledge set, including transformation operations and logical statements, in the optimization module of FIG. 3.",
        "FIG. 11 is an illustration of a maximization step in the optimization module of FIG. 3.",
        "Overview",
        "As noted above, when a blood sample is passed through a flow cytometry system, the system generates N data points in multiple dimensions. In the present example, the flow cytometer obtains data in seven dimensions. The dimensions are referred to herein as \u201cchannels\u201d and are abbreviated EXT, EXT_Int, RAS, RAS_Int, FSL, FSH, and TOF, and have been defined previously. The physical properties of the different white blood cells cause light passing through them to scatter differently. For example, larger cells generally have greater EXT and EXT_Int values due to their greater light occlusion, while cells with greater internal complexity tend to produce greater light scatter and this is observed at the FSH detector. In a flow cytometry application of this invention, the goal of the methods described herein is to find, i.e., identify and classify, these populations in the midst of noise and to give quantitative or qualitative estimates on the relative frequencies of each white blood cell type. Obviously, in other applications of this invention the populations will correspond to other quantities and so the application in the field of flow cytometry is offered by way of example and not limitation.",
        "The sample-to-sample and machine-to-machine variability combined with varying degrees of noise resulting from unknown cellular events greatly complicate this classification problem and call for a robust analysis method that offers the ability to combine expert knowledge with stable unsupervised classifying algorithms. This disclosure provides such a robust analysis method.",
        "The present disclosure provides for a method and system for identifying populations in a multi-dimensional data set. The system contains two primary elements. Firstly, a library of finite mixture models is provided, components of which are probability density functions characterizing each population of events expected in the data set. One model is selected from the library for use in the processing described herein. The second element is an expert knowledge set encoding a priori \u201cexpert\u201d experience with the multi-dimensional data, expressed in the form of data transformations and logical statements or operations (\u201crules\u201d herein) concerning the expected populations.",
        "In a flow cytometry example, the expert knowledge set takes advantage of how an expert hematologist would approach the problem of finding population distributions in a data set (e.g., expected locations of the five WBC types). In particular, an expert has, as a result of previous information derived from blood manipulation studies, a good idea where population distributions fall in one or more two-dimensional projections of the seven-dimensional data. There are no necessary bounds on what might comprise an expert's a priori knowledge set, but examples include cluster position, geometric shape within some two-dimensional projections, and cluster position relative to other clusters. Such relationships often correspond to, and encode, known differences between the cell types, e.g. neutrophils are larger than most lymphocytes, and eosinophils contain more dense organelles than monocytes, etc. but could also arise from instrument specific knowledge. The present inventive methods provide an automated classification system and methods that rely on similar types of information, and, importantly, code such knowledge into an expert knowledge set of data transformations and logical statements or operations, and uses such knowledge set to more accurately classify the data set into populations.",
        "In a practical implementation of the method, the finite mixture models and the expert rules are stored in computer memory and used by a data processing unit, e.g. computer workstation, to automatically identify populations in the data set. The memory further stores program code for the computing system comprising instructions for operating on the multi-dimensional data, selecting a finite mixture model from the library of finite mixture models, and incorporating an expert knowledge set, to thereby identify populations of events in the multi-dimensional data set, as will be explained in detail below.",
        "The identification of populations in the multi-dimensional data set can be converted to quantitative or qualitative data presented in a human-perceptible form, such as a graph or plot of the data with color coding to identify discrete populations in the data set or as an output in terms of numbers or percentages of data points in the data set which are associated with the populations. As another example, the identified populations can be represented as one or more files in electronic from which can be stored in memory in the computer system, or transferred over a network to a computer workstation for further analysis or display to an operator (e.g., hematologist, veterinarian, or primary care physician).",
        "FIG. 1 is a schematic representation of one exemplary environment in the form of a flow cytometry system 10 that implements this invention. The system 10 includes a flow cytometer 12 having a flow cell 14 through which a sample 16, in this case human or animal blood, is passed. The flow cell 14 includes a laser light source 18 and a plurality of detectors 20, including one measuring the extinction of the light from the laser (EXT channel), a detector measuring Right Angle Scatter (RAS channel), a forward angle scatter detector (FSH channel), and possibly other detectors. Additionally, signal from one or more channels may be integrated over a time period to form an additional integration channel, e.g., RAS_Int channel. There as a total of seven channels in the illustrated embodiment. Thus, for each event (e.g. each cell passing through the flow cell 14) data is collected in seven channels. Such data is converted into digital form and supplied over a cable 22 to a data processing instrument 24, which may take the form of a general purpose computer workstation. The workstation includes a display 26 for presentation of the channel data, e.g., in the form of scatter plots, or presentation of textual reports indicating the relative frequencies of populations in the data collected by the flow cell 14. The workstation 24 may also include attached peripheral devices, e.g., printers, and may also include a connection to a local or wide area network so as to allow flow cytometry data to be shared with other computing resources or transmitted to a remote location such as a lab, primary care physician, hospital, etc. The data processing unit 24 may also be incorporated into the flow cytometer 12 itself.",
        "FIG. 2 is a block diagram of the data processing unit 24 of FIG. 1. The data processing unit 24 includes input and output circuitry for connecting the unit 24 to the analytical instrument and to any attached computer networks, a central processing unit 28, user interface devices 26, attached peripheral devices 32, and one or memory devices 34. The memory 34 may take the form of a hard disk memory. Such memory stores data sets and program code used in the methods described herein. The memory includes data representing a library of finite mixture models 40, an expert knowledge set 42 consisting of expert rules 44 in the form of code representing logical operations and statements, and geometrical and probability transformations 46 in the form of code. The memory 34 further stores the multi-dimensional flow cell data 52. The memory further stores executable program code and data structures 50 which operate on the flow cell data 52, one or more finite mixture models 40 in the library of models and the expert knowledge set 42. The memory further stores data representing scaling factors 54 which are used in a pre-optimization step to scale the data to account for machine to machine variability as will be explain in further detail later on.",
        "Finite Mixture Model Usage in Event Classification 40",
        "A finite mixture model is a finite weighted sum of probability density functions, one per population (or class). Specifically, a finite mixture model containing G probability density functions takes the form",
        "Pr\n      \u2061\n      \n        (\n        \n          \n            x\n            j\n          \n          |\n          \u03a9\n        \n        )\n      \n    \n    =\n    \n      \n        \u2211\n        \n          \n            i\n            =\n            1\n          \n          ,\n          \n            \n          \n          \u2062\n          \n            \u2026\n            \u2062\n            \n              \n            \n            \u2062\n            G\n          \n        \n      \n      \u2062\n      \n        \n          \u03c0\n          i\n        \n        \u2062\n        \n          \n            f\n            i\n          \n          \u2061\n          \n            (\n            \n              \n                x\n                j\n              \n              |\n              \u03a9\n            \n            )\n          \n        \n      \n    \n  \n  ,\n  \n    \n      with\n      \u2062\n      \n        \n      \n      \u2062\n      \n        \n          \u2211\n          \n            \n              i\n              =\n              1\n            \n            ,\n            \n              \n            \n            \u2062\n            \n              \u2026\n              \u2062\n              \n                \n              \n              \u2062\n              G\n            \n          \n        \n        \u2062\n        \n          \u03c0\n          i\n        \n      \n    \n    =\n    1\n  \n  ,\n\n\n\n\nand where \u03a9 is a vector of parameters including both the class weights \u03c0i and the individual density function parameters. G corresponds to the number of expected populations in the classification problem. Finite mixture models have attracted a great deal of attention from the Bayesian pattern recognition community where they consider each density function fi as a conditional probability of a data point arising from a density function characteristic of a given classifier Ci or outcome type. To emphasize this, the following notation for a finite mixture model is used:",
        "Pr\n      \u2061\n      \n        (\n        \n          \n            x\n            j\n          \n          |\n          \u03a9\n        \n        )\n      \n    \n    =\n    \n      \n        \u2211\n        \n          \n            i\n            =\n            1\n          \n          ,\n          \n            \n          \n          \u2062\n          \n            \u2026\n            \u2062\n            \n              \n            \n            \u2062\n            G\n          \n        \n      \n      \u2062\n      \n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                C\n                i\n              \n              |\n              \u03a9\n            \n            )\n          \n        \n        \u2062\n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                \n                  x\n                  j\n                \n                |\n                \n                  C\n                  i\n                \n              \n              ,\n              \u03a9\n            \n            )\n          \n        \n      \n    \n  \n  ,\n  \n    \n      with\n      \u2062\n      \n        \n      \n      \u2062\n      \n        \n          \u2211\n          \n            \n              i\n              =\n              1\n            \n            ,\n            \n              \n            \n            \u2062\n            \n              \u2026\n              \u2062\n              \n                \n              \n              \u2062\n              G\n            \n          \n        \n        \u2062\n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                C\n                i\n              \n              |\n              \u03a9\n            \n            )\n          \n        \n      \n    \n    =\n    1\n  \n  ,\n\n\n\n\nwhere the conditional nature of the density function is noted explicitly, and the weighting value \u03c0i have been replaced by Pr(Ci|\u03a9), (considered an a priori estimate of the probability of an observed data point xj having been generated from the outcome type Ci). Because the weighting values are not conditioned on the observed data point xj, they correspond to the relative frequency of events from each class (Ci).",
        "Given an optimized finite mixture model, it is common to classify data points 108 using the following classification schema\n\nClass(xj)=arg max{Pr(Ci|xj,\u03a9)|i=1, 2, . . . , G},\n\nwhere, according to Bayes' rule,",
        "Pr\n    \u2061\n    \n      (\n      \n        \n          \n            C\n            i\n          \n          |\n          \n            x\n            j\n          \n        \n        ,\n        \u03a9\n      \n      )\n    \n  \n  =\n  \n    \n      \n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                C\n                i\n              \n              |\n              \u03a9\n            \n            )\n          \n        \n        \u2062\n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                \n                  x\n                  j\n                \n                |\n                \n                  C\n                  i\n                \n              \n              ,\n              \u03a9\n            \n            )\n          \n        \n      \n      \n        Pr\n        \u2061\n        \n          (\n          \n            \n              x\n              j\n            \n            |\n            \u03a9\n          \n          )\n        \n      \n    \n    .\n  \n\n\n\n\nHence, given an optimized finite mixture model there is a natural way to classify points. The art in the use of a finite mixture model for classification lies in the optimization process itself.",
        "A variety of methods for deriving an optimized (or trained) finite mixture model exist in the literature. A novel optimization method is described next, which incorporates multiple levels of expert knowledge from the classification problem domain.",
        "Finite Mixture Model Library and Initial Model Selection",
        "As it happens, different patient samples demonstrate the presence of different types of cellular populations. One of the most notable population differences can be observed in the neutrophil populations of canine cancer patients, where several veterinarians have noted a \u201cleft-shift\u201d population. The \u201cleft-shift\u201d neutrophil population has a significantly lower RAS position than in a normal patient (on the same instrument), but it also demonstrates a marked shape change in the RAS_Peak by EXT_Peak projection (as opposed to having no significant shape differences in the FSH_Peak by TOF projection). In order to accommodate these different types of populations, the classifying algorithm allows for a library of possible populations, which amounts to a list of different Gaussian density functions for each expected event population. Hence, in the \u201cleft-shift\u201d classification problem, such a library would contain two distinct Gaussians for the neutrophil populations. And ideally, given a \u201cleft-shift\u201d sample, the algorithm would recognize this sample condition and elect to start the finite mixture model optimization process with the appropriate neutrophil density function.",
        "Note that a grouping formed of a choice of one density function for each cell type (or expected data class) from the library, with a weighting assigned to each density function, constitutes a finite mixture model. For example, a library that contained two neutrophil, three monocyte, and four lymphocyte densities would effectively define 2*3*4=24 possible finite mixture models. Each combination of density parameters determines a different finite mixture model and is denoted by \u03a9k. Since model optimization tries to find the most appropriate parameters for the classification problem (given the observed data), starting with an \u03a9k closest to the eventual solution saves computational time and increases the odds of finding the right classification. This leads us to a finite mixture model selection problem, which from a Bayesian perspective is solved by choosing the parameters \u03a9k that yield the greatest",
        "Pr\n    \u2061\n    \n      (\n      \n        \n          \u03a9\n          k\n        \n        |\n        X\n      \n      )\n    \n  \n  =\n  \n    \n      \n        \n          Pr\n          \u2061\n          \n            (\n            \n              \u03a9\n              k\n            \n            )\n          \n        \n        \u2062\n        \n          Pr\n          \u2061\n          \n            (\n            \n              X\n              |\n              \n                \u03a9\n                k\n              \n            \n            )\n          \n        \n      \n      \n        Pr\n        \u2061\n        \n          (\n          X\n          )\n        \n      \n    \n    .\n  \n\n\n\n\nAnd while Pr(X) is unknown, it is constant for a given data set X. Also, assuming statistical independence between the observations in X, we can expand",
        "Pr\n    \u2061\n    \n      (\n      \n        X\n        |\n        \n          \u03a9\n          k\n        \n      \n      )\n    \n  \n  =\n  \n    \n      \u220f\n      \n        \n          j\n          =\n          1\n        \n        ,\n        \n          \n        \n        \u2062\n        \n          \u2026\n          \u2062\n          \n            \n          \n          \u2062\n          N\n        \n      \n    \n    \u2062\n    \n      \n    \n    \u2062\n    \n      \n        \u2211\n        \n          \n            i\n            =\n            1\n          \n          ,\n          \n            \n          \n          \u2062\n          \n            \u2026\n            \u2062\n            \n              \n            \n            \u2062\n            G\n          \n        \n      \n      \u2062\n      \n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                C\n                i\n              \n              |\n              \n                \u03a9\n                k\n              \n            \n            )\n          \n        \n        \u2062\n        \n          \n            Pr\n            \u2061\n            \n              (\n              \n                \n                  \n                    x\n                    j\n                  \n                  |\n                  \n                    C\n                    i\n                  \n                \n                ,\n                \n                  \u03a9\n                  k\n                \n              \n              )\n            \n          \n          .\n        \n      \n    \n  \n\n\n\n\nHence, given some expectations on the frequencies of each possible finite mixture model described by a finite mixture model library, one can identify the best candidate for an initial FMM by finding\n\n\u03a9=arg max{Pr(\u03a9k)Pr(X|\u03a9k)|k=1, 2, . . . , K}.",
        "Data generated by different instruments within a fixed classification problem can also complicate the discrimination task. These differences can often be traced back to the manufacturing process for sensor standardization, and generally alter the locations and shapes of the populations being sought. Additionally, changes in the power output of the laser have the effect of moving populations in the seven-dimensional input space. While finite mixture model libraries could be constructed to accommodate these differences, and thereby allow one library specification for all machines, additional inventions are described herein that take advantage of the finite mixture model approach.",
        "Given any finite mixture model (and in practice one is probably best off choosing the most frequently used model from the library), one can assess how well the model fits that data set using",
        "Pr\n      \u2061\n      \n        (\n        \n          X\n          |\n          \n            \u03a9\n            k\n          \n        \n        )\n      \n    \n    =\n    \n      \n        \u220f\n        \n          \n            j\n            =\n            1\n          \n          ,\n          \n            \n          \n          \u2062\n          \n            \u2026\n            \u2062\n            \n              \n            \n            \u2062\n            N\n          \n        \n      \n      \u2062\n      \n        \n      \n      \u2062\n      \n        \n          \u2211\n          \n            \n              i\n              =\n              1\n            \n            ,\n            \n              \n            \n            \u2062\n            \n              \u2026\n              \u2062\n              \n                \n              \n              \u2062\n              G\n            \n          \n        \n        \u2062\n        \n          \n            Pr\n            \u2061\n            \n              (\n              \n                \n                  C\n                  i\n                \n                |\n                \n                  \u03a9\n                  k\n                \n              \n              )\n            \n          \n          \u2062\n          \n            Pr\n            \u2061\n            \n              (\n              \n                \n                  \n                    x\n                    j\n                  \n                  |\n                  \n                    C\n                    i\n                  \n                \n                ,\n                \n                  \u03a9\n                  k\n                \n              \n              )\n            \n          \n        \n      \n    \n  \n  ,\n\n\n\n\n(or the negative log of this quantity). Fixing the finite mixture model \u03a9k we have found it advantageous to maximize",
        "Pr\n    \u2061\n    \n      (\n      \n        \n          X\n          \u2297\n          s\n        \n        |\n        \n          \u03a9\n          k\n        \n      \n      )\n    \n  \n  =\n  \n    \n      \u220f\n      \n        \n          j\n          =\n          1\n        \n        ,\n        \n          \n        \n        \u2062\n        \n          \u2026\n          \u2062\n          \n            \n          \n          \u2062\n          N\n        \n      \n    \n    \u2062\n    \n      \n    \n    \u2062\n    \n      \n        \u2211\n        \n          \n            i\n            =\n            1\n          \n          ,\n          \n            \n          \n          \u2062\n          \n            \u2026\n            \u2062\n            \n              \n            \n            \u2062\n            G\n          \n        \n      \n      \u2062\n      \n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                C\n                i\n              \n              |\n              \n                \u03a9\n                k\n              \n            \n            )\n          \n        \n        \u2062\n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                \n                  \n                    x\n                    j\n                  \n                  \u2062\n                  s\n                \n                |\n                \n                  C\n                  i\n                \n              \n              ,\n              \n                \u03a9\n                k\n              \n            \n            )\n          \n        \n      \n    \n  \n\n\n\n\nwith respect to the M\u00d71 real-valued vector s (M=number of input channels). This maximization is referred to herein as the scaling factor search process 104 in the pre-optimization step (FIG. 3, 104) since the resulting vector st=(s1, s2, . . . , sM) expands or contracts the ith input coordinate by si. Many different search algorithms could be employed to find the desired scaling factor, and in the presently preferred implementation, once found, the finite mixture model selection criteria described above has been employed. This added pre-optimization step greatly reduces the required library's complexity and additionally reduces the classification algorithm's execution time.",
        "Expert Knowledge Set 42",
        "As noted above, the systems and methods of this disclosure use what is referred to herein as an expert knowledge set. This set consists of two sub elements: a collection of expert data transforms, and a collection of expert rules which may take the form of logical statements or logical operations. As the name implies, expert data transforms are mathematical functions that alter data in some fashion. From the mathematical perspective, the data collected by the analytical instrument can be thought of as a list of length N of seven dimensional vectors, where N is the number of digitized events. But one could just as well consider this data set as seven N-dimensional vectors, one vector for each input channel. The expert transformations act on these N-dimensional vectors, and output any number of similar vectors. The outputs can be thought of as derived coordinates since each observation has a value in each output. Such expert transforms come in several varieties, including geometrical, and probabilistic transforms, as will be explained below.",
        "A presently preferred implementation allows expert transform outputs to serve as inputs to any other transform. Moreover, once created, transform output vectors can be referenced by name and may be combined into other transforms (as inputs) or rule constructions (described below) without regard to their originating transform. This flexibility thereby allows any combination of hierarchies of inputs and data transformations to be used.",
        "On first glance the ability to transform the data does not appear to be a very powerful tool. In fact it would appear that these manipulations only serve to complicate the problem by adding any number of new coordinates above and beyond the original seven collection channels. While this is true, they benefit us by allowing an expert to modify the \u201cpresentation\u201d of the data to the classification algorithm, thereby emphasizing known aspects of the populations sought.",
        "A domain expert's knowledge is encoded in what is referred to herein as \u201cexpert rules\u201d (FIG. 2, item 44). Each rule contains two essential elements: a logical statement on the transform output vectors, and a list of population effects. The logical statement takes the form of a list of transform outputs together with an inequality for each (e.g. <=0 or >0). Such a list defines a subset of data points (possibly empty) that satisfies all inequalities on the list. We'll call this subset the rule's \u201ctrue domain,\u201d and its complement (points on which at least one of the logical statements is false), the rule's \u201cfalse domain.\u201d",
        "A rule's population effects consist of a list of population names (classes) and a weighting or posterior probability adjustment scalar for each. A rule is \u201capplied\u201d by multiplying those rows of the hidden data (Pr(Ci|xj,\u03a9)) corresponding to data points in the rule's true domain and those columns defined by the populations in the rule's list of effected populations by the adjustment scalar.",
        "Hence, for example, a rule that combines three expert data transforms to define a region in which neutrophils are expected to be plentiful would probably increase the odds of finding neutrophils in the True domain while decreasing the odds of finding a non-neutrophil event. And in the complementary region it would reduce the odds of finding neutrophils. Because the hidden data (Pr(Ci|xj,\u03a9)) plays a critical role in the model optimization mathematics, the expert rules are able to guide the classifying algorithm towards a preferred classification using simple logical statements, typically defined relative to the algorithm's best current estimate of population locations.",
        "Identification Method/Program Code 50",
        "Now that the finite mixture model and expert rules concepts have been described in more detail, this disclosure will proceed to describe a process or method by which these elements are combined and used in conjunction with a multi-dimensional data set to generate an event classification (i.e. identify populations). The process described subsequently is preferably coded in software and run on the analytical instrument or the data processing unit of FIG. 1. Pseudo-code for a main processing loop and main subroutines is set forth later, as are data structures that are used by the code.",
        "The computational process described below is fundamentally a maximization process. In particular, the process seeks the assignment of events in the multi-dimensional data to each Gaussian density in such a way as to yield the highest overall probability that the semi-parametric finite mixture model generated the data. As is common with these types of computations, they can find sub optimal solutions (local minima) and get struck there. The machine learning literature contains many heuristics that address this problem. The present solution avoids such problems by using an unsupervised clustering algorithm modified to include input in the form of expert knowledge, coded as expert transformations and rules, as will be explained now in detail.",
        "FIG. 3 is a flow chart showing, in conceptual form, the major processing steps embodied in the program code to identify populations in the a multidimensional data set 52 obtained from an analytical instrument, e.g., flow cytometer of FIG. 1. The code operates on a data set obtained by processing a sample in the instrument and collecting, digitizing and storing the multidimensional data, indicated at 102. The program code 100 includes a pre-optimization module 104. This module does two operations: 1) applies a linear scaling factor to the data collected at step 102 and 2) selects a finite mixture model from the library in the manner described above. The model optimization module 106 iteratively 106D performs three operations: (1) an expectation operation on at least a subset of the multi-dimensional data set (commonly referred to as the Expectation step in the Expectation-Maximization Algorithm literature) 106A, (2) an application of the expert knowledge set to data resulting from the expectation operation 106B, and (3) a maximization operation updating parameters associated with the density function of the selected finite mixture model 106C.",
        "Still referring to FIG. 3, the event classification module 108 of FIG. 3 is responsive to the output of the optimization module (i.e., a final expectation operation) and performs a classifying of the multi-dimensional data set into one or more populations. This module codes the operation:\n\nClass(xj)=arg max{Pr(Ci|xj,\u03a9)|i=1, 2, . . . , G} discussed above.",
        "The program code optionally includes a post-classification module 110 which modifies the classification of the multidimensional data set using one or more expert rules from the expert knowledge set. The program code further includes a module 112 returning results to the operator, e.g., by displaying the data on a monitor with color coding to indicate how the data was classified, providing quantitative results as to the classification, or other output method, such as storing the classification data in a file and making it available either locally or remotely to an operator or customer.",
        "FIG. 4 is an illustration showing, in simplified form, the operations performed by the modules in the flow chart of FIG. 3. The input data set 52 consists of multi-dimensional data, which can be represented as projections in two dimensions by plotting data values in a coordinate system with the X and Y axes being two channels selected in the seven available channels. Such data exists in raw form. The pre-optimization module 104 takes the data points and multiplies their values by a scalar in seven dimensions to thereby calculate a scaled data set 52\u2032. Following completion of the scale factor search, a finite mixture model 40 is selected from the library of models. The model 40 consists of a set of weighted probability density functions, each of which are shown by the ellipses 40. Each ellipse (probability density function) is associated with an expected population in the data set, e.g., the ellipse with the letter N represents the neutrophils probability density function, the ellipse with the letter E represents the eosinophil probability density function, M represents monocytes, etc. Such probability density functions are defined on all seven dimensional vectors, so the ellipses shown in FIG. 4 should only be interpreted as two dimensional representations of these higher dimensional density functions (perhaps suggestive of the density function's ninetieth percentile in the chosen two dimensional projection).",
        "As mentioned previously, the model optimization module 106 consists of three separate sub-steps: expectation 106A, application of expert rules 106B, and maximization 106C, performed in an iterative manner indicated by the arrow 106D. The expectation step 106A computes the \u201chidden data\u201d, which estimates the posterior probability of each event given the current estimates for each class density function. The expert knowledge set module 106B transforms the data set and uses logical statements to identify interesting subsets of the data set on which adjustments are made to the probability values assigned in the expectation step 106A. The maximization step 106C modifies the parameters in the finite mixture model (the mean vector and covariance matrix defining the probability density function), essentially changing the shape of the model using the hidden data and the results from the application of the expert knowledge set in step 106B. The process loops back and modules 106A, 106B and 106C repeat if necessary until a maximization criteria (fit between the finite mixture model and scaled data set) is met. At step 108, the classification module executes and the individual events in the data set are classified as being a member of a single population, e.g., eosinophil, monocyte, basophil, neutrophil, etc. Post-classification adjustments, if necessary, are performed at this stage. FIG. 4 also shows the effects of the output results module 112, e.g., the data is presented as a two-dimensional plot with the data points color coded to show their membership in discrete populations 109. The output results module may also give absolute numbers or percentages, such as the percent of the events being in each population, the total number of events in each population, the concentration of a population, e.g., number of neutrophils per liter of blood, or in any other appropriate form.",
        "The modules 104, 106 and 108 of FIGS. 3 and 4 will now be described in further detail.",
        "A. Pre-Optimization 104 (FIGS. 3, 4, 5, 6)",
        "The pre-optimization module 104 starts by accessing the multi-dimensional data 52 and a library of finite mixture models 40, shown in FIG. 5. The data 52 is represented schematically as a two dimensional plot as is customary in this art. The library of finite mixture models 40 includes seven dimensional weighted Gaussian probability density functions, one for each expected population in the data set 52. More than one probability density function may exist for each population. The library in this example consists of two lymphocyte density functions 40A and 40B, two monocytes density functions 40C and 40D, one eosinophils density function 40E, and three neutrophil density functions 40F, 40G and 40H.",
        "The pre-optimization module 104 step has several functions: A first function is to find scalars s1, . . . s7 such that s1*X1, s2*X2, . . . s7*X7 has the highest probability of being generated from at least one FMM combination from the library. X1, . . . , X7 are a N\u00d71 vector of the multi-dimensional data, where N is the number of events and 1 . . . 7 index the seven channels. The second pre-optimization function is to record the finite mixture model (set of individual density functions 40) that yield the highest total probability. This finite mixture model serves as an initial guess for the optimized model's parameters, and will be used in the subsequent processing. Both of these functions were described previously in the discussion concerning the selection of an initial finite mixture model from the library. A third pre-optimization function is to remove data associated with control particles in the sample from the data set so as to avoid assigning a control particle to one of the expected populations in the data set, and to reduce calculation time.",
        "The result of the operation of the pre-optimization module is scaled data and initial finite mixture model parameters. This is shown in FIG. 6. Comparing FIG. 6 with FIG. 5, it can be seen that the data set is extended out away from the origin (as a result of application of the scaling operation), and a subset of all the probability density functions in the library has been elected\u2014one density function for lymphocytes 40B, one 40D for monocytes, one 40E for eosinophils, and one 40G for neutrophil, collectively forming a finite mixture model. The point cloud 53 represents non-white blood cells and there is no probability density function used for this population. The point cloud 55 represents control particles and this data is removed from the data set, as indicated by the X.",
        "The rationale for the pre-processing step is that one needs to find reasonable starting conditions (parameters) for the finite mixture model, and remove the control particles from the data passed to the later steps. Machine-to-machine standardization differences complicate the general classification problem (this is primarily the result of historical standardization practices and the fact that previous classifying algorithms used a reduced dataset). The primary source of machine-to-machine standardization differences can be traced back to the channel gains used during the digitized data collection process. These gains are set during the manufacturing process and have been observed to vary over the product manufacturing cycle. Generally speaking, the manufacturing standardization process adjusts the gains so as to position the control particle's centroid position at a specific location in a subset of the seven collection channels, while placing loose specifications for those not used by the current white blood cell classification algorithm. These adjustments are judged acceptable by a human observer who has access to the scatter plots and the classifying algorithm's performance. This disclosure replaces this human observer with a mathematical function, one that assesses algorithm performance (or potential performance). Instead of altering the electronic gains (as the manufacturing technician would), the algorithm uses seven scalar multipliers (one for each input channel) to move the data in space so as to maximize the likelihood the data arose from a specified model in the library of all possible finite mixture model combinations.",
        "Since the flow cytometer (e.g. the LASERCYTE) generates seven-dimensional datasets, there will be seven scaling factors. These factors are generally expected to be around 1.0, but have been seen to vary from 0.5 to 2.0 for some machines.",
        "B. Model Optimization 106 (106A, 106B and 106C, FIGS. 3, 4, 7-11)",
        "The model optimization module 106, and specifically sub-steps 106A, 106B and 106C of FIGS. 3 and 4 will now be discussed in conjunction with FIGS. 7-11.",
        "Conceptually, the model optimization module 106 seeks to adjust the parameters of the initial finite mixture model (FIG. 6, probability density functions 40B, 40D, 40E, 40G) so as to best accommodate (model) the data being classified. This step consists of three steps performed iteratively. These are an expectation step 106A (FIGS. 7 and 8), an expert knowledge set application step 106B (transformations and logical operations) (FIGS. 9 and 10), and a maximization step 106C (FIG. 11). Because we adjust (or bias) the hidden data in this optimization process, it differs from those found in the general Expectation-Maximization algorithm (Dempster et al., 1967). Before going through each of these individually, a few general comments are offered initially.",
        "Because the goal at this stage of the computation is to estimate the best parameters for the finite mixture model (given the initial model parameters, the scaling adjustments, and any applied Expert Rules), it is possible to operate on a subset of the entire collected data set (see SubsetSize parameter in MVN_Collection definition described below). Hence the developer has the option of specifying an optimization dataset size and the algorithm will randomly select (uniformly distributed across all events) a subset on which to optimize. Some of the advantages of sub-sampling for optimization include: reduced influence of rare noise in convergence, and speed. However, the first advantage also plays against us because rare populations may not be sufficiently well represented in order for the model to find them.",
        "One way to increase the chances of finding rare populations, and one that is uniquely available because of the use of a finite mixture model, is to add pseudo rare population events to the dataset based on the density function selected in the initial model search process. This is enabled via a list of populations from which to simulate data and simulation parameters that determine the number of pseudo-events to create and any modifications to the densities themselves, e.g. shrunken covariance (see MVNEMSimulateEvents parameters in the MVN_Collection definition). These events are appended to the random subset of events used for optimization, and are removed before the final event classification step in which all events (not just the optimization subset) are classified.",
        "Step 1. Expectation (E) (106A, FIGS. 7 and 8)",
        "The (s+1)st iteration of the Expectation step 106 in the optimization module 106 computes an array of numbers (numEvents\u00d7numModelComponents) that the literature often refers to as the hidden data. Specifically, this data is related to the probability that an event arose from each of the different density functions in the finite mixture model. We will denote an entry in this array by Pr(Ci|xj,\u03a9(s+1)) (or zij(s+1) as is common in the literature) where",
        "z\n          ij\n          \n            (\n            \n              s\n              +\n              1\n            \n            )\n          \n        \n        =\n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                \n                  C\n                  i\n                \n                |\n                \n                  x\n                  j\n                \n              \n              ,\n              \n                \u03a9\n                \n                  (\n                  \n                    s\n                    +\n                    1\n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n  \n  \n    \n      \n        =\n        \n          \n            \n              Pr\n              \u2061\n              \n                (\n                \n                  \n                    C\n                    i\n                  \n                  |\n                  \n                    \u03a9\n                    \n                      (\n                      s\n                      )\n                    \n                  \n                \n                )\n              \n            \n            \u2062\n            \n              Pr\n              \u2061\n              \n                (\n                \n                  \n                    \n                      x\n                      j\n                    \n                    |\n                    \n                      C\n                      i\n                    \n                  \n                  ,\n                  \n                    \u03a9\n                    \n                      (\n                      s\n                      )\n                    \n                  \n                \n                )\n              \n            \n          \n          \n            Pr\n            \u2061\n            \n              (\n              \n                x\n                |\n                \n                  \u03a9\n                  \n                    (\n                    s\n                    )\n                  \n                \n              \n              )\n            \n          \n        \n      \n    \n  \n  \n    \n      \n        \n          =\n          \n            \n              \n                Pr\n                \u2061\n                \n                  (\n                  \n                    \n                      C\n                      i\n                    \n                    |\n                    \n                      \u03a9\n                      \n                        (\n                        s\n                        )\n                      \n                    \n                  \n                  )\n                \n              \n              \u2062\n              \n                Pr\n                \u2061\n                \n                  (\n                  \n                    \n                      \n                        x\n                        j\n                      \n                      |\n                      \n                        C\n                        i\n                      \n                    \n                    ,\n                    \n                      \u03a9\n                      \n                        (\n                        s\n                        )\n                      \n                    \n                  \n                  )\n                \n              \n            \n            \n              \n                \u2211\n                \n                  \n                    m\n                    =\n                    1\n                  \n                  ,\n                  \n                    \n                  \n                  \u2062\n                  \u2026\n                  \u2062\n                  \n                    \n                  \n                  ,\n                  G\n                \n              \n              \u2062\n              \n                \n                  Pr\n                  \u2061\n                  \n                    (\n                    \n                      \n                        C\n                        m\n                      \n                      |\n                      \n                        \u03a9\n                        \n                          (\n                          s\n                          )\n                        \n                      \n                    \n                    )\n                  \n                \n                \u2062\n                \n                  Pr\n                  \u2061\n                  \n                    (\n                    \n                      \n                        \n                          x\n                          j\n                        \n                        |\n                        \n                          C\n                          m\n                        \n                      \n                      ,\n                      \n                        \u03a9\n                        \n                          (\n                          s\n                          )\n                        \n                      \n                    \n                    )\n                  \n                \n              \n            \n          \n        \n        ,\n      \n    \n  \n\n\n\n\nis computed based on the previous iteration's values for the mixing coefficients Pr(Ci|\u03a9(s)), and the density function's parameters \u03a9(s). This hidden data is core to both the EM algorithm (see algorithm details below) and the Expert Rules (which adjusts these values preferentially based on expert knowledge about the interdependencies between the sought after event populations).",
        "The expectation step is conceptually illustrated in FIGS. 7 and 8. FIG. 7 shows the scaled data set 52\u2032 and points 53A-53E each representing an event in the multi-dimensional data. For each point in the multi-dimensional data, the module 106A computes a probability, based on the values of event data and the parameters of the probability density functions in the mixture model, that that event is a member of each of the classes represented by the Gaussian probability density functions 40B, 40D, 40E and 40G forming the finite mixture model. Such probability values (array of numbers) are the \u201chidden data\u201d and is stored in the memory of the processing unit.",
        "FIG. 8 shows in graphic form the so-called hidden data as a probability assignment indicated by square on a probability axis. Each event data point 53A-E is shown as having a probability axis 60, and the position of the square 62 on the axis 60 indicates relative probability (a value between 0 and 1). In the left half of FIG. 8, the location of the square 60 on the probability axis 62 indicates the probability that the given data point is a member of the neutrophil (\u201cN\u201d) class 40G Point 53A is located close to the center of the ellipse 40G, so it has a high probability, as indicated by the position of the square 62 close to the left hand edge of the axis towards a probability of \u201c1\u201d. Conversely, point 53E is farther from the center of the neutrophil probability distribution 40G, and hence has a probability value closer to 0 on the probability axis 60. The right hand side of this figure shows the same assignment of probability, but this time for the monocyte probability density 40D. Point 53D is relatively close to the center of the monocytes probability density 40D and so has a square 62 positioned close to the \u201c1\u201d end of the probability axis 60, indicating that a high probability is assigned to this event.",
        "Such assignments as shown in FIG. 8 are made for all events (or a subset of events in an alternative embodiment), and for all probability distributions in the finite mixture model.",
        "Step 2. Application of Expert Knowledge Set (106B, FIGS. 4, 9 and 10)",
        "The module 106B (FIG. 4) of the optimization module provides for the application of the expert knowledge set to the hidden data and specifically provides for transformation operations and application of logical statements (\u201cexpert rules\u201d) on the hidden data resulting from the expectation process. The expert transformation operations can consist of geometrical operations (e.g. polar angle and radial distance transformations) or probability operations such as a Mahalanbois Distance transformation based on specific populations (classes) in the finite mixture model.",
        "An example of a geometrical transformation will be described first. Select two channels from the original seven channels, say RAS_Peak and EXT_Peak, and suppose for this example that there are 10,000 events in a given sample. Since each of the 10,000 data points has a RAS_Peak and EXT_Peak coordinate, we can compute the polar coordinates (relative to RAS_Peak and EXT_Peak) and output both the angle made between each point and the RAS_Peak axis (for example) and the distance of that point from the origin. In the language of the expert data transform, the input vectors here are the RAS_Peak vector and the EXT_Peak vector, each of length 10,000, while the outputs would be two new vectors, say RAS_Peak\u00d7EXT_Peak PolarAngle and RAS_Peak\u00d7EXT_Peak RadialDistance, each also of length 10,000\u2014one pair for each event in the digitized dataset. While this example has two input and two output vectors there is no limit to the number of inputs or outputs, nor any constraint that there be an equal number of inputs and outputs. In fact many transforms have multiple inputs and only one output vector.",
        "In addition to transforming data a transform must select a special point in each of its the output vectors, namely the zero point. These zero points define logical conditionals on the event data set, specifically, an event is either greater than or equal to zero or it is less than zero. Formally, if there are M*>M possible transform outputs, the choice of a zero point in any one output corresponds to an (M*\u22121)-dimensional hyper plane in M* dimensional space. The choice of a zero point corresponds to an affine codimension one hyper plane and a test for <=0 or >0 selects one side of each hyper plane.",
        "The following example of FIGS. 9 and 10 is offered to illustrate conceptually this process for one such expert rule. Each bold line 70A and 70B in FIGS. 9 and 10 corresponds to the zero hyper plane for one transform. In this case, both level sets 70A and 70B represent polar angle transforms where the difference between these two sets lies in the choice of specific zeros (angles). Zero hyper plane 70A is chosen to separate the neutrophils 40G and eosinophils 40E from the monocytes 40D, while 70B places its zero so as to separate monocytes 40D and eosinophils 40E from the neutrophils 40G.",
        "Alternative transforms may move the zero point in the collected data channels to the expected location of the neutrophil centroid 40G. Or, one may prefer to center the data at a point two standard deviations from the neutrophil centroid in RAS_Peak channel so that an event greater than zero has less than a 95% chance of being a neutrophil. For either of these outputs, we can assign a logical true/false value to each event in the input dataset according to whether it is above or below zero. In this fashion, an output vector implies a logical statement about each event in the dataset.",
        "The Expert Rule application operates on the hidden data values estimated during the previous E-step, taking into account the zero point transformations just performed. Recall that each rule is constructed by the conjunction of a finite list of logical statements on the events (in this case those events selected for model optimization) that defines a True and False domain for that rule together with a list of population classes and associated weighting factors for each domain. The True and False domains correspond to two subsets of rows in the hidden data array, those rows associated with events falling into the True domain and its complimentary set of rows respectively. The population lists associated with these domains identify columns in the hidden data array, and the expert provided weights tell us how to modify (by multiplication) the hidden data for each column and subset of rows.",
        "Formally, each expert rule is defined as a pairing (L,E) where L=((ls,bs):s=1, . . . , S) is a collection of pairs of (M*\u22121) dimensional hyper planes ls within the space of the input channels and the expert transform outputs (dimension=M*) and sidedness indicators bs, and E=(et=(Pt, wt):t=1, . . . , T) is a collection of pairs of expected population identifiers Pt (e.g. class names or finite mixture model component indices) and scalar values wt. Note that a (M*\u22121) dimensional hyper plane is defined by one of the transform outputs where the sidedness indicator takes the form of a simple inequality. Hence there is a one-to-one correspondence between each (ls, bs) pairing and a specific transform output and designated zero point in that output coordinate. For lack of a better notation, the rule can be stated as follows:",
        "l\n      s\n    \n    \u2061\n    \n      (\n      \n        x\n        j\n      \n      )\n    \n  \n  =\n  \n    {\n    \n      \n        \n          \n            true\n            ,\n          \n        \n        \n          \n            \n              if\n              \u2062\n              \n                \n              \n              \u2062\n              \n                \n                  l\n                  s\n                \n                \u2061\n                \n                  (\n                  \n                    x\n                    j\n                  \n                  )\n                \n              \n            \n            \u2264\n            \n              b\n              s\n            \n          \n        \n      \n      \n        \n          \n            false\n            ,\n          \n        \n        \n          otherwise\n        \n      \n    \n  \n\n\n\n\nTo apply this rule, first define R(X) to be the set of data points lying on the designated side of all hyper planes in L as follows\n\nR(X)={xj|ls(xj)=true, s=1, . . . , S},\n\nwhich is a subset of the data set X and corresponds to what we've called the rule R's true domain. And given this notation, rule R's effects on the hidden data is Pr(Ci|xj,\u03a9)=wi*Pr(Ci|xj,\u03a9) for any xj in R(X) and each i in {Pl: t=1, . . . , T}. The factors wi are probability weighting factors.",
        "The right hand side of FIG. 9 depicts conceptually the effects of the weighting factors wi on the neutrophil column of the hidden data. The \u201ctrue domain\u201d is determined as those points (events) having a value that is above the zero vector 70A the neutrophil expert rule AND below the zero vector 70B. Point 53A satisfies this criteria, and so its probability value (location of square 62 on the probability axis 60), is increased, as can be seen by a comparison between the left hand side of FIG. 9 with the right hand side of FIG. 9 for this point. All of the other data points 53 shown in FIG. 9 do not satisfy this criteria, and so their probability assignments (represented by the position of the squares 62 on the probability axes 60) are lowered, as indicated by the movement of the squares towards the zero end of the probability axes 60 (compare left side of FIG. 9 to right side of FIG. 9).",
        "These expert rules 44 are shown in FIG. 9 has having two separate components: a rules component comprising logical statements 44A and actions 44B operating on the probability values assigned to the events in the hidden data, namely one action increasing the probability of an event being a neutrophil if the rules 44A are satisfied and decreasing the probability of an event belonging to the neutrophil population if the rules are not satisfied. Three logical statements 44A are shown, the first two of which define the zero point hyper planes shown as vectors 70A and 70B and a third statement (>R7+3TOF SD) defining a third hyper plane, the two dimensional projection of which is not shown in order to avoid cluttering FIG. 9. The third vector (not shown) could be considered as defining the third side of the triangle 74 representing a region in seven dimensional space defined by the rules 44A. In the nomenclature of the rules 44A of FIG. 9, SD represents \u201cstandard deviation\u201d, and the three rules define the three zero point planes described above and, by implication, the true and false domains depending on where a given event lies relative to the union or intersection of such planes.",
        "FIG. 9 shows the application of the expert transformations and rules for one population Gaussian density distribution, namely density 40G. FIG. 10 shows that the operation described above can be applied for more than one probability density (or class) in the mixture model. In particular, FIG. 10 shows that each point (event) 53 has two probability values assigned to it, again represented by the position of a square 62 on a probability axis 60. The second probability axis in FIG. 10 is the probability that the event is associated with the monocytes class 40D in the mixture model. Take for example point 53D. Axis 60A represents the probability axis for the event 53D belonging to the neutrophil population. Axis 60B represents the probability that the event 53E belongs to the monocyte population. Comparing the left hand side of FIG. 10 with the right hand side of FIG. 10, the square 62B is moved closer to the \u201c1\u201d end of the probability axis 60B due to the position of the event 53 relative to the zero hyper planes 70A and 70B\u2014above vector 70B but below vector 70A (i.e., in the false domain for the neutrophil expert rule). Similarly, the square 62B for point 53E is moved towards the \u201c1\u201d end of the probability axis 60B due to its position relative to the zero hyper planes. These actions are represented by the actions aspect 44B of the expert rules. Specifically, these actions modify probability assignments represented by the hidden data matrix.",
        "These operations are performed for all points in the event data set and for all components of the mixture model. Moreover, the program code may specify any number of these rules and transforms as needed for the classification problem at hand.",
        "Step 3. Maximization (M) (106C, FIGS. 4, 11)",
        "The Maximization step of the EM algorithm updates each density function's parameters and the mixing coefficients based on the hidden data, as modified by the application of the expert rules module 106C. This operation is represented schematically in FIG. 11 by moving, and changing the shapes, of each of the probability density functions 40B, 40D, 40E, 40G forming the finite mixture model as indicated at 40B\u2032, 40D\u2032, 40E\u2032, 40G\u2032.",
        "From a simplified perspective, if the hidden data were binary, which is to say we knew precisely which event class ought to be assigned to any event, updating the parameters would be easy since one would only include those events known to belong to a cluster and then one would use standard maximum likelihood estimate methods, for example, the maximum likelihood estimate for a populations mean is the mean vector of all events belonging to that population. As one can observe from the M-step formulas (below), the hidden data simply serves as a weighting mechanism in the simplified estimate formulas. While this satisfies the casual observer, it must be noted that the parameter update rules actually result from an algebraic solution to a gradient ascent optimization problem (see standard references on finite mixture model optimization).",
        "Because the disclosed methods use an unconstrained update method in the implementation of the M-step, several problems can arise. Most notably, when an expected population is poorly represented in a data file, the maximum likelihood estimate for its covariance matrix may collapse. Additionally, but more from the perspective of the specific application, some populations must always be present in a white cell count. Both of these situations are controlled using two modifications to the standard M-step. First, a minimum prior threshold is placed on each density function in the finite mixture model. Second, the code allows the expert to include some representation from the initial finite mixture model's mean and covariance matrices. Regarding the prior threshold, once a component's prior drops below its threshold, the component is removed from the continuing calculations while its parameters are frozen at their current values. If a deactivated classifier corresponds to an expected population that is required in the final report, their finite mixture model components will be reactivated prior to event classification and the component's initial parameter values will be used.",
        "The other way in which the implementation differs from a standard version of the maximization step in the EM algorithm is the use of priors placed on each population's parameters. Specifically, the mean and covariance parameters for each component in the finite mixture model can be biased (in a Bayesian manner as is commonly used in an Monte Carlo Markov Chain optimization approach) toward the initial density function's parameters. Implementation specific parameters determine how much biasing is used in the M-step formulas.",
        "Note that extreme biasing (strongly defined population parameter priors) can potentially cause a population to remain fixed at its initial settings. A finite mixture model component of this nature can be considered so stable as to never need updating. It is common to use this technique for the density function associated with a control particle, which tends to be easy to find in most files and whose density function is therefore very generic (large covariance eigenvalues).",
        "Formally, the (s+1)st iteration of the maximization step uses the following formulas for updating the parameters to each component's density function. Specific parameters that are updated are the mixing coefficients",
        "Pr\n      \u2061\n      \n        (\n        \n          \n            C\n            i\n          \n          |\n          \n            \u03a9\n            \n              (\n              \n                s\n                +\n                1\n              \n              )\n            \n          \n        \n        )\n      \n    \n    =\n    \n      \n        \u2211\n        \n          j\n          =\n          1\n        \n        n\n      \n      \u2062\n      \n        \n          z\n          ij\n          \n            (\n            s\n            )\n          \n        \n        n\n      \n    \n  \n  ,\n\n\n\n\nthe mean estimate for each class's Gaussian density function",
        "\u03bc\n      i\n      \n        (\n        \n          s\n          +\n          1\n        \n        )\n      \n    \n    =\n    \n      \n        \n          \n            \u2211\n            \n              j\n              =\n              1\n            \n            n\n          \n          \u2062\n          \n            \n              z\n              ij\n              \n                (\n                s\n                )\n              \n            \n            \u2062\n            \n              y\n              j\n            \n          \n        \n        +\n        \n          \n            \u03ba\n            i\n          \n          \u2062\n          \n            \u03bc\n            i\n            \n              (\n              0\n              )\n            \n          \n        \n      \n      \n        \n          \n            \u2211\n            \n              j\n              =\n              1\n            \n            n\n          \n          \u2062\n          \n            z\n            ij\n            \n              (\n              s\n              )\n            \n          \n        \n        +\n        \n          \u03ba\n          i\n        \n      \n    \n  \n  ,\n\n\n\n\nwhere \u03bai is a real number that weighs in some amount of the initial mean vector, and the covariance matrix for each class's Gaussian density function",
        "\u2062\n    \n      \n        \n          V\n          i\n          \n            (\n            \n              s\n              +\n              1\n            \n            )\n          \n        \n        =\n        \n          \n            \n              \u2211\n              \n                j\n                =\n                1\n              \n              n\n            \n            \u2062\n            \n              \n                \n                  z\n                  ij\n                  \n                    (\n                    s\n                    )\n                  \n                \n                \u2061\n                \n                  (\n                  \n                    \n                      y\n                      j\n                    \n                    -\n                    \n                      \u03bc\n                      i\n                      \n                        (\n                        \n                          s\n                          +\n                          1\n                        \n                        )\n                      \n                    \n                  \n                  )\n                \n              \n              \u2062\n              \n                \n                  (\n                  \n                    \n                      y\n                      j\n                    \n                    -\n                    \n                      \u03bc\n                      i\n                      \n                        (\n                        \n                          s\n                          +\n                          1\n                        \n                        )\n                      \n                    \n                  \n                  )\n                \n                t\n              \n            \n          \n          \n            \n              \u2211\n              \n                j\n                =\n                1\n              \n              n\n            \n            \u2062\n            \n              z\n              ij\n              \n                (\n                s\n                )\n              \n            \n          \n        \n      \n      ,\n      \n        \n\n      \n      \u2062\n      \n        \n      \n      \u2062\n      and\n    \n  \n\n\n\n\n  \n    \n      \n        \u03a3\n        i\n        \n          (\n          \n            s\n            +\n            1\n          \n          )\n        \n      \n      =\n      \n        \n          \n            (\n            \n              \u03a3\n              i\n              \n                (\n                0\n                )\n              \n            \n            )\n          \n          \n            -\n            1\n          \n        \n        +\n        \n          \n            V\n            i\n            \n              (\n              \n                r\n                +\n                1\n              \n              )\n            \n          \n          \u2062\n          \n            \n              \u2211\n              \n                j\n                =\n                1\n              \n              n\n            \n            \u2062\n            \n              z\n              ij\n              \n                (\n                s\n                )\n              \n            \n          \n        \n        +\n        \n          \n            \n              \n                \u03c1\n                i\n              \n              \u2062\n              \n                \n                  \u2211\n                  \n                    j\n                    =\n                    1\n                  \n                  n\n                \n                \u2062\n                \n                  z\n                  ij\n                  \n                    (\n                    s\n                    )\n                  \n                \n              \n            \n            \n              \n                \u03c1\n                i\n              \n              +\n              \n                \n                  \u2211\n                  \n                    j\n                    =\n                    1\n                  \n                  n\n                \n                \u2062\n                \n                  z\n                  ij\n                  \n                    (\n                    s\n                    )\n                  \n                \n              \n            \n          \n          \u2062\n          \n            (\n            \n              \n                \u03bc\n                i\n                \n                  (\n                  \n                    r\n                    +\n                    1\n                  \n                  )\n                \n              \n              -\n              \n                \u03bc\n                i\n                \n                  (\n                  0\n                  )\n                \n              \n            \n            )\n          \n          \u2062\n          \n            \n              (\n              \n                \n                  \u03bc\n                  i\n                  \n                    (\n                    \n                      r\n                      +\n                      1\n                    \n                    )\n                  \n                \n                -\n                \n                  \u03bc\n                  i\n                  \n                    (\n                    0\n                    )\n                  \n                \n              \n              )\n            \n            t\n          \n        \n      \n    \n    ,\n  \n\n\n\nwhere zij(s)=Pr(Ci|xj,\u03a9(s)) is the hidden data values from the recently completed Expectation step, and \u03c1i biases a population's covariance matrix towards the initial matrix \u03a3i(0). These update formulas are specific to the use of Gaussian density functions, but are founded on standard Bayesian priors.",
        "After the maximization process completes and new parameters for the finite mixture model density distributions are assigned, the process loops back to the expectation step 106A and the process of 106A, 106B and 106C described above repeats until a close fit between the model and the data set is achieved. The closeness required to cease execution of the iterations is a configurable parameter in the algorithm. After the final maximization iteration, a final application of the expectation step 106A is then performed and then the classification process 108 executes.",
        "C. Classification (108, FIG. 3, 4, 11)",
        "The event classification step uses Bayes rule together with the parameter estimates returned from the model optimization process (106C) to assign events in the multidimensional data to one of the expected populations. Prior to this, we must extend the hidden data calculations returned from the model optimization (potentially computed on a random subset of the collected events), re-activate any components of the finite mixture model that may have been silenced during optimization (including the control particle component if these events were hidden during the model optimization), and drop any simulated pseudo-events. Once the hidden data is computed for the entire dataset, the developer has the option of applying expert rules for an optional post classification step (discussed below).",
        "By Bayes rule, an event is then assigned to the class with the greatest class-specific posterior probability (Pr(Ci|xj,\u03a9)), and in particular:\n\nClass(xj)=arg max{Pr(Ci|xj,\u03a9)|i=1, 2, . . . , G}.",
        "These quantities incorporate changes made to each class's density function parameters during model optimization (EM updates plus Expert Rules) and a final E-step.",
        "D. Optional Post-Classification Processing 110 (FIG. 3)",
        "The post-classification process serves as a \u201cclean-up\u201d step because it allows the expert rules to examine the final classification resulting from step 108 and, depending on an event's classification, where it falls relative to a rule's True or False domain and the relative class frequency, it may be reclassified. Post-classification rules differ from optimization rules in that they have minimum requirements for being applied. These \u201ctriggers\u201d are meant to control the application of these rules. Also, as post-classification rules, they are no longer able to modify/influence the hidden data information, and therefore have different \u201ceffects\u201d. Specifically, all post-classification rules have two common elements: a FromPopulation list, and a ToPopulation specification, which determine which events are available to be changed and what population they will be changed to (provided they fall into the rule's True domain). There are no consequences for events that fall into a post-classification rule's False domain\u2014the classification into a population remains intact. In one embodiment, there are two types of post-classification expert rules: Misclassification, and MissingRequiredPopulation, and each are triggered by different conditions.",
        "After post-classification 110 has been performed, results of the process are then presented to a user as indicated in module 112 of FIG. 3, e.g., on the display of populations on a graphical user interface of a workstation, in the form of a printout containing quantitative results, or in some other form.",
        "Further Exemplary Implementation Details",
        "The program code to identify populations or clusters from an input data set operates an input dataset retrieved from memory. The input data set consists of multi-dimensional data observations obtained from the analytical instrument (e.g., flow cytometer) and a parameter file including the finite mixture model library and the expert knowledge set. This section is devoted to describing one possible embodiment of the input file contents and structure.",
        "As we have above, we denote the observed event vectors (multidimensional input data set) as X={xj} where xj is one observation vector, and in the illustrative embodiment is seven-dimensional, for seven input data channels.",
        "The parameter input file determines the specifics of the classifying process and primarily contains the finite mixture model library, and the expert knowledge set consisting of expert transforms, and expert rules (logical statements or operations). The parameter file is generally associated with the sample's species. Accordingly, it would be expected that an expert in the problem domain using the disclosed classifying methodology would construct a specific parameter file suitable for the problem domain in question.",
        "Formally, the parameter file \u03a9 is an ordered set (M,F,T,R), where\n\n    1. M contains a finite mixture model library and some general switches and process control parameters (see MVN_Collection Structure section below),\n    2. F is a FIFO of recent scaling vectors (see Scaling Factor FIFO section below),\n    3. T contains the Expert Transforms to be used (see Expert Transform Definition section below), and\n    4. R contains the Expert Rules structure (see Expert Rule Definition section below).",
        "Algorithm Pseudo Code",
        "The following section describes the main program loop and subroutines of the program code in accordance with one possible embodiment.",
        "\u00a9 IDEXX Laboratories, Inc. 2005. See notice regarding copyright at the beginning of this document.",
        "function Main (inputDataFilename)\n\n\n\n\n\n\n\n\n\n/* get inputs */\n\n\n\nX = read observations from inputDataFilename\n\n\n\nspecies = get sample species from inputDataFilename\n\n\n\ninputModelFilename = pick Model Inputs using sample species\n\n\n\nscalingFactorFIFO = read ScaleFactorFIFO associated with sample\n\n\n\n\n\n\n\n\n\nspecies\n\n\n\n\n\n\n\n\n\nMVN_Collection = read Algorithm Input Parameters from\n\n\n\n\n\n\n\n\n\ninputModelFilename\n\n\n\n\n\n\n\n\n\n/* removed control particle events from input data */\n\n\n\nif (MVN_Collection.CallFindLatex)\n\n\n\n\n\n\n\n\n\nprunedX = remove control particles from input X\n\n\n\n\n\n\n\n\n\nelse\n\n\n\n\n\n\n\n\n\nprunedX = X\n\n\n\n\n\n\n\n\n\nend\n\n\n\n/* scale input data & find initial FMM parameters */\n\n\n\nif (MVN_Collection.SearchForScalingFactors)\n\n\n\n\n\n\n\n\n\n[MVN, scaledX, scaledPrunedX] = searchForScalingFactor(X,\n\n\n\n\n\n\n\n\n\nprunedX, MVN_Collection,\n\n\n\ncalingFactorFIFO)\n\n\n\n\n\n\n\n\n\nelse\n\n\n\n\n\n\n\n\n\nMVN = get first FMM from library in MVN_Collection initial\n\n\n\n\n\n\n\n\n\nmodel list\n\n\n\n\n\n\n\n\n\nscaledX = X\n\n\n\nscaledPrunedX = prunedX\n\n\n\n\n\n\n\n\n\nend\n\n\n\n/* add simulated data from specific (generally rare) populations */\n\n\n\nif (MVN.SimulateEvents)\n\n\n\n\n\n\n\n\n\nscaledPrunedX = addSimulatedEvents(MVN, scaledPrunedX)\n\n\n\n\n\n\n\n\n\nend\n\n\n\n/* optimize FMM parameters */\n\n\n\nif (MVN.MVNEMCallEM)\n\n\n\n\n\n\n\n\n\nif (MVN.SubsetSize > 0)\n\n\n\nscaledPrunedXSubset = select MVN.SubsetSize data vectors\n\n\n\nrandomly from scaledPrunedX\n\n\n\nend\n\n\n\noptimizedNVN = runModifiedEM(MVN, scaledPrunedXSubset)\n\n\n\nif (MVN.EMOnEntireFile)\n\n\n\n\n\n\n\n\n\nfinalMVN = runModifiedEM(optimizedMVN, scaledX)\n\n\n\n\n\n\n\n\n\nelse\n\n\n\n\n\n\n\n\n\nfinalMVN = optimizedMVN\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\n/* classify all events & output to file */\n\n\n\nXClasses = classifyEvents(scaledX, finalMVN)\n\n\n\nOutputClassesToFile(XClasses)\n\n\n\n\n\n\n\nEnd\n\n\nfunction addSimulatedEvents(MVN, X)\n\n\n\n\n\n\n\n\n\nfor i=1 to length MVN.SimulateEventsForPopulations list\n\n\n\n\n\n\n\n\n\npopIndex = index into MVN.Component(*) of ith population\n\n\n\n\n\n\n\nindex on list\n\n\n\n\n\n\n\n\n\nscaledPopulationCovariance = MVN.Component\n\n\n\n(popIndex) .Covar\n\n\n\n\n\n\n\n\n\n* MVN.SimulateEventsPopulationCovarWeights (i)\n\n\n\n\n\n\n\n\n\nnumEventsToSimulate =\n\n\n\nMVN.SimulateEventsPopulationSizeScale\n\n\n\n\n\n\n\n\n\n* MVN.SubsetSize\n\n\n\n\n\n\n\n\n\nfor j=1 to numEventsToSimulate\n\n\n\n\n\n\n\n\n\nnewDataPoint = random vector sampled from Gaussian\n\n\n\n\n\n\n\n\n\ndensity with centroid =\n\n\n\nMVN.Component(popIndex) .Mean and covariance =\n\n\n\nscaledPopulationCovariance\n\n\n\n\n\n\n\n\n\n/* add newDataPoint to end of list of input vectors\n\n\n\n\n\n\n\n*/\n\n\n\n\n\n\n\n\n\nX = [X, newDataPoint]\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn X\n\n\n\n\n\n\n\nend\n\n\nfunction runModifiedEM(MVN, X)\n\n\n\n\n\n\n\n\n\npreviousTotalScore = 0\n\n\n\ntotalScoreDiff = infinity\n\n\n\ndo while (I < MVN.MVNEMMaxIterations) or\n\n\n\n\n\n\n\n\n\n(totalScoreDiff < MVN.MVNEMTotalScoreDiffThreshold)\n\n\n\n\n\n\n\n\n\n/* estimate EM hidden data */\n\n\n\nprobComponentIGivenXj = Estep(MVN, X)\n\n\n\n/* apply expert rules */\n\n\n\n\n\n\n\n\n\nif (MVN.ApplyExpertRuleConstraintsWithinEM)\n\n\n\n\n\n\n\n\n\nprobComponentIGivenXj = applyExpertRules (MVN,\n\n\n\nprobComponentIGivenXj, X)\n\n\n\n\n\n\n\n\n\nend\n\n\n\n/* update FMM parameters using hidden data and observed\n\n\n\n\n\n\n\n\n\ndata */\n\n\n\n\n\n\n\n\n\nMVN = Mstep(MVN, probComponentIGivenXj, X)\n\n\n\n/* compute metric for convergence test */\n\n\n\ntotalScore = totalLikelihoodScore(MVN,\n\n\n\n\n\n\n\n\n\nprobComponentIGivenXj, X)\n\n\n\n\n\n\n\n\n\ntotalScoreDiff = totalScore \u2212 previousTotalScore\n\n\n\npreviousTotalScore = totalScore\n\n\n\n\n\n\n\n\n\nend\n\n\n\noptimizedMVN = MVN\n\n\n\n\n\n\n\n\n\nreturn optimizedMVN\n\n\n\n\n\n\n\nend\n\n\nfunction classifyEvents(scaledX, MVN)\n\n\n\n\n\n\n\n\n\n/* compute EM hidden data for all inputs */\n\n\n\nprobComponentIGivenXj = Estep(MVN, scaledX)\n\n\n\n/* assign most likely class to each event */\n\n\n\nforeach i in 1 to number of vectors X in scaledX\n\n\n\n\n\n\n\n\n\nclass (i) = argmax(probComponentIGivenXj(i, *))\n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn classes\n\n\n\n\n\n\n\nend\n\n\nfunction Estep(MVN, X)\n\n\n\n\n\n\n\n\n\nnumEvents = length(X)\n\n\n\n/* compute the probability of each event given the current\n\n\n\nparameters for each component density function in the FMM.\n\n\n\nSpecifically, compute\n\n\n\nPr(x_j | C_I) ~ exp[ (x_j \u2212 M) S{circumflex over (\u2009)}\u22121 (x_j \u2212 M)\u2032 ], where\n\n\n\n\n\n\n\n\n\nM = current estimate for centroid of cluster i\n\n\n\nS = current estimate for covariance of cluster i */\n\n\n\n\n\n\n\n\n\nfor i=1 to MVN.NumComponents\n\n\n\n\n\n\n\n\n\nif (MVN.Component(i) .Active)\n\n\n\n\n\n\n\n\n\nfor j=1 to numEvents\n\n\n\n\n\n\n\n\n\nprobXjGivenComponentI(j,i) = probability of xj\n\n\n\n\n\n\n\n\n\ngiven current Gaussian parameters\n\n\n\nfor component i in MVN\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\nelse /* inactive component */\n\n\n\n\n\n\n\n\n\nprobXjGivenComponentI = 0 matrix\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\n/* compute the probability of observation x_j given the model,\n\n\n\n\n\n\n\n\n\nwhich is a denominator in the last calculation. Specifically,\n\n\n\ncompute\n\n\n\n\n\n\n\n\n\nPr(x_j | FMM) = sum_i { Pr(C_i) * Pr(x_j | C_i) } */\n\n\n\n\n\n\n\n\n\nfor j=1 to numEvents\n\n\n\npartialTermInSum(j, i) = MVN.Component(i) .Prior *\n\n\n\n\n\n\n\n\n\nprobXjGivenComponentI(j, i)\n\n\n\n\n\n\n\n\n\nprobXjGivenFMM(j) = sum over i (partialTermInSum(j,i))\n\n\n\nend\n\n\n\n/* compute posterior probability of each component given an\n\n\n\n\n\n\n\n\n\nevent. Specifically, compute\n\n\n\nPr(C_i | x_j) = Pr(x_j | C_i)*Pr(C_i) / Pr(x_j | FMM) */\n\n\n\n\n\n\n\n\n\nfor i=1 to MVN.NumComponents\n\n\n\n\n\n\n\n\n\nfor j=1 to numEvents\n\n\n\nProbComponentIGivenXj = partialTermInSum(j,i) /\n\n\n\n\n\n\n\n\n\nprobXjGivenFMM(j)\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn probComponentIGivenXj\n\n\n\n\n\n\n\nend\n\n\nfunction applyExpertRules(MVN, probComponentIGivenXj, X)\n\n\n\n\n\n\n\n\n\n/* compute expert transform output vectors */\n\n\n\nsort expert transforms by CONSTRUCT_ORDER so that any\n\n\n\n\n\n\n\n\n\ntransform's inputs are computed prior to being referenced by\n\n\n\nanother transform\n\n\n\n\n\n\n\n\n\nforeach expert transform E in sorted order\n\n\n\n\n\n\n\n\n\ncompute transform E's output vectors\n\n\n\nforeach output vector created by E\n\n\n\n\n\n\n\n\n\ntranslate output values to expert defined zero point\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\n/* apply expert rules */\n\n\n\nforeach expert rule R\n\n\n\n\n\n\n\n\n\n/* find points in True and false domains */\n\n\n\nT(X) = identify data points satisfying R's logical\n\n\n\n\n\n\n\n\n\nstatement\n\n\n\n\n\n\n\n\n\nF(X) = compliment of T(X) in X\n\n\n\n/* loop over R's effected populations */\n\n\n\nforeach class C in R's true domain effected populations\n\n\n\n\n\n\n\n\n\nlist\n\n\n\n\n\n\n\n\n\nadjustmentTrue(C) = C's adjustment factor for True\n\n\n\n\n\n\n\n\n\ndomain\n\n\n\n\n\n\n\n\n\nProbComponentIGivenXj(T(X), C) = adjustmentTrue(C) *\n\n\n\n\n\n\n\n\n\nProbComponentIGivenXj(T(X), C)\n\n\n\n\n\n\n\n\n\nadjustmentFalse(C) = C's adjustment factor for False\n\n\n\n\n\n\n\n\n\ndomain\n\n\n\n\n\n\n\n\n\nProbComponentIGivenXj(F(X), C) = adjustmentFalse(C) *\n\n\n\n\n\n\n\n\n\nProbComponentIGivenXj(F(X), C)\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn probComponentIGivenXj\n\n\n\n\n\n\n\nend\n\n\nfunction Mstep(MVN, probComponentIGivenXj, X)\n\n\n\n\n\n\n\n\n\n/* update finite mixture model parameters using following\n\n\n\n\n\n\n\n\n\nformulas */\n\n\n\n\n\n\n\n\n\nforeach class Ci in finite mixture model\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    Pr\n    \u2062\n    \n      \n    \n    \u2062\n    \n      (\n      \n        \n          C\n          i\n        \n        |\n        \n          \u03a9\n          \n            (\n            \n              s\n              +\n              1\n            \n            )\n          \n        \n      \n      )\n    \n  \n  =\n  \n    \n      \n        \u2211\n        \n          \n        \n      \n      \n        j\n        =\n        1\n      \n      n\n    \n    \u2062\n    \n      \n        z\n        ij\n        \n          (\n          s\n          )\n        \n      \n      /\n      n\n    \n  \n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n  \n    \u03bc\n    i\n    \n      (\n      \n        s\n        +\n        1\n      \n      )\n    \n  \n  =\n  \n    \n      \n        \n          \u2211\n          \n            j\n            =\n            1\n          \n          n\n        \n        \u2062\n        \n          z\n          ij\n          \n            (\n            s\n            )\n          \n        \n        \u2062\n        \n          y\n          j\n        \n      \n      +\n      \n        \n          \u03ba\n          i\n        \n        \u2062\n        \n          \u03bc\n          i\n          \n            (\n            0\n            )\n          \n        \n      \n    \n    \n      \n        \n          \u2211\n          \n            j\n            =\n            1\n          \n          n\n        \n        \u2062\n        \n          z\n          ij\n          \n            (\n            s\n            )\n          \n        \n      \n      +\n      \n        \u03ba\n        i\n      \n    \n  \n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n  \n    V\n    i\n    \n      (\n      \n        s\n        +\n        1\n      \n      )\n    \n  \n  =\n  \n    \n      \n        \u2211\n        \n          j\n          =\n          1\n        \n        n\n      \n      \u2062\n      \n        \n          z\n          ij\n          \n            (\n            s\n            )\n          \n        \n        \u2061\n        \n          (\n          \n            \n              y\n              j\n            \n            -\n            \n              \u03bc\n              i\n              \n                (\n                \n                  s\n                  +\n                  1\n                \n                )\n              \n            \n          \n          )\n        \n      \n      \u2062\n      \n        \n          (\n          \n            \n              y\n              j\n            \n            -\n            \n              \u03bc\n              i\n              \n                (\n                \n                  s\n                  +\n                  1\n                \n                )\n              \n            \n          \n          )\n        \n        t\n      \n    \n    \n      \n        \u2211\n        \n          j\n          =\n          1\n        \n        n\n      \n      \u2062\n      \n        z\n        ij\n        \n          (\n          s\n          )\n        \n      \n    \n  \n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n  \n    \n      \n        \n          \n            \u03a3\n            i\n            \n              (\n              \n                s\n                +\n                1\n              \n              )\n            \n          \n          =\n        \n      \n    \n    \n      \n        \n          \n            \n              (\n              \n                \u03a3\n                i\n                \n                  (\n                  0\n                  )\n                \n              \n              )\n            \n            \n              -\n              1\n            \n          \n          +\n          \n            \n              V\n              i\n              \n                (\n                \n                  r\n                  +\n                  1\n                \n                )\n              \n            \n            \u2062\n            \n              \n                \u2211\n                \n                  j\n                  =\n                  1\n                \n                n\n              \n              \u2062\n              \n                z\n                ij\n                \n                  (\n                  s\n                  )\n                \n              \n            \n          \n          +\n          \n            \n              \n                \n                  \u03c1\n                  i\n                \n                \u2062\n                \n                  \n                    \u2211\n                    \n                      j\n                      =\n                      1\n                    \n                    n\n                  \n                  \u2062\n                  \n                    z\n                    ij\n                    \n                      (\n                      s\n                      )\n                    \n                  \n                \n              \n              \n                \n                  \u03c1\n                  i\n                \n                +\n                \n                  \n                    \u2211\n                    \n                      j\n                      =\n                      1\n                    \n                    n\n                  \n                  \u2062\n                  \n                    z\n                    ij\n                    \n                      (\n                      s\n                      )\n                    \n                  \n                \n              \n            \n            \u2062\n            \n              (\n              \n                \n                  \u03bc\n                  i\n                  \n                    (\n                    \n                      r\n                      +\n                      1\n                    \n                    )\n                  \n                \n                -\n                \n                  \u03bc\n                  i\n                  \n                    (\n                    0\n                    )\n                  \n                \n              \n              )\n            \n            \u2062\n            \n              \n                (\n                \n                  \n                    \u03bc\n                    i\n                    \n                      (\n                      \n                        r\n                        +\n                        1\n                      \n                      )\n                    \n                  \n                  -\n                  \n                    \u03bc\n                    i\n                    \n                      (\n                      0\n                      )\n                    \n                  \n                \n                )\n              \n              t\n            \n          \n        \n      \n    \n  \n  \u2003\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\nend\n\n\n\nreturn MVN\n\n\n\n\n\n\n\nend\n\n\nfunction totalLikelihoodScore(MVN, probComponentIGivenXj, X)\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    return\n    \u2062\n    \n      \n    \n    \u2062\n    Pr\n    \u2062\n    \n      \n    \n    \u2062\n    \n      (\n      \n        X\n        |\n        \n          \u03a9\n          k\n        \n      \n      )\n    \n  \n  =\n  \n    \n      \u220f\n      \n        \n          j\n          =\n          1\n        \n        ,\n        \u2026N\n      \n      \n        \n      \n    \n    \u2062\n    \n      \n    \n    \u2062\n    \n      \n        \u2211\n        \n          \n            i\n            =\n            1\n          \n          ,\n          \u2026G\n        \n        \n          \n        \n      \n      \u2062\n      \n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                C\n                i\n              \n              |\n              \n                \u03a9\n                k\n              \n            \n            )\n          \n        \n        \u2062\n        \n          Pr\n          \u2061\n          \n            (\n            \n              \n                \n                  x\n                  j\n                \n                |\n                \n                  C\n                  i\n                \n              \n              ,\n              \n                \u03a9\n                k\n              \n            \n            )\n          \n        \n      \n    \n  \n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\nend\n\n\nFunction ScaleFactorSearch\n\n\n\n\n\n\n\n\n\nInitializeParameters( )\n\n\n\nFIFOScore = TestFactor(LastFIFOFactor)\n\n\n\nEoverOScore = TestFactor(ECPCentroid ./ OCPCentroid)\n\n\n\nBestF = argmin(FIFOScore, EoverOScore)\n\n\n\nBestScore = min(FIFOScore, EoverOScore)\n\n\n\nIter = 0\n\n\n\nDo while (Iter < MaxIter) & (BestScore > a(n))\n\n\n\n\n\n\n\n\n\nLet f be randomly sampled from a Gaussian distribution with\n\n\n\n\n\n\n\n\n\ncentroid BestF and covariance \u03a3\n\n\n\n\n\n\n\n\n\nTestScore = TestFactor(f)\n\n\n\nBestScore = min(BestScore, TestScore)\n\n\n\n\n\n\n\n\n\nEnd\n\n\n\n\n\n\n\nFunction InitializeParameters\n\n\n\n\n\n\n\n\n\nX = (x1, x2, . . . , xn)be a list of input vectors\n\n\n\n\u039b = a classifying system library\n\n\n\nF(\u039b) = (f1, f2, . . . , fp) be the Scaling Factor FIFO associated with\n\n\n\n\n\n\n\n\n\n\u039b, ordered by increasing date of discovery\n\n\n\n\n\n\n\n\n\nIf cov(F(\u039b)) is symmetric positive definite\n\n\n\n\n\n\n\n\n\n\u03a3 = cov(F(\u039b))\n\n\n\n\n\n\n\n\n\nElse\n\n\n\n\n\n\n\n\n\nLet \u03a3 be \u03b5*Id for \u03b5 defined outside algorithm\n\n\n\n\n\n\n\n\n\nEnd\n\n\n\na(n) = acceptance log likelihood threshold\n\n\n\nMM = argmax(Prior Pr(Mk) |Mk a partition system in )\n\n\n\nECPCentroid = g for g identified as the sample control particle\n\n\n\n\n\n\n\n\n\n(latex)\n\n\n\n\n\n\n\n\n\nOCPCentroid = observed control particle centroid\n\n\n\n\n\n\n\nFunction TestFactor(f)\n\n\n\n\n\n\n\n\n\ns(f) = \u2212Log Pr(X|MM)\n\n\n\nIf (s(f) < a(n))\n\n\n\n\n\n\n\n\n\nScaledX = X .* f\n\n\n\nPush f onto F( )\n\n\n\nExit ScaleFactorSearch\n\n\n\n\n\n\n\n\n\nElse\n\n\n\n\n\n\n\n\n\nReturn s(f)\n\n\n\n\n\n\n\n\n\nEnd",
        "Data Structures",
        "Multivariate Normal, Finite Mixture Model (FMM) Library (Collection)",
        "An ASCII (text) file defines a finite mixture model library. The file has three primary sections (or types of data): Header data, which is key name, value paired on each record, Cluster data, which defines the Gaussian density function parameters, and the InitialModelList section, which provides a means to restrict the library to specific combinations of density functions as opposed to all combinations. The sections must appear in the file in the order: Header, Clusters, Model List. Any record (in any section) that starts with a \u2018#\u2019 character is considered a comment and plays no role in either the file parse or algorithm execution. The format of these three sections is described next.",
        "Once this file is loaded into memory, the ExpertTransform, ExpertMetric, and ExpertRule structures are added to this one so that the MVN_Collection structure becomes the primary algorithm structure used throughout the code. After the initial FMM has been selected, the MVN_Collection structure is transferred to an MVN structure which is identical to the MVN_Collection with the exception of moving the \u2018.Cluster(*).Component(*).\u2019 subfield to a \u2018.Component.\u2019 subfield.",
        "MVN_Collection Header",
        "The Header section of the MVN Collection file contains one key name, value pair per record. There is no restriction on name length. A comma (and any number of spaces) separates a Key name from its associated value. The Matlab function ReadMVN_Collection_ASCII places the Key/Value pairs in the returned structure with fieldnames identical to the key name. The associated values may be converted to numerical, Boolean, or string types according to the type of value being read. Consult the conversion data structure found in ReadMVN_Collection_ASCII to determine which value type is returned.",
        "Appendix A contains a table describing the currently expected/supported key/value pairs together with a brief description of the parameter's role in the algorithm.",
        "Expert Transforms",
        "Expert transforms can be defined by a list of structures in the programming language MATLAB. The fields for such structures are described in Appendix B.",
        "Expert Rules",
        "Expert Rules can likewise be defined by a Matlab list of structures. The fields of each structure are described in Appendix C.",
        "While a number of exemplary aspects and embodiments have been discussed above, those of skill in the art will recognize certain modifications, permutations, additions and sub-combinations thereof. It is therefore intended that the following appended claims and claims hereafter introduced are interpreted to include all such modifications, permutations, additions and sub-combinations as are within their true spirit and scope.",
        "APPENDIX A\n\n\n\n\n\n\n\nMVN Collection Header Definition\n\n\n\n\n\n\n\n\n\nKey name\nValue Type\nDescription\n\n\n\n\n\nVersion\nString\nModel version number. Is placed in FCS file.\n\n\nSpecies\nString\nIdentifies species. Tested for equality against\n\n\n\n\nIDXSpecies value in FCS file.\n\n\nCellType\nString\nIdentifies \u2018Red\u2019, \u2018White\u2019, or \u2018NBC\u2019. Tested for equality\n\n\n\n\nagainst IDXCellType value in FCS file.\n\n\nNumClusters\nInteger\nNumber of clusters in library. Each cluster may have many\n\n\n\n\nexamples (components). Generally expect one cluster per\n\n\n\n\nevent population to be modeled.\n\n\nNumDimensions\nInteger\nNumber of input channels. This is redundant with the\n\n\n\n\nnumber of channels listed in the CoordinateOrder\n\n\n\n\nstring.\n\n\nCoordinateOrder\nString\nComma separated list of input channels to be retrieved from\n\n\n\n\nthe input FCS file. The number of substrings must equal\n\n\n\n\nthe NumDimensions value specified above. Substrings\n\n\n\n\nmust match the Channel names found in the FCS file header\n\n\n\n\nkey IDXChannel<integer>. Note that the \u2018_\u2019\n\n\n\n\ncharacter takes the place of a space character in the FCS\n\n\n\n\nfile's field.\n\n\nInclude\nBoolean\nIf Boolean is true, a Background (Junk Collector) Gaussian\n\n\nBackground\n\ndensity is added to the finite mixture model. This assumes\n\n\nComponent\n\nthat the last cluster in the MVNCollection Cluster list\n\n\n\n\ndefines the Background cluster.\n\n\nCallFindLatex\nBoolean\nIf Boolean is true, Latex events are found and its estimated\n\n\n\n\ncentroid will be considered if a scaling factor search is\n\n\n\n\nrequested. In order to mask (or hide) Latex events during\n\n\n\n\nthe EM optimization step, this Boolean and\n\n\n\n\nMVNEMHideLatexEventsDuringEM must both be set\n\n\n\n\nto true.\n\n\nSubsetSize\nInteger\nDetermines the size of the random event subset (of entire\n\n\n\n\nFCS file) to be used for optimization steps.\n\n\nSearchForScaling\nBoolean\nIf Boolean is true, search for scaling factors prior to EM\n\n\nFactors\n\noptimization. If Boolean is false, no search is performed\n\n\n\n\nand the first component from each cluster will be selected\n\n\n\n\nas the initial FMM.\n\n\nScaleFactor\n\nPrefix for parameters used in the scale factor search code.\n\n\nSearch <Suffix>\n\nExample key name:\n\n\n\n\nScaleFactorSearchHistoryFIFOLen\n\n\nHistoryFIFOLen\nInteger\nNumber of prior scaling factors to be recorded for each\n\n\n\n\ninstrument. FIFO (plus additional data) is stored in the\n\n\n\n\nMatlab binary file:\n\n\n\n\n\u201cWhite_<SerialNumber>_ScalingHistory.\n\n\n\n\nmat\u201d\n\n\nSufficientScore\nReal\nSets \u201cacceptable\u201d scaling factor performance threshold. If\n\n\n\n\nthe total negative log likelihood value associated with a\n\n\n\n\nparticular scaling factor vector drops below this value, the\n\n\n\n\nscaling factor search terminates, returning the associated\n\n\n\n\nscaling factor. Default: \u22127000.0\n\n\nGenericMaxNumRandom\nInteger\nSets the default number of time the scaling factor search\n\n\nSteps\n\nalgorithm will test random factors. This value will be\n\n\n\n\nchanged if:\n\n\n\n\nNo scaling history exists for the instrument, or\n\n\n\n\nThe initial total log likelihood value (min of\n\n\n\n\nhistory value and latex based value) exceeds the\n\n\n\n\nScaleFactorSearchMinInitialScore\n\n\n\n\nThreshold\n\n\n\n\nRegardless of the maximum number of iterations allowed,\n\n\n\n\nif the total log likelihood estimate falls below the sufficient\n\n\n\n\nscore threshold, the search terminates prior to this\n\n\n\n\nmaximum iteration number.\n\n\n\n\nDefault: 50\n\n\nMinInitialScore\nReal\nIf the initial total log likelihood score exceeds this value\n\n\nThreshold\n\nthen presumably the data deviates radically from the\n\n\n\n\nexpected (model), and it is likely more scaling factor\n\n\n\n\niterations will be needed to adjust the data.\n\n\n\n\nDefault: 5000.0\n\n\nWeakInitial\nInteger\nMaximum number of scaling factor search iterations to be\n\n\nMaxNumRandom\n\nperformed if initial total log likelihood score exceeds\n\n\nSteps\n\nScaleFactorSearchMinInitialScoreThreshold.\n\n\n\n\nDefault: 75\n\n\nNewMachine\nInteger\nMaximum number of scaling factor search iterations to be\n\n\nMaxNumRandom\n\nperformed in the absence of ScalingFactor History FIFO.\n\n\nSteps\n\nDefault: 100\n\n\nUseHistory\nBoolean\nIf Boolean is true, the scaling factor with the lowest total\n\n\n\n\nlog likelihood score in the Scaling Factor FIFO is tested\n\n\n\n\nagainst the Latex based total log likelihood score. The\n\n\n\n\nfactor amongst these two will serve as the seed for the\n\n\n\n\nscaling factor search algorithm. If this Boolean is false, the\n\n\n\n\nsearch algorithm will be seeded with the Latex based\n\n\n\n\nscaling factor.\n\n\nRandomWalk\nReal\nDetermines the spread of the random sampling process used\n\n\nCovariance\n\nto search for an optimal scaling factor. This parameter\n\n\nEpsilon\n\nloosely plays the role of a \u201cstep size\u201d in a gradient ascent-\n\n\n\n\nlike search, in the sense that large epsilon values produce\n\n\n\n\nsearch algorithms that flop about a great deal and are unable\n\n\n\n\nto find and follow valleys. On the other hand, when epsilon\n\n\n\n\nis too small, convergence is slow because the random test\n\n\n\n\npoints are too near the last minimum score. The default\n\n\n\n\nvalue was found through a process of trial and error.\n\n\n\n\nDefault: 0.0001\n\n\nScoreThreshold\nReal\nIf the total log likelihood for the final scaling factor and\n\n\nForFixed\n\noptimal model falls below this threshold value, all the\n\n\nPopulation\n\ncovariance matrices are toggled to FIXED so that the M-\n\n\nCovariance\n\nstep will never modify the individual population's\n\n\n\n\ncovariance estimates.\n\n\n\n\nDefault: \u221210,000.0\n\n\nMinThresholds\nReal vector\nComma separated vector of real numbers (one for each\n\n\n\n\ninput channel) that determines the lowest scaling factor.\n\n\n\n\nThis threshold is considered after a random scaling factor\n\n\n\n\ncandidate is generated and before the total log likelihood\n\n\n\n\nscore is computed. Any coordinate of the candidate found\n\n\n\n\nbelow the corresponding minimum defined here is set back\n\n\n\n\nto the minimum value. These are intended to globally\n\n\n\n\nconstrain the search algorithm to a region of scale factor\n\n\n\n\nspace known to be acceptable.\n\n\nMaxThresholds\nReal vector\nSame as ScaleFactorSearchMinThresholds but\n\n\n\n\nwith respect to a maximum rather than a minimum\n\n\nUseInitial\nBoolean\nIf Boolean is true, restricts the search for an initial FMM to\n\n\nModelList\n\nthose defined on the initial model list. This is currently\n\n\n\n\noverridden in the code to always being false (ECT\n\n\n\n\nOct. 12, 2005).\n\n\nNumInitialModels\nInteger\nUsed during MVNCollection file parse to determine the\n\n\n\n\nnumber of initial model definitions to read from file. If this\n\n\n\n\nnumber is less than the actual number in the list, those\n\n\n\n\ninitial models beyond this index in the list will be ignored.\n\n\nIntialModelList\nReal\nIf the search for an initial FMM is constrained to the initial\n\n\nMaxNegLogP\n\nmodel list, but no model on the list produces a total log\n\n\n\n\nlikelihood score lower than this value, then the search is\n\n\n\n\nextended to all possible models.\n\n\nEMOnEntireFile\nBoolean\nIf Boolean is true, EM algorithm (together with\n\n\n\n\nExpertRules) will be run on all events in the input file after\n\n\n\n\nthe model optimization step is completed on a random\n\n\n\n\nsubset of the same file. This has generally not been found\n\n\n\n\nto be useful in this application.\n\n\nMVNEM <Suffix>\nInteger\nPrefix for parameters used in the Expectation-Maximization\n\n\n\n\n(model optimization) portion of the algorithm. Example\n\n\n\n\nkey name: MVNEMCallEM\n\n\nCallEM\nBoolean\nIf Boolean is true, EM algorithm will be used to optimize\n\n\n\n\nthe FMM parameters after the scaling factor search\n\n\n\n\nalgorithm selects the optimal initial model. If False, a\n\n\n\n\nprimitive Latex classification will take place, but all other\n\n\n\n\nevents will be classified as UNK (== BG).\n\n\nMaxIterations\nInteger\nUpper bound on the number of EM iterations to be\n\n\n\n\nperformed\n\n\nHideLatexEvents\nBoolean\nIf Boolean is true, events thought to be Latex during the\n\n\nDuringEM\n\nFindLatexAndRescale function will be removed\n\n\n\n\nfrom the data during model optimization. After EM\n\n\n\n\nterminates, and before the event classification is computed,\n\n\n\n\nthe latex events will be returned to the data set and the\n\n\n\n\nLatex component of the FMM will be reactivated. This\n\n\n\n\nspeeds up model optimization convergence (as latex is\n\n\n\n\ngenerally easy to find), while still allowing the latex\n\n\n\n\ncomponent to participate in the Bayesian classification step\n\n\n\n\n(hence Latex class remains Gaussian irrespective of any\n\n\n\n\ntricks used to remove the events in\n\n\n\n\nFindLatexAndRescale).\n\n\nSimulateEvents\nBoolean\nIf Boolean is true, events will be added to the collected data\n\n\n\n\naccording to the Gaussian density functions for each\n\n\n\n\nspecified population. For example, if\n\n\n\n\nMVNEMSimulateEventsForPopulations\n\n\n\n\ncontains the string EOS, the optimal initial FMM\n\n\n\n\ncomponent for EOS (with covariance scaled by S) would be\n\n\n\n\nrandomly sampled from N times, and these events would be\n\n\n\n\nadded to the optimization data subset. N is defined by the\n\n\n\n\nindex-matched fraction found in\n\n\n\n\nMVNEMSimulateEventsPopulationSizeScale.\n\n\n\n\nS is defined by the index-matched real found in\n\n\n\n\nMVNEMSimulateEventsPopulationCovarWeights.\n\n\n\n\nSo, for example if the ForPopulations,\n\n\n\n\nPopulationCovarWeights, and\n\n\n\n\nPopulationSizeScale values were \u2018EOS, MONO\u2019\n\n\n\n\n\u20180.5, 1.0\u2019, and \u20180.01, 0.05\u2019, and the\n\n\n\n\nSubsetSize = 4000, then 0.01 * 4000 = 40 events\n\n\n\n\nwould be randomly sampled from the EOS Gaussian\n\n\n\n\ndensity function with covariance scaled by 0.5, and 0.05 * 4000 = 200\n\n\n\n\nevents would be randomly sampled from the\n\n\n\n\nMONO Gaussian density function with covariance as\n\n\n\n\ndefined in the FMM.\n\n\n\n\nIf Boolean is false, no random events will be generated.\n\n\n\n\nDefault: False\n\n\nSimulateEvents\n\nPrefix for parameters used in the simulated events portion\n\n\n<Suffix>\n\nof the algorithm. Example key name:\n\n\n\n\nMVNEMSimulateEventsForPopulations\n\n\nForPopulations\nComma\nComma separated string that identifies which Gaussian\n\n\n\nseparated text\ndensity functions need to be randomly sampled. Values\n\n\n\n\nbetween commas must be exact matches to the\n\n\n\n\nInternalClassNames found in the FMM structure.\n\n\n\n\nExample: EOS, MONO\n\n\nPopulationCovar\nReal vector\nComma separated row vector of scalar values used to shrink\n\n\nWeights\n\nor expand the covariance matrix used for random sampling.\n\n\n\n\nSmaller weights (less than 1.0) cause the density function to\n\n\n\n\nbe more \u201cconcentrated\u201d near the population's centroid,\n\n\n\n\nwhile larger values (greater than 1.0) cause the sampled\n\n\n\n\nevents to be more widely distributed. Values are index-\n\n\n\n\nmatched with the population names listed in\n\n\n\n\nMVNEMSimulateEventsForPopulations.\n\n\n\n\nHence, expanding on the example provided for that string,\n\n\n\n\nif\n\n\n\n\nMVNEMSimulateEventsPopulationCovarWeights\n\n\n\n\nis 0.5, 1.0, the EOS covariance matrix would\n\n\n\n\nbe multiplied by 0.5 prior to random sampling.\n\n\nPopulationSize\nReal vector\nComma separated row vector of fractions used to define\n\n\nScale\n\nhow many simulation events to be generated for each\n\n\n\n\npopulation specified on\n\n\n\n\nMVNEMSimulateEventsForPopulations.\n\n\nApplyExpertRule\nBoolean\nIf Boolean is true, Expert Rules of type\n\n\nConstraints\n\nDuringOptimization will be applied to the hidden\n\n\nWithinEM\n\ndata of the EM algorithm (Pr(Class_I|Obs_j)). Expert\n\n\n\n\nRules are defined in a file separate from this file and are\n\n\n\n\nexplained below. If False, no rules are used.\n\n\nReactivate\nBoolean\nIf Boolean is true, any population designed as a\n\n\nCounted\n\nCountedCell (see Cluster Structure below), that is\n\n\nPopulations\n\ninactivated during model optimization (EM steps) will be\n\n\nPostEM\n\nreactivated prior to classification steps. Since these\n\n\n\n\ncomponents became inactive for mathematical reasons\n\n\n\n\n(covariance failed to be symmetric positive definite for\n\n\n\n\nexample), the current model parameters ought to be\n\n\n\n\nregarded as suspect. For this reason, the Covariance matrix\n\n\n\n\nand Mean vector found in the initial FMM structure are\n\n\n\n\ncopied back into the optimized FMM structure, while the\n\n\n\n\ncomponent prior is left at its last observed value.\n\n\nApplyPostEM\n\nPrefix for parameters used after Expectation-Maximization\n\n\n<Suffix>\n\n(model optimization) portion of the algorithm terminates.\n\n\n\n\nExample key name:\n\n\n\n\nMVNEMApplyPostEMDimensionReduction\n\n\nPreClassification\nBoolean\nIf Boolean is true, Expert Rules of type\n\n\nExpert\n\nDuringOptimization will be applied to the hidden\n\n\nRules\n\ndata of the EM algorithm without the final M-step updates.\n\n\n\n\nThis option is obsolete as it is likely to \u201cover-drive\u201d the\n\n\n\n\nhidden data probabilities used for classification. If true, one\n\n\n\n\nwill likely stop getting \u201celliptical\u201d shaped clusters.\n\n\nDimension\nBoolean\nIf Boolean is true, the EXT_Int and RAS_Int channel\n\n\nReduction\n\ndata will be ignored during the classification step. This\n\n\n\n\noption pre-dates the use of a predicted EXT_Int channel,\n\n\n\n\nwhich works better than this option. Hence, this should not\n\n\n\n\nbe used (ECT Oct. 13, 2005).\n\n\nDropBackground\nBoolean\nIf Boolean is true, the Background (BG) component is\n\n\nPostEMPre-\n\ninactivated prior to classification. The remaining\n\n\nClassification\n\npopulation priors are adjusted appropriately (proportional to\n\n\n\n\ncurrent priors). This results in zero UNK events in the final\n\n\n\n\nclassification.",
        "MVN_Collection Clusters\n\n\n\n\n\n\n\n\n\nKey name\nValue Type\nDescription\n\n\n\n\n\nCluster\nInteger\nIdentifies the cluster index within the\n\n\n\n\nMVN_Collection.Clusters structure. Integers\n\n\n\n\nmust be sequential starting at 1.\n\n\nNumComponents\nInteger\nDetermines the number of components\n\n\n\n\n(Gaussian density function parameters) to\n\n\n\n\nexpect for a iven cluster (population).\n\n\nCountAsCell\nBoolean\nIf set to true for a cluster, events classified to\n\n\n\n\nthat cluster are expected to be white blood\n\n\n\n\ncells. While this designation does not control\n\n\n\n\nthe final WBC count (which is computed by\n\n\n\n\nResCalc.EXE), it does designate this cluster as\n\n\n\n\nbeing distinguished amongst all clusters. See\n\n\n\n\nfor example\n\n\n\n\nMVNEMReactivateCountedPopulations\n\n\n\n\nPostEM above.\n\n\nInternalClassCode\nInteger\nEvent classification code used within the\n\n\n\n\nalgorithm. Since all references are generally\n\n\n\n\nmade through the InternalClassName,\n\n\n\n\nthis value is not commonly found in the code\n\n\n\n\nitself. The ability to have multiple clusters all\n\n\n\n\nmapping onto the same output class. For\n\n\n\n\nexample, two lymphocyte clusters both with\n\n\n\n\nthe same ReportedClassName and\n\n\n\n\nReportedClassCode but with distinct\n\n\n\n\nInternalClassCode and\n\n\n\n\nInternalClassName allows the\n\n\n\n\ndeveloper more flexibility when it comes to\n\n\n\n\nmodeling non-Gaussian populations.\n\n\nInternalClassName\nString\nString defines how this cluster will be\n\n\n\n\nreferenced from within the algorithm. This\n\n\n\n\nvalue, and all references to it are case\n\n\n\n\nsensitive.\n\n\nReportedClassCode\nInteger\nEvent classification code referenced outside\n\n\n\n\nthe algorithm. These values determine the\n\n\n\n\nfinal Classifier values that are output to\n\n\n\n\nthe FCS file.\n\n\nReportedClassName\nString\nString defines how this cluster will be\n\n\n\n\nreferenced outside the algorithm. This value,\n\n\n\n\nand all references to it are case sensitive. This\n\n\n\n\nstring will contribute to the IDXRegion\n\n\n\n\nvalues.\n\n\nComponent\nInteger\n\n\nComponentName\nString\n\n\nPrior\nReal\n\n\nMinPrior\nReal\n\n\nMeanPriorCount\nReal\n\n\nCovarTetheringWeight\nReal\n\n\nFixedMeanParams\nBoolean\n\n\nFixedCovarParams\nBoolean\n\n\nMean\nReal vector\n\n\nCovarianceScalingFactor\nReal\n\n\nCovariance",
        "Collection Initial Models List\n\n\n\n\n\n\n\n\n\n\n\nKey name\nValue Type\nDescription",
        "Expert Transform Structure Definition\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\nNAME\nString\nUser defined name for transform. Not referenced any place.\n\n\nTYPE\nString\nTransform type determines the constructor function used to\n\n\n\n\ninstantiate the output vectors. See list below of supported\n\n\n\n\nTransform Types.\n\n\nCONSTRUCT_ORDER\nReal number\nTransforms are sorted (ascending) by this value and constructed\n\n\n\n\naccordingly. Transform outputs required for other transforms must\n\n\n\n\nhave smaller CONSTRUCT_ORDER than the transforms using them.\n\n\nINPUTS\nList of IOStructs\nDefines the input vectors for transformation\n\n\nOUTPUTS\nList of IOStructs\nDefines the output vectors for transformation\n\n\nPARAMETERS\nStruct\nType specific parameters\n\n\nMIN_CUT\nList of real values\nLower limit for acceptable cut value. List length must equal\n\n\n\n\nOUTPUTS length, and limit applies to the output with the same\n\n\n\n\nindex.\n\n\nMAX_CUT\nList of real values\nUpper limit for acceptable cut value. List length must equal\n\n\n\n\nOUTPUTS length, and limit applies to the output with the same\n\n\n\n\nindex.\n\n\nOUT_OF_RANGE_RESPONSE\nString\nDefines transform behavior when candidate cut falls outside interval\n\n\n\n\ndefined by [MIN_CUT, MAX_CUT]\n\n\n\n\nUNAVAILABLE \u2192 Outputs labeled unavailable\n\n\n\n\nTRUNCATE \u2192 Cut set at MIN_CUT if less than MIN_CUT, and set\n\n\n\n\nat MAX_CUT if greater than MAX_CUT\n\n\n\n\nIGNORE \u2192 Ignores Min and Max values",
        "Expert Transforms are defined by a Matlab list of structures. The fields of each structure are described here.",
        "IOStructs Definition\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\nNAME\nString\nUser defined name for transform.\n\n\n\n\nNot referenced any place.\n\n\nTYPE\nString\nEither:\n\n\n\n\nCHANNEL \u2192 Name refers to one of the initial\n\n\n\n\ninput vectors, e.g. RAS_Peak\n\n\n\n\nMETRIC \u2192 Name refers to an output vector\n\n\n\n\nfrom an ExpertTransform",
        "ExpertTransform Types\n\n\n\n\n\n\n\n\nTransform Name\nDescription\n\n\n\n\n\nCOORDINATE\nCopies inputs to outputs while providing a number of ways\n\n\n\nto define the cut point relative to a population's centroid.\n\n\n\nCut point methods include:\n\n\n\nAbsolute: Moves the zero point to a fixed\n\n\n\nlocation in the input coordinate.\n\n\n\nPopulationRelative: Allows one to\n\n\n\nmove the zero point in each input to some offset\n\n\n\n(covariance based) from a population's centroid.\n\n\n\nOne can specify whether the centroid and\n\n\n\ncovariance estimates come from the latest EM\n\n\n\nestimate of these population parameters or those of\n\n\n\nthe input FMM model.\n\n\n\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: Arbitrary\n\n\n\nNote: All parameters are vectors to allow for multiple\n\n\n\noutputs relative to one population, e.g. Mono(RAS){Dyn},\n\n\n\nMono(RAS + ISD){Dyn}, can all be defined in one\n\n\n\ntransform.\n\n\nBARYCENTRIC_1D\nProjects all data onto a line (in n-space) joining two\n\n\n\npopulation centroids such that values near zero will have\n\n\n\nprojected near one population centroid and those near one\n\n\n\nhave projected near the second population centroid. If x0, x1\n\n\n\nare the centroids of the two populations (as vectors in the\n\n\n\ninput space to this transform), then the output value\n\n\n\nassociated with event y is the real number that satisfies the\n\n\n\nequation y = t * x1 + (1 \u2212 t) * x0. Projecting all events onto\n\n\n\nthis t coordinate produces a one-dimensional measurement\n\n\n\nsystem from any number of input coordinates. Moreover,\n\n\n\nthe two population centroids reside at known coordinates\n\n\n\n(zero and one). Hence, an expert is able to construct any\n\n\n\nnumber of new coordinates by measuring an event's\n\n\n\nlocation relative to any two populations. This coordinate is\n\n\n\nthe output metric for this transform.\n\n\n\nCut point Methods: Ideally, a histogram constructed in the\n\n\n\nresulting barycentric coordinate will have a large number of\n\n\n\npoints at zero and one with a valley between them. The\n\n\n\ngoal of this cut point method is to find this valley. Sadly,\n\n\n\nhistograms derived from all the events under consideration\n\n\n\ncan fail to have a valley because events far from the line\n\n\n\nmay project between the two anchoring populations. Near\n\n\n\nthe populations one might expect this problem to go away.\n\n\n\nAnd we accomplish this restriction by considering only\n\n\n\nthose points within a fixed distance of the population-\n\n\n\njoining line using the magnitude of the vector perpendicular\n\n\n\nto the population-joining line to each event.\n\n\n\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: One = Barycentric (t) value\n\n\nPOLAR_ANGLE\nTransforms the rectilinear input coordinates into polar\n\n\n\ncoordinates and outputs the angle. The first input is taken\n\n\n\nas the X-axis and the second the Y-axis. Angles are\n\n\n\nmeasured from X to Y and lie between 0 and pi.\n\n\n\nCut point method: Transform parameters define a rectangle\n\n\n\nin (modulus, angle) coordinates based on population means.\n\n\n\nA histogram in the angular coordinate is built from the\n\n\n\nevents falling within this rectangle and a valley is sought\n\n\n\nbetween the edges of the minimum and maximum angular\n\n\n\nbounds.\n\n\n\nNum Inputs: Two - X = first input, Y = second input\n\n\n\nNum Outputs: One = Angle between event and the first\n\n\n\ninput axis, i.e. second input == 0\n\n\nMAHALANOBIS\nComputes the Mahalanobis distance using the centroid and\n\n\n\ncovariance (either runtime estimated from the EM hidden\n\n\n\ndata, or from the model inputs) parameters for a specified\n\n\n\npopulation. Since the inputs can be any subset of the\n\n\n\noriginal channels (or outputs from other transforms) this\n\n\n\ntransform allows one to \u201cweight\u201d the hidden data values\n\n\n\nbased on density properties found in subspaces. This, in a\n\n\n\nsense, weights the contribution of some input channels.\n\n\n\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: One\n\n\nCHANNEL_SATURATION\nThis is an attempt to find a natural separation between the\n\n\n\nregion of space containing true data and those events that\n\n\n\ntend to accumulate at or near the saturation point on a given\n\n\n\nchannel. Two inputs are required. One is expected to\n\n\n\ncontain the saturation events while the other defines a\n\n\n\nregion in which to search for a natural cut point. This has\n\n\n\nbeen used most often with TOF as the saturation channel\n\n\n\nand FSH Peak as the second input.\n\n\n\nNum Inputs: Two\n\n\n\nNum Outputs: One = Input Y coordinate values\n\n\nNEG_LOG_FMM\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: One = negative log likelihood ratio of two\n\n\n\nFMMs\n\n\nNEG_LOG_MVN_PDF\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: One = negative log of Gaussian probability\n\n\n\nvalues for each data point\n\n\nCONSTRAINED_NEG_LOG_MVN_PDF\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: One\n\n\nLOGICAL_OR\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: One = Boolean vector resulting from Logical\n\n\n\nOR of all inputs.\n\n\nTRIANGLE_AREA\nNum Inputs: Two\n\n\n\nNum Outputs: One = signed triangle area\n\n\nORIGINAL_R8_CUT\nNum Inputs: Two\n\n\n\nNum Outputs: One = radial distance from \u201cwedge\u201d origin\n\n\nPCA\nNum Inputs: Arbitrary\n\n\n\nNum Outputs: Arbitrary\n\n\nWHITE_TRASH\nNum Inputs: Two\n\n\n\nNum Outputs: One = vertical distance from arc\n\n\nBAYESIAN_CLASSIFIER\nThere is a serious bug in this transform that renders it\n\n\n\nuseless. The original intention was to perform an\n\n\n\nintermediate classification before completing the EM\n\n\n\nalgorithm. Output was expected to be a Boolean with True\n\n\n\nvalues for events classified to be a specified population in\n\n\n\nthe FMM. Left as s stub in case anyone else figures out my\n\n\n\nerror. ECT Oct. 14, 2005\n\n\nHIERARCHICAL_CLUSTERING\nAttempted to use a nearest neighbor joining algorithm to\n\n\n\nclassify event clusters. Intended to be used in a\n\n\n\nPostClassification type Rule. Found the version 6.5 matlab\n\n\n\nof linkage too slow to be useful and ran out of time to write\n\n\n\na faster one. Left this as a stub in case anyone else started\n\n\n\ndown this path later. ECT Oct. 14, 2005",
        "COORDINATE ExpertTransform Parameter Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStandardizeData\nBoolean\n\n\n\nCutMethod\nString\n\n\n\nCutMethodParameters\nCutMethodStruct",
        "CutMethodStruct Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPopulation\nString\n\n\n\nUseModelMean\nBoolean\n\n\n\nUseCovarOffset\nBoolean\n\n\n\nUseModelCovar\nBoolean\n\n\n\nOffsetScaling\nList of real\n\n\n\n\nnumbers",
        "BARYCENTRIC_1D ExpertTransform Parameter Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPointAt1\nPointStruct\n\n\n\nPointAt0\nStruct\n\n\n\nRegionOfInterestParameters\nROIStruct\n\n\n\nHistogramValleyParameters\nHistoStruct",
        "PointStruct Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nString\n\n\n\nUseModalMean\nBoolean",
        "ROIStruct Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMaxDistanceFromLine\nReal number\n\n\n\nMinBinT\nReal number\n\n\n\nMaxBinT\nReal number",
        "HistoStruct Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumBins\nReal number\n\n\n\nPopulationMeanOffset\nReal number\n\n\n\nPopulationCommonSD\nReal number\n\n\n\nFirstPopulationPrior\nReal number",
        "POLARANGLE ExpertTransform Parameter Definition\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\nMinModulus\nModulusStruct\n\n\n\nMaxModulus\nModulusStruct\n\n\nMinAngle\nAngleStruct\n\n\nMaxAngle\nAngleStruct\n\n\nMinModulusDifference\nReal number\n\n\nMinInAnnulusToUse\nReal number\n\n\nSparseAnnulusMinModulusAdjustment\nReal number\n\n\nSparseAnnulusMaxModulusAdjustment\nReal number\n\n\nUseModulusHisto\nBoolean\n\n\nModulusHisto\nHistoStruct\n\n\nAngularHisto\nHistoStruct",
        "ModulusStruct Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUseAbsolute\nBoolean\n\n\n\nAbsoluteValue\nReal number\n\n\n\nUseModelMean\nBoolean\n\n\n\nPopulation\nString\n\n\n\nUseModelCovarOffset\nBoolean\n\n\n\nModelCovarOffset\nReal number\n\n\n\nCovarCoordinate\nString",
        "AngleStruct Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUseAbsolute\nBoolean\n\n\n\nAbsoluteValue\nReal number\n\n\n\nUseModelMean\nBoolean\n\n\n\nPopulation\nString\n\n\n\nOffsetDegrees\nReal number",
        "MAHALANOBIS ExpertTransform Parameter Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPopulation\nString\n\n\n\nUseModelMean\nBoolean\n\n\n\nUseModelCovar\nBoolean\n\n\n\nCutMethod\nString\n\n\n\nCutMethodParameters\nCutMethodString",
        "CHANNEL_SATURATION ExpertTransform Parameter Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPopulation\nString\n\n\n\nSaturationInput\nInputStruct\n\n\n\nBoundingBoxInput\nInputStruct\n\n\n\nHistogramValleyParameters\nHistoStruct\n\n\n\nCovarBoundingOffsetScale\nReal number",
        "InputStruct Definition\n\n\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nString\n\n\n\nName\nString\n\n\n\nUseModalMean\nBoolean\n\n\n\nUseCovarOffset\nBoolean\n\n\n\nUseModelCovar\nBoolean\n\n\n\nOffsetScaling\nReal number",
        "Expert Rules",
        "Expert Rules are defined by a Matlab list of structures. The fields of each structure are described here.",
        "Expert Rule Structure Definition\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\nNAME\nString\nUser defined name for transform.\n\n\n\n\nNot referenced any place.\n\n\nTYPE\nString\nDetermines when during\n\n\n\n\nalgorithm execution Rule is used.\n\n\n\n\nCurrent types:\n\n\n\n\n\u2018DuringOptimization\u2019 \u2192\n\n\n\n\nRule is applied between\n\n\n\n\nExpectation and Maximization\n\n\n\n\nstep while optimizing the FMM\n\n\n\n\nparameters\n\n\n\n\n\u2018PostClassification\u2019 \u2192\n\n\n\n\nRule is applied after event classes\n\n\n\n\nhave been assigned and before\n\n\n\n\nclassification is written to final\n\n\n\n\nFCS file\n\n\nPARAMETERS\nStructure\nStructure contains parameters\n\n\n\n\nused by the specific rule instance.\n\n\n\n\nDifferent rule Types have\n\n\n\n\ndifferent expected parameters.\n\n\nHUMAN_RULES_AND_METRICS\nList of MetricStructs\nList identifies the Expert\n\n\n\n\nTransform Outputs that define the\n\n\n\n\nTrue Domain. Use is able to\n\n\n\n\nselect the \u201c>\u201d or \u201c<\u201d zero regions,\n\n\n\n\nand whether each output is\n\n\n\n\nessential for the rule definition.\n\n\n\n\nLogical \u201cAND\u201d is used to\n\n\n\n\ncombine the Transform Output\n\n\n\n\nLogicals.\n\n\nEFFECT\nList of EffectStructs\nList of populations effected\n\n\n\n\nwithin the True Domain and the\n\n\n\n\nmultiplicative weights used to\n\n\n\n\nadjust the hidden data for the EM\n\n\n\n\nalgorithm.\n\n\nOUT_EFFECT\nList of EffectStructs\nList of populations effected in the\n\n\n\n\nFalse Domain for this rule.\n\n\n\n\nSimilar to EFFECT otherwise.",
        "MetricStruct Definition\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\nMetric\nString\nFirst character of string must be\n\n\n\n\neither \u2018>\u2019 or \u2018<\u2019, while the\n\n\n\n\nremainder must match identically\n\n\n\n\n(case included) with a transform\n\n\n\n\nOutput Vector name.\n\n\nEssentialForRule-\nBoolean\nIf True and metric referenced by\n\n\nAvailability\n\nMetric string is UNAVAILABLE,\n\n\n\n\nthen Rule will be not be applied.\n\n\n\n\nIf False and metric references by\n\n\n\n\nMetric string is UNAVAILABLE,\n\n\n\n\nthen individual metric is skipped in\n\n\n\n\nthe True Domain definition.\n\n\n\n\nIf metric referenced by Metric\n\n\n\n\nString is AVAILABLE, Boolean\n\n\n\n\nvalue is irrelevant.",
        "EffectStruct Definition\n\n\n\n\n\n\n\n\n\nFieldname\nValue Type\nDescription\n\n\n\n\n\nPopulation\nString\nUser defined name for Population\n\n\n\n\nas it appears in the\n\n\n\n\nInternalClassName in the\n\n\n\n\nMVN_Collection structure.\n\n\nProbabilityAdjustment\nReal number\nThe EM hidden data for specified\n\n\n\n\npopulation is multiplied by this\n\n\n\n\nvalue."
    ],
    "citations": [
        "5380663",
        "5451525",
        "5627037",
        "6524960",
        "6618143",
        "6784981",
        "7043500",
        "7218764",
        "2001/0049689",
        "2005/0112541",
        "2006/0190195",
        "0553951",
        "1686494",
        "WO 0185914",
        "WO 2005008254",
        "WO 2005085842"
    ],
    "us_classification": "702 21",
    "international_classifications": [
        {
            "classification_level": "A",
            "section": "G",
            "classification_class": "01",
            "subclass": "N",
            "main_group": "33",
            "subgroup": "48"
        }
    ]
}