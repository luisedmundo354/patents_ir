<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298749-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298749</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10752731</doc-number>
<date>20040107</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>702</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>12</main-group>
<subgroup>56</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>37039542</main-classification>
<further-classification>709212</further-classification>
</classification-national>
<invention-title id="d0e53">Completion coalescing by TCP receiver</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6718370</doc-number>
<kind>B1</kind>
<name>Coffman et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709212</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7016354</doc-number>
<kind>B2</kind>
<name>Vangal et al.</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370392</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7181544</doc-number>
<kind>B2</kind>
<name>Vangal et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709250</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2002/0062402</doc-number>
<kind>A1</kind>
<name>Regnier et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709313</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2002/0152315</doc-number>
<kind>A1</kind>
<name>Kagan et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2003/0031172</doc-number>
<kind>A1</kind>
<name>Grinfeld</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2003/0076822</doc-number>
<kind>A1</kind>
<name>Shalom et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370378</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2004/0042497</doc-number>
<kind>A1</kind>
<name>Vangal et al.</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370503</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2004/0062267</doc-number>
<kind>A1</kind>
<name>Minami et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370463</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2005/0021558</doc-number>
<kind>A1</kind>
<name>Beverly et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>7071041</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2005/0033988</doc-number>
<kind>A1</kind>
<name>Chandrashekhar et al.</name>
<date>20050200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713201</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2005/0165985</doc-number>
<kind>A1</kind>
<name>Vangal et al.</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710107</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2006/0168281</doc-number>
<kind>A1</kind>
<name>Starr et al.</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709230</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00014">
<othercit>Parallel TCP for High Performance Communication subsystems.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00015">
<othercit>Embedded Protocol Processor for Fast and Efficient Packet Reception.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
</references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>370389</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370394</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370419</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370463</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709250</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050147039</doc-number>
<kind>A1</kind>
<date>20050707</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Biran</last-name>
<first-name>Giora</first-name>
<address>
<city>Zichron-Yaakov</city>
<country>IL</country>
</address>
</addressbook>
<nationality>
<country>IL</country>
</nationality>
<residence>
<country>IL</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Makhervaks</last-name>
<first-name>Vadim</first-name>
<address>
<city>Yokneam</city>
<country>IL</country>
</address>
</addressbook>
<nationality>
<country>IL</country>
</nationality>
<residence>
<country>IL</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Blecker</last-name>
<first-name>Ira D.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Hoffman, Warnick &amp; D'Alessandro LLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kizou</last-name>
<first-name>Hassan</first-name>
<department>2616</department>
</primary-examiner>
<assistant-examiner>
<last-name>Ahmed</last-name>
<first-name>Salman</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and system for completion coalescing by a Transmission Control Protocol (TCP) receiver (e.g., in a TCP/IP offload engine (TOE)). The method comprises: processing inbound TCP segments; and performing completion processing of received TCP ACKS and/or RDMA Read Requests independently of the processing of the inbound TCP segments.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="124.71mm" wi="197.10mm" file="US07298749-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="197.53mm" wi="137.58mm" orientation="landscape" file="US07298749-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="219.46mm" wi="141.31mm" orientation="landscape" file="US07298749-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="234.95mm" wi="104.73mm" orientation="landscape" file="US07298749-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="208.79mm" wi="163.58mm" orientation="landscape" file="US07298749-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="237.07mm" wi="137.16mm" orientation="landscape" file="US07298749-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Technical Field</p>
<p id="p-0003" num="0002">The present invention relates generally to Transmission Control Protocol (TCP) systems. More particularly, the present invention provides a method, system, and computer program product for completion coalescing by a TCP receiver (e.g., in a TCP/IP offload engine (TOE)).</p>
<p id="p-0004" num="0003">2. Related Art</p>
<p id="p-0005" num="0004">As known in the art, TCP is a data transfer protocol that uses acknowledgement and timeout mechanisms to provide reliable services. To this extent, TCP assigns a sequence number to each byte transmitted, and expects a positive acknowledgement (ACK) from the receiving TCP. If the TCP ACK is not received within a timeout interval, the data is retransmitted. Other, more advanced retransmit schemes are also used, which allow the retransmit process to start upon reception of multiple (e.g., three) duplicated ACKS (a duplicated ACK is an ACK which does not change the left window edge of a TCP window).</p>
<p id="p-0006" num="0005">The use of the acknowledgement mechanism is based on sending dedicated TCP ACK segments, or piggy-backing TCP ACK information in the TCP headers of data segments. However, processing of dedicated TCP ACK segments or piggy-backed TCP ACK information is a clear overhead to the network. One way that TCP attempts to reduce this overhead is by using a delayed TCP ACK approach. This approach allows a single TCP ACK to be sent for each two (or more) received TCP segments.</p>
<p id="p-0007" num="0006">Additional TCP ACK processing overhead arises from the completion processing of each received TCP ACK segment or data segment carrying new TCP ACK information. As known in the art, such completion processing involves, for example, the reading and processing of a posted consumer request (e.g., descriptors read), to identify whether this request has been completed or not. A major problem with TCP, is that TCP does not provide a simple way to map TCP sequence numbers to consumer requests. In InfiniBand, for example, an acknowledgement segment carries not only a byte sequence number, but also a message sequence number. This allows ACK processing and completion handling to be performed without the need to gather information to perform ACK SN— to consumer request mapping. In TCP, however, an ACK does not carry such information. As such, in TCP, information must be gathered to perform ACK SN— to—consumer request mapping. One way to gather the required information involves the reading and processing of consumer requests. Therefore, performing such time consuming operations for each received TCP ACK both consumes network and processing resources and forces the logic processing of inbound TCP segments to wait for the completion processing of each received TCP ACK to finish, before processing the next TCP segment. Thus, the completion processing overhead comprises two parts: the overhead of the completion operation itself; and the coupling of inbound TCP segment processing logic with completion processing logic.</p>
<p id="p-0008" num="0007">There is a need, therefore, for a method, system, and computer program product for processing inbound TCP segments (including ACKS) independently from completion processing. This allows the processing of inbound TCP segments to continue without waiting for the completion processing of each received TCP ACK to finish. Also, the delayed, separate completion processing allows the present invention to perform coalescing of ACKS (i.e., one completion operation may be performed for multiple ACKS, instead of one completion operation per ACK). The same approach may also be applied to the completion processing of RDMA Read Requests.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0009" num="0008">The present invention provides a method and system for processing inbound TCP segments (including ACKS) independently from completion processing. In particular, each received TCP ACK (dedicated or carried by a data segment) is not processed immediately by inbound segment processing logic, but is instead scheduled for processing using a completion coalescing list. Scheduling a connection for completion processing is done by updating TCP ACK information in a connection context, and adding the connection context to the completion coalescing list.</p>
<p id="p-0010" num="0009">A first aspect of the present invention is directed to a method for completion processing, comprising: processing inbound TCP segments; and performing completion processing of received TCP ACKS independently of the processing of the inbound TCP segments.</p>
<p id="p-0011" num="0010">A second aspect of the present invention is directed to a system for completion processing, comprising: TCP logic for processing inbound TCP segments; and a system for performing completion processing of received TCP ACKS independently of the processing of the inbound TCP segments.</p>
<p id="p-0012" num="0011">A third aspect of the present invention provides a computer program product for performing the methods of the present invention.</p>
<p id="p-0013" num="0012">The foregoing and other features of the invention will be apparent from the following more particular description of embodiments of the invention.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The embodiments of this invention will be described in detail, with reference to the following figures, wherein like designations denote like elements, and wherein:</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a block diagram of a completion coalescing system for the completion processing of TCP ACKS in accordance with the present invention.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> illustrates the structure of a completion coalescing list in accordance with the present invention.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIGS. 3A-3B</figref> illustrate the addition of a completion context to the completion coalescing list in accordance with the present invention.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a block diagram of a completion coalescing system for the completion processing of TCP ACKS and remote data memory access (RDMA) Read Responses in accordance with the present invention.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> illustrates the completion ordering rules of the RDMA protocol.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> schematically illustrates an RDMA Read operation.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0021" num="0020">The present invention provides a method, system, and computer program product for completion coalescing by a Transmission Control Protocol (TCP) receiver.</p>
<p id="p-0022" num="0021">Referring now to <figref idref="DRAWINGS">FIG. 1</figref>, there is illustrated a block diagram of a completion coalescing system <b>10</b> in accordance with the present invention. It is assumed for the purposes of this description that the reader has an understanding of TCP commensurate with one skilled in the art. Accordingly, a detailed description of TCP is not provided herein.</p>
<p id="p-0023" num="0022">Completion coalescing system <b>10</b> includes TCP logic <b>12</b>, transmit/retransmit handler <b>14</b>, completion handler <b>16</b>, and completion coalescing list <b>18</b>. In accordance with the present invention, the completion operation for each received TCP ACK (dedicated or carried by a data segment) is not processed immediately by TCP logic <b>12</b>, but is instead scheduled for processing using a completion coalescing list <b>18</b>. The TCP ACK, however, is processed immediately by TCP logic <b>12</b>.</p>
<p id="p-0024" num="0023">TCP logic <b>12</b> includes receive (Rx) TCP logic <b>20</b> and transmit (Tx) TCP logic <b>22</b>. Rx TCP logic <b>20</b> processes received TCP segments. This includes, for example, extraction of TCP ACK information, such as the sequence number of the last acknowledged byte of the TCP data stream (i.e. LastAckedSN), from the received TCP segments. This information (i.e., LastAckedSN) is passed to completion handler <b>16</b> as a completion request <b>24</b>. To pass this completion information (i.e., via a completion request <b>24</b>) to completion handler <b>16</b>, the present invention uses completion coalescing list <b>18</b>. The completion information is passed via a connection context in completion coalescing list <b>18</b> (LastAckedSN is a field of the connection context which carries the most recently ACKed SN). The connection context itself is chained to completion coalescing list <b>18</b>, but only if the connection does not have a pending completion request. If the connection is already waiting for completion handling in the completion coalescing list <b>18</b> (i.e., the connection already has a pending completion request), the information in the connection context is updated to carry the more recent LastAckedSN. This separates Rx TCP Logic <b>20</b> (or handling/processing of received TCP segments) from the relatively slow, and bursty completion process.</p>
<p id="p-0025" num="0024">Tx TCP logic <b>22</b> of TCP logic <b>12</b> decides what should be transmitted for a given connection. Tx TCP <b>22</b> logic may decide to perform a transmit of the new TCP segment, or perform a retransmit of a previously transmitted TCP segment. Retransmit can be caused, for example, by a timeout, or by other fast-recovery methods implemented by Tx TCP logic <b>22</b>. Tx TCP logic <b>22</b> passes a request <b>26</b> to perform a transmit/retransmit operation to the transmit/retransmit handler <b>14</b>, which performs the requested operation.</p>
<p id="p-0026" num="0025">Completion coalescing list <b>18</b> is a list of connections, or more precisely, connection contexts. A connection context is a data structure (i.e., including data, pointers, fields, bits, flags, etc.) that stores data pertaining to a particular connection. Completion coalescing list <b>18</b> is a unidirectional linked list implemented by chaining connection contexts using pointers inside the context. Completion coalescing list <b>18</b> holds connection contexts corresponding to connections that have a pending completion request to handle. Reception of a TCP ACK, for example, is one of the triggers that may lead to adding a connection context to completion coalescing list <b>18</b> (i.e., a TCP ACK is a trigger for scheduling a connection context in completion coalescing list <b>18</b> for completion handling by completion handler <b>16</b>). Each connection may appear in completion coalescing list <b>18</b> only once. If a connection context corresponding to a connection is already chained to completion coalescing list <b>18</b>, the connection context is updated to carry the most recent information, and is kept in the same location in completion coalescing list <b>18</b> where it was originally chained.</p>
<p id="p-0027" num="0026">As illustrated in <figref idref="DRAWINGS">FIG. 2</figref>, completion coalescing list <b>18</b> is implemented using a pointer <b>28</b> held in each connection context <b>30</b>. To this extent, each connection context <b>30</b> has a field <b>32</b> which points, via a pointer <b>28</b>, to the next connection context <b>30</b> in completion coalescing list <b>18</b>. A connection is added to the tail <b>36</b> of completion coalescing list <b>18</b> by a request (i.e., a completion request) from Rx TCP logic <b>20</b> of TCP logic <b>12</b>, and removed from the head <b>34</b> of completion coalescing list <b>18</b> by completion handler <b>16</b>.</p>
<p id="p-0028" num="0027">Referring again to <figref idref="DRAWINGS">FIG. 1</figref>, it should be noted that in order to perform a retransmit operation, transmit/retransmit handler <b>14</b> needs to make sure that all preceding completion requests for that connection have been completed. The reason for this is that the retransmit operation generally starts from the last not-completed byte of the TCP data stream (or from or inside the last not-completed request of a consumer). Therefore, the completion operation must precede the handling of a retransmit. Since completion requests <b>24</b> are normally not handled immediately, and are instead handled by completion handler <b>16</b> via completion coalescing list <b>18</b>, there is a need to make sure that the given connection does not wait in completion coalescing list <b>18</b> prior to completion handling by completion handler <b>16</b>. To ensure that the completion operation is completed as soon as possible for that connection, transmit/retransmit handler <b>14</b> sends a high-priority completion request <b>24</b><sub>HP </sub>to completion handler <b>16</b>, requesting that completion handler <b>16</b> perform the completion operation as soon as possible for the given connection (i.e., completion coalescing list <b>18</b> is bypassed). Transmit/retransmit handler <b>14</b> subsequently waits for completion of this operation, and only then performs the retransmit operation.</p>
<p id="p-0029" num="0028">Completion handler <b>16</b> is configured to take (i.e., pull) connection contexts <b>30</b> one-by-one from the head <b>34</b> (<figref idref="DRAWINGS">FIG. 2</figref>) of completion coalescing list <b>18</b>, and uses completion information in each pulled connection context <b>30</b> to perform a completion operation in a manner known in the art. As described above, completion hander <b>16</b> may also receive a high-priority completion request <b>24</b><sub>HP </sub>from transmit/retransmit handler <b>14</b> logic to perform an “urgent” completion operation for the specified connection. In such a case, completion handler <b>16</b> finishes the current completion operation, and performs the completion operation requested by transmit/retransmit handler <b>14</b>.</p>
<p id="p-0030" num="0029">As detailed above, connection contexts <b>30</b> are chained in completion coalescing list <b>18</b> using a pointer <b>28</b> held in field <b>32</b> of each connection context <b>30</b>. To be more precise, connection contexts <b>30</b> are chained in completion coalescing list <b>18</b> using a Context[Ch#]::NextInAckList field <b>32</b> in connection context <b>30</b>.</p>
<p id="p-0031" num="0030">The Context[Ch#]::NextInAckList field <b>32</b> of connection context <b>30</b> holds the connection number of the next connection context <b>30</b> in the chain of connection contexts <b>30</b> forming completion coalescing list <b>18</b> (i.e., the Context[Ch#]::NextInAckList field <b>32</b> effectively provides a pointer <b>28</b> to the next connection context <b>30</b> in the chain). When adding a new connection context <b>30</b> to the chain (e.g., upon receipt of a new TCP ACK), the Context[Ch#]::NextInAckList field <b>32</b> of the last connection context <b>30</b> of the chain is updated to refer to the newly added connection context <b>30</b>. This is shown in a simplistic manner in <figref idref="DRAWINGS">FIGS. 3A and 3B</figref>. Specifically, in <figref idref="DRAWINGS">FIG. 3A</figref>, completion coalescing list <b>18</b> is shown as including two connection contexts <b>301</b>, <b>302</b> chained together, with the Context[Ch#]::NextInAckList field <b>32</b>, of connection context <b>30</b>, pointing (pointer <b>281</b>) to the last connection context (i.e., connection context <b>302</b>) in completion coalescing list <b>18</b>. When a new connection context <b>303</b> is added to the tail <b>36</b> of the chain (e.g., upon receipt of a new TCP ACK), the Context[Ch#]::NextInAckList field <b>322</b> of connection context <b>302</b> is updated to refer (pointer <b>282</b>) to the newly added connection context <b>303</b>, which now is located at the tail <b>36</b> of completion coalescing list <b>18</b>.</p>
<p id="p-0032" num="0031">When a new TCP ACK arrives, Rx TCP logic <b>20</b> of TCP logic <b>12</b> first updates the TCP ACK information carried by the received TCP segment, using the Context[Ch#]::LastAckedSN field <b>38</b> of connection context <b>30</b> (see, e.g., the Context[Ch#]::LastAckedSN field <b>383</b> in connection context <b>303</b>, <figref idref="DRAWINGS">FIG. 3B</figref>). Although not shown in <figref idref="DRAWINGS">FIG. 3B</figref>, each connection context <b>30</b> includes a Context[Ch#]::LastAckedSN field <b>38</b>. Connection context <b>30</b> field Context[Ch#]::LastAckedSN <b>38</b> indicates the sequence number of the last acknowledged byte of the TCP data stream.</p>
<p id="p-0033" num="0032">Connection context <b>30</b> also holds a bit indicating whether or not the connection context has a valid completion processing request. This bit is provided in the Context[Ch#]::CompletionReq field <b>40</b> of connection context <b>30</b> (see, e.g., the Context[Ch#]::CompletionReq field <b>403</b> in connection context <b>303</b>, <figref idref="DRAWINGS">FIG. 3B</figref>). Although not shown in <figref idref="DRAWINGS">FIG. 3B</figref>, each connection context <b>30</b> includes a Context[Ch#]::CompletionReq field <b>40</b>. This bit also indicates whether connection context <b>30</b> has already been chained to completion coalescing list <b>18</b> or not. If connection context <b>30</b> is already chained to completion coalescing list <b>18</b> (i.e., Context[Ch#]::CompletionReq is set), the update of Context[Ch#]::LastAckedSN effectively means the coalescing of ACK information in the connection contexts <b>30</b> corresponding to received TCP ACKS.</p>
<p id="p-0034" num="0033">If a connection context <b>30</b> (e.g., a connection context corresponding to a new TCP ACK) does not have any pending completion requests, i.e., Context[Ch#]::CompletionReq is clear, the connection context <b>30</b> is added to the tail <b>36</b> of completion coalescing list <b>18</b>, and the Context[Ch#]::NextInAckList field of the last connection context <b>30</b> in completion coalescing list <b>18</b> is updated to refer to the newly added connection context <b>30</b> (i.e., via the connection number of the next connection context <b>30</b> in the chain).</p>
<p id="p-0035" num="0034">Completion requests in completion coalescing list <b>18</b> are served by completion handler <b>16</b>. Completion handler <b>16</b> operates a synchronously (i.e., independently, or in parallel with) from transmit/retransmit handler <b>14</b> and the Rx TCP logic <b>20</b>. This allows the completion processing to be kept separate from the posted to transmit requests and inbound TCP traffic.</p>
<p id="p-0036" num="0035">Completion handler <b>16</b> dequeues connection context <b>30</b> from the head <b>34</b> of completion coalescing list <b>18</b>, and uses the Context[Ch#]::LastAckedSN field to perform completion processing in a manner known in the art. After processing the completion request, completion handler <b>16</b> clears the Context[Ch#]::CompletionReq bit for the corresponding connection context <b>30</b>. Since the connection context <b>30</b> may have been updated with a new completion request during completion processing, completion handler <b>16</b> determines whether the Context[Ch#]::LastAckedSN field is equal to the processed LastAckedSN, before clearing the Context[Ch#]::CompletionReq bit. If the Context[Ch#]::LastAckedSN field is not equal to the processed LastAckedSN, the completion handler <b>16</b> performs completion processing using the updated LastAckedSN. This is one way to resolve the updating of the LastAckedSN during completion handling. Another way would place that connection back to the end of completion coalescing list <b>18</b>, and wait for a later service cycle to handle its completion.</p>
<p id="p-0037" num="0036">The use of a completion coalescing list <b>18</b> and completion handler <b>16</b> by completion coalescing system <b>10</b> reduces completion processing overhead when compared to prior art completion processing techniques. Although the processing of each completion request involves one or more descriptor read operations, which have a processing cost that is highly dependent on the system configuration (e.g., location of the descriptors, latency of descriptor read operation, etc.), the use of completion coalescing system <b>10</b> of the present invention nevertheless reduces the required number of completion request processing operations and allows better utilization of the fetched descriptors. Therefore, in spite of additional reads on the part of connection context needed to perform the completion operation, completion coalescing system <b>10</b> of the present invention improves overall system performance. A greater benefit provided by the completion coalescing approach of the present invention is the separation of the completion operation from the TCP receive operation. This allows the completion coalescing system <b>10</b> of the present invention to continue to receive new TCP segments, regardless of how slow the completion handling process is.</p>
<p id="p-0038" num="0037">Another improvement provided by completion coalescing system <b>10</b> of the present invention is the decoupling of the processing of inbound TCP segments from completion handler <b>16</b>. This also reduces performance demands from completion handler <b>16</b> and reduces the priority of completion handling. Completion handling becomes a self-tuning mechanism: more connections waiting for completion processing, more aggressive completion coalescing, less time and bandwidth consumed by completion processing.</p>
<p id="p-0039" num="0038">The completion coalescing list presented above may be adapted to process completion of a pending RDMA Read Request upon the delivery of an inbound RDMA read response. It is assumed for the purpose of this description that the reader has an understanding of the RDMA protocol and its implementation in an RNIC environment commensurate with one skilled in the art. The RDMA protocol is well documented and is available, for example, on the Web at &lt;www.rdmaconsortium.org&gt;.</p>
<p id="p-0040" num="0039">A completion coalescing system <b>100</b> in accordance with another embodiment of the present invention, and capable of processing completion of a pending RDMA Read Request, is illustrated in <figref idref="DRAWINGS">FIG. 4</figref>. As shown, completion coalescing system <b>100</b> comprises TCP logic <b>12</b> (including Rx TCP logic <b>20</b> and Tx TCP logic <b>22</b>), transmit/retransmit handler <b>14</b>, completion handler <b>16</b>, and completion coalescing list <b>18</b>, which operate as described above with regard to the corresponding components of completion coalescing system <b>10</b>. In addition, completion coalescing system <b>100</b> includes RDMA logic <b>102</b> for handling received RDMA messages.</p>
<p id="p-0041" num="0040">RDMA protocol defines special completion ordering rules (see, e.g., <figref idref="DRAWINGS">FIG. 5</figref>) including, for example, that all RDMA requests must be completed in the order that they have been posted by a consumer. RDMA has three types of requests:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0041">1) RDMA operations consisting of a single RDMA message (e.g., Send, Write). These operations are used to transfer data from a local to remote host, and include a single RDMA message sent from the remote to the local host.</li>
    <li id="ul0001-0002" num="0042">2) RDMA operations consisting of several (e.g., two) RDMA messages (e.g., Read). The Read operation is intended to read data from a remote memory. Such an operation consists of two RDMA messages: Read Request and Read Response. The Read Request is a message sent by a request originator to the remote data source. The Read Request message carries all information necessary to read the data from the remote memory, and to build a response message. The response message, generated by the remote host, is a Read Response. The Read Response message carries the data to be written to the requester memory, and a description of location to which the data should be written. The Read Operation is illustrated schematically in <figref idref="DRAWINGS">FIG. 6</figref>.</li>
    <li id="ul0001-0003" num="0043">3) Local RDMA operations (like Bind, Fast-Register, etc.), which do not result in the transmission of any data (e.g., a TCP segment).</li>
</ul>
</p>
<p id="p-0042" num="0044">Local RDMA operations are considered as completed when their processing is finished by the RDMA network interface card (RNIC). Send and Write operations are considered completed when the RNIC can guarantee that all TCP segments in the RDMA message can be reliably transmitted to the other end point of the TCP connection. The Read operation is considered completed when the RDMA Read Response message has been successfully received by Read initiator.</p>
<p id="p-0043" num="0045">A portion of the completion ordering rules requires that an RDMA Read Request is completed only when an RDMA Read Response message is received. Therefore, in order to support RDMA protocol, the completion handler <b>16</b> needs an additional completion indication: reception of an RDMA Read Response <b>104</b> (which effectively means completion of a corresponding RDMA Read Request). Thus, when RDMA logic <b>102</b> receives an RDMA Read Response <b>104</b> it posts a completion request <b>106</b> to the completion coalescing list <b>18</b>. Accordingly, completion handler <b>16</b> performs completion operations using both information from TCP ACKS, and received RDMA Read Responses, provided in the connection contexts <b>30</b> of completion coalescing list <b>18</b>.</p>
<p id="p-0044" num="0046">An approach similar to that described above with regard to the completion processing of received TCP ACKS can be used for the completion processing of pending RDMA Read Requests upon delivery of inbound RDMA Read Responses. To this extent, connection contexts <b>30</b> corresponding to RDMA Read Requests are chained in completion coalescing list <b>18</b>. To allow coalescing of completed RDMA Read Requests, the connection context <b>30</b> carries the number of completed RDMA Read Requests in a Context[Ch#]: CompletedReadRequestNum field.</p>
<p id="p-0045" num="0047">When receive logic of RDMA logic <b>102</b> delivers an inbound RDMA Read Response <b>104</b>, it increases the number of completed RDMA Read Requests, and updates the Context[Ch#]::CompletedReadRequestNum field in connection context <b>30</b> accordingly. If a connection is not yet chained to the completion coalescing list <b>18</b>, i.e., (Context[Ch#]::CompletedReadRequestNum was equal to zero, and Context[Ch#]::CompletionReq is clear), the context is chained to the completion coalescing list <b>18</b> by updating the Context[Ch#]::NextInAckList field <b>32</b> of the last connection context <b>30</b> in the completion coalescing list to point to the newly added connection context <b>30</b> (see, e.g., the process illustrated in <figref idref="DRAWINGS">FIGS. 3A-3B</figref>). In addition, upon the chaining of newly added connection context <b>30</b> to the completion coalescing list, the Context[Ch#]::CompletionReq bit should be set as well.</p>
<p id="p-0046" num="0048">Several operations require prior handling of completion requests. For example, operations such as a retransmit request (discussed above) and an inbound RDMA Read Request, may require prior handling of completion requests. An RDMA Read Request, for example, requires prior completion processing only if the Read Queue has no free place to put the request. In this case, RDMA logic <b>102</b> needs first to free some space in the Read Queue before processing the RDMA Read Request (this process is described in greater detail below). In both cases, processing of completion requests cannot be delayed and must be performed before processing of the request. In those cases a coalescing bypass is performed, and completion handler <b>16</b> receives a separate request <b>108</b> to perform completion for the given connection. In this case processing of completion request is done independently from the position of the completion context <b>30</b> in the completion coalescing list <b>18</b>. After completion processing, the processing of the original request (retransmit, inbound RDMA Read Response) can be resumed.</p>
<p id="p-0047" num="0049">Another completion request that may come from RDMA Logic <b>124</b>, is a request to perform a “high priority” completion operation for a given connection. This request is similar to the completion request <b>24</b><sub>HP </sub>sent to completion handler <b>16</b> by transmit/retransmit logic <b>14</b> (see description above). This is a blocking request, which means that RDMA Logic <b>102</b> waits for completion handler <b>16</b> to perform this request. The reason for this request is reception of a RDMA Read Request, and lack of free space in the Receive Queue. RDMA Protocol limits the number of inbound RDMA Read Requests that can be pending (on the wire) in the given moment. This number defines the depth of the Read Queue. Due to coalescing of completion requests (e.g., received TCP ACKS) in the completion coalescing list <b>18</b>, it might be case that the Read Queue is not cleaned up yet by the completion handler <b>16</b> (i.e. the completion request is still in the completion coalescing list <b>18</b>), and in that case, RDMA logic <b>102</b> needs first to free some space in the Read Queue, and only then processes an inbound RDMA Read Request.</p>
<p id="p-0048" num="0050">It is understood that the systems, functions, mechanisms, methods, and modules described herein can be implemented in hardware, software, or a combination of hardware and software. They may be implemented by any type of computer system or other apparatus adapted for carrying out the methods described herein. A typical combination of hardware and software could be a general-purpose computer system with a computer program that, when loaded and executed, controls the computer system such that it carries out the methods described herein. Alternatively, a specific use computer, containing specialized hardware for carrying out one or more of the functional tasks of the invention could be utilized. The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods and functions described herein, and which—when loaded in a computer system—is able to carry out these methods and functions. Computer program, software program, program, program product, or software, in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following: (a) conversion to another language, code or notation; and/or (b) reproduction in a different material form</p>
<p id="p-0049" num="0051">While this invention has been described in conjunction with the specific embodiments outlined above, it is evident that many alternatives, modifications and variations will be apparent to those skilled in the art. Accordingly, the embodiments of the invention as set forth above are intended to be illustrative, not limiting. Various changes may be made without departing from the spirit and scope of the invention as defined in the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for completion processing, comprising:
<claim-text>processing inbound TCP segments;</claim-text>
<claim-text>performing completion processing of received TCP ACKS independently of the processing of the inbound TCP segments;</claim-text>
<claim-text>scheduling the completion processing of each received TCP ACK using a completion coalescing list; and</claim-text>
<claim-text>passing completion information corresponding to each received TCP ACK to a completion handler via the completion coalescing list;</claim-text>
<claim-text>wherein, in response to a retransmit operation, the completion coalescing list is selectively bypassed and the completion information is sent directly to the completion handler for completion processing.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the completion information corresponding to each received TCP ACK is passed to the completion handler via a connection context in the completion coalescing list.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>chaining the connection context to the completion coalescing list.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the completion context is only chained to the completion coalescing list if a connection corresponding to the connection context does not have a pending completion request.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein, if the connection corresponding to the connection context does have a pending completion request, updating information in the connection context.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the updated information in the connection context comprises a last acknowledged sequence number (LastAckedSN).</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A method for completion processing, comprising:
<claim-text>processing inbound TCP segments;</claim-text>
<claim-text>performing completion processing of received TCP ACKS independently of the processing of the inbound TCP segments, wherein the processing of the inbound TCP segments continues without waiting for the completion processing of each received TCP ACK to finish;</claim-text>
<claim-text>scheduling the completion processing of each received TCP ACK using a completion coalescing list;</claim-text>
<claim-text>processing completion of an RDMA Read Request upon reception of an RDMA Read Response using the completion coalescing list; and</claim-text>
<claim-text>selectively bypassing the completion coalescing list and sending the RDMA Read Request directly to the completion handler for completion processing.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:
<claim-text>chaining a connection context corresponding to the RDMA Read Request to the completion coalescing list.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein selectively bypassing the completion coalescing list is performed in response to a Read Queue not having sufficient free space to place the RDMA Read Request.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A system for completion processing, comprising:
<claim-text>TCP logic for processing inbound TCP segments;</claim-text>
<claim-text>a system for performing completion processing of received TCP ACKS independently of the processing of the inbound TCP segments;</claim-text>
<claim-text>a completion coalescing list for scheduling completion processing of each received TCP ACK;</claim-text>
<claim-text>a completion handler for completion processing of each received TCP ACK, wherein completion information corresponding to each received TCP ACK is passed to the completion handler via a connection context in a completion coalescing list; and</claim-text>
<claim-text>a transmit/retransmit handler for sending the completion information directly to the completion handler for completion processing in response to a retransmit operation requested by the TCP logic, thereby selectively bypassing the completion coalescing list.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the TCP logic chains the connection context to the completion coalescing list.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the TCP logic only chains the completion context to the completion coalescing list if a connection corresponding to the connection context does not have a pending completion request.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein, if the connection corresponding to the connection context does have a pending completion request, the TCP logic updates information in the connection context.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the updated information in the connection context comprises a last acknowledged sequence number (LastAckedSN).</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A system for completion processing, comprising:
<claim-text>TCP logic for processing inbound TCP segments;</claim-text>
<claim-text>a system for performing completion processing of received TCP ACKS independently of the processing of the inbound TCP segments, wherein the processing of the inbound TCP segments continues without waiting for the completion processing of each received TCP ACK to finish;</claim-text>
<claim-text>a completion coalescing list for scheduling the completion processing of each received TCP ACK;</claim-text>
<claim-text>RDMA logic for handling received RDMA messages, and for scheduling an RDMA Read Request for completion processing by chaining a connection context corresponding to the RDMA Read Request to the completion coalescing list; and</claim-text>
<claim-text>a completion handler for completion processing of each RDMA Read Request, wherein completion information corresponding to each RDMA Read Request is passed to the completion handler via the connection context in the completion coalescing list;</claim-text>
<claim-text>wherein the RDMA logic is configured to selectively bypass the completion coalescing list and send the RDMA Read Request directly to the completion handler for completion processing.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the completion coalescing list is selectively bypassed in response to a Read Queue not having sufficient free space to place the RDMA Read Request.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A program product stored on a computer readable medium, which when executed, provides completion processing, the computer readable medium comprising program code for:
<claim-text>processing inbound TCP segments;</claim-text>
<claim-text>performing completion processing of received TCP ACKS independently of the processing of the inbound TCP segments;</claim-text>
<claim-text>scheduling the completion processing of each received TCP ACK using a completion coalescing list; and</claim-text>
<claim-text>passing completion information corresponding to each received TCP ACK to a completion handler via the completion coalescing list;</claim-text>
<claim-text>wherein, in response to a retransmit operation, the completion coalescing list is selectively bypassed and the completion information is sent directly to the completion handler for completion processing.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
