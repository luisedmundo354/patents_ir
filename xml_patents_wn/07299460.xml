<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299460-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299460</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10446698</doc-number>
<date>20030529</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>608</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>45</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717137</main-classification>
<further-classification>717136</further-classification>
<further-classification>717138</further-classification>
<further-classification>717139</further-classification>
</classification-national>
<invention-title id="d0e53">Method and computer program for converting an assembly language program for one processor to another</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>3976978</doc-number>
<kind>A</kind>
<name>Patterson et al.</name>
<date>19760800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711208</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5560013</doc-number>
<kind>A</kind>
<name>Scalzi et al.</name>
<date>19960900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717138</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5768593</doc-number>
<kind>A</kind>
<name>Walters et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717141</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5991531</doc-number>
<kind>A</kind>
<name>Song et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703 26</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5991870</doc-number>
<kind>A</kind>
<name>Koumura et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712208</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6360194</doc-number>
<kind>B1</kind>
<name>Egolf</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703 26</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6446034</doc-number>
<kind>B1</kind>
<name>Egolf</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703 27</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6981132</doc-number>
<kind>B2</kind>
<name>Christie et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712226</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7028292</doc-number>
<kind>B1</kind>
<name>Yokota et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717139</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>JP</country>
<doc-number>03-241432</doc-number>
<date>19911000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>JP</country>
<doc-number>07-210397</doc-number>
<kind>A</kind>
<date>19950800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>JP</country>
<doc-number>08-179953</doc-number>
<kind>A</kind>
<date>19960700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00013">
<othercit>Kemal Ebcioglu, et al., “Dynamic Binary Translation and Optimization,” IEEE Transactions on Computers, vol. 50, No. 6, pp. 529-548 (Jun. 2001).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00014">
<othercit>Open Source DAISY (Dynamically Architected Instruction Set from Yorktown), IBM Internet home page (http://oss.software.ibm.com/developerworks/opensource/daisy/).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00015">
<othercit>Anton Chernoff, et al., “FX!32 A Profile-Directed Binary Translator,” IEEE Micro, vol. 18, No. 2, pp. 56-64 (Mar./Apr. 1998).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00016">
<othercit>Alexander Klaiber, et al., “The Technology Behind Crusoe™ Processors,” Transmeta Corporation, pp. 1-18 (Jan. 2000).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>Dynamite Dynamic Binary Translation, Transitive Technologies Ltd., 2001 (http://www.transives.com).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>M.F. Smith, et al., “Automatic Assembler Source Translation from the Z80 to the MC6809,” IEEE Micro, pp. 3-9, (Apr. 1984).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>TMS320C5x to TMS320C54x Translation Utility, Literature No. BPRA075, published by Texas Instrument Europe (Feb. 1998).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>4</number-of-claims>
<us-exemplary-claim>4</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>717136-139</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>12</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040243983</doc-number>
<kind>A1</kind>
<date>20041202</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Kumura</last-name>
<first-name>Takahiro</first-name>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Dickstein, Shapiro, LLP.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>NEC Corporation</orgname>
<role>03</role>
<address>
<country>JP</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>An</last-name>
<first-name>Meng-Al T.</first-name>
<department>2193</department>
</primary-examiner>
<assistant-examiner>
<last-name>Mitchell</last-name>
<first-name>Jason</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Disclosed is a technology of converting a first assembly language program implementable on a first processor to a second assembly language program implementable on another processor. The two assembly language programs are described using same instructions. A unique address in the first assembly language program is assigned to a first number of bytes, and a unique address in the second assembly language program is assigned to a second number of byte numbers. The first number is larger than the second number. The first assembly language program is read from a storage. Thereafter, one or more address descriptions of the first assembly language program are translated to another one or more address descriptions using a ratio of the first number to the second number so that the first assembly language program is implementable on the second processor, wherein the ratio is 2 or a positive integer more than 2.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="200.49mm" wi="112.27mm" file="US07299460-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="216.66mm" wi="115.40mm" file="US07299460-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="139.53mm" wi="131.83mm" file="US07299460-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="182.96mm" wi="143.34mm" file="US07299460-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="125.90mm" wi="142.75mm" file="US07299460-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="109.90mm" wi="148.25mm" file="US07299460-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="123.11mm" wi="141.99mm" file="US07299460-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="104.14mm" wi="121.84mm" file="US07299460-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="214.97mm" wi="140.04mm" file="US07299460-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="224.28mm" wi="146.22mm" file="US07299460-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="190.84mm" wi="140.80mm" file="US07299460-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="182.54mm" wi="143.68mm" file="US07299460-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="128.44mm" wi="131.83mm" file="US07299460-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention relates to a method and computer program for converting an assembly language program for one processor so as to be implementable on another processor.</p>
<p id="p-0004" num="0003">2. Description of Related Art</p>
<p id="p-0005" num="0004">A processor (or microprocessor) is a computer which executes a program in order to produce a desired behavior. The program consists of a set of statements for implementing operations such as addition, subtraction, data-read from a memory connected to the processor, data-write to such a memory, etc. An instruction set varies from processor to processor, and hence, if an assembly language program described for one processor is to be implemented on another processor, it is necessary to convert the instruction descriptions for one processor to those implementable on another processor.</p>
<p id="p-0006" num="0005">As is known in the art, the instruction (code) conversions are generally grouped into two: one is a conversion at a binary level and the other at a source level. The instruction conversion at the binary level is disclosed in the following documents (1) to (5), while the instruction conversion at the source code level is disclosed in the following documents (6) and (7).</p>
<p id="p-0007" num="0006">The document (1) is a paper entitled “Dynamic Binary Translation and Optimization” by Kermal Ebcioglu, et al., IEEE Transactions on Computers, Vol. 50, No. 6, pp. 529-548, June 2001. The document (2) is a paper entitled “Open Source DAISY” available at IBM internet home page (http://oss.software.ibm.com/developerworks/opensource/daisy/). Each of the documents (1) and (2) is concerned with a translator named DAISY which is software for dynamically translating binary codes for the Intel x86 or IBM PowerPC to the IBM VLIW (Very Long Instruction Word) processor.</p>
<p id="p-0008" num="0007">The document (3) is a paper entitled “FX132 A profile-Directed Binary Translator” by Anton Chernoff, et al., IEEE Micro, Vol. 18, No. 2, pp.56-64, March/April 1998. The document (3) describes the software named FX132 for converting the binary codes for the x86 architecture so as to be executed on the Alpha processor.</p>
<p id="p-0009" num="0008">The document (4) is a technical report entitled “The Technology Behind Crusoe Processors” by Alexander Klaiber, et al., Transmeta Corporation, pp.1-18, January 2000. Although the processor Crusoe has an instruction set which is a different architecture of the Intel x86, the Crusoe is able to translate the instructions of the x86 to those of the Crusoe at a binary level.</p>
<p id="p-0010" num="0009">The document (5) is a product data sheet entitled “Dynamite Dynamic Binary Translation” by Transitive Technologies Ltd., 2001, available at http://www.transives.com. According to this document, the binary codes for one processor are translated to the binary codes for another processor.</p>
<p id="p-0011" num="0010">The document (6) is a paper entitled “Automatic Assembler Source Translation from the Z80 to the MC6809” by M. F. Smith, et al., IEEE Micro, Vol., No. 2, pp.3-9, April, 1984. This document describes a technology for converting Z80 code to MC6809 code using a Pascal program.</p>
<p id="p-0012" num="0011">The document (7) is a paper entitled “TMS320C5x to TMS320C54x Translation Utility”, Literature Number: BPRA075, published by Texas Instrument Europe, February 1998. This document describes the translation technology for converting the assembly source codes for the C5x of the Texas Instruments to the assembly codes which are executable on the C54x processor.</p>
<p id="p-0013" num="0012">As is known in the art, there are two types of addressing schemes: one is byte addressing where a unique address is assigned to each byte of memory, and the other is word addressing where a unique address is assigned to more than one byte of memory.</p>
<p id="p-0014" num="0013">Each of the above-mentioned documents (1) to (7) discloses technologies for converting the assembly language program having the same addressing scheme of byte addressing.</p>
<p id="p-0015" num="0014">Up until now, however, no proposal has been made which converts the assembly language instructions (viz., assembly language program) with different addressing schemes (viz., byte addressing and word addressing). The reason for this may reside in the fact that it is difficult to effectively convert the address descriptions in the original program without sacrifice of the execution time on the target program, and that the code size of the converted program becomes undesirably lengthy.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0016" num="0015">It is therefore an object of the present invention to provide a method and computer program via which an assembly language program for one processor is converted so as to be implementable on another processor wherein the addressing schemes differ with the two processors.</p>
<p id="p-0017" num="0016">In brief, these objects are achieved by the techniques for converting a first assembly language program implementable on a first processor to a second assembly language program implementable on another processor. The two assembly language programs are described using same instructions. A unique address in the first assembly language program is assigned to a first number of bytes, and a unique address in the second assembly language program is assigned to a second number of byte numbers. The first number is larger than the second number. The first assembly language program is read from a storage device. Thereafter, one or more address descriptions of the first assembly language program are translated to other one or more address descriptions using a ratio of the first number to the second number so that the first assembly language program is implementable on the second processor, wherein the ratio is 2 or a positive integer more than 2.</p>
<p id="p-0018" num="0017">One aspect of the present invention resides in a method of converting a first assembly language program implementable on a first processor to a second assembly language program implementable on a second processor, the first and second assembly language programs being described using same instructions, a unique address in the first assembly language program being assigned to a first number of bytes, and a unique address in the second assembly language program being assigned to a second number of byte numbers, the first number being larger than the second number, comprising the steps of: reading the first assembly language program from a storage; and converting one or more address descriptions of the first assembly language program to another one or more address descriptions using a ratio of the first number to the second number so that the first assembly language program is implementable on the second processor, wherein the ratio is 2 or a positive integer more than 2.</p>
<p id="p-0019" num="0018">Another aspect of the present invention resides in a method of converting a first assembly language program implementable on a first processor to a second assembly language program implementable on a second processor, the first and second assembly language programs being described using same instructions, a unique address in the first assembly language program being assigned to a first number of bytes, and a unique address in the second assembly language program being assigned to a second number of byte numbers, the first number being larger than the second number, comprising the steps of: (a) reading the first assembly language program from a storage; (b) searching the first assembly language program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a ratio of the first number to the second number; and (c) searching the first assembly language program to find a first instruction for reading a value from a memory using an address described by a character string and/or a numerical value, and searching the first assembly language program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found, the character string and/or the numerical value contained in the first or second instruction is multiplied by L.</p>
<p id="p-0020" num="0019">Still another aspect of the present invention resides in a method of converting a first assembly language program implementable on a first processor to a second assembly language program implementable on a second processor, the first and second assembly language programs being described using same instructions, a unique address in the first assembly language program being assigned to a first number of bytes, and a unique address in the second assembly language program being assigned to a second number of byte numbers, the first number being larger than the second number, comprising the steps of: (a) reading the first assembly language program from a storage; (b) searching the first assembly language program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a ratio of the first number to the second number; (c) searching the first assembly language program to find a first instruction for reading a value from the memory using an address described by a character string and/or a numerical value, and searching the first assembly language program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found then the character string and/or the numerical value contained in the first or second instruction is multiplied by L; and (d) searching the first assembly language program to find a third instruction for transferring a value described by a character string and/or a numerical value to an address register, and if the third instruction is found, then the character string or the numerical value contained in the third instruction is multiplied by L.</p>
<p id="p-0021" num="0020">Still another aspect of the present invention resides in a computer program product in a computer readable media for use in converting a first assembly language program implementable on a first processor to a second assembly language program implementable on a second processor, the first and second assembly language programs being described using same instructions, a unique address in the first assembly language program being assigned to a first number of bytes, and a unique address in the second assembly language program being assigned to a second number of byte numbers, the first number being larger than the second number, the computer program product comprising: instructions for reading the first assembly language program from a storage; and instructions for converting one or more address descriptions of the first assembly language program to another one or more address descriptions using a ratio of the first number to the second number so that the first assembly language program is converted to the second assembly language program so as to be implementable on the second processor, wherein the ratio is 2 or a positive integer more than 2.</p>
<p id="p-0022" num="0021">Still another aspect of the present invention resides in a computer program product in a computer readable media for use in converting a first assembly language program implementable on a first processor to a second assembly language program implementable on a second processor, the first and second assembly language programs being described using same instructions, a unique address in the first assembly language program being assigned to a first number of bytes, and a unique address in the second assembly language program being assigned to a second number of byte numbers, the first number being larger than the second number, comprising: instructions for reading the first assembly language program from a storage; instructions for searching the first assembly language program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a ratio of the first number to the second number; and instructions for searching the first assembly language program to find a first instruction for reading a value from a memory using an address described by a character string and/or a numerical value, and searching the first assembly language program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found, the character string and/or the numerical value contained in the first or second instruction is multiplied by L.</p>
<p id="p-0023" num="0022">Still another aspect of the present invention resides in a computer program product in a computer readable media for use in converting a first assembly language program implementable on a first processor to a second assembly language program implementable on a second processor, the first and second assembly language programs being described using same instructions, a unique address in the first assembly language program being assigned to a first number of bytes, and a unique address in the second assembly language program being assigned to a second number of byte numbers, the first number being larger than the second number, comprising: instructions for reading the first assembly language program from a storage; instructions for searching the first assembly language program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a ratio of the first number to the second number; instructions for searching the first assembly language program to find a first instruction for reading a value from the memory using an address described by a character string and/or a numerical value, and searching the first assembly language program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found then the character string and/or the numerical value contained in the first or second instruction is multiplied by L; and instructions for searching the first assembly language program to find a third instruction for transferring a value described by a character string and/or a numerical value to an address register, and if the third instruction is found, then the character string or the numerical value contained in the third instruction is multiplied by L.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0024" num="0023">The features and advantages of the present invention will become more clearly appreciated from the following description taken in conjunction with the accompanying drawings in which like elements or portions are denoted by like reference numerals and in which:</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 1</figref> is a flow chart which shows the steps which characterize the operation according to a first embodiment of the present invention;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram schematically showing general purpose registers and address registers, which are referred to when describing the operations embodying the present invention;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 3</figref> shows reference symbols and examples of instructions both described in an original program for one processor to be converted to that for another processor according to the first embodiment of the present invention;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 4</figref> shows an original program which is subject to conversion according to the first embodiment of the present invention;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIGS. 5 and 6</figref> show programs each of which is obtained during the conversion of the original program according to the first embodiment of the present invention;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 7</figref> shows a program after the conversion of the original program is completed according to the first embodiment of the present invention;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 8</figref> is a flow chart which shows the steps which characterize the operation according to a second embodiment of the present invention;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 9</figref> shows reference symbols and examples of instructions both described in an original program for one processor which is converted according to the first embodiment of the present invention;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 10</figref> shows an original program which is converted according to the second embodiment of the present invention;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 11</figref> shows a program during the conversion of the original program according to the second embodiment of the present invention; and</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 12</figref> shows a program after the conversion of the original program is completed according to the second embodiment of the present invention;</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0036" num="0035">In an assembly language program which is described so as to be implemented on a given processor, the addresses are generally classified into a base address and offset addresses. The base address is typically indicated by a character string (viz., a sequence of characters) and is used to denote a starting address of a predetermined memory space consisting of array elements (or cells). Each array element in the memory space is accessed using an offset address indicating an offset from the base address. The offset address is usually described using a character string and/or a numerical value. Hereinafter, the offset address is referred to simply as an address.</p>
<p id="p-0037" num="0036">As mentioned above, an addressing scheme where more than one byte of memory has a unique address is called “word addressing”, while an addressing scheme where each byte of memory has a unique address is “byte addressing”. In the instant disclosure, a word addressing type processor is referred to as a processor W, and a byte addressing type processor is referred to as a processor B for the convenience of description.</p>
<p id="p-0038" num="0037">In an assembly language program which is described to be implemented on the processor W, a software tool such as a linker automatically assigns a character string to a word address. Likewise, in an assembly language program described for the processor B, a software tool automatically assigns a character string to a byte address.</p>
<p id="p-0039" num="0038">It is assumed that the architectures of the processors W and B are identical except the addressing schemes, and hence the instructions of the processors W and B are also identical with each other. In this case, if the program described for the processor W is implemented on the processor B without any conversion, only a character string which is automatically assigned an address by the linker has a byte address, and the remaining numerical values or character strings, each of which is not automatically assigned an address, has a word address. Accordingly, in order that the program described for the processor W is successfully implemented on the processor B, it is necessary to change the address descriptions in the program described for the processor W.</p>
<p id="p-0040" num="0039">The following discussion focuses on converting the program described for the processor W to that implementable on the processor B under the above-mentioned assumptions. A ratio of the number of bytes assigned to a unique address in the program for the processor W to the number of bytes (viz., a single byte) assigned to a unique address in the program for the processor B is denoted by L.</p>
<p id="p-0041" num="0040">As is known, it is typical that an address is indicated by the sum of two or more addresses described by a character string(s) and/or a numerical value(s). Designating the symbol character string and the numerical value by “label” and “K” respectively, an address is usually indicated by [label+K] by way of example. In this case, “K” may also represent a symbol character.</p>
<p id="p-0042" num="0041">A first embodiment of the present invention will be described with reference to <figref idref="DRAWINGS">FIGS. 1 to 7</figref>.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 1</figref> is a flow chart which shows the steps which characterize the operation of the first embodiment via which an original program described for the processor W is converted to that implementable on the processor B. An appropriate storage <b>10</b> such as a floppy-disk, hard disk, etc. is provided for storing the program conversion software according to the first embodiment and the original program to be converted. When the original program conversion is to be initiated, the conversion program and the original program are loaded from the storage <b>10</b> into a computer <b>12</b>. As shown in <figref idref="DRAWINGS">FIG. 1</figref>, the program conversion according to the first embodiment is generally divided into four steps <b>14</b>, <b>16</b>, <b>18</b> and <b>20</b>.</p>
<p id="p-0044" num="0043">At step <b>14</b>, if a character string to which an address is assigned in the original program matches predetermined conditions, the character string is multiplied by 1/L where, as mentioned above, L is a ratio of byte numbers assigned to a unique address in the original processor W to byte numbers assigned to a unique address in a target processor (viz., the processor B). More specifically, at step <b>14</b>, the conversion program searches the original program to find a character string which is automatically assigned an address by a software tool such as a linker and does not indicate a branch destination. If the character string is found, the character string is multiplied by 1/L.</p>
<p id="p-0045" num="0044">In order to explain the operations at steps <b>16</b> and <b>18</b>, it is necessary to define the architecture which is common to the two processors W and B. It is assumed that each of the processors W and B is provided with general purpose registers Rn (n=0 to (N−1)) and address registers Am (m=0 to (M−1)), as schematically shown in <figref idref="DRAWINGS">FIG. 2</figref>. As is known in the art, each of the general purpose registers Rn is used by a processor for temporarily storing data or computation results, or sometimes is used for storing addresses of a memory operatively coupled to the processor. On the other hand, each of the address registers Am is dedicated to storing addresses.</p>
<p id="p-0046" num="0045">It is further assumed that the address, which is used by the processor when data is read from the memory and written thereinto, is described by a character string and/or a numerical value. In order to simplify the description, when the contents of a register Am or Rn is multiplied, it may be expressed simply by “multiply Am” or “multiply Rn” by way of example. That is to say, the expression of the contents of the register may occasionally be omitted.</p>
<p id="p-0047" num="0046">The operations at steps <b>16</b> and <b>18</b> are implemented under the following rules 1 and 2.</p>
<p id="p-0048" num="0047">Rule 1</p>
<p id="p-0049" num="0048">When a value is read from the memory or written thereinto, if all or part of the address of the memory is described by a character string and/or a numerical value, the character string and/or the numerical value is multiplied by L.</p>
<p id="p-0050" num="0049">Rule 2</p>
<p id="p-0051" num="0050">If all or part of the address is stored in a general purpose register Rn, an instruction for multiplying Rn by L is inserted so as to be implemented during the execution cycle preceding the cycle in which the original address is implemented, and an instruction for multiplying the general purpose register Rn by 1/L is inserted so as to be implemented during the execution cycle immediately after the cycle in which the original address is implemented.</p>
<p id="p-0052" num="0051">The Rules 1 and 2 will be discussed in more detail with reference to instructions shown in <figref idref="DRAWINGS">FIG. 3</figref>, which are common to both the processors W and B. It is to be noted that the instructions shown in <figref idref="DRAWINGS">FIG. 3</figref> are exemplary in that, as is known in the art, the assembly language instructions are different from processor to processor.</p>
<p id="p-0053" num="0052">In <figref idref="DRAWINGS">FIG. 3</figref>, a plurality of symbols such as LDST<b>0</b>, LDST<b>2</b>, etc. listed in the left column are described in comments in the original program and referred to by the program converter. Further, in <figref idref="DRAWINGS">FIG. 3</figref>, the instructions are exemplified at the right column, which instructions are respectively related to the corresponding symbols at the left column and referred to using the symbols by the program converter so as to be converted if necessary.</p>
<p id="p-0054" num="0053">The conversion of the original instructions will be described below with reference to Rules 1 and 2.</p>
<p id="p-0055" num="0054">&lt;&lt;Conversion of Instruction referred to using the symbol “LDST<b>0</b>”&gt;&gt;</p>
<p id="p-0056" num="0055">The instruction referred to using “LDST<b>0</b>” is for reading data from an address described by a character string and/or a numerical value, or for writing data into such an address. In this case, Rule 1 is applied to this instruction, and accordingly, the character string and/or the numerical value is multiplied by L. For example,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[label+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[(label+<i>K</i>)*<i>L]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
where “label” is a character string to which an address is automatically assigned by software such as a linker, and K represents a symbol character or a numerical value such as a constant.
</p>
<p id="p-0057" num="0056">&lt;&lt;Conversion of Instruction referred to using the symbol “LDST<b>1</b>”&gt;&gt;</p>
<p id="p-0058" num="0057">The instruction referred to using “LDST<b>1</b>” is used to read data from an address indicated by a general purpose register, or used to write data into such an address. In this case, Rule 2 is applied to this instruction. Thus, an instruction for multiplying the general purpose register storing all or part of the address by L is inserted in the execution cycle preceding the cycle in which the original instruction is implemented. In addition, an instruction for multiplying the general purpose register storing all or part of the address by 1/L is inserted in the execution cycle immediately after the cycle in which the original instruction is implemented. For example, if L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>R0=*[R4]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4<i>=R</i>4<i>+R</i>4<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0<i>=*[R</i>4]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4<i>=R</i>4&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0059" num="0058">The add instruction R<b>4</b>=R<b>4</b>+R<b>4</b> for doubling the contents of R<b>4</b> can be replaced by a left shift instruction R<b>4</b>=R<b>4</b>&lt;&lt;1, which is also applicable to the following discussion.</p>
<p id="p-0060" num="0059">&lt;&lt;Conversion of Instruction referred to using the symbol “LDST<b>2</b>”&gt;&gt;</p>
<p id="p-0061" num="0060">The instruction referred to using “LDST<b>2</b>” is used to read data from an address which is the sum of two addresses: one is described by a character string and/or a numerical value and the other is the contents of a general purpose register, or also used to write data into such an address. In this case, Rules 1 and 2 are applied to converting this instruction. That is, the instruction related to “LDST<b>2</b>” is converted such that a character string and/or a numerical value, which forms part or all of an address, are multiplied by L. Further, an instruction for multiplying the general purpose register storing all or part of the address by L is inserted so as to be implemented during an execution cycle preceding the cycle in which the original instruction is implemented. In addition, an instruction for multiplying the general purpose register storing all or part of the address by 1/L is inserted so as to be implemented during the execution cycle immediately after the cycle in which the original instruction is implemented. For example, if L=2 then
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0<i>=*[R</i>4<i>+K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4=<i>R</i>4+<i>R</i>4<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0<i>=*[R</i>4+(<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4<i>=R</i>4&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0062" num="0061">&lt;&lt;Conversion of Instruction referred to using the symbol “LDST<b>3</b>”&gt;&gt;</p>
<p id="p-0063" num="0062">The instruction referred to using “LDST<b>3</b>” is used to read data from an address which is the sum of two general purpose registers, or write data into such an address. In this case, Rule 2 is applied to the conversion of this instruction. That is, two instructions for respectively multiplying the general purpose registers each storing all or part of the address by L are inserted so as to be implemented during the execution cycles preceding the cycle in which the original instruction is implemented. In addition, two instructions for respectively multiplying the general purpose registers each storing all or part of the address by 1/L are inserted so as to be implemented during the execution cycles immediately after the cycle in which the original instruction is implemented. For example, if L=2 then
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[<i>R</i>4+<i>R</i>5]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following five instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4=<i>R</i>4+<i>R</i>4<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>5=<i>R</i>5+<i>R</i>5<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[<i>R</i>4+<i>R</i>5]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4=<i>R</i>4&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>5=<i>R</i>5&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0064" num="0063">&lt;&lt;Conversion of Instruction referred to using the symbol “ADD<b>1</b>”&gt;&gt;</p>
<p id="p-0065" num="0064">The instruction referred to using “ADD<b>1</b>” is used to add a value stored in a general purpose register and a value read from the memory and then store the sum in the general purpose register. In this case, if all or part of the address of the memory, from which the data is to be retrieved, is described by a character string and/or a numerical value, then the character sting and/or a numerical value are multiplied by L. As an alternative, in the case where all or part of the address is loaded to a general purpose register, an instruction for multiplying the address stored in the general purpose register by L is inserted so as to be implemented during an execution cycle preceding the cycle where the instruction is implemented, and in this case, further, an instruction for multiplying the address stored in the general purpose registers by 1/L is inserted so as to be implemented during the execution cycle immediately after the cycle where the original instruction is implemented. When the instruction related to the symbol “ADD<b>1</b>” is implemented using an address described by a character string and/or a numerical value, Rule 1 is applied to such a case. For example, if L=2, then
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[label+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[(label+<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0066" num="0065">On the other hand, in the case where the address is stored in the general purpose register R<b>4</b> when implementing the instruction related to the symbol “ADD<b>1</b>”, Rule 2 is used. For example, in this case, the conversion is implemented as follows (assuming L=2),
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>R</i>4]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4=<i>R</i>4+<i>R</i>4<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>R</i>4]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4<i>=R</i>4&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0067" num="0066">Further, if the address in the instruction referred to using the symbol ADD<b>1</b> is represented by the sum of the general purpose register R<b>4</b> and the symbol character K, Rule 1 is applied thereto. For example, when assuming L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>R</i>4+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4=<i>R</i>4+<i>R</i>4<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>R</i>4+(<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4<i>=R</i>4&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0068" num="0067">Still further, if the address in the instruction related to the symbol ADD<b>1</b> is represented by the sum of the general purpose registers R<b>4</b> and R<b>5</b>, then Rule 2 is applied thereto. For example, when assuming L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>R</i>4+<i>R</i>5]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following five instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4=<i>R</i>4+<i>R</i>4<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>5=<i>R</i>5+<i>R</i>5<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>R</i>4+<i>R</i>5]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>4<i>=R</i>4&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>5<i>=R</i>5&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. 3</figref> does not list the other instructions such as subtraction, multiplication, division, shift, logical operation, etc. However, if each of these instructions involves an instruction which accompanies data-read from the memory or data-write thereinto, the address description in such an instruction is converted as mentioned above.</p>
<p id="p-0070" num="0069">Rules 1 and 2 are not applied to the instructions related to the symbols such as MV<b>0</b>, ADD<b>0</b>, and SHIFT<b>0</b>, and hence these instructions remain unchanged during the program conversion in question.</p>
<p id="p-0071" num="0070">The above-mentioned conversions of instruction descriptions are implemented at steps <b>16</b> and <b>18</b>. At step <b>16</b>, as shown in <figref idref="DRAWINGS">FIG. 1</figref>, a symbol character string and/or a numerical value, which indicates an address for data-read or data-write with respect to the memory, is multiplied by L. More specifically, at step <b>16</b>, the conversion program according to the first embodiment searches the assembly language program, which has been processed at step <b>14</b>, to find a first instruction for reading a value from the memory using an address described by a character string and/or a numerical value, and further searches the assembly language program, which has been processed at step <b>14</b>, to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found, the character string and/or the numerical value contained in the first or second instruction is multiplied by L.</p>
<p id="p-0072" num="0071">On the other hand, at step <b>18</b>, as shown in <figref idref="DRAWINGS">FIG. 1</figref>, if there is an instruction for reading or writing a value using an address stored in a general purpose register with respect to the memory, new instructions for multiplying the contents of registers by L or 1/L are inserted into the original assembly language program. In more specific term, at step <b>18</b>, the conversion program according to the first embodiment of the present invention searches the assembly language program, which has been processed at step <b>14</b>, to find a third instruction for reading a value from the memory using an address stored in a general purpose register, and further searches the original assembly language program, which has been processed at step <b>14</b>, to find a fourth instruction for writing a value to the memory using an address stored in a general purpose register, and if the third or fourth instruction is found, an instruction for multiplying the contents of the general purpose register by L is inserted so as to be implemented during an execution cycle preceding the cycle in which the third or fourth instruction is implemented, and further, an instruction for multiplying the contents of the general purpose register by 1/L is inserted so as to be implemented during an execution cycle immediately after the cycle in which the third or fourth instruction is executed.</p>
<p id="p-0073" num="0072">At step <b>20</b>, a redundant instructions inserted at step <b>18</b> is deleted, which will be described later in detail.</p>
<p id="p-0074" num="0073">One concrete example of the first embodiment of the present invention will be described. As mentioned above, the architectures of the processors W and B are assumed to be identical except the addressing schemes (viz., word and byte addressing respectively). That is, the assembly language instructions of the processors W and B are identical with each other. Under such assumption, the assembly language program described for the processor W is converted so as to be implementable on the processor B.</p>
<p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. 4</figref> shows an original assembly language program which is described for the processor W and is subject to the program conversion. A single instruction is described in one line, and the end of the instruction is terminated by a semicolon “;”. A description between /* and */ is a comment wherein the symbols shown in <figref idref="DRAWINGS">FIG. 3</figref> are described and referred to by the program converter. In <figref idref="DRAWINGS">FIG. 4</figref>, the character string “label<b>1</b>” is a label indicative of an address in the memory, and the actual address thereof is automatically assigned by another software tool such as a linker when implemented on the processors W and B. It is assumed L=2 in the following description.</p>
<p id="p-0076" num="0075">Since the character string “label<b>1</b>” is only automatically assigned an address by the linker in this particular case, the character string “label<b>1</b>” is converted to “label<b>1</b>/<b>2</b>” at step <b>14</b>, leaving the other instruction descriptions unchanged.</p>
<p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. 5</figref> shows the original assembly language program which has been processed at step <b>14</b>.</p>
<p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. 6</figref> shows the program which has been processed at steps <b>16</b> and <b>18</b>, and in <figref idref="DRAWINGS">FIG. 6</figref>, the instructions inserted at step <b>16</b> are indented. For a better understanding of the instant embodiment, the operation performed at steps <b>16</b> and <b>18</b> on the program processed at step <b>14</b> will be described.</p>
<p id="p-0079" num="0078">(1) No conversion is carried out on the transfer instructions “mv<b>0</b>” and “mv<b>1</b>”.</p>
<p id="p-0080" num="0079">(2) Regarding the instruction referred to using the symbol “ldst<b>0</b>”, the character string (=label) and a numerical value (=4) is multiplied by 2 (=L) (Line <b>5</b>).</p>
<p id="p-0081" num="0080">(3) Regarding the load instruction referred to using the symbol “ldst<b>1</b>”, an instruction for multiplying the register R<b>4</b> by 2 is inserted immediately before the instruction associated with “load<b>1</b>” (Line <b>6</b>), and an instruction for multiplying R<b>4</b> by ½ is inserted immediately after the instruction associated with “load<b>1</b>” (Line <b>8</b>).</p>
<p id="p-0082" num="0081">(4) Regarding the load instruction referred to using the symbol “ldst<b>2</b>”, an instruction for multiplying the register R<b>4</b> storing the address by 2 is inserted immediately before the load instruction associated with “ldst<b>2</b>” (Line <b>9</b>), and an instruction for multiplying the register R<b>4</b> by ½ is inserted immediately after the instruction related to “ldst<b>2</b>” (Line <b>11</b>). Further, the numerical value <b>4</b> (corresponding to K) is multiplied by 2 (Line <b>10</b>).</p>
<p id="p-0083" num="0082">(5) Regarding the load instruction referred to using “ldst<b>3</b>”, two instructions for respectively doubling the registers R<b>4</b> and R<b>5</b> each of which stores the address, are inserted immediately before the load instruction associated with “load<b>3</b>” (Lines <b>12</b> and <b>13</b>), and two instructions for respectively multiplying the registers R<b>4</b> and R<b>5</b> by ½ are inserted immediately after the load instruction associated with “ldst<b>3</b>” (Lines <b>15</b> and <b>16</b>).</p>
<p id="p-0084" num="0083">No conversion is implemented on the add instructions related to “add<b>0</b>” and “add<b>1</b>”.</p>
<p id="p-0085" num="0084">Subsequently, the redundant instruction(s) inserted at step <b>18</b> is removed at step <b>20</b>. It is understood that some instructions, which have been inserted when converting add and shift instructions, are unnecessary. As seen from <figref idref="DRAWINGS">FIG. 6</figref>, the add instruction “R<b>4</b>=R<b>4</b>+R<b>4</b>” (Line <b>9</b>) is inserted immediately after the shift instruction “R<b>4</b>=R<b>4</b>&gt;&gt;1” (Line <b>8</b>). However, the least significant bit of the register R<b>4</b> has been made zero by the add instruction “R<b>4</b>=R<b>4</b>+R<b>4</b>” (Line <b>6</b>), and accordingly, in case the above-mentioned two instructions be executed, the contents of the register R<b>4</b> remains unchanged. Thus, the two instructions inserted at Lines <b>8</b> and <b>9</b> are meaningless or redundant. The same discussion is applicable to the shift instruction “R<b>4</b>=R<b>4</b>&gt;&gt;1” (Line <b>11</b>) and the add instruction “R<b>4</b>=R<b>4</b>+R<b>4</b>” (Line <b>12</b>). These redundant instructions are removed at step <b>20</b>. The converted program after removing the redundant instructions is shown in <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0086" num="0085">A second embodiment of the present invention will be described with reference to <figref idref="DRAWINGS">FIGS. 8 to 12</figref>.</p>
<p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. 8</figref> is a flow chart which shows the steps which characterize the second embodiment via which an original program described for the processor W is converted so as to be implementable on the processor B. As in the first embodiment, the program conversion software according to the second embodiment is stored in the storage <b>10</b> of <figref idref="DRAWINGS">FIG. 1</figref>, and the original program to be converted is also stored in the same storage <b>10</b> by way of example. As shown in <figref idref="DRAWINGS">FIG. 8</figref>, the program conversion according to the second embodiment is generally comprised of steps <b>24</b>, <b>26</b>, <b>28</b>, <b>30</b>, <b>32</b>, and <b>34</b>. Step <b>24</b> is identical to step <b>14</b> (<figref idref="DRAWINGS">FIG. 1</figref>), and as such, the description of step <b>24</b> will be omitted for brevity.</p>
<p id="p-0088" num="0087">As in the first embodiment, in order to explain the operations at steps <b>26</b>, <b>28</b>, <b>30</b>, and <b>32</b>, it is necessary to define the architecture including the instructions which are common to the processors W and B, and registers used thereby. The assumptions, which have been made before referring to Rules 1 and 2 with respect to the first embodiment, apply to the second embodiment.</p>
<p id="p-0089" num="0088">The operations at steps <b>26</b>, <b>28</b>, <b>30</b>, and <b>32</b> are implemented according to the following Rules 3 to 6.</p>
<p id="p-0090" num="0089">Rule 3</p>
<p id="p-0091" num="0090">When a value is read from the memory or written thereinto, if all or part of the address of the memory is described by a character string and/or a numerical value, the string and/or the numerical value is multiplied by L.</p>
<p id="p-0092" num="0091">Rule 4</p>
<p id="p-0093" num="0092">As to an instruction for transferring a value to an address register Am, if all or part of the value (viz., address) to be transferred is described by a character string and/or a numerical value, the character string and/or the numerical value is multiplied by L.</p>
<p id="p-0094" num="0093">Rule 5</p>
<p id="p-0095" num="0094">As to an instruction for transferring a value to an address register Am, if all or part of the value (viz., address) to be transferred is stored in a memory space other than the address registers, an instruction for multiplying the contents of the address register Am by L is inserted so as to be implemented during the execution cycle immediately after the cycle wherein the original transfer instruction is implemented. As an alternative, if all or part of the address to be transferred is stored in a memory space other than the address registers, an instruction for multiplying the address stored in the memory space by L is inserted so as to be implemented during the execution cycle preceding the cycle wherein the original transfer instruction is implemented, and in addition, an instruction for multiplying the address stored in the memory space by 1/L is inserted so as to be implemented during the execution cycle immediately after the cycle wherein the original transfer instruction is implemented.</p>
<p id="p-0096" num="0095">Rule 6</p>
<p id="p-0097" num="0096">As to an instruction for transferring a value stored in an address register Am to a memory space other than the address registers, if all or part of the address is stored in the address register Am, an instruction for multiplying the transferred address by 1/L is inserted so as to be implemented during the execution cycle immediately after the cycle wherein the original transfer instruction is implemented. As an alternative, if all or part of the address is stored in an address register Am, an instruction for multiplying the address stored in the address register Am by 1/L inserted so as to be implemented during the execution cycle preceding the cycle wherein the original transfer instruction is implemented, and further, an instruction for multiplying the address stored in the address register Am by L is inserted so as to be implemented during the execution cycle immediately after the cycle wherein the original transfer instruction is implemented.</p>
<p id="p-0098" num="0097">The above-mentioned Rules 3 to 6 will further be described with reference to the examples of instructions shown in <figref idref="DRAWINGS">FIG. 9</figref> which corresponds to <figref idref="DRAWINGS">FIG. 3</figref>. As in the first embodiment, the symbols are described in comments in the original program and referred to by the program converter in order to convert the instructions related to the symbols. Further, as mentioned above, the descriptions of assembly language instructions vary from processor to processor, and thus, the instructions shown in <figref idref="DRAWINGS">FIG. 9</figref> are exemplary. Instructions related to the symbols “LDST<b>4</b>”, “LDST<b>6</b>”, “MV<b>0</b>”, “ADD<b>0</b>”, “ADD<b>2</b>”, and “SHFT<b>0</b>”, which are listed in <figref idref="DRAWINGS">FIG. 9</figref> but not described above, correspond to none of Rules 3 to 6, and thus they are not subject to any conversion during the program translation.</p>
<p id="p-0099" num="0098">&lt;&lt;Conversion of Instruction referred to using the symbol “LDST<b>0</b>”&gt;&gt;</p>
<p id="p-0100" num="0099">The instruction referred to using “LDST<b>0</b>” is an instruction for reading data from the memory at an address which is described by a character string and/or a numerical value, or an instruction for writing data into such an address. In this case, Rule 3 is applied to this instruction, and accordingly, the symbol character sequence and/or the numerical value is multiplied by L. For example, if L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[label+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[(label+<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0101" num="0100">&lt;&lt;Conversion of Instruction referred to using the symbol “LDST<b>4</b>”&gt;&gt;</p>
<p id="p-0102" num="0101">The instruction referred to using “LDST<b>4</b>” is not converted.</p>
<p id="p-0103" num="0102">&lt;&lt;Conversion of Instruction referred to using the symbol “LDST<b>5</b>”&gt;&gt;</p>
<p id="p-0104" num="0103">The instruction referred to using “LDST<b>2</b>” is an instruction for reading data from an address which is the sum of two addresses: one is described by a character string and/or a numerical value and the other is stored in an address register, or an instruction for writing data into such an address. In this case, Rule 3 is applied to the conversion of this instruction. The address stored in the address register has been converted to a byte address at the time when being transferred to the address register, as will be described in connection with the symbol “MV<b>1</b>” in the following, and as such, only the character string and/or the numerical value is multiplied by L. For example, if L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[<i>A</i>0+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=*[<i>A</i>0+(<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0105" num="0104">&lt;&lt;Conversion of Instruction referred to using the symbol “MV<b>1</b>”&gt;&gt;</p>
<p id="p-0106" num="0105">The instruction referred to using the symbol “MV<b>1</b>” is an instruction for transferring a value described by a character string and/or a value to the address register. In this instance, Rule 4 is applied to the conversion of this instruction. That is, this instruction is converted such that the address register stores the value multiplied by L. For example, in the case of L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>A0=K<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=(<i>K</i>)*2<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0107" num="0106">&lt;&lt;Conversion of Instruction referred to using a symbol “MV<b>2</b>”&gt;&gt;</p>
<p id="p-0108" num="0107">The instruction referred to using the symbol “MV<b>2</b>” is an instruction for transferring a value stored in a general purpose register to an address register, and, thus, Rule 5 is applied to the conversion of this instruction. In this case, the instruction is converted such that the address register stores L times the value stored in the general purpose register. For example, in the case of L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>A0=R0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following two instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>A0=R0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0<i>=A</i>0+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
As an alternative,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>A0=R0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+<i>R</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>A0=R0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>R0<i>=R</i>0&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0109" num="0108">&lt;&lt;Conversion of instruction referred to using the symbol “MV<b>3</b>”&gt;&gt;</p>
<p id="p-0110" num="0109">The instruction referred to using “MV<b>3</b>” is an instruction for transferring a value stored in the address register to a general purpose register, and thus, Rule 6 is applied to the conversion of this instruction. In this case, the instruction is converted such that the general purpose register stores 1/L times the value stored in the address register.</p>
<p id="p-0111" num="0110">For example, in the case of L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>R<b>0</b>=A<b>0</b><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following two instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>R0=A0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>R0=R0&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
As an alternative,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>R0=A0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0<i>=A</i>0&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>R0=A0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=<i>A</i>0+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0112" num="0111">&lt;&lt;Conversion of Instruction referred to using the symbol “MV<b>4</b>”&gt;&gt;</p>
<p id="p-0113" num="0112">The instruction referred to using “MV<b>4</b>” is an instruction for moving a value (viz., address) from the memory to an address register. In this case, if all or part of the address is described by a character string and/or a numerical value, the character string and/or the numerical value is multiplied by L (Rule 3), and subsequently the value in the address register is multiplied by L (Rule 5).</p>
<p id="p-0114" num="0113">For example, in the case of L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=*[label+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following two instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=*[(label+<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=<i>A</i><b>0</b>+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
On the other hand, when a value is read from the memory using an address stored in the address register, Rule 5 is applied to this case. For example, in the case of L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0<i>=*[A</i>1]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following two instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0<i>=*[A</i>1]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=<i>A</i>0+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Further, if a value is read from the memory using an address which is the sum of an address stored in the address register and an address described by a character string and/or a numerical value, the original instruction is converted using Rules 3 and 5. For example, in the case of L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=*[<i>A</i>1+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following two instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=*[<i>A</i>1+(<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=<i>A</i>0+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0115" num="0114">&lt;&lt;Conversion of Instruction referred to using the symbol “MV<b>5</b>”&gt;&gt;</p>
<p id="p-0116" num="0115">The instruction referred to using “MV<b>5</b>” is an instruction for transferring a value stored in an address register to the memory. In this case, the value stored in the address register is multiplied by 1/L, after which the multiplied value in the address register has been moved to the memory. Further, an instruction for multiplying the value stored in the address register by L is inserted after the multiplied value in the address register is moved to the memory. In this instance, if all or part of the address of the memory is described by a character string and/or a numerical value, then they are multiplied by L. The conversion is implemented using Rules 3 and 6. For example, assuming L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>*[label1+<i>K]=A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0<i>=A</i>0&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>*[(label1+<i>K</i>)*2<i>]=A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=<i>A</i>0+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
On the other hand, if a value is transferred to the memory using an address stored in an address register, Rule 6 applies in this case. For example, assuming L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>*[A1]=A0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0<i>=A</i>0&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>*[A1]=A0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=<i>A</i>0+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Further, if a value is transferred to the memory using an address which is the sum of an address stored in an address register and an address described by a character string and/or a numerical value, the original instruction is converted using Rules 3 and 6. For example, in the case of L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>*[<i>A</i>1+<i>K]=A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to the following three instructions
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0<i>=A</i>0&gt;&gt;1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>*[<i>A</i>1+(<i>K</i>)*2<i>]=A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>0=<i>A</i>0+<i>A</i>0<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0117" num="0116">&lt;&lt;Conversion of Instruction referred to using the symbol “ADD<b>1</b>”&gt;&gt;</p>
<p id="p-0118" num="0117">The instruction referred to using “ADD<b>1</b>” is an instruction for adding a value stored in a general purpose register and a value read from the memory, and then transferring the sum to the general purpose register, in the case of which Rule 3 applies. If all or part of the address of the memory is described by a character string and/or a numerical value, then they are multiplied by L. For example, assuming L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[label+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[(lable+<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
On the other hand, when an address is represented by the sum of an address of the address register A<b>0</b> and the symbol character K, the following translation is implemented. That is, if L=2,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>A</i>0+<i>K]</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
is converted to
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>0=<i>R</i>0+*[<i>A</i>0+(<i>K</i>)*2]<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0119" num="0118"><figref idref="DRAWINGS">FIG. 9</figref> does not list the instructions for subtraction, multiplication, division, shift, and logical operation. If any one of these instructions includes an instruction such as to read data from the memory or write data thereinto, the address appearing in such an instruction is converted as mentioned above.</p>
<p id="p-0120" num="0119">The above-mentioned conversions of instruction descriptions are implemented at steps <b>26</b>, <b>28</b>, <b>30</b>, and <b>32</b> of <figref idref="DRAWINGS">FIG. 8</figref>. At step <b>26</b>, as shown in <figref idref="DRAWINGS">FIG. 8</figref>, if there is an instruction, in the program having been processed at step <b>24</b>, for reading or writing a value with respect to the memory using an address described by a character string and/or a numerical value, the character string and/or a numerical value is multiplied by L.</p>
<p id="p-0121" num="0120">More specifically, at step <b>26</b>, the conversion program according to the second embodiment of the present invention searches the program having been processed at step <b>24</b> to find a first instruction for reading a value from the memory using an address described by a character string and/or a numerical value, and searching the program having been processed at step <b>24</b> to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found then the character string and/or the numerical value contained in the first or second instruction is multiplied by L.</p>
<p id="p-0122" num="0121">At step <b>28</b>, as shown in <figref idref="DRAWINGS">FIG. 8</figref>, if there is an instruction, in the program having been processed at step <b>24</b>, for moving a value described by a character string and/or a numerical value to an address register, the character string and/or the numerical value is multiplied by L.</p>
<p id="p-0123" num="0122">To describe in more detail, the conversion program according to the second embodiment searches the program having been processed at step <b>24</b> to find a third instruction for transferring a value described by a character string and/or a numerical value to an address register, and if the third instruction is found, then the character string or the numerical value contained in the third instruction is multiplied by L.</p>
<p id="p-0124" num="0123">At step <b>30</b>, as shown in <figref idref="DRAWINGS">FIG. 8</figref>, if there is an instruction, in the program having been processed at step <b>24</b>, for transferring a value stored in a non-address-register to an address register, a new instruction for multiplying the value stored in the address register by L is inserted, or two new instructions are inserted: one is for multiplying the value to be transferred by L, and the other for multiplying the value to be transferred by 1/L.</p>
<p id="p-0125" num="0124">In more specific term, at step <b>30</b>, the conversion program according to the second embodiment searches the program having been processed at step <b>24</b> to find a fourth instruction for transferring a value stored in a memory space other than address registers to an address register, and if the fourth instruction is found then an instruction for multiplying the value stored in the address register by L is inserted so as to be implemented during an execution cycle immediately after the cycle in which the fourth instruction is executed. As an alternative, if the aforesaid fourth instruction is found, an instruction for multiplying the value to be transferred by L is inserted so as to be implemented during an execution cycle preceding the cycle in which the fourth is implemented, and further an instruction for multiplying the value to be transferred by 1/L is inserted so as to be implemented during an execution cycle immediately after the cycle in which the fourth instruction is implemented.</p>
<p id="p-0126" num="0125">At step <b>32</b>, as shown in <figref idref="DRAWINGS">FIG. 8</figref>, if there is an instruction for transferring a value stored in an address register to a non-address-register, a new instruction for multiplying the value stored in the non-address-register 1/L is inserted, or two new instructions are inserted: one is for multiplying the value to be transferred by 1/L and the other for multiplying the value to be transferred by L.</p>
<p id="p-0127" num="0126">More specifically, at step <b>32</b>, the conversion program according to the second embodiment searches the program having been processed at step <b>24</b> to find a fifth instruction for transferring a value stored in an address register to a memory space other than the address registers, and if the fifth instruction is found then an instruction for multiplying the value stored in the memory space other than the address registers by 1/L is inserted so as to be implemented during an execution cycle immediately after the cycle in which the fifth instruction is executed. As an alternative, if the aforesaid fifth instruction is found, an instruction for multiplying the value to be stored in the address register by 1/L is inserted so as to be implemented during an execution cycle preceding the cycle in which the fifth instruction is implemented, and further, an instruction for multiplying the value stored in the address register by L is inserted so as to be implemented during an execution cycle immediately after the cycle in which the fifth instruction is implemented.</p>
<p id="p-0128" num="0127">At step <b>34</b>, if there is a redundant instruction(s) inserted at steps <b>30</b> and <b>32</b> the redundant instruction(s) is deleted. The operation at step <b>34</b> is identical to that at step <b>20</b>, and accordingly the further description thereof will be omitted for simplifying the instant disclosure.</p>
<p id="p-0129" num="0128">One concrete example of the second embodiment of the present invention will be described. As in the first embodiment, the architectures of the processors W and B are assumed to be identical except the addressing schemes (viz., word and byte addressing respectively). That is, the assembly language instructions of the processors W and B are identical with each other. Under such assumptions, the assembly language program described for the processor W is converted so as to be implementable on the processor B.</p>
<p id="p-0130" num="0129"><figref idref="DRAWINGS">FIG. 10</figref> shows an original assembly language program which is described for the processor W and is subject to the program conversion according to the second embodiment. As mentioned in connection with <figref idref="DRAWINGS">FIG. 4</figref>, a single instruction is described in one line, and the end of the instruction is terminated by a semicolon “;”. A description between /* and */ is a comment wherein the symbols shown in <figref idref="DRAWINGS">FIG. 9</figref> are described and referred to by the program converter. In <figref idref="DRAWINGS">FIG. 10</figref>, the character string “label<b>1</b>” is a label indicative of an address in the memory, and the actual address thereof is automatically assigned by another software tool such as a linker when implemented on the processors W and B. It is assumed L=2 in the following description.</p>
<p id="p-0131" num="0130">Since the character string “label<b>1</b>” is only automatically assigned an address by the linker in this particular case, the character string “label<b>1</b>” is converted to “label<b>1</b>/2” at step <b>24</b>, leaving the other instruction descriptions unchanged.</p>
<p id="p-0132" num="0131"><figref idref="DRAWINGS">FIG. 11</figref> shows the original assembly language program which has been processed at step <b>24</b>.</p>
<p id="p-0133" num="0132">The program, which has been processed at steps <b>26</b>, <b>28</b>, <b>30</b>, and <b>32</b>, contains no redundant instruction and hence is the final program (viz., converted program) which is shown in <figref idref="DRAWINGS">FIG. 12</figref>.</p>
<p id="p-0134" num="0133">The conversion processes performed at steps <b>26</b>, <b>28</b>, <b>30</b>, and <b>32</b> will be described with reference to <figref idref="DRAWINGS">FIG. 12</figref>. In <figref idref="DRAWINGS">FIG. 12</figref>, the instructions inserted at steps <b>30</b> and <b>32</b> are indented to distinguish them from the non-inserted instructions. Since the conversion of the instruction descriptions per se has been described in detail, it is deemed easy to understand the operation performed at steps <b>26</b>, <b>28</b>, <b>30</b>, and <b>32</b>, and accordingly only a brief description thereof will be given for brevity. In the following, it is assumed L=2.</p>
<p id="p-0135" num="0134">(1) No conversion is carried out on the transfer instruction referred to using “mv<b>0</b>”.</p>
<p id="p-0136" num="0135">(2) Regarding the transfer instruction referred to using “mv<b>1</b>”, a value transferred to the address register is multiplied by 2 (=L).</p>
<p id="p-0137" num="0136">(3) Regarding the transfer instruction referred to using “mv<b>2</b>”, an instruction for multiplying the address register by 2 is inserted immediately after the original instruction.</p>
<p id="p-0138" num="0137">(4) Regarding the load instruction referred to using the symbol “ldst<b>0</b>”, a character string and/or a numerical value is multiplied by 2.</p>
<p id="p-0139" num="0138">(5) No conversion is carried out on the load instruction referred to using “ldst<b>4</b>”.</p>
<p id="p-0140" num="0139">(6) Regarding the load instruction referred to using the symbol “ldst<b>5</b>”, a character string and/or a numerical value indicating an address is multiplied by 2.</p>
<p id="p-0141" num="0140">(7) No conversion is carried out on the transfer instruction referred to using “ldst<b>6</b>”.</p>
<p id="p-0142" num="0141">(8) No conversion is carried out on the add instruction referred to using “add<b>0</b>”.</p>
<p id="p-0143" num="0142">(9) Regarding the add instruction referred to using “add<b>1</b>”, a character string and/or a numerical value is multiplied by 2.</p>
<p id="p-0144" num="0143">(10) Regarding the transfer instruction referred to using “mv<b>3</b>”, an instruction for multiplying the address register by ½ is inserted immediately after the original instruction.</p>
<p id="p-0145" num="0144">A file format of the original program has not been explained in the above. However, the application of the present invention is independent of the file format (binary file or text file). By way of example, in the case where an original program to be converted is a binary file, the character strings are represented by binary codes. In this ease, the binary codes are converted according to the present invention, after which the converted program can be processed so as to be derived as a binary file or a text file using a conventional technique.</p>
<p id="p-0146" num="0145">The program conversion embodying the present invention can be implemented statically or dynamically. That is to say, it is possible to previously convert the original program and thereafter implement the converted program, and as an alternative, the conversion of the original program can be carried out concurrently with the implementation of the converted program.</p>
<p id="p-0147" num="0146">When the converted programs shown in <figref idref="DRAWINGS">FIGS. 7 and 12</figref> are implemented on the processor B, an actual address assigned to the character string such as “label<b>1</b>” should be a multiple of L.</p>
<p id="p-0148" num="0147">The first and second embodiments of the present invention have so far been described in connection with the case where one processor is of the word addressing type and the other of the byte addressing type. However, it is within the scope of the present invention to apply the invention to the case where the two processors both operate under the word addressing scheme.</p>
<p id="p-0149" num="0148">Further, the present invention is also applicable to the case where both the addressing schemes and the instructions are different with the two processors such as W and B.</p>
<p id="p-0150" num="0149">The foregoing descriptions show two preferred embodiments. However, other various modifications are apparent to those skilled in the art without departing from the scope of the present invention which is only limited by the appended claims. Therefore, the embodiments and modification shown and described are only illustrated, not restrictive.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of converting a first assembly program implementable on a first processor to a second assembly program implementable on a second processor, the first and second assembly programs being described using same instructions, a unique address in the first assembly program being assigned to a plurality of bytes, and a unique address in the second assembly program being assigned to a single byte, comprising the steps of:
<claim-text>(a) reading the first assembly program from a storage;</claim-text>
<claim-text>(b) searching the first assembly program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a number of the plurality of bytes; and</claim-text>
<claim-text>(c) searching the first assembly program to find a first instruction for reading a value from a memory using an address described by a character string and/or a numerical value, and searching the first assembly program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found, the character string and/or the numerical value contained in the first or second instruction is multiplied by L.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A method of converting a first assembly program implementable on a first processor to a second assembly program implementable on a second processor, the first and second assembly programs being described using same instructions, a unique address in the first assembly program being assigned to a plurality of bytes, and a unique address in the second assembly program being assigned to a single byte, comprising the steps of:
<claim-text>(a) reading the first assembly program from a storage;</claim-text>
<claim-text>(b) searching the first assembly program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a number of the plurality of bytes;</claim-text>
<claim-text>(c) searching the first assembly program to find a first instruction for reading a value from the memory using an address described by a character string and/or a numerical value, and searching the first assembly program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found then the character string and/or the numerical value contained in the first or second instruction is multiplied by L; and</claim-text>
<claim-text>(d) searching the first assembly program to find a third instruction for transferring a value described by a character string and/or a numerical value to an address register, and if the third instruction is found, then the character string or the numerical value contained in the third instruction is multiplied by L.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A computer program product in a computer readable media for use in converting a first assembly program implementable on a first processor to a second assembly program implementable on a second processor, the first and second assembly programs being described using same instructions, a unique address in the first assembly program being assigned to a plurality of bytes, and a unique address in the second assembly program being assigned to a single byte, comprising:
<claim-text>instructions for reading the first assembly program from a storage;</claim-text>
<claim-text>instructions for searching the first assembly program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a number of the plurality of bytes; and</claim-text>
<claim-text>instructions for searching the first assembly program to find a first instruction for reading a value from a memory using an address described by a character string and/or a numerical value, and searching the first assembly program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found, the character string and/or the numerical value contained in the first or second instruction is multiplied by L.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A computer program product in a computer readable media for use in converting a first assembly program implementable on a first processor to a second assembly program implementable on a second processor, the first and second assembly programs being described using same instructions, a unique address in the first assembly program being assigned to a first number of bytes, and a unique address in the second assembly program being assigned to a single byte, comprising:
<claim-text>instructions for reading the first assembly program from a storage;</claim-text>
<claim-text>instructions for searching the first assembly program to find a character string which is automatically assigned an address by a software tool and does not indicate a branch destination, and if the character string is found, the character string is multiplied by 1/L where L is a number of the plurality of bytes;</claim-text>
<claim-text>instructions for searching the first assembly program to find a first instruction for reading a value from the memory using an address described by a character string and/or a numerical value, and searching the first assembly program to find a second instruction for writing a value to the memory using an address described by a character string and/or a numerical value, and if the first or second instruction is found then the character string and/or the numerical value contained in the first or second instruction is multiplied by L; and</claim-text>
<claim-text>instructions for searching the first assembly program to find a third instruction for transferring a value described by a character string and/or a numerical value to an address register, and if the third instruction is found, then the character string or the numerical value contained in the third instruction is multiplied by L.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
