<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299356-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299356</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10653500</doc-number>
<date>20030902</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>877</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>9</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>713169</main-classification>
<further-classification>713168</further-classification>
<further-classification>713170</further-classification>
<further-classification>380 28</further-classification>
<further-classification>380 29</further-classification>
</classification-national>
<invention-title id="d0e53">Key conversion method for communication session encryption and authentication system</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4200770</doc-number>
<kind>A</kind>
<name>Hellman et al.</name>
<date>19800400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5241599</doc-number>
<kind>A</kind>
<name>Bellovin et al.</name>
<date>19930800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5434918</doc-number>
<kind>A</kind>
<name>Kung et al.</name>
<date>19950700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5841871</doc-number>
<kind>A</kind>
<name>Pinkas</name>
<date>19981100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5872917</doc-number>
<kind>A</kind>
<name>Hellman</name>
<date>19990200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6058480</doc-number>
<kind>A</kind>
<name>Brown</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6076163</doc-number>
<kind>A</kind>
<name>Hoffstein et al.</name>
<date>20000600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6085320</doc-number>
<kind>A</kind>
<name>Kaliski, Jr.</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6105133</doc-number>
<kind>A</kind>
<name>Fielder et al.</name>
<date>20000800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6161185</doc-number>
<kind>A</kind>
<name>Guthrie et al.</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6170058</doc-number>
<kind>B1</kind>
<name>Kausik</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6189098</doc-number>
<kind>B1</kind>
<name>Kaliski, Jr.</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6199113</doc-number>
<kind>B1</kind>
<name>Alegre et al.</name>
<date>20010300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6226383</doc-number>
<kind>B1</kind>
<name>Jablon</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6230269</doc-number>
<kind>B1</kind>
<name>Spies et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>6367010</doc-number>
<kind>B1</kind>
<name>Venkatram et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>6377691</doc-number>
<kind>B1</kind>
<name>Swift et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>6393127</doc-number>
<kind>B2</kind>
<name>Vogler</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>6487667</doc-number>
<kind>B1</kind>
<name>Brown</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>6920559</doc-number>
<kind>B1</kind>
<name>Nessett et al.</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713168</main-classification></classification-national>
</citation>
<citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>7069438</doc-number>
<kind>B2</kind>
<name>Balabine et al.</name>
<date>20060600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713168</main-classification></classification-national>
</citation>
<citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2002/0095507</doc-number>
<kind>A1</kind>
<name>Jerdonek</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00023">
<othercit>Kaufman et al., “Network Security—Private Communication in a Public World”, 1995, Prentice Hall, pp. 243-249.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00024">
<othercit>Li et al., “An Improved Key Distribution Protocol with Perfect Reparability”, IEEE, 2000, Retrieved from the Internet on Feb. 7, 2007: &lt;URL: http://ieeexplore.ieee.org/iel5/7015/18913/00875801.pdf&gt;.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00025">
<othercit>Stallings, “Cryptography and Network Security—Principles And Practice”, Aug. 2002, Prentice Hall, 3rd Edition, pp. 143-167.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00026">
<othercit>Bellovin, Steven M., et al., “Limitations of the Kerberos Authentication System,” USENIX, Winter 1991, Dallas, Texas, 1-16 (A version of this paper with published in Oct. 1990 in Computer Communications Review).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00027">
<othercit>Diffie, Whitfield, et al., “New Directions in Cryptography,” IEEE Transactions on Information Theory, vol. IT-22, No. 6, Nov. 1976, 644-654.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00028">
<othercit>Federal Information Processing Standards Publication (FIPS) 46-3, “Data Encryption Standard (DES),” Oct. 25, 1999, 18 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00029">
<othercit>Federal Information Processing Standards Publication (FIPS) 180-1, “Secure Hash Standard,” Apr. 17, 1995, 18 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00030">
<othercit>Noakes-Fry, Kristen, “Public-Key Infrastructure: Technology Overview,” DPRO-90693, Gartner Technology Overview, May 20, 2003, 18 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00031">
<othercit>Park, Stephen K., et al., “Random Number Generators: Good Ones are Hard to Find,” Communications of the ACM 31(10), Oct. 1988, 1192-1201.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00032">
<othercit>Wheatman, V., “Public-Key Infrastructure Q&amp;A,” Gartner Research Note, Nov. 13, 2002, 5 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00033">
<othercit>Pescatore, John, “Another Microsoft Security Flaw Threatens Users' Trust,” FT-17-8896, Gartner FirstTake, Aug. 15, 2002, 2 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00034">
<othercit>Pescatore, J., et al., “Secure Sockets Layer Sometimes Isn't,” Gartner Research Note, Apr. 3, 2002, 4 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00035">
<othercit>Rivest, R., RFC 1320, “The MD4 Message-Digest Algorithm,” MIT Laboratory for Computer Science and RSA Data Security, Inc., Apr. 1992, 20 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00036">
<othercit>Rivest, R., RFC 1321, “The MD5 Message-Digest Algorithm,” MIT Laboratory for Computer Science and RSA Data Security, Inc., Apr. 1992, 22 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00037">
<othercit>Lloyd, B, et al., RFC 1334, “PPP Authentication Protocols,” L&amp;A and Daydreamer, Oct. 1992, 14 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00038">
<othercit>Kohl, J., et al., RFC 1510, “The Kerberos Network Authentication Service (V5),” Digital Equipment Corporation and ISI, Sep. 1993, 97 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00039">
<othercit>Schneier, Bruce, “Applied Cryptography,” Second Ed. John Wiley and Sons, Inc. (1996), 233-560.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00040">
<othercit>Smith, K., RFC 1934, “Ascend's Multilink Protocol Plus (MP+),” Ascend Communications, Apr. 1996, 37 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00041">
<othercit>Fielding, R., et al., RFC 2068, “Hypertext Transfer Protocol—HTTP/1.1,” UC Irvine, DEC, MIT/LCS, Jan. 1997, 134 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00042">
<othercit>Zorn, G., RFC 2759, “Microsoft PPP CHAP Extensions, Version 2,” Microsoft Corporation, Jan. 2000, 16 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>22</number-of-claims>
<us-exemplary-claim>22</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>10</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050050322</doc-number>
<kind>A1</kind>
<date>20050303</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Mizrah</last-name>
<first-name>Len L.</first-name>
<address>
<city>San Carlos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Haynes Beffel &amp; Wolfeld LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Authernative, Inc.</orgname>
<role>02</role>
<address>
<city>Walnut Creek</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Barron, Jr.</last-name>
<first-name>Gilberto</first-name>
<department>2132</department>
</primary-examiner>
<assistant-examiner>
<last-name>Dinh</last-name>
<first-name>Minh</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">An interactive mutual authentication protocol, which does not allow shared secrets to pass through untrusted communication media, integrates an encryption key management system into the authentication protocol. The server encrypts a particular data random key by first veiling the particular data random key using a first conversion array seeded by a shared secret, and then encrypting the veiled particular data random key. The client decrypts and unveils the particular data random key using the shared secret, and returns a similarly veiled version of the particular data random key using a second conversion array seeded by a shared secret. Access to the shared secret indicates authenticity of the stations. The procedure may be repeated for a second shared secret for strong authentication, without allowing shared secrets to pass via untrusted media.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="231.99mm" wi="178.90mm" file="US07299356-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="232.24mm" wi="176.19mm" file="US07299356-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="231.99mm" wi="174.67mm" file="US07299356-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="236.22mm" wi="182.37mm" file="US07299356-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="226.99mm" wi="181.53mm" file="US07299356-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="229.87mm" wi="173.82mm" file="US07299356-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="225.81mm" wi="173.06mm" file="US07299356-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="237.66mm" wi="171.62mm" file="US07299356-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="245.62mm" wi="162.05mm" orientation="landscape" file="US07299356-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="266.11mm" wi="168.49mm" orientation="landscape" file="US07299356-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="231.56mm" wi="174.24mm" file="US07299356-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">The present application is related to U.S. patent application Ser. No. 10/653,506, entitled COMMUNICATION SESSION ENCRYPTION AND AUTHENTICATION SYSTEM, invented by Mizrah, and filed on 2 Sep. 2003.</p>
<p id="p-0003" num="0002">The present application is related to U.S. patent application Ser. No. 10/653,503, entitled KEY GENERATION METHOD FOR COMMUNICATION SESSION ENCRYPTION AND AUTHENTICATION SYSTEM, invented by Mizrah, and filed on 2 Sep. 2003.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">1. Field of the Invention</p>
<p id="p-0005" num="0004">The invention relates generally to security of authentication and data transmission over untrusted communication media in client-server computer, network, and other architectures, and more particularly to encryption key management systems and authentication protocols.</p>
<p id="p-0006" num="0005">2. Description of the Related Art</p>
<p id="p-0007" num="0006">Electronic networks of interconnected devices and users continue to grow with unprecedented rate. They have become foundations for vitally important infrastructures enabling e-commerce, communications, corporate and government operations, healthcare, education, and other important areas. This phenomenon was actively studied and commercialized during the last quarter of the 20<sup>th </sup>century, and there is every indication this activity will intensify well into the 21<sup>st </sup>century.</p>
<p id="p-0008" num="0007">There are various parties involved in remote relationships over distributed electronic networks. Most known representations are business-to-business (b2b), business-to-consumers (b2c), and peer-to-peer (p2p), describing scaled-down to hardware devices communication, for instance, peer router to peer router, or device-to-device (d2d). One of the fundamental problems for continued growth of electronic networks and their efficient utilization is establishing trust between remote counterparts in b2b, b2c, d2d, and other interrelating over network parties. It is common knowledge that computer network intruders (or intruding organizations) cause ever-growing direct economic losses to enterprises and individual consumers. They significantly undermine the progress in applying network technologies to certain areas, especially related to parties having legal and financial responsibilities, and national security.</p>
<p id="p-0009" num="0008">Trust to remote humans or devices, interacting over electronic networks, has two components. The first component is identification and verification of the parties at the beginning of the communication session (mutual authentication). The second component is associated with trust to information transferred during the communication session over untrusted communication media (communication lines). It includes the following specific requirements—confidentiality (none can read the message except the intended recipient), integrity (none altered, tampered witn, or modified the message against the original), and non-repudiation (the sender can not deny the fact of having sent the message).</p>
<p id="p-0010" num="0009">Authentication and cryptography are key enabling technologies employed to satisfy the security requirements listed above. Authentication factors are typically characterized as “what user knows” (for instance, passwords, PINs), “what user has” (for instance, hardware token, smart card), and “what user is” (particular biometric traits; for instance, fingerprints, voice patterns, etc.). Passwords are the most ubiquitous over electronic networks as an authentication factor due to ease of use, low cost and easy electronic deployment. Most of the strong (two-, or three-factor) authentication systems are still using passwords or PINs as one of the system authentication factors.</p>
<p id="p-0011" num="0010">However, passwords provide low security due to insufficient protection against numerous known intruding attacks on databases where the passwords are residing, social engineering attacks, videotaping or “shoulder surfing” attacks during password entry stages, memory sniffing attacks, Trojan horse attacks, and network sniffing attacks. Perhaps, the latter are the most dangerous attacks as a distributed electronic network (like Internet) has numerous access points. There are authentication systems transmitting passwords in clear text (for instance, Password Authentication Protocol (PAP) RFC 1334-2, Telnet, and FTP). Certainly, there is no protection at all in such cases. More protected authentication systems transmit encrypted passwords over electronic networks.</p>
<p id="p-0012" num="0011">There are several approaches in transferring an encrypted password. The first one is based on the one-way encryption—calculating the password's hash value with one of the standard hashing algorithms (for example, SHA-1 Secure Hash Algorithm, FIPS PUB 180-1, Secure Hash Standard, 1995, Apr. 17, or MD5 Message Digest Algorithms, RFC 1320 and RFC 1321, April 1992, by Ronald L. Rivest) at both client and server locations. The client transmits the hashed password (of the user at the client platform) to the server, where it is compared with the password of the same client (the same user at the client platform) from the database connected to the server (typically, user passwords are already stored in password files in hashed form for database protection; that is why there is no need to perform text-to-hash encryption operation). Unfortunately, the progress in integrated circuit (ASIC, FPGA, etc.) design and manufacturing drastically reduced protection of hashed passwords, as dictionary or brute force computer processing attacks became extremely efficient. It is worthy to note that sometimes intercepting a hashed password is sufficient enough to break the system without learning the actual password.</p>
<p id="p-0013" num="0012">There are more sophisticated authentication systems based on Challenge-Handshake Authentication Protocol (CHAP, for instance, RFC 1334-3, RFC 1934, RFC 2759) used by Microsoft for Windows NT remote log-in. The server (the authenticator) sends the “challenge” to the client (the peer), where the message gets encrypted using the client's (the peer's) password. Actually, the “challenge” sent to the client platform is then encrypted at the client location three times using the first seven bytes of the password's hash value as the first DES key (Data Encryption Standard and other known encryption algorithms used for data encryption and decryption described in Bruce Schneier, Applied Cryptography, Second Edition, John Wiley and Sons, Inc., at pp. 233-560, (1996)); the next seven bytes of the password's hash value used as the second DES key, and the remaining two bytes of the password's hash value concatenated with five zero-filled bytes used as a third DES key. Eventually, three 64-bit “responses” (the “challenge” encrypted with DES keys as described above) are sent back to the server (the authenticator), where they are compared with the similar outputs calculated at the server. If the values match, the authentication is acknowledged; otherwise the connection should be terminated.</p>
<p id="p-0014" num="0013">Passwords (client/server shared secrets) in CHAP never enter communication lines in either form. This is a serious security advantage of this protocol. Also, CHAP prevents playback attacks by using “challenges” of a variable value. The server (the authenticator) is in control of the frequency and timing of the “challenge”. CHAP assumes that passwords are already known to the client and the server, and are easily accessible during a CHAP session. However, frequent usage of the same static encryption keys derived from a password on the client host, and applied to encrypt even random “challenge” numbers sent in clear text to the client, raises some security concerns. It provides ample opportunities for intruders, sniffing the network with the following offline computer data processing attacks.</p>
<p id="p-0015" num="0014">Various modifications of client/server authentication employing a challenge/response protocol are disclosed in Bellovin et al., U.S. Pat. No. 5,241,599, Kung et al., U.S. Pat. No. 5,434,918, Pinkas, U.S. Pat. No. 5,841,871, Hellman, U.S. Pat. No. 5,872,917, Brown, U.S. Pat. No. 6,058,480, Hoffstein at al., U.S. Pat. No. 6,076,163, Guthrie et al., U.S. Pat. No. 6,161,185, Jablon, U.S. Pat. No. 6,226,383, Swift et al., U.S. Pat. No. 6,377,691, Brown, U.S. Pat. No. 6,487,667, Jerdonek, U.S. Pub. No. 2002/0095507. Some of these patents go beyond security ofjust only an authentication process. They explore the opportunity of utilizing challenge/response type protocols as a basis for an encryption key management system. This can extend security for the entire communication session duration, allowing for encrypted data transmission between parties once their mutual authentication is completed.</p>
<p id="p-0016" num="0015">U.S. Pat. No. 5,434,918 and U.S. Pat. No. 6,377,691 applied client/server authentication based on different modifications of a challenge/response protocol to exchange secret keys (symmetric cryptography) between parties. There were attempts combining challenge/response protocols with well-known encryption key management systems. For instance, U.S. Pat. No. 6,076,163 and U.S. Pub. No. 2002/0095507 disclose versions of a challenge/response protocol utilizing an authentication and encryption key management system based on PKI (Public Key Infrastructure (Hellman et al., U.S. Pat. No. 4,200,770, and Diffie at al., IEEE Transactions on Information Theory, vol. IT-22, No. 6, November 1976)), whereas U.S. Pat. No. 5,841,871 discloses a version of a challenge/response protocol integrated with Kerberos (MIT, 1988; RFC 1510))—the authentication and encryption key management system.</p>
<p id="p-0017" num="0016">Another approach would be encrypting passwords (either text or hash) with a secret key (symmetric cryptography) on the client side, before transmission, and then, decrypt it on the server side for comparison with the password stored in the server-connected database. Though it can be a viable solution, there are several security requirements making this approach a very difficult one to implement. The first issue is how to manage the session secret key distribution between the client and the server. Otherwise, if the secret keys are statically preset at the client and the server hosts, they become a security concern by themselves. Moreover, having static keys for numerous communication sessions makes encrypted passwords vulnerable against offline computer data processing attacks. There are protocols, not based on a challenge/response type mechanism, where authentication credentials are distributed over communication lines with help of PKI. They were disclosed in Kaliski, U.S. Pat. No. 6,085,320, Kausik, U.S. Pat. No. 6,170,058, Kaliski, U.S. Pat. No. 6,189,098, Spies, U.S. Pat. No. 6,230,269 and Volger, U.S. Pat. No. 6,393,127. Despite recognized scientific studies and long-time exposure, PKI and Kerberos authentication and encryption key management systems have not experienced a wide industry acceptance due to their complexity, cost, and mandatory requirements to trust artificial third parties (see, for instance, Gartner QA-18-7301, 13 Nov. 2002, by V. Wheatman, Public-Key Infrastructure Q&amp;A, and DPRO-90693, 20 May 2003, by Kristen Noakes-Fry, Public Key Infrastructure: Technology Overview; USENIX, 91, Dallas, Tex., “Limitations of the Kerberos Authentication System”, by Steven M. Bellovin and Michael Merritt). SSL (Secure Socket Layer, based on PKI protocol developed by Netscape Communications in 1994) is also known for its security deficiencies, high cost and complexity in assuring “client browser”/“Web server” encrypted communication (see, for instance, Gartner T-16-0632, 3 Apr. 2002, by J. Pescatore and V. Wheatman, and FT-178896, 15 Aug. 2002, by J. Pescatore). Hence, there is a significant interest in exploring other encryption key management systems, similar to the challenge/response authentication protocols mentioned above, for instance, Fielder, U.S. Pat. No. 6,105,133, Alegre, U.S. Pat. No. 6,199,113, and Venkatram, U.S. Pat. No. 6,367,010.</p>
<p id="p-0018" num="0017">Aspects of this invention are particularly concerned with security of authentication systems and encrypted information exchange over distributed computer networks. Prior art encrypted authentication protocol implementations based on PKI, SSL, and Kerberos exhibited numerous security flaws and a prohibitive level of complexity and cost for various applications, businesses and organizations. There is a substantial need for improved and more efficient encrypted authentication protocols, addressing less complex infrastructures required, and less costly for practical implementation encryption key management systems. These improved encrypted authentication protocols should also include secure mutual authentication built into the protocols; randomly generated session secret keys; new cryptographic algorithms allowing for scalable security authentication and data encryption, and further allowing for variation based on the power of computer and network resources.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0019" num="0018">In accordance with the present invention, there are two secrets uniquely shared by either client/server pair, or authenticator/peer pair, and required for their mutual authentication. In the preferred embodiments, both secrets will suffice for a “what user knows” type authentication factor and either could be in a form of passwords or PINs, though other types of shared secrets can be used. Like other challenge/response type authentication protocols, where shared secrets are never in transit over communication lines, the protocol of the present invention does not allow shared secrets to pass through untrusted communication media. In order to avoid transmission of the shared secrets, a new encryption key management system has been integrated into the authentication protocol, becoming an essential part of the protocol itself.</p>
<p id="p-0020" num="0019">The main function of this encryption key management system is a secure distribution within either client/server pair, or authenticator/peer pair of a secret session random key (the same secret key is used in symmetric cryptography to encrypt and then decrypt digital information). Successful exchange of this encryption key enables secure resolution of two fundamental tasks. First, it allows for secure transit of the protocol data over communication lines in encrypted form, permitting explicit mutual authentication of the connected parties. Second, the post-authentication stage of the communication session can use secure encryption for the data exchange, since each party has already obtained the secret session random key.</p>
<p id="p-0021" num="0020">A series of new algorithms has been developed in the present invention and built into the new encryption key management system mentioned above. There is an algorithm (Time Interplay Limited Session Random Key (SRK) Algorithm (TILSA)) for generating and eventually obliterating arrays of session secret random keys. It starts long before the session begins and keeps processing these arrays during each communication session and well beyond it. At the same time, this algorithm allows concurrent communication between a number of client/server or authenticator/peer pairs with the same keys in the generated arrays (the multi-threading technology).</p>
<p id="p-0022" num="0021">Another algorithm (Key Encryption/Decryption Iterative Algorithm (KEDIA)) is initialized, provided there is a request for connection. It initiates an iterative sequence of messages from the server to the client and back to the server, each containing a consecutive session secret random key, encrypted with the session secret random key preceding the encrypted one in the array, and sent to the client in the previous message. The client can decrypt any following message and obtain an intermediate session secret random key from the array, provided the client could decrypt the previous message. The iterations continue until client/server (or authenticator/peer) mutual authentication is completed, and the Final Secret Key (FSK) is exchanged between the parties. More particularly, client/server (or authenticator/peer) authentication credentials and FSK eventual high security are achieved by applying, during each cycle of key encryption at the server (and its decryption at the client platform), either of Byte-Veil-Unveil (ByteVU), Bit-Veil-Unveil (BitVU), or Byte-Bit-Veil-Unveil (BBVU) algorithms. Each of these algorithms disassembles message bytes, or bits, or both bytes and bits in combination, together at the server and reassembles them at the client according to a certain procedure, which is started with the pair's shared secret. In other words, the client/server or authenticator/peer pair employs their shared secret to first build the session “security bridge” over the untrusted communication medium until “the bridge” is believed secure enough. Then, the authentication credentials can be safely tested with ByteVU, BitVU, or BBVU algorithms at the respective counterparts for the final mutual authentication, enabling the communication session. Otherwise, if the mutual authentication is not completed, the communication session is terminated.</p>
<p id="p-0023" num="0022">In one aspect of the invention, the client/server authentication protocol (Message Encrypt/Decrypt Iterative Authentication (MEDIA) protocol, which includes the encryption key management system described above), is highly resilient against session eavesdropping attacks, replay attacks, man-in-the-middle attacks, online and offline computer-processing attacks (like a dictionary attack or a brute force attack), and session hijacking attacks. Inability to successfully complete the MEDIA protocol can be regarded as intrusion detection (if there are more than just a few failed attempts from the same client caused by mistyping the entry data by a user on the client platform, or inaccurately set up hardware authentication credentials).</p>
<p id="p-0024" num="0023">In another aspect of the invention, the MEDIA protocol ends up with a FSK secret key, which can be used beyond the client/server authentication protocol stage of the communication session for encrypting data in transit and decrypting it upon arrival either to the server, or to the client. Security of FSK, and authentication credentials (client/server shared secrets) are guarded by five security tiers of the MEDIA authentication protocol and can be scaled with the client and server platforms' CPU power and the network throughput. In order to enhance security, FSK, as well as the entire series of preceding FSK session iterative random secret keys of the MEDIA protocol, are never transmitted over untrusted electronic communication media in their original form, or as their hash equivalents.</p>
<p id="p-0025" num="0024">In yet another aspect of the invention, the MEDIA protocol contains the encryption key management system, integrated into the protocol, represented by TILSA, KEDIA and ByteVU, BitVU, or BBVU algorithms. Their collective utilization assures randomly generated arrays of session secret keys, having limited life time and enabling efficient key encrypt/decrypt iterative messaging procedures, employing for each instance of iteration (each message encrypted on the server and decrypted on the client) a shared secret (password, PIN, or pattern) known only to the client and to the server. Moreover, the shared secrets (for instance, client and server passwords) are never transmitted over untrusted communication media in any form.</p>
<p id="p-0026" num="0025">In still another aspect of the invention, the five security tiers of the MEDIA protocol provide for a message confidentiality (no one can read messages; this is increasingly true with the increased number of SRK in the TILSA and the number of message iterations in the KEDIA). Message integrity is preserved because, if an intruder altered or in some way tampered with the message in the conversion array, potentially available to an intruder while it is in transit on communication lines, then it will be impossible for ByteVU, BitVU, or BBVU algorithms to reassemble the encrypted keys or authentication credentials, either at the client or at the server. Message non-repudiation is guaranteed by the mutual authentication mechanism (the fifth security tier)—without exception only the client and the server know their shared secrets and respectively could send a message.</p>
<p id="p-0027" num="0026">In a further aspect of the invention, the post-authentication part of the MEDIA session continued with FSK can also employ such message integrity control technique as encrypting with FSK the message hash, before the message is encrypted with FSK. Then the message hash can be decrypted with FSK on the receiving end, and compared with the same message, hashing it after having the message decrypted with FSK.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0028" num="0027">Additional objects, features, capabilities and advantages of the present invention will be apparent from the following detailed description when read in conjunction with the accompanying drawings in which:</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 1</figref> is a graphic illustration of the Time Interplay Limited SRK (Session Random Key) Algorithm (TILSA) according to the present invention.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 2</figref> is a graphic illustration of the Array of Data Encryption Keys (ADEK) branch of the TILSA algorithm according to the present invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 3</figref> is a graphic illustration of the Key Encryption/Decryption Iterative Algorithm (KEDIA) according to the present invention.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 4</figref> is a graphic illustration of the KEDIA typical message encryption at the server and its decryption at the client applying one of Byte-Veil-Unveil (ByteVU), Bit-Veil-Unveil (BitVU), or Byte-Bit-Veil-Unveil (BBVU) algorithms according to the present invention.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of the Byte-Veil-Unveil (ByteVU) algorithm according to the present invention.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram of the Bit-Veil-Unveil (BitVU) algorithm according to the present invention.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram of the Byte-Bit-Veil-Unveil (BBVU) algorithm according to the present invention.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 8A</figref> is the Message Encrypt/Decrypt Iterative Authentication (MEDIA) protocol (the server side) according to the present invention.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 8B</figref> is the Message Encrypt/Decrypt Iterative Authentication (MEDIA) protocol (the client side) according to the present invention.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 9</figref> illustrates the Graphical User Interface (GUI) enabling client/server mutual authentication at the client platform according to the MEDIA protocol, and a graphical illustration of the distributed protected network resources, including the authentication server, and the user base for which the MEDIA protocol is used, according to the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0039" num="0038">According to the present invention, there are shared secrets (several secrets are needed in strong authentication cases and also in a case of mutual authentication) between two parties attempting to establish trust over untrusted electronic communication media. Shared secrets are usually established during an account open procedure. Though the server password could be shared by the plurality of users, it is assumed, without sacrificing any generality of the disclosed authentication protocol, that the preferred embodiment of this invention is to provide a unique server password for each user. Account set/reset online automated utilities would greatly facilitate establishing uniquely personalized server and user passwords. Client/server or d2d (authenticator/peer) communication sessions would be typical cases, though the client/server protocol would remain the preferred embodiment. There are no limitations on the nature of the shared secrets used. They could be “what user knows” secrets, for example, passwords, or “what user has” secrets, i.e., tokens and smart cards, or, alternatively, “what user is” secrets, for example, biometrics. However, the preferred embodiments would relate to secrets in the category of “what user knows”. Also, there are no limitations on the network layer over which the authentication protocol is established—it could be TCP/IP stack, IPsec, or other communication protocols. Nevertheless, the preferred embodiments will assume HTTP (RFC 2068 Hypertext Transfer Protocol—HTTP/1.1 January 1997). Also, the invention implies contemporary object-oriented software technologies like Java, C++, and .NET, providing multi-threading, serialization, servlet and applet techniques, library of cryptographic algorithms, GUI (Graphical User Interface) capabilities, and connectors/drivers like JDBC to standard commercial databases.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 1</figref> is a graphic illustration of the Time Interplay Limited SRK (Session Random Key) Algorithm (TILSA) according to the present invention. Before any communication session starts, the server-placed logic continuously and periodically generates (Session Random Key Generator <b>1005</b>) an array (Array of Session Keys (ASK) <b>1013</b>) of Session Random Keys (SRK) <b>1011</b>—secret keys (symmetric cryptography). Each key has two different lifetimes. The first lifetime (LT<b>1</b>) is the lifetime for establishing a client/server communication session, provided there is a request from a client or plurality of clients (Client <b>1</b> <b>1003</b>, Client <b>2</b> <b>1007</b>, . . . , Client N-<b>1</b> <b>1008</b>, and Client N <b>1009</b>) during LT<b>1</b> to initiate a communication session. Each client can establish a communication link <b>1015</b>, <b>1006</b>, . . . , <b>1016</b>, <b>1017</b> to Web Server <b>1002</b> and Compute/Applications Server <b>1001</b> through communication network <b>1004</b>. The beginning of LT<b>1</b> <b>1014</b> is synchronized with each SRK <b>1011</b> generation, placing it into ASK <b>1013</b>.</p>
<p id="p-0041" num="0040">For instance, in <figref idref="DRAWINGS">FIG. 1</figref>, SRK<b>1</b> appears in ASK <b>1013</b> at the time mark “0 minute”, and at the moment that time mark 1 minute LT<b>1</b> of SRK<b>1</b> has expired, though SRK<b>1</b> remains inside ASK <b>1013</b>. SRK Generator <b>1005</b> at this moment generates SRK <b>2</b> and places it into ASK <b>1013</b>. By the time mark 2 minutes SRK <b>2</b> LT<b>1</b> has expired, even though SRK <b>2</b> remains inside ASK <b>1013</b>. Again, at this time SRK Generator <b>1005</b> generates and places into ASK <b>1013</b> SRK <b>3</b>, which LT<b>1</b> becomes expired at the 3 minutes mark. This procedure is periodically repeated as long as SRK Generator <b>1005</b> is on. Client <b>1</b> <b>1003</b> and Client N <b>1009</b> made a connection request during the time interval between time mark 4 minutes and time mark 5 minutes, since SRK Generator <b>1005</b> began generating SRK <b>1011</b> and filling them into ASK <b>1013</b>. The only SRK <b>1011</b> not yet expired LT<b>1</b> in ASK <b>1013</b> during this time interval is SRK <b>5</b>. Therefore, SRK <b>5</b> is used to establish communication sessions with these clients. Similarly, Client <b>2</b> requested a communication session between time mark 8 minutes and time mark 9 minutes, whereas Client N-<b>1</b> requested a communication session between time mark 1 minute and 2 minutes. Hence, the SRK <b>1011</b> used to establish these communication sessions are, respectively, SRK <b>9</b> and SRK <b>2</b>.</p>
<p id="p-0042" num="0041">Once LT<b>1</b> is expired, the server generates and places into ASK <b>1013</b> another SRK <b>1012</b>, which LT<b>1</b> is just started. SRK <b>1011</b> second life time LT<b>2</b> defines the life time inside the limited size ASK <b>1013</b>. The maximum size of ASK <b>1013</b> can be characterized with the parameter Nmax which indicates maximum number of SRK <b>1011</b> in ASK <b>1013</b> possible (for instance, Nmax=5 in <figref idref="DRAWINGS">FIG. 1</figref>). Typically, LT<b>1</b>&lt;LT<b>2</b>, and in the most preferred embodiment LT<b>1</b> can be derived as LT<b>1</b>=LT<b>2</b>/Nmax. Without sacrificing any generality limitations of TILSA, LT<b>2</b> was chosen, for example, to be equal to 5 minutes in <figref idref="DRAWINGS">FIG. 1</figref>. Then, LT<b>1</b> according to the formulae presented above, is equal to 1 minute. After LT<b>1</b> expired, for any given SRK <b>1011</b>, the key has LT<b>2</b>−LT<b>1</b> time remaining to support communication session threads having been initiated during LT<b>1</b>. Once LT<b>2</b> expired, SRK <b>1011</b> is removed from ASK <b>1013</b>, effectively canceling any further participation of this particular SRK <b>1011</b> in the parties' communication session engagements. Certainly, each SRK <b>1011</b> can be used to originate multiple threads of communication sessions with each Session Elapsed Time (SET) less or equal to LT<b>2</b>−LT<b>1</b>. However, SET=LT<b>2</b>−LT<b>1</b> is the preferred embodiment. Without sacrificing any generality limitations of TILSA, SET=4 minutes in <figref idref="DRAWINGS">FIG. 1</figref>. Taking SRK<b>5</b> in <figref idref="DRAWINGS">FIG. 1</figref> as an example of any SRK <b>1011</b> genesis, one can note that SRK <b>5</b> is the last key to fulfill ASK <b>1013</b> to its maximum size Nmax=5, and SRK <b>5</b> appears inside ASK <b>1013</b> at the 4-minute mark, since SRK Generator <b>1005</b> began generating SRK <b>1011</b> and filling them into ASK <b>1013</b>. Then, during SRK <b>5</b> LT<b>1</b>=1 minute, the key can be engaged into initiating multiple communication session threads with the clients requesting connections. From time mark 5 minutes, and until time mark 9 minutes, SRK<b>5</b>, in accordance with SET=4 minutes, is kept inside ASK <b>1013</b> available to support communication session threads started during SRK <b>5</b> LT<b>1</b>. During this particular time interval, from time mark 5 minutes to time mark 9 minutes, SRK <b>1</b>, SRK <b>2</b>, SRK <b>3</b>, and SRK <b>4</b> in ASK <b>1013</b> are being gradually replaced every minute by SRK <b>6</b>, SRK <b>7</b>, SRK <b>8</b>, and SRK <b>9</b>, respectively. Eventually, at time mark 9 minutes SRK<b>5</b> is canceled, ultimately being replaced by SRK <b>10</b>.</p>
<p id="p-0043" num="0042">This Time Interplay Limited SRK Algorithm (TILSA) is the first security tier of the authentication protocol, assuring supply of SRK <b>1011</b> to initiate any client/server communication session. However, the time to initiate a session (approximately one minute, without sacrificing any generality limitations of TILSA) and the time to continue the session authentication protocol (possibly several minutes, without sacrificing any generality limitation of TILSA) are quite limited for any given SRK <b>1011</b>, thus hindering a possible intruding activity.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 2</figref> is a graphic illustration of the Array of Data Encryption Keys (ADEK) branch of the TILSA algorithm according to the present invention. The essential part of TILSA is generating (Data Random Key Generator <b>2005</b>) an array of Data Random Keys (DRK) <b>2013</b>—secret keys to support the authentication session for any particular SRK <b>1011</b> starting a communication session thread. This array of DRK (Array of Data Encryption Keys (ADEK) <b>2012</b>) is regenerated and specifically attributed to each SRK <b>1011</b>, together and concurrently with originating any new SRK <b>1011</b> with the logic located on the server side; explaining why there is no latency in the DRK supply during a client/server encrypted authentication session. The number of DRK <b>2013</b> in ADEK <b>2012</b> is fixed, acting as a security parameter for the MEDIA authentication protocol being presented. Each ADEK <b>2012</b> can be used for a plurality of threads initiated with a particular SRK, to which this ADEK <b>2012</b> belongs. The ADEK <b>2012</b> lifetime is limited and equal to the lifetime of the originated SRK <b>1011</b> in ASK <b>1013</b>, being LT<b>2</b>. Deleting SRK <b>1011</b> from ASK <b>1013</b> inevitably deletes ADEK <b>2013</b>, corresponding to this SRK <b>1011</b>.</p>
<p id="p-0045" num="0044">Once the client requested a connection to the server supported by the user name of the user on the client platform (or the client host name), a suitable SRK <b>1011</b>, accompanied by LT<b>1</b>, not yet expired, is sent to the client by the server. In the most preferred embodiment of this invention, SRK <b>1011</b> is sent to the client in a compiled form (for example, as a class file). This is the second security tier of the authentication protocol, in view of the fact that reengineering a compiled key given a short SRK <b>1011</b> lifetime LT<b>2</b> is a formidable task. Therefore, the first two security tiers make SRK <b>1011</b> quite resilient to the on line attacks during the session time, because of incommensurate times to reengineer SRK <b>1011</b> versus SRK <b>1011</b> expiration time LT<b>2</b>. However, SRK <b>1011</b> is still vulnerable against off line attacks and needs to be enhanced further to avoid any loss of authentication credentials and the eventual session Final Secret Key (FSK).</p>
<p id="p-0046" num="0045">Since SRK <b>1011</b> is sent to the client as the first message, the logic located on the server and on the client sides generates a series of messages having been sent from the server to the client, and back to the server with the following Key Encryption/Decryption Iterative Algorithm (KEDIA). <figref idref="DRAWINGS">FIG. 3</figref> is a graphic illustration of the Key Encryption/Decryption Iterative Algorithm (KEDIA) according to the present invention. In step <b>1</b> <b>3005</b>, client <b>3002</b> sends a connection request to server <b>3001</b> over communication network <b>3003</b>. In step <b>2</b> <b>3006</b>, SRKi (with the currently active LT<b>1</b>—between time mark i−1 minutes and time mark 1 minutes) is sent to client <b>3002</b>, and stored there, initiating the communication interface. In step <b>3</b> <b>3007</b>, client <b>3002</b> enters the user name, the user password, and the server password, if it is a user at the client platform <b>3002</b>, or the host name, the host ID, and the server password, if it is the client platform (the peer). In step <b>4</b> <b>3008</b>, the user name (or the host name) is hashed, encrypted with SRKi and sent to server <b>3001</b>, while the user password (or the host ID) and the server password were not sent, remaining at client <b>3002</b>.</p>
<p id="p-0047" num="0046">In step <b>5</b> <b>3009</b>, server <b>3001</b> checks the validity of the user name (or the host name), obtained in the step <b>4</b>, through the database to which it is connected. The session is terminated, if the user name (or the host name) is not valid. Otherwise, server <b>3001</b> in step <b>3009</b> sends DRK <b>1</b> encrypted with SRKi to client <b>3002</b>, where DRK <b>1</b> is decrypted with SRKi, and stored at client <b>3002</b>. During the same step <b>3009</b>, client <b>3002</b> sends a DRK <b>1</b>, which is converted to its hash equivalent and encrypted with DRK <b>1</b>, to server <b>3001</b>. This message confirms to server <b>3001</b> that client <b>3002</b> obtained and decrypted DRK <b>1</b>, and it is ready for receiving another secret key. In step <b>6</b> <b>3010</b>, server <b>3010</b> first decrypts hashed DRK <b>1</b>, received in step <b>5</b> from client <b>3002</b>, with DRK <b>1</b>. If DRK <b>1</b> is correct, server <b>3001</b> sends DRK <b>2</b> encrypted with DRK <b>1</b> to client <b>3002</b>, where DRK <b>2</b> is decrypted with DRK <b>1</b>, and stored at client <b>3002</b>. Otherwise, the communication session is terminated. During the same step <b>6</b> <b>3010</b>, client <b>3002</b> sends a DRK <b>2</b>, converted to its hash equivalent, and encrypted with DRK <b>2</b>, to server <b>3001</b>. This message confirms to server <b>3001</b> that client <b>3002</b> obtained and decrypted DRK <b>2</b>, and it is ready for receiving another secret key.</p>
<p id="p-0048" num="0047">This iterative process continues up to step n <b>3014</b>. Parameter n is actually the maximum number of DRK <b>2013</b> in ADEK <b>2012</b> (<figref idref="DRAWINGS">FIG. 2</figref>), and should be chosen for any practical implementation of this encrypted authentication protocol. Then, assuming DRKn−1 hash received from client <b>3002</b> in the previous step n−1 is correct, server <b>3001</b>, sends DRKn, encrypted with client <b>3002</b> hashed password (taken from server database <b>3004</b>, as server <b>3001</b> knows from step <b>4</b> <b>3008</b>, the identification of the client (or the user on the client platform)) to client <b>3002</b>, where DRKn is decrypted with the client <b>3002</b> password, stored at the client side in step <b>3</b>. During the same step n, client <b>3002</b> sends to server <b>3001</b> hashed DRKn encrypted with the client <b>3002</b> password, stored at client <b>3002</b> at step <b>3</b> and converted to its hash equivalent. Step n is an important first phase towards client/server mutual authentication. Indeed, the client can decrypt DRKn only in the case where client <b>3002</b> knows the user <b>3002</b> password. Then, client <b>3002</b> encrypts hashed DRKn with the client <b>3002</b> hashed password, as a secret key and sends it back to server <b>3001</b> in same step n <b>3014</b>. Having received DRKn encrypted with client <b>3001</b> password, server <b>3001</b> decrypts it with the client <b>3001</b> password, and, if it is correct, server <b>3001</b>, in step n−1 <b>3015</b>, sends to client <b>3002</b> DRKn encrypted with hashed server <b>3001</b> password as a key.</p>
<p id="p-0049" num="0048">Certainly, client <b>3002</b>, already aware of DRKn from the previous step n <b>3014</b>, compares the result of decrypting the last message with the server <b>3001</b> password, stored at client <b>3001</b> in step <b>3</b> <b>3007</b>, and converted to its hash equivalent, with DRKn. If they are the same, the client is assured that the communication session is with the correct server, as only client <b>3002</b> and server <b>3001</b> know the server <b>3001</b> password. Otherwise, the client <b>3002</b> terminates the communication session, and intrusion detection is reported. Eventually, during same step n+1 <b>3015</b>, client <b>3002</b> sends to server <b>3001</b> hashed DRKn encrypted with the server password, stored at client <b>3002</b>, at step <b>3</b> <b>3007</b>, and converted to its hash equivalent. This message, transmitted back to server <b>3001</b>, means that client <b>3002</b> has established trust to server <b>3001</b>. In step n+2 <b>3016</b>, server <b>3001</b> decrypts hashed DRKn with the server password from the <b>3004</b> database connected to the server, and compares the result with DRKn at server <b>3001</b>. Depending on the comparison results, server <b>3001</b>, during same step n+2 <b>3016</b>, sends to client <b>3002</b> the authentication signal “go/no” encrypted with DRKn−1, stored at client <b>3002</b>, at the step, prior to step <b>3014</b>. This completes the client/server mutual authentication and Final Secret Key (FSK) exchange according to the KEDIA algorithm.</p>
<p id="p-0050" num="0049">One encryption/decryption algorithm used in an embodiment of the invention is the Triple Data Encryption Standard block cipher algorithm. Triple-DES (3DES), based upon the Triple Data Encryption Algorithm (TDEA), is described in FIPS 46-3. Other block cipher algorithms are also suitable, including RC6, Blowfish/Twofish, Rijndael, and AES. See, Bruce Schneier, Applied Cryptography, Second Edition, John Wiley and Sons, Inc., cited above.</p>
<p id="p-0051" num="0050">In this form the KEDIA algorithm, described above as part of the authentication communication protocol, is the third security tier, efficient against online and offline intruding attacks. Among other factors, the security against online attacks is increased due to effectively extending the time, needed by an intruder to decrypt the entire series of DRK <b>2013</b> in ADEK <b>2012</b>, whereas the ADEK <b>2012</b> life time is quite limited and is actually equal to LT<b>2</b>, the same as for SRK <b>1011</b>, which originated this ADEK <b>2013</b>. As mentioned above, the number of DRK <b>2013</b> in ADEK <b>2012</b> is the authentication protocol security parameter and can be chosen according to the security requirements, considering the actual system CPU and network resources. Security against offline attacks is assured through the mutual client/server authentication utilizing shared secrets known only to the client, and to the server. Moreover, the client supposed to perform a strong (two factors) authentication, as the KEDIA algorithm requires the client to enter correctly the client (the user on the client platform) password and the server password, unique to the client (the user on the client platform). Important security feature of the KEDIA algorithm are (1) that client/server passwords never enter communication lines in either form, (2) client/server pair performs mutual authentication in steps n <b>3014</b>, n+1 <b>3015</b>, and n+2 <b>3016</b>, and (3) client/server pair exchanges FSK enabling transmitted data encryption during the post-authentication stage of the communication session.</p>
<p id="p-0052" num="0051">In the case where an intruder intercepts the last message in step n+2, and somehow knows the format of the “go/no” authentication signals, a brute force computer processing attack could be applied to uncover DRKn−1. However, the intruder would only gain limited access as DRKn−1 is detached from client/server authentication credentials, and from DRKn (which is FSK in this particular embodiment of the KEDIA algorithm).</p>
<p id="p-0053" num="0052">Therefore, an offline attack is senseless, as the intruder going backward through steps <b>3013</b>, <b>3010</b>, <b>3009</b>, and <b>3008</b> could find DRKn−2 DRKn−3, . . . , DRK <b>1</b>, and eventually SRKi, which are all only one-time session random keys, and they can not be reused. Certainly, the intruder could further decrypt the user name; however, this is not regarded as a secret. The time DRKn−1, operating during the client/server communication session, is excruciatingly small for attempting an online computer processing attack. Even assuming this attack successful, all, the intruder could do is to send to client <b>3002</b> an incorrect authentication signal, which will be visualized in the user's session GUI, but would never take effect in the actual system. This is because the authentication signal “go/no” enables functionality through the server <b>3001</b> side logic.</p>
<p id="p-0054" num="0053">The KEDIA algorithm security has been further significantly enhanced by integrating and synthesizing it with the Byte-Veil-Unveil (ByteVU) algorithm, the Bit-Veil-Unveil (BitVU) algorithm, and the Byte-Bit-Veil-Unveil (BBVU) algorithm. All three algorithms are built around the idea that every encrypted message in the client/server dialogue in the KEDIA algorithm is a fixed byte size, relatively small (typically 16 bytes) message. The algorithms employ the fact that the server already has identified who the client pretends to be, after receiving the user name (or the host name) during the initial connection request. At this time, the server finds the password, or another shared secret, corresponding to the user name (or the host name), in the server database <b>3004</b>, connected to the server. Then, the server employs this information to disassemble only message bytes, or only bits, or the combination thereof, inside a certain conversion array, making their reassembling a highly improbable task, unless the client knows the shared secret. In this case, the message, which is the encrypted key, is easily recovered and eventually decrypted with the secret key, learned from the previous message.</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 4</figref> is a graphic illustration of the KEDIA algorithm. This is a typical message encryption at the server and its decryption at the client, applying along with encryption and decryption procedures one of Byte-Veil-Unveil (ByteVU), Bit-Veil-Unveil (BitVU), or Byte-Bit-Veil-Unveil (BBVU) algorithms, according to the present invention. Step <b>6</b> <b>3010</b> has been chosen as a typical message example in the KEDIA algorithm. According to <figref idref="DRAWINGS">FIG. 3</figref>, during this step, server <b>3001</b> sends DRK <b>2</b> encrypted with DRK <b>1</b> to client <b>3002</b>, where DRK <b>2</b> is decrypted with DRK <b>1</b>, received by client <b>3002</b> in the previous step <b>3009</b> from server <b>3001</b>. In <figref idref="DRAWINGS">FIG. 4</figref>, step <b>3010</b> is split for clarity into two parts <b>4001</b> and <b>4002</b>, which are related to preparing the message at server <b>3001</b>, and treating the received message at client <b>3002</b>, respectively. Blocks <b>4003</b>, <b>4005</b>, <b>4007</b>, and <b>4009</b> depict the process the message is going through, before it is sent to client <b>3002</b>. DRK <b>2</b> (for instance, 16 bytes long, secret key to be used with a block-cipher encryption algorithm) is supplied by Server DRK Generator <b>2005</b> (see <figref idref="DRAWINGS">FIG. 2</figref>) <b>4003</b>. In the following step <b>4005</b>, server <b>3001</b>, already having identified who claims to be the user on the client platform, (or what is the claimed client platform host name), extracts the respective user password (or the client host ID) from the database <b>3004</b> attached to server <b>3001</b>. Eventually, according to block <b>4007</b>, server <b>3001</b> uses this information to trigger operation of one of ByteVU, BitVU, or BBVU algorithms, having been chosen by a particular security system, considering security requirements vs. cost trade-offs (time of operations, CPU power of client/server platforms, and the network throughput). As a final result <b>4009</b>, the conversion array, containing disassembled DRKj bytes, or bits, or the combination thereof, gets encrypted with DRK<b>1</b>, and sent to client <b>3002</b>.</p>
<p id="p-0056" num="0055">Part <b>4002</b> of step <b>3010</b>, related to the received message treatment at client <b>3002</b>, is expanded by the series of blocks <b>4004</b>, <b>4006</b>, <b>4008</b>, and <b>4010</b> in <figref idref="DRAWINGS">FIG. 4</figref>. According to block <b>4004</b>, client <b>3002</b> decrypts the conversion array with DRKj-<b>1</b>, stored by client <b>3002</b> from the previous message <b>3011</b> from server <b>3001</b>. Then, client <b>3002</b> supplies the user password (or the client host ID) which was entered into the KEDIA algorithm at step <b>3</b> <b>3007</b> (see <figref idref="DRAWINGS">FIG. 3</figref>), enabling reassembling of DRK <b>2</b> from the decrypted conversion array <b>4006</b>. As it is shown in block <b>4008</b>, the operation is triggered for one of ByteVU, BitVU, or the BBVU algorithms, having been chosen on the client side the same one, as on the server side. Eventually, according to block <b>4008</b>, either the message bytes, or bits, or the combination thereof, get reassembled, and finally, as it is shown in block <b>4010</b>, DRK <b>2</b> is reconstructed to its original form.</p>
<p id="p-0057" num="0056">In compliance with <figref idref="DRAWINGS">FIG. 4</figref>, each message of the KEDIA algorithm employs additional treatment as compared to the standard encryption/decryption operations. This treatment is triggered by the client/server shared secret at the sending and receiving communication channel ends. <figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of the Byte-Veil-Unveil (ByteVU) algorithm according to the present invention. Block <b>5001</b> shows DRKj, where each byte is separated from a neighboring byte with a vertical bar. Without sacrificing any generality of the ByteVU algorithm, DRKj is assumed to be a 16-bytes key in <figref idref="DRAWINGS">FIG. 5</figref>. The user password (or the client host ID), supplied by server <b>3001</b> in a hashed form, plays a seed role for Server Sequential Random Number Generator (SRNG) <b>5002</b>. SRNG <b>5002</b> generates a random sequence of integers, and it is the same sequence of integers, each from 1 to 10, for any given seed. In other words, the password (or the client host ID) and the SRNG sequence of integers are uniquely associated. Block <b>5005</b> introduces a conversion array which, without sacrificing any generality limitations of ByteVU algorithm, has 16 equal sections <b>5006</b>, <b>5007</b>, <b>5008</b>, <b>5009</b>, and <b>5010</b>, with 10 bytes per each section. <figref idref="DRAWINGS">FIG. 5</figref> presents an exemplary case, when SRNG <b>5002</b> generated 16 sequential integers 4, 9, . . . , 2, and 7.</p>
<p id="p-0058" num="0057">The first integer 4 is used by the logic located by the server <b>3001</b> to replace byte r<b>1</b>,<b>4</b> in the first section <b>5006</b> of conversion array <b>5005</b> by the first byte xh<b>1</b> of DRKj in <b>5001</b>. Similarly, the second integer 9 is used by that same logic to replace byte r<b>2</b>,<b>9</b> in the second section <b>5007</b> of conversion array <b>5005</b> by the second byte xh<b>2</b> <b>5012</b> of DRKJ in <b>5001</b>. The same procedure is applied to all integers in the sequence generated by SRNG <b>5002</b>, until DRKJ 15<sup>th </sup>byte xh<b>15</b> in <b>5001</b> is replacing the 2<sup>nd </sup>byte r<b>15</b>,<b>2</b> in the 15<sup>th </sup>th section <b>5009</b> of conversion array <b>5005</b>, and eventually DRKj 16<sup>th </sup>byte xh<b>16</b> in <b>5001</b> is replacing the 7<sup>th </sup>byte r<b>16</b>,<b>7</b> in the 16<sup>th </sup>section of conversion array <b>5005</b>. Once all bytes of DRKj are veiled in this manner inside conversion array <b>5005</b>, the entire conversion array <b>5005</b> is encrypted with DRKj-<b>1</b>, and the message is sent to client <b>3002</b>. At client <b>3002</b>, the encrypted conversion array is decrypted with DRKj-<b>1</b>, saved at client <b>3002</b>, from the previous server message (step <b>3011</b> in KEDIA, <figref idref="DRAWINGS">FIG. 3</figref>).</p>
<p id="p-0059" num="0058">The next procedure, reversed as compared to the procedure described above on the server <b>3001</b> side, is applied. The user password (or the client host ID) saved at the client platform in step <b>3007</b> of the KEDIA algorithm (see <figref idref="DRAWINGS">FIG. 3</figref>) is supplied in a hashed form as a seed to Client Sequential Random Number Generator (SRNG) <b>5003</b>, identical to the one on the server <b>3001</b> side. This password (or host ID) triggers SRNG <b>5003</b> to generate the same sequence of integers, as on server <b>3001</b> side before 4, 9, . . . , 2, 7. Then, the logic placed on client <b>3002</b> used the first integer 4 to extract DRKj first byte xh<b>1</b> from the fourth position in first 10 bytes section <b>5006</b> of conversion array <b>5005</b>, and place it back in the 1<sup>st </sup>position of DRKj <b>5001</b>. Consequently, the second integer 9 is used to extract DRKJ second byte from the 9<sup>th </sup>position in 10 bytes section <b>5007</b> of conversion array <b>5005</b>, and place it back into the 2<sup>nd </sup>byte position of DRKj <b>5001</b>. This procedure is going on, until, eventually, the 15<sup>th </sup>byte of DRKj xh<b>15</b> is extracted from the 2<sup>nd </sup>byte position in 15<sup>th </sup>10 bytes section <b>5009</b> of conversion array <b>5005</b>, and placed back into 15<sup>th </sup>byte position of DRKj <b>5001</b> as well as the 16<sup>th </sup>th byte of DRKj xh<b>16</b> <b>5011</b> extracted from the 7<sup>th </sup>byte position in 15<sup>th </sup>10 bytes section <b>5010</b> of conversion array <b>5005</b>, and placed back into 15<sup>th </sup>byte position of DRKj <b>5001</b>. This completes the reassembling procedure of the ByteVU algorithm to restore DRKj at client <b>3002</b>.</p>
<p id="p-0060" num="0059">A suitable sequential random number generator SRNG for use in embodiments of the invention is a Java version of the well known “Lehmer generator.” See, Park &amp; Miller, “Random Number Generators, Good Ones are Hard to Find,” Communications of the ACM, Vol. 31, No. 10, (1988), pages 1192-1201.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram of the Bit-Veil-Unveil (BitVU) algorithm according to the present invention. The BitVU algorithm is a natural extension of the ByteVU algorithm. Instead of veiling bytes of DRKj, the BitVU algorithm veils bits of DRKj. It is assumed, without sacrificing any generality limitations of the BitVU algorithm, that DRKj bit size is 128 bits <b>6001</b>. Each bit of DRKj in <b>6001</b> is separated from a neighboring bit with a vertical bar. Server Sequential Random Number Generator (SRNG) <b>6002</b> uses the user password (or the client host ID) supplied by the server in a hashed form as a seed, allowing for the generation of a random series of 128 integers with values ranging from 1 to 128 (for instance, 4, 127, . . . , 4, 2), and each one pointing to a DRKj consecutive bit veiled position in conversion array <b>6005</b>, respective sections <b>6006</b>, <b>6007</b>, . . . , <b>6008</b>, . . . , <b>6009</b>, and <b>6010</b> of 128 bit size each. In other words, the password (or the client host ID) and the SRNG <b>6002</b> sequence of integers are uniquely associated.</p>
<p id="p-0062" num="0061">Block <b>6005</b> introduces a conversion array which, without sacrificing any generality limitations of BitVU algorithm, has 128 equal sections <b>6006</b>, <b>6007</b>, . . . , <b>6008</b>, . . . , <b>6009</b>, and <b>6010</b>, with 128 bits per each section. <figref idref="DRAWINGS">FIG. 6</figref> presents an exemplary case, when SRNG <b>6002</b> generated <b>128</b> sequential integers 4, 127, . . . , 4, and 7. For this exemplary case disclosed in <figref idref="DRAWINGS">FIG. 6</figref>, the 1<sup>st </sup>bit of DRKj <b>6001</b> yh<b>1</b> is put into the 4<sup>th </sup>bit position of first section <b>6006</b> instead of r<b>1</b>,<b>4</b> bit; then the 2<sup>nd </sup>bit of DRKJ <b>6001</b> yh<b>2</b> <b>6012</b> is put into 127<sup>th </sup>bit position of second section <b>6007</b> instead of r<b>2</b>,<b>127</b> bit, and so on, until 127<sup>th </sup>bit of DRKj <b>6001</b> is put into the 4<sup>th </sup>position of 127<sup>th </sup>section <b>6009</b> instead of r<b>127</b>,<b>4</b> bit. Ultimately, the 128<sup>th </sup>bit of DRKj <b>6001</b> is put into the 2<sup>nd </sup>bit position of the 128<sup>th </sup>section <b>6010</b> of conversion array <b>6005</b> instead of r<b>128</b>,<b>2</b> bit. Once all bites of DRKj are veiled in this manner inside conversion array <b>6005</b>, the entire conversion array <b>6005</b> is encrypted with DRKj-<b>1</b>, and the message is sent to client <b>3002</b>.</p>
<p id="p-0063" num="0062">At client <b>3002</b>, the encrypted conversion array is decrypted with DRKj-<b>1</b>, saved at client <b>3002</b>, from the previous server message (step <b>3011</b> in the KEDIA algorithm, <figref idref="DRAWINGS">FIG. 3</figref>). Then the procedure, a reversed one as compared to that which is described above for the BitVU algorithm on server <b>3001</b> side, is applied. The user password (or the client host ID) saved at the client platform in step <b>3007</b> of the KEDIA algorithm (see <figref idref="DRAWINGS">FIG. 3</figref>) is supplied in a hashed form as a seed to Client Sequential Random Number Generator (SRNG) <b>6003</b>, identical to the one on the server <b>3001</b> side. This password (or host ID) triggers SRNG <b>6003</b> to generate the same sequence of integers as on server <b>3001</b> side before, that is 4, 127, . . . , 4, 2. Then, the logic placed on client <b>3002</b> used the first integer <b>4</b> to extract DRKj 1<sup>st </sup>byte yh<b>1</b> from the 4<sup>th </sup>position in 1<sup>st </sup>128 bits section <b>6006</b> of conversion array <b>6005</b>, and placed it back in the 1<sup>st </sup>position of DRKj <b>6001</b>. Consequently, the second integer <b>127</b> is used to extract DRKj 2<sup>nd </sup>bit from the 127<sup>th </sup>position in 2<sup>nd </sup>128 bits section <b>6007</b> of conversion array <b>6005</b>, and place it back into the 2<sup>nd </sup>bit position of DRKj <b>6001</b>. This procedure continues until, ultimately, the 127<sup>th </sup>bit of DRKj yh<b>127</b> is extracted from the 4<sup>th </sup>bit position in 127<sup>th </sup>128 bits section <b>6009</b> of conversion array <b>6005</b>, and placed back into 127<sup>th </sup>bit position of DRKj <b>6001</b>, as well as the 128<sup>th </sup>bit of DRKj yh<b>128</b> <b>6011</b> being extracted from the 2<sup>nd </sup>bit position in 128<sup>th </sup>128 byte size section <b>6010</b> of conversion array <b>6005</b>, and placed back into 128<sup>th </sup>bit position of DRKj <b>6001</b>. This completes the reassembling procedure of the BitVU algorithm to restore DRKJ at client <b>3002</b>.</p>
<p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram of the Byte-Bit-Veil-Unveil (BBVU) algorithm according to the present invention. Block <b>7001</b> shows DRKj, where each byte is separated from a neighboring byte with a vertical bar. Without sacrificing any generality limitations of the BBVU algorithm, DRKJ is assumed to be a 16-bytes key in <figref idref="DRAWINGS">FIG. 7</figref>. The user password (or the client host ID), supplied by server <b>3001</b> in a hashed form, plays a seed role for Server Sequential Random Number Generator (SRNG) <b>7002</b>. SRNG <b>7002</b> generates a random sequence of 16 integers, and then the server's Sequential Direct Bit Position Scrambler (SDBPS) <b>7006</b> scrambles all bit positions in the veiled byte <b>7010</b>. SDBPS <b>7006</b> generates a random series of non-repeating eight digits within the range from 1 to 8, for each of SRNG <b>7002</b> integers in the sequence. In other words, the password (or the client host ID), the SRNG <b>7002</b> sequence of integers, and the series of digits generated by SDBPS <b>7006</b> are uniquely associated. Applying the same seed (the user password, or the server host ID, in a hashed form) will result in the same sequence of integers generated by SRNG <b>7002</b>, and the same series of digits generated by SDBPS <b>7006</b> for each integer in the sequence.</p>
<p id="p-0065" num="0064">Block <b>7006</b> introduces a conversion array which, without sacrificing any generality limitations of the BBVU algorithm, has <b>16</b> sections similar to <b>7008</b>, with 10 bytes per section. Similarly to the ByteVU algorithm, each section will veil one byte of DRKj <b>7001</b> in a position, respective to the particular integer value generated by SRNG <b>7002</b>. For instance, the 1<sup>st </sup>byte of DRKj <b>7001</b> xh<b>1</b> occupies the 4<sup>th </sup>byte position in section <b>7008</b>, replacing r<b>1</b>,<b>4</b> byte. <figref idref="DRAWINGS">FIG. 7</figref> presents an exemplary case, where the 1<sup>st </sup>DRKj byte xh<b>1</b> has an 8-bit representation from the most significant bit xh<b>1</b>,<b>8</b> to the least significant bit xh<b>1</b>,<b>1</b> <b>7009</b>, and chosen as 01011101 in <figref idref="DRAWINGS">FIG. 7</figref> <b>7009</b>. SRNG <b>7002</b> generated 16 sequential integers 4, . . . , while SDBPS <b>7006</b> generated a series of eight non-repeating digits 3, 1, 8, 5, 4, 2, 7, and 6 for the first integer 4 <b>7011</b>, and a similar series of digits for the rest of the integers. Eventually, all bits of the 1<sup>st </sup>DRKj <b>7001</b> byte in <b>7008</b> occupy new bit positions, consecutively specified in the SDBPS <b>7006</b> generated series of digits for the first integer 4. For a particular example in <figref idref="DRAWINGS">FIG. 7</figref> <b>7012</b>, it is 01011011. The same process <b>7013</b> of scrambling bits for each veiled byte of DRKj <b>7001</b> in conversion array <b>7007</b> is continued, until all bytes of DRKj are veiled, and all bit positions of each veiled byte are scrambled. Then, the entire conversion array <b>7007</b> is encrypted with DRKj-<b>1</b>, and the message is sent to client <b>3002</b>.</p>
<p id="p-0066" num="0065">At client <b>3002</b>, the encrypted conversion array is decrypted with DRKj-<b>1</b>, saved at client <b>3002</b>, from the previous server message (step <b>3011</b> in KEDIA, <figref idref="DRAWINGS">FIG. 3</figref>). Then the procedure, a reversed one as compared to that which is described above for the BBVU algorithm on server <b>3001</b> side, is applied. The user password (or the client host ID), saved at the client platform in step <b>3007</b> of the KEDIA algorithm (see <figref idref="DRAWINGS">FIG. 3</figref>), is supplied in a hashed form as a seed to Client Sequential Random Number Generator (SRNG) <b>7005</b> identical to the one on the server <b>3001</b> side. This password (or host ID) triggers SRNG <b>7005</b> to generate the same sequence of integers as on server <b>3001</b> side before 4, . . . . Client Sequential Reverse Bit Position Scrambler (SRBPS) <b>7003</b> generates the reversed series of digits for each integer, as compared to its server counterpart SDBPS <b>7006</b>. For instance, for the first integer 4, SRBPS <b>7003</b> generates the reversed series 2, 6, 1, 5, 4, 8, 7, and 3, which allows the logic placed on client side <b>3002</b> to restore bits in the original order for the 1<sup>st </sup>byte of DRKj-<b>2</b> means that the 2<sup>nd </sup>bit of the scrambled byte will become the least significant bit in the restored 1<sup>st </sup>DRKJ byte, and so on, until 3, the last digit in the series, is reached, indicating that the 3<sup>rd </sup>bit in the scrambled byte will become the most significant bit in the restored 1<sup>st </sup>byte. Meanwhile, integer 4 points to the 4<sup>th </sup>position in section <b>7008</b> of conversion array <b>7007</b>, where the 1<sup>st </sup>DRKj byte has been veiled. The same procedure continues, until all byes of DRKj <b>7001</b> and their respective bits are returned to their original positions. This completes the reassembling procedure of the BBVU algorithm to restore DRKJ at client <b>3002</b>.</p>
<p id="p-0067" num="0066">At this time it is important to note that the ByteVU, BitVU, and BBVU algorithms, disclosed above, require assessment of security of these algorithms against possible computer processing attacks now and in the future. Table 1 below presents a summary of this assessment. SRNG <b>5002</b>, <b>5003</b> (<figref idref="DRAWINGS">FIG. 5</figref>), <b>600</b>, <b>6003</b> (<figref idref="DRAWINGS">FIG. 6</figref>), and <b>7002</b>, <b>7003</b> (<figref idref="DRAWINGS">FIG. 7</figref>) generate integers pseudo-randomly, as well as SDBPS <b>7006</b> and SRBPS <b>7003</b> (<figref idref="DRAWINGS">FIG. 7</figref>). Hence, probabilities of veiling each byte and bit inside a Conversion Array (CA) for each algorithm can be viewed as independent ones. Best microprocessors achieved ˜1 GHz clock rate barrier by the beginning of the 21<sup>st </sup>century. Previously, forecasting allowed for at least 25-35 years, until the clock rate would reach ˜(100-1000) GHz. Thus, currently available ˜1E10 instructions per second could reach ˜(1E12-1E13) instructions per second in a distant future, (assuming microprocessor RISC pipelined architecture with up to 10 stages per cycle). A very conservative assumption is made that the attacking computers have 100% efficiency of their CPU utilization during an attack. In other words, testing each possible combination of all bytes, bits, or the combination thereof, of a veiled message in CA will consume only one microprocessor instruction.</p>
<p id="p-0068" num="0067">Column <b>1001</b> in Table 1 presents particular geometries of CA chosen in each algorithm for the assessment. Column <b>1002</b> gives the bit size of each algorithm CA for every geometry selected in <b>1001</b>. Column <b>1003</b> presents the total number of pseudo-random integers generated by SRNG of each algorithm with respect to the geometries chosen in <b>1001</b>. Column <b>1004</b> introduces probability models for each algorithm with respect to the geometries of CA chosen in <b>1001</b>. Every position in <b>1004</b> gives probability to estimate the entire combination of veiled bytes, bits, or the combination thereof, for each algorithm, under given geometry of CA in <b>1001</b>. Column <b>1005</b> presents for each CA its transit time, given the slowest standard modem of 28.8 kbps (kilobits per second) of contemporary networks (for example, the Internet). Column <b>1006</b> presents assessed time, required for a brute force attack now and in a distant future, for each algorithm and their respective geometries of CA chosen in <b>1001</b>. Column <b>1007</b> presents an approximate time for one advanced microprocessor (1 GHZ/100 GHz) instruction now, and in a distant future.</p>
<p id="p-0069" num="0068">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="42pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="28pt" align="center"/>
<colspec colname="4" colwidth="49pt" align="center"/>
<colspec colname="5" colwidth="42pt" align="center"/>
<colspec colname="6" colwidth="56pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="7" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="7" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>1001</entry>
<entry>1002</entry>
<entry/>
<entry>1004</entry>
<entry>1005</entry>
<entry>1006</entry>
<entry>1007</entry>
</row>
<row>
<entry/>
<entry>↓</entry>
<entry>↓</entry>
<entry>1003</entry>
<entry>↓</entry>
<entry>↓</entry>
<entry>↓</entry>
<entry>↓</entry>
</row>
<row>
<entry/>
<entry>CA Size</entry>
<entry>CA</entry>
<entry>↓</entry>
<entry>Prob-</entry>
<entry>CA Transit</entry>
<entry>Brute Force</entry>
<entry>CPU One</entry>
</row>
<row>
<entry/>
<entry>#of</entry>
<entry>Total</entry>
<entry>SRNG</entry>
<entry>ability</entry>
<entry>Time</entry>
<entry>Attack</entry>
<entry>Instruction</entry>
</row>
<row>
<entry/>
<entry>rows vs.</entry>
<entry>Bit</entry>
<entry>total</entry>
<entry>Model</entry>
<entry>modem</entry>
<entry>Time</entry>
<entry>Time, (S)</entry>
</row>
<row>
<entry/>
<entry># of BB</entry>
<entry>Size</entry>
<entry>#</entry>
<entry>for CA</entry>
<entry>28.8 kbps</entry>
<entry>Now/Future</entry>
<entry>Now/Future</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="7" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="28pt" align="center"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="center"/>
<colspec colname="5" colwidth="49pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="center"/>
<colspec colname="7" colwidth="56pt" align="center"/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>ByteVU</entry>
<entry>16r/16 bytes</entry>
<entry>2048 bits</entry>
<entry> 16</entry>
<entry>(1/16){circumflex over ( )}16</entry>
<entry>71 milliSec.</entry>
<entry>58 y/7 months</entry>
<entry>1E-10/1E-12</entry>
</row>
<row>
<entry>BitVU</entry>
<entry>128r/2 bits</entry>
<entry> 256 bits</entry>
<entry>128</entry>
<entry>(1/2){circumflex over ( )}128</entry>
<entry> 9 milliSec.</entry>
<entry>1E21 y/1E19 y</entry>
<entry>1E-10/1E-12</entry>
</row>
<row>
<entry>BBVU</entry>
<entry>16r/2 bytes</entry>
<entry> 256 bits</entry>
<entry>144</entry>
<entry>((.5)(1/8){circumflex over ( )}8){circumflex over ( )}16</entry>
<entry> 9 milliSec.</entry>
<entry>8E102y/8E100y</entry>
<entry>1E-10/1E-12</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0070" num="0069">Summarizing the assessment results in Table 1, it can be noted that each of ByteVU, BitVU, and BBVU algorithms give extremely high security now and in a distant future for the respective geometries selected in <b>1001</b>. At the same time, one CA message transit times <b>1005</b>, even for the slowest standard modems, are reasonable enough for the disclosed algorithms practical utilization in the MEDIA protocol. Certainly, geometry parameters in <b>1001</b> can be regarded as security parameters of the MEDIA protocol, and these parameter changes could allow for security trade-offs vs. cost (CPU power of client/server or authenticator/peer platforms, and the network throughput). Also, replacing slow modems by contemporary high-speed network connections, like DSL, would significantly reduce message transit times in <b>1005</b>.</p>
<p id="p-0071" num="0070">The combination of the KEDIA algorithm and any one of ByteVU, BitVU, and BBVU algorithms comprise the fourth security tier, which makes the encrypted authentication protocol highly secure against online and offline attacks. The algorithms described above allow for the encryption key management security to be scaled with CPU and network throughput resources. During the encryption key distribution stage over communication lines, shared secrets never leave the server, or the client. However, they are repeatedly employed for each iterative message encryption/decryption by KEDIA and any of ByteVU, BitVU, or BBVU algorithms on the server and the client platform as well. Only when the client and the server eventually have in their possession the Final Secret Key (FSK) satisfying the required security level, then the server and the client will perform mutual authentication in a way that neither of authentication credentials enter communication lines in either form. The authentication session is denied, provided the parties' mutual authentication is not successfully completed. This part of the encrypted authentication protocol completes the client/server mutual authentication. At the same time, it is the final fifth security tier of the encrypted authentication protocol.</p>
<p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref> illustrate the server and the client side of the Message Encrypt/Decrypt Iterative Authentication (MEDIA) protocol according to the present invention. Without sacrificing any generality limitations of the MEDIA protocol, the exemplary case presented in <figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref> is assuming HTTP communication protocol (RFC <b>2068</b> Hypertext Transfer Protocol—HTTP/1.1 January 1997), Java applet/servlet multi-threading object-oriented communication technology, and a standard Web server technology. However, the MEDIA protocol can be integrated into any other network communication protocol, and enabled with various object-oriented technologies. The ByteVU algorithm has been included into the MEDIA protocol in <figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref>, though any of BitVU and BBVU algorithms could serve there equally well.</p>
<p id="p-0073" num="0072">Messages sent to the client and received at the server are numbered in <b>8000</b>. Key functional message destinations on the server side are in <b>8001</b>, and on the client side they are in <b>8016</b>. For each message received at the server, its content description is in <b>8003</b>, whereas for each message received at the client, its content description is in <b>8014</b>. Similarly, for each message sent from the server, its content description is in <b>8002</b>, whereas for each message sent from the client, its content description is in <b>8015</b>. The choice of any one of ByteVU, BitVU, or BBVU algorithms to be used in the MEDIA protocol and the parameters of the respective conversion array are in <b>8006</b> for the server side, and in <b>8010</b> for the client side. Seeds, having been used to trigger SRNG (Sequential Random Number Generator), are in <b>8007</b> for the server side, and they are in <b>8009</b> for the client side. Which direction a particular MEDIA message is sent towards, is in <b>8008</b>. The ByteVU algorithm conversion array parameters, chosen in <figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref> (10 sections with 25 bytes size of each), give extremely high security protection against online and offline intruding attacks, even for one MEDIA message as it was shown above. Therefore, it is practically justifiable to reduce iterations in the KEDIA algorithm by limiting DRKn in <figref idref="DRAWINGS">FIG. 3</figref> to DRK <b>2</b> only. It saves client/server platforms CPU and network resources, while keeping a very high security level.</p>
<p id="p-0074" num="0073">It is assumed, without sacrificing any generality of the MEDIA protocol, that for this particular embodiment of the MEDIA protocol (<figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref>), the client is a user at the client platform. The communication session begins with the user's request (message <b>1</b>) to the server to reach a protected network resource, for example, a URL (Universal Resource Locator), a protected link, a protected file, a protected directory, or another protected network resource. This message initiates the MEDIA protocol on the server side. The server replies to the user (message <b>2</b>), sending SRK <b>1011</b> (see <figref idref="DRAWINGS">FIG. 1</figref>) over the communication line (the Internet) in a compiled class form, which prevents any easy key reuse or reengineering, if it is intercepted by an intruder. The user enters into the GUI (Graphical User Interface, designed into the applet and sent from the server to the client in message <b>2</b> along with the SRK) the user name, the user password, and the server password. The passwords stay stored at the client, while the user name gets encrypted with the SRK and sent to the server in message <b>3</b>.</p>
<p id="p-0075" num="0074">The server (logic on the server side in this exemplary case could be implemented in the Java servlet technology) replies in message <b>4</b> with DRK <b>1</b> <b>2012</b> (<figref idref="DRAWINGS">FIG. 2</figref>) bytes veiled with the ByteVU algorithm, triggered by the server, supplying the hashed password of the assumed user as a seed. The resulting ByteVU conversion array is encrypted with the SRK and sent to the client. The client, having known the SRK and the user password, entered into the GUI in the previous message <b>3</b>, decrypts the conversion array and reassembles DRK <b>1</b> bytes. In message <b>5</b>, from the client to the server, hashed DRK <b>1</b> bytes are veiled with ByteVU algorithm, triggered by the user password, stored at the client earlier in step <b>3</b> (<figref idref="DRAWINGS">FIG. 8B</figref>), and converted to its hash equivalent. Then, the conversion array is encrypted with DRK <b>1</b> and sent to the server, which decrypts the conversion array with DRK <b>1</b>, and triggers ByteVU with the hashed password of the assumed user, taken from the database attached to the server. If the hashed DRK <b>1</b> is correct, reassembled in this way, it is actually the authentication signal from the client to the server, as nobody except the client knows the user password used to trigger the ByteVU algorithm when receiving message <b>4</b>, and sending message <b>5</b>.</p>
<p id="p-0076" num="0075">If DRK <b>1</b> is incorrect, the MEDIA protocol is terminated by the server sending a “no” authentication message (or an error message: “user password is incorrect”) to the client, encrypted with SRK. Otherwise, the server sends to the client message <b>6</b> containing DRK <b>2</b>, which bytes are disassembled by the ByteVU algorithm, triggered by the user hashed password, used as a seed for SRNG <b>5002</b> (<figref idref="DRAWINGS">FIG. 5</figref>). Then, the conversion array is encrypted with DRK <b>1</b> and sent to the client, where it is decrypted with DRK <b>1</b> stored at the client from the previous message <b>5</b>, and DRK <b>2</b> bytes get reassembled by the ByteVU algorithm, triggered by the user password, stored at the client earlier in step <b>3</b> (<figref idref="DRAWINGS">FIG. 8B</figref>). The client replies to the server with message <b>7</b>, sending to the server hashed DRK <b>2</b>, which bytes are veiled by the ByteVU algorithm, triggered by the user password, stored at the client in the previous message <b>3</b>, and converted to its hash equivalent. The server decrypts message <b>7</b> from the client with DRK <b>2</b>, and reassembles the hashed DRK <b>2</b> bytes with the ByteVU algorithm, triggered by the user password, taken from the attached to the server database, and converted to its hash equivalent. If DRK <b>2</b> is correct, the server sends to the client message <b>8</b> with DRK <b>2</b>, which bytes are disassembled with the ByteVU algorithm, triggered by the server password. Otherwise, if DRK <b>2</b> is not correct, the MEDIA protocol is terminated. The conversion array of the ByteVU algorithm in message <b>8</b> is encrypted with DRK <b>2</b> and sent to the client.</p>
<p id="p-0077" num="0076">The client, receiving message <b>8</b> from the server, decrypts it with DRK <b>2</b>, and reassembles the hashed DRK <b>2</b> bytes with the ByteVU algorithm, triggered by the server password, stored on the client side in message <b>3</b>. Then, the client compares the decrypted and reassembled DRK <b>2</b> with DRK <b>2</b> from the previous message <b>6</b>. If they are the same, it is viewed by the client as the authentication signal from the server, because only the client and server share the server password. Hence, it was the only server, which could send the last message <b>8</b> to the client. Now, as the trust is established by the client to the server, the client sends to the server message <b>9</b> with hashed DRK <b>2</b>, which bytes are disassembled with the ByteVU algorithm, triggered by the server password, stored on the client side in message <b>3</b>, and converted to its hash equivalent. Eventually, the conversion array of the ByteVU algorithm is encrypted with DRK <b>2</b> and sent to the server. The server, having received message <b>9</b> from the client, decrypts it with DRK <b>2</b>, and reassembles the hashed DRK <b>2</b> bytes with the ByteVU algorithm, triggered by the hashed server password. If DRK <b>2</b> is correct, it is viewed by the server as a second authentication factor from the client (the client confirmed the server password), in addition to the first factor, having been checked in the message <b>6</b> from the client (the client confirmed the user password).</p>
<p id="p-0078" num="0077">This completes the mutual authentication of the client/server pair according to the MEDIA protocol, and the server is now ready to make an authentication decision. In the end, the server sends to the client message <b>10</b>, which has either a “go” authentication signal, assuming DRK <b>2</b> in message <b>9</b> from the client was correct, or an error message: “the server password is incorrect”, assuming DRK <b>2</b> in message <b>9</b> from the client was incorrect. Each signal byte is disassembled with the ByteVU algorithm, triggered by the user password from the database, attached to the server, and then the conversion array of the ByteVU algorithm is encrypted with DRK <b>1</b> and sent to the client in message <b>10</b>. Having received the message <b>10</b>, the client decrypts it with DRK <b>1</b>, stored at the client platform during message <b>4</b>, and reassembles the signal bytes with the ByteVU algorithm, triggered by the user password, stored at the client side in message <b>3</b>.</p>
<p id="p-0079" num="0078">This effectively completes the entire MEDIA protocol of the client/server communication session as presented in <figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref>. As one can see, authentication credentials (the user password and the server password in this particular embodiment) have never passed through communication lines in any form. Also, the client/server mutual authentication has been completed within the MEDIA protocol, as well as the exchange of FSK (Final Secret Key, which is DRK <b>2</b> in this particular embodiment) having been performed within the client/server pair. The server password and the user password enable secure mutual authentication, according to the MEDIA protocol architecture. At the same time, they are both playing a role of a strong two-factor authentication of the client at the server platform.</p>
<p id="p-0080" num="0079"><figref idref="DRAWINGS">FIG. 9</figref> illustrates the Graphical User Interface (GUI) enabling client/server mutual authentication at the client platform according to the MEDIA protocol, and a graphical illustration of the distributed protected network resources, including the authentication server, and the user base the MEDIA protocol is used for, according to the present invention. This GUI has already been mentioned or assumed along with the preferred embodiments of this invention, described herein, for instance, in <figref idref="DRAWINGS">FIG. 3</figref> step <b>3</b> <b>3007</b>, <figref idref="DRAWINGS">FIG. 8B</figref> messages <b>3</b>, <b>5</b>A, and <b>10</b> <b>8016</b>. The user on a client platform <b>9015</b>, or <b>9021</b> in <figref idref="DRAWINGS">FIG. 9</figref> is trying to reach a protected network destination <b>9020</b>. It invokes the MEDIA protocol through an interactive communication session between web server <b>9018</b>, compute server <b>9024</b>, program logic <b>9017</b>, and security and account databases <b>9022</b> and <b>9023</b>, all located on the server side, with GUI <b>9003</b> located on the client side. There are different means to implement this scheme, for example, thick or thin software client, permanently placed on a client platform, or a Java applet, loading GUI <b>9003</b>, and its respective client-side logic into a browser. The latter case in the preferred embodiment in <figref idref="DRAWINGS">FIG. 9</figref> is assumed here. Also, the network, over which the communication session is established, could be either only LAN (Local Area Network), or WAN (Wide Area Network), or a combination of LAN and WAN together. In the particular embodiment in <figref idref="DRAWINGS">FIG. 9</figref>, Internet <b>9019</b> is assumed as a preferred embodiment, enabling client/server dialogue through communication links <b>9016</b>.</p>
<p id="p-0081" num="0080">GUI <b>9003</b> has several operation modes <b>9009</b>: login session mode <b>9010</b>, account set-up mode <b>9011</b>, user password reset mode <b>9012</b>, and server password reset mode <b>9013</b>. Login session <b>9010</b> is the default operation mode. The user enters the user name in window <b>9004</b>, the user password in window <b>9005</b>, and the server password in window <b>9006</b>. The user has a choice to enter alphanumeric characters, or their echo dots for security reasons by toggling button <b>9014</b>. The session elapsed time clock <b>9007</b> visualizes this value to the user, and signals communication session termination once the session time has expired. After the authentication credentials are all entered into <b>9004</b>, <b>9005</b>, and <b>9006</b>, the client indicates login button <b>9008</b>, which completes step <b>3</b> <b>3007</b> in <figref idref="DRAWINGS">FIG. 3</figref>, or message <b>3</b> in <figref idref="DRAWINGS">FIG. 8B</figref>. Then the other steps of the MEDIA protocol are initiated. Stoplight <b>9001</b> turns yellow, when button <b>9008</b> is indicated, signaling the MEDIA protocol is in progress for the first authentication factor (the user password) examination. Message <b>8</b> in <figref idref="DRAWINGS">FIG. 8B</figref>, having arrived at the client, initiates stoplight <b>9001</b> to change color from red at the beginning of the session to green, once it is checked by the client placed logic that DRK <b>2</b> delivered in the message <b>8</b> is identical to DRK <b>2</b>, delivered in message <b>6</b>.</p>
<p id="p-0082" num="0081">Similarly, stoplight <b>9002</b> turns from red to the yellow color right after stoplight <b>9001</b> turned green, signaling that the MEDIA protocol is in progress for the second authentication factor (the server password) examination. Indeed, once the client received message <b>10</b> in <figref idref="DRAWINGS">FIG. 8B</figref>, stoplight <b>9002</b> turns green, signaling successful client/server mutual authentication, FSK exchange, and completion of the MEDIA protocol. If the client received message <b>5</b>A from the server (<figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref>), stoplight <b>9001</b> turns red, back from the yellow color, and the error message “the user password is incorrect” appears in system window <b>9014</b>, signaling the MEDIA protocol termination. Also, if the client received authentication signal “no” in message <b>10</b> from the server (<figref idref="DRAWINGS">FIG. 8A</figref> and <figref idref="DRAWINGS">FIG. 8B</figref>), stoplight <b>9002</b> turns red, back from the yellow color, and the error message “the server password is incorrect” appears in system window <b>9014</b>, signaling the MEDIA protocol termination.</p>
<p id="p-0083" num="0082">Though, a server password unique to each user remains the preferred embodiment of this invention, various business environments, or enterprise/organization/agency IT resource configurations may require some modifications to the MEDIA protocol. The exemplary case would be when users of all computer platforms logged-in from the same server in an isolated LAN environment (or the same cluster of servers). Then the system administrator may preset the same server password at all platforms, during each platform configuration and setup on the network. This would require any user to enter only the user name, and the user password in GUI <b>9003</b> inside an enterprise, organization, or agency. Alternatively, messages <b>8</b> and <b>9</b> in the MEDIA protocol (<figref idref="DRAWINGS">FIG. 9</figref>) could be eliminated entirely for the above case, which effectively excludes the need for server password to perform a user (a client platform) authentication and a session key exchange. However, any connection with servers and users outside the particular LAN perimeter would probably require the reinstatement of server passwords for security reasons.</p>
<p id="p-0084" num="0083">While the present invention is disclosed by reference to the preferred embodiments and examples detailed above, it is to be understood that these examples are intended in an illustrative rather than in a limiting sense. It is contemplated that modifications and combinations will readily occur to those skilled in the art, which modifications and combinations will be within the spirit of the invention and the scope of the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for mutual authentication of a first station and a second station, comprising:
<claim-text>providing a particular data random key at the first station, disassembling and veiling the particular data random key by forming a first conversion array seeded by a shared secret and then encrypting the first conversion array to produce a first encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>sending a first message to the second station including the first encrypted data set key, where the second station decrypts first encrypted data set and unveils and reassembles said particular data random key using the shared secret, and where the second station disassembles and veils a version of the particular data random key by forming a second conversion array seeded by the shared secret and then encrypts the second conversion array to produce a second encrypted data set, and sends a second message to the first station carrying the second encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>receiving the second message, and decrypting the second encrypted data set, and reassembling and unveiling the version of the particular data random key at the first station using the shared secret;</claim-text>
<claim-text>determining at the first station if the version of the particular data random key matches an expected version the particular data random key, and if so providing an additional particular data random key at the first station, disassembling and veiling the additional particular data random key by forming a third conversion array seeded by the shared secret and then encrypting the third conversion array to produce a third encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>sending a third message to the second station including the third encrypted data set, where the second station decrypts the third encrypted data set and reassembles and unveils said additional particular data random key using the shared secret, and where the second station disassembles and veils a version of the additional particular data random key by forming a fourth conversion array seeded by the shared secret and then encrypts the fourth conversion array to produce a fourth encrypted data set, and sends a fourth message to the first station carrying the fourth encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>receiving the fourth message, and decrypting the fourth encrypted data set and reassembling and unveiling the version of the additional particular data random key at the first station using the shared secret;</claim-text>
<claim-text>determining at the first station if the version of the additional data random key matches an expected version of the additional data random key, and if so disassembling and veiling the additional particular data random key by forming a fifth conversion array seeded by an additional shared secret and then encrypting the fifth conversion array to produce a fifth encrypted data set, where access to the additional shared secret indicates authenticity of the first station; and</claim-text>
<claim-text>sending a fifth message to the second station including the fifth encrypted data set, where the second station decrypts the fifth encrypted data set, reassembles and unveils said additional particular data random key using the additional shared secret, and determines at the second station if a version of the additional data random key matches an expected version of the additional data random key.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, and including
<claim-text>generating one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions, and</claim-text>
<claim-text>placing a byte of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Z bit positions in an order, and including
<claim-text>generating one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Z and identifying one of said Z bit positions, and</claim-text>
<claim-text>placing a bit of said random key in each of said X sections at the one of said Z bit positions identified by the corresponding one of said X values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, each of said Y byte positions including B bit positions in an order, and including
<claim-text>generating one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a first pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions,</claim-text>
<claim-text>using a random number generator seeded by said shared secret to produce a second pseudorandom number having B values corresponding with respective bits in a byte of said random key, the B values each being between 1 and B and identifying one of said B bit positions,</claim-text>
<claim-text>placing a byte, including B bits, of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values, and</claim-text>
<claim-text>mapping the B bits of said byte of said random key to said B bit positions identified by the corresponding one of said B values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, each of said Y byte positions including B bit positions in an order, and including
<claim-text>generating one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a first pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions,</claim-text>
<claim-text>using a random number generator to produce a second pseudorandom number having B values corresponding with respective bits in a byte of said random key, the B values each being between 1 and B and identifying one of said B bit positions,</claim-text>
<claim-text>placing a byte, including B bits, of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values, and</claim-text>
<claim-text>mapping the B bits of said byte of said random key to said B bit positions identified by the corresponding one of said B values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, including presenting a use interface to the second station from the first station carrying parameters of said first and second conversion arrays.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, including executing an interactive exchange of messages to deliver the particular data random key from the first station to the second station.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A data processing apparatus, comprising:
<claim-text>a processor, a communication interface adapted for connection to a communication medium, and memory storing instructions for execution by the data processor, the instructions including</claim-text>
<claim-text>logic to provide a particular data random key at the first station and to disassemble and veil the particular data random key by forming a first conversion array seeded by a shared secret and then to encrypt the first conversion array to produce a first encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>logic to send a first message to the second station including the first encrypted data set, where the second station decrypts and unveils the first encrypted data set using the shared secret, and where the second station disassembles and veils a version of the particular data random key by forming a second conversion array seeded by the shared secret and then encrypts the second conversion array to produce a second encrypted data set, and sends a second message to the first station carrying the second encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>logic to receive the second message, and to decrypt and unveil the version of the particular data random key at the first station using the shared secret;</claim-text>
<claim-text>logic to determine at the first station if the version of the particular data random key matches an expected version the particular data random key, and if so provide an additional particular data random key at the first station, disassemble and veil the additional particular data random key by forming a third conversion array seeded by the shared secret and then to encrypt the third conversion array to produce a third encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>logic to send a third message to the second station including the third encrypted data set, where the second station decrypts the third encrypted data set and reassembles and unveils the additional particular data random key using the shared secret, and where the second station disassembles and veils a version of the additional particular data random key by forming a fourth conversion array seeded by the shared secret and then encrypts the fourth conversion array to produce a fourth encrypted data set, and sends a fourth message to the first station carrying the fourth encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>logic to receive the fourth message, and decrypt the fourth encrypted data set and to reassemble and unveil the version of the additional particular data random key at the first station using the shared secret;</claim-text>
<claim-text>logic to determine at the first station if the version of the additional data random key matches an expected version of the additional data random key, and if so to disassemble and veil the additional particular data random key by forming a fifth conversion array seeded by an additional shared secret and then encrypt the fifth conversion array to produce a fifth encrypted data set, where access to the additional shared secret indicates authenticity of the first station; and</claim-text>
<claim-text>logic to send a fifth message to the second station including the fifth encrypted data set, where the second station can decrypt the fifth encrypted data set, and can reassemble and unveil said additional particular data random key using the additional shared secret, in order to determine at the second station if a version of the additional data random key matches an expected version of the additional data random key.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The apparatus of <claim-ref idref="CLM-00008">claim 8</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, and including logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions, and</claim-text>
<claim-text>to place a byte of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The apparatus of <claim-ref idref="CLM-00008">claim 8</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Z bit positions in an order, and including logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Z and identifying one of said Z bit positions, and</claim-text>
<claim-text>to place a bit of said random key in each of said X sections at the one of said Z bit positions identified by the corresponding one of said X values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The apparatus of <claim-ref idref="CLM-00008">claim 8</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, each of said Y byte positions including B bit positions in an order, and including logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a first pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions,</claim-text>
<claim-text>use a random number generator seeded by said shared secret to produce a second pseudorandom number having B values corresponding with respective bits in a byte of said random key, the B values each being between 1 and B and identifying one of said B bit positions,</claim-text>
<claim-text>place a byte, including B bits, of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values, and</claim-text>
<claim-text>map the B bits of said byte of said random key to said B bit positions identified by the corresponding one of said B values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The apparatus of <claim-ref idref="CLM-00008">claim 8</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, each of said Y byte positions including B bit positions in an order, and including logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a first pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions,</claim-text>
<claim-text>use a random number generator to produce a second pseudorandom number having B values corresponding with respective bits in a byte of said random key, the B values each being between 1 and B and identifying one of said B bit positions,</claim-text>
<claim-text>place a byte, including B bits, of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values, and</claim-text>
<claim-text>map the B bits of said byte of said random key to said B bit positions identified by the corresponding one of said B values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The apparatus of <claim-ref idref="CLM-00008">claim 8</claim-ref>, including logic to present a user interface to the second station from the first station carrying parameters of said first and second conversion arrays.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The apparatus of <claim-ref idref="CLM-00008">claim 8</claim-ref>, including logic to execute an interactive exchange of messages to deliver the particular data random key from the first station to the second station.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. An article, comprising:
<claim-text>machine readable data storage medium having computer program instructions stored therein for establishing a communication session on a communication medium between a first data processing station and a second data processing station having access to the communication medium, said instructions comprising</claim-text>
<claim-text>logic to provide a particular data random key at the first station and to disassemble and veil the particular data random key by forming a first conversion array seeded by a shared secret and then to encrypt the first conversion array to produce a first encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>logic to send a first message to the second station including the first encrypted data set, where the second station decrypts and unveils the first encrypted data set using the shared secret, and where the second station disassembles and veils a version of the particular data random key by forming a second conversion array seeded by the shared secret and then to encrypt the second conversion array to produce a second encrypted data set, and sends a second message to the first station carrying the second encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>logic to receive the second message, and to decrypt and unveil the version of the particular data random key at the first station using the shared secret;</claim-text>
<claim-text>logic to determine at the first station if the version of the particular data random key matches an expected version the particular data random key, and if so provide an additional particular data random key at the first station, disassemble and veil the additional particular data random key by forming a third conversion array seeded by the shared secret and then to encrypt the third conversion array to produce a third encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>logic to send a third message to the second station including the third encrypted data set, where the second station decrypts the third encrypted data set and reassembles and unveils the additional particular data random key using the shared secret, and where the second station disassembles and veils a version of the additional particular data random key by forming a fourth conversion array seeded by the shared secret and then encrypts the fourth conversion array to produce a fourth encrypted data set, and sends a fourth message to the first station carrying the fourth encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>logic to receive the fourth message, and decrypt the fourth encrypted data set and to reassemble and unveil the version of the additional particular data random key at the first station using the shared secret;</claim-text>
<claim-text>logic to determine at the first station if the version of the additional data random key matches an expected version of the additional data random key, and if so to disassemble and veil the additional particular data random key by forming a fifth conversion array seeded by an additional shared secret and then encrypt the fifth conversion array to produce a fifth encrypted data set, where access to the additional shared secret indicates authenticity of the first station; and</claim-text>
<claim-text>logic to send a fifth message to the second station including the fifth encrypted data set, where the second station can decrypt the fifth encrypted data set, and can reassemble and unveil said additional particular data random key using the additional shared secret, in order to determine at the second station if a version of the additional data random key matches an expected version of the additional data random key.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The article of <claim-ref idref="CLM-00015">claim 15</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, and the instructions include logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions, and</claim-text>
<claim-text>to place a byte of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The article of <claim-ref idref="CLM-00015">claim 15</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Z bit positions in an order, and the instructions include logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Z and identifying one of said Z bit positions, and</claim-text>
<claim-text>to place a bit of said random key in each of said X sections at the one of said Z bit positions identified by the corresponding one of said X values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The article of <claim-ref idref="CLM-00015">claim 15</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, each of said Y byte positions including B bit positions in an order, and the instructions include logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a first pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions,</claim-text>
<claim-text>use a random number generator seeded by said shared secret to produce a second pseudorandom number having B values corresponding with respective bits in a byte of said random key, the B values each being between 1 and B and identifying one of said B bit positions,</claim-text>
<claim-text>place a byte, including B bits, of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values, and</claim-text>
<claim-text>map the B bits of said byte of said random key to said B bit positions identified by the corresponding one of said B values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The article of <claim-ref idref="CLM-00015">claim 15</claim-ref>, where the one of the first and second conversion arrays comprises X sections, each of said X sections including Y byte positions in an order, each of said Y byte positions including B bit positions in an order, and the instructions include logic to
<claim-text>generate one of the first and second conversion arrays using a random number generator seeded by said shared secret to produce a first pseudorandom number having X values corresponding with respective sections of said X sections, the X values each being between 1 and Y and identifying one of said Y byte positions,</claim-text>
<claim-text>use a random number generator to produce a second pseudorandom number having B values corresponding with respective bits in a byte of said random key, the B values each being between 1 and B and identifying one of said B bit positions,</claim-text>
<claim-text>place a byte, including B bits, of said random key in each of said X sections at the one of said Y byte positions identified by the corresponding one of said X values, and</claim-text>
<claim-text>map the B bits of said byte of said random key to said B bit positions identified by the corresponding one of said B values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The article of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the instructions include logic to present a user interface to the second station from the first station carrying parameters of said first and second conversion arrays.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The article of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the instructions include logic to execute an interactive exchange of messages to deliver the particular data random key from the first station to the second station.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A method for mutual authentication of a first station and a second station, comprising:
<claim-text>providing a particular data random key at the first station, disassembling and veiling the particular data random key by forming a first conversion array seeded by a shared secret and then encrypting the first conversion array to produce a first encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>sending a first message to the second station including the first encrypted data set, where the second station decrypts first encrypted data set and unveils and reassembles said particular data random key using the shared secret;</claim-text>
<claim-text>receiving the first message at the second station and decrypting the first encrypted data set, and reassembling and unveiling the particular data random key at the second station; and</claim-text>
<claim-text>determining at the second station if the particular data random key matches an expected version the particular data random key, and if so and disassembling and veiling a version of the particular data random key by forming a second conversion array seeded by the shared secret and then encrypting the second conversion array to produce a second encrypted data set, and sending a second message to the first station carrying the second encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>receiving the second message at the first station, and decrypting the second encrypted data set, and reassembling and unveiling the version of the particular data random key at the first station using the shared secret;</claim-text>
<claim-text>determining at the first station if the version of the particular data random key matches an expected version the particular data random key, and if so providing an additional particular data random key at the first station, disassembling and veiling the additional particular data random key by forming a third conversion array seeded by the shared secret and then encrypting the third conversion array to produce a third encrypted data set, where access to the shared secret indicates authenticity of the first station;</claim-text>
<claim-text>sending a third message to the second station including the third encrypted data set;</claim-text>
<claim-text>receiving the third message at the second station and decrypting the third encrypted data set and unveiling and reassembling the additional particular data random key using the shared secret, and determining at the second station if the additional particular data random key matches an expected version the additional particular data random key, and if so disassembling and veiling a version of the additional particular data random key by forming a fourth conversion array seeded by the shared secret and then encrypting the fourth conversion array to produce a fourth encrypted data set;</claim-text>
<claim-text>sending a fourth message to the first station carrying the fourth encrypted data set, where access to the shared secret indicates authenticity of the second station;</claim-text>
<claim-text>receiving the fourth message, and decrypting the fourth encrypted data set and unveiling and reassembling the version of the additional particular data random key at the first station using the shared secret;</claim-text>
<claim-text>determining at the first station if the version of the additional data random key matches an expected version the additional data random key, and if so disassembling and veiling the additional particular data random key by forming a fifth conversion array seeded by an additional shared secret and then encrypting the fifth conversion array to produce a fifth encrypted data set, where access to the additional shared secret indicates authenticity of the first station;</claim-text>
<claim-text>sending a fifth message to the second station including the fifth encrypted data set;</claim-text>
<claim-text>receiving the fifth message at the second station, and decrypting the fifth encrypted data set, and unveiling and reassembling said additional particular data random key using the additional shared secret; and</claim-text>
<claim-text>determining at the second station if a version of the additional data random key matches an expected version of the additional data random key.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
