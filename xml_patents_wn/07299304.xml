<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299304-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299304</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>09989136</doc-number>
<date>20011120</date>
</document-id>
</application-reference>
<us-application-series-code>09</us-application-series-code>
<us-term-of-grant>
<us-term-extension>597</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>3</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>710 11</main-classification>
<further-classification>710  8</further-classification>
<further-classification>710 10</further-classification>
<further-classification>710 15</further-classification>
</classification-national>
<invention-title id="d0e53">Method and architecture to support interaction between a host computer and remote devices</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5636211</doc-number>
<kind>A</kind>
<name>Newlin et al.</name>
<date>19970600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370465</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6711630</doc-number>
<kind>B2</kind>
<name>Dubal et al.</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710  8</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2002/0078259</doc-number>
<kind>A1</kind>
<name>Wendorf et al.</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709328</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2003/0035074</doc-number>
<kind>A1</kind>
<name>Dubil et al.</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>348734</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2003/0046557</doc-number>
<kind>A1</kind>
<name>Miller et al.</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713186</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2003/0063608</doc-number>
<kind>A1</kind>
<name>Moonen</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370390</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2003/0117433</doc-number>
<kind>A1</kind>
<name>Milton et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345738</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2003/0163542</doc-number>
<kind>A1</kind>
<name>Bulthuis et al.</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709208</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00009">
<othercit>Richard, Gonden G., “Service Advisement and Discovery: Enabling Universal Device Cooperation”, IEEE Internet Computing, Sep.-Oct. 2000, all.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00010">
<othercit>“Universal Plug and Play Device Architecture”, 2001, ver. 1.0, pp. 1-53, Microsoft Corporation.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00011">
<othercit>“Understanding Universal Plug and Play”, Operating System, Microsoft Windows Me Millennium Edition, pp. 1-39.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>11</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>710  8</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>710 11</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>710 10</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>710 15</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345738</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709217</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709328</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370432</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370390</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>11</number-of-drawing-sheets>
<number-of-figures>13</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030101294</doc-number>
<kind>A1</kind>
<date>20030529</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Saint-Hilaire</last-name>
<first-name>Ylian</first-name>
<address>
<city>Hillsboro</city>
<state>OR</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Edwards</last-name>
<first-name>Jim W.</first-name>
<address>
<city>Portland</city>
<state>OR</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Blakely, Sokoloff, Taylor &amp; Zafman LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Intel Corporation</orgname>
<role>02</role>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Peyton</last-name>
<first-name>Tammara</first-name>
<department>2182</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and architecture for enabling interaction between a remote device and a host computer. A service provided by the remote device is discovered, and a description pertaining to the service is retrieved by the host computer. A network communication link is the established between the remote device and the host computer based on connection information provided by the description. Host-side and client-side software service modules are run on the host and remote devices to enable interaction between the devices using a service protocol that is specific to the service. Various service protocols are provided, including a display service protocol and an input service protocol. Using commands provided by each protocol, the host computer is enabled to control the service remotely by pushing data and appropriate commands to the remote device, whereupon these commands are processed by the client-side service module to perform service operations that employ the sent data.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="180.85mm" wi="159.94mm" file="US07299304-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="264.16mm" wi="206.93mm" file="US07299304-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="210.99mm" wi="177.21mm" file="US07299304-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="212.68mm" wi="172.64mm" file="US07299304-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="229.11mm" wi="192.70mm" file="US07299304-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="214.97mm" wi="170.43mm" file="US07299304-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="168.49mm" wi="199.90mm" file="US07299304-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="255.10mm" wi="196.00mm" file="US07299304-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="253.49mm" wi="186.01mm" file="US07299304-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="259.50mm" wi="194.06mm" file="US07299304-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="250.70mm" wi="188.64mm" file="US07299304-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="187.20mm" wi="171.20mm" file="US07299304-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention concerns interaction with remote devices in general, and a method and system for performing remote interaction with low-resource devices, including display, playback and synchronization of multimedia content and receiving input from such devices.</p>
<p id="p-0004" num="0003">2. Background Information</p>
<p id="p-0005" num="0004">Today, there are several software tools that enable users to interact with a host computer from a remote location through software products running on both a remote computer and the host computer. These software products generally fall under the category of “remote control” software, and include such products as PC Anywhere, Carbon Copy, Windows Terminal Server, and RDP (remote desktop protocol) for Microsoft Windows operating system environments, and X-Windows for UNIX and LINUX environments.</p>
<p id="p-0006" num="0005">As shown in <figref idref="DRAWINGS">FIG. 1</figref>, these software products typically include a set of client-side software components <b>10</b> running on a remote computer <b>12</b> that interact with host-side software components <b>14</b> running on a host computer <b>16</b> via a communication link over a network <b>18</b>. Notably, the client-side software components require both an operating system (OS) <b>20</b> and computer hardware resources components to enable the operating system to run, such as a high speed CPU <b>22</b> and memory <b>24</b>. As a result, remote computer <b>12</b> requires both hardware and software (i.e., the OS) components that are fairly expensive. Furthermore, much of the hardware and software components are duplicative when considering that similar hardware and OS software is required for host computer <b>16</b>.</p>
<p id="p-0007" num="0006">Recent advancements have also lead to the availability of standalone devices that are used for displaying and/or generating multimedia content. For example, digital picture frames are used to display one or more digital pictures that are stored on a memory media card; in order to change the pictures, the memory media card needs to be changed. Another common stand-alone device is the set-top box, which enables users to receive various multimedia content via a television network (e.g., cable or satellite network), and many models further enable users to access the Internet via a dial-up or cable link.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0008" num="0007">The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same becomes better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic diagram illustrating a conventional architecture that enables a host computer to be accessed via a remote computer;</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic diagram of an exemplary architecture that enables a host or “extended” PC to interact with various remote devices in accordance with the present invention;</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic diagram illustrating exemplary host-side and client-side software components to enable an extended PC to interact with a remote device;</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating operations that are performed to enable interaction between a host computer and a remote device;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 5</figref> is a schematic diagram illustrating a plurality of Universal Plug and Play (UPnP)-enabled devices, embedded devices, services, and control points for explaining a typical UPnP environment</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 6</figref> is a block schematic diagram illustrating UPnP device and service advertisement and control point search mechanisms;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 7</figref> comprises a set of three tables presenting tabular information pertaining to discovery messages broadcast during a UPnP discovery step;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 8</figref> is a block schematic diagram illustrating how description information is retrieved during a UPnP description step;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 9</figref> is a schematic block diagram illustrating an exemplary architecture in accordance with the invention that enables a host computer to display content on a remote device;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 10</figref> is a schematic block diagram illustrating an exemplary architecture in accordance with the invention that enables a host computer to send audio content to a remote device and have the audio content played back by the remote device;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 11</figref> is a schematic block diagram illustrating an exemplary architecture in accordance with the invention that enables various input devices operatively coupled to a remote device to provide input to a host computer;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 12</figref> is a schematic block diagram illustrating an exemplary architecture corresponding to a PC/CE adapter that enables an extended PC to push display and audio content to devices connected to the PC/CE adapter; and</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 13</figref> is a schematic diagram illustrating a personal computer that may be used for an extended PC in accordance with the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0003" level="1">DETAILED DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS</heading>
<p id="p-0022" num="0021">A system and method for displaying interacting with remote devices via an extended PC host is described in detail herein. In the following description, numerous specific details are provided, such as exemplary service protocols and system architectures, to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, etc. In other instances, well-known structures or operations are not shown or described in detail to avoid obscuring aspects of various embodiments of the invention.</p>
<p id="p-0023" num="0022">Reference throughout this specification to “one embodiment” or “an embodiment” means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases “in one embodiment” or “in an embodiment” in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.</p>
<p id="p-0024" num="0023">The present invention provides a mechanism that enables interaction between a low-cost networked device (i.e., the remote device) and an “extended” personal computer, wherein a majority of the software and hardware components used to enable the interaction are provided by the extended PC, and the remote device requires limited hardware that supports “lightweight” software service components. The extended PC, which is also referred to as a “host” PC herein, is termed “extended” because it extends the reach of a PC in a home environment.</p>
<p id="p-0025" num="0024">As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the present invention enables interaction between a plurality of remote devices, including digital picture frames <b>30</b>, electronic game boards <b>32</b>, digital network tables <b>34</b> and television adapters <b>36</b>, and an “extended” personal computer (PC) <b>38</b> (also referred to as the “host” or “host computer”) via a network <b>40</b>. In addition to the devices shown herein, the remote devices may include any device capable of hosting a network connection, including information terminals and kitchen management devices. Typically, network <b>40</b> may comprise a wired or wireless network, such as networks based on the 802.11a, 802.11b, HPNA, Ethernet, HomeRF, HomePlug, IEEE 1394 (Firewire), etc, standards, or hybrid networks that use two or more of these network standards. Generally, the interactions between a remote device and an extended PC are enabled by host-side software components <b>42</b> running on extended PC <b>38</b> and a set of software service components running on the remote device. Exemplary software services components are enabled, in part, by Universal Plug and Play (UPnP) modules <b>44</b>, and include sound service modules <b>46</b>, display service modules <b>48</b>, input service modules <b>50</b> and video service modules <b>52</b>.</p>
<p id="p-0026" num="0025">An exemplary software architecture that facilitates interaction with a digital network tablet is shown in <figref idref="DRAWINGS">FIG. 3</figref>. The architecture includes host-side software components <b>54</b> that interact with client-side components <b>56</b>. The host-side software components include a picture application <b>58</b>, a jukebox application <b>60</b>, a UPnP device abstraction layer <b>62</b>, a UPnP module <b>64</b>, a sound module <b>66</b>, an input module <b>68</b>, a display module <b>70</b>, and a network interface module <b>72</b>. The client-side software services include a UPnP module <b>40</b>, an input service module <b>50</b>, a sound service module <b>46</b>, and display service module <b>48</b>.</p>
<p id="p-0027" num="0026">A flowchart corresponding to a general high-level use-case of the invention is shown in <figref idref="DRAWINGS">FIG. 4</figref>. In order to enable uni- and bi-directional interactions with remote devices, there needs to be a mechanism to establish network communication between the extended PC and each remote device. As explained below in further detail, this process begins in a block <b>80</b> by allocating an IP address for the device, and then using a discovery mechanism that enables devices connected to an appropriate network to be “discovered” in a block <b>81</b>. After the device has been discovered, description information pertaining to the capabilities of the device and services provided by the device are retrieved in a block <b>82</b>. Using connectivity data provided by this information, a network communication link is established between the extended PC and the remote device in a block <b>83</b>.</p>
<p id="p-0028" num="0027">In general, each device will provide one or more services that may be requested to be performed by other devices on the network. These services may typically include “remote display,” “remote audio,” “remote input,” “remote video,” and other similar services. Typically, each service will be designed to interact with a corresponding service component (e.g., software module) running on extended PC <b>38</b>. For example, for each client-side software service module shown in <figref idref="DRAWINGS">FIG. 3</figref>, there is a corresponding host-side software component running on extended PC <b>38</b>.</p>
<p id="p-0029" num="0028">Each of the software components running on extended PC <b>38</b> comprise one or more software modules that are specifically-tailored to interact with a corresponding remote device service using a particular service protocol. Depending on the services supported by a given host, corresponding host-side modules and protocols will be selectively loaded and enabled for execution on extended PC <b>38</b> in a block <b>84</b>. Interaction between the host and client devices will then be performed using appropriate service protocols in a block <b>85</b>.</p>
<p id="h-0004" num="0000">Establishing Network Connection, Discovery and Retrieving Capabilities using UPnP</p>
<p id="p-0030" num="0029">In one embodiment, establishing network communication, discovery of devices, and retrieval of those devices' capabilities and services is enabled through Universal Plug and Play. UPnP is an architecture for pervasive peer-to-peer network connectivity that enables network communication between UPnP-enabled devices using zero-configuration, “invisible” networking. Through UPnP, a device can dynamically join a network, obtain an IP address, convey its capabilities, and learn about the presence and capabilities of other devices sharing the network. UPnP leverages Internet components, including IP, TCP, UDP, HTTP, and XML. Like the Internet, contracts are based on wire protocols that are declarative, expressed in XML, and communicated via HTTP. Furthermore, UPnP networking is media independent, does not require device drivers, and can be implemented using any programming language on any operating system.</p>
<p id="p-0031" num="0030">The basic building blocks of UPnP networks are devices, services and control points. As shown in <figref idref="DRAWINGS">FIG. 5</figref>, each UPnP-enabled device comprises a container of one or more services and optional nested (i.e., embedded) devices and services. For instance, a UPnP device <b>90</b> comprises a single device <b>92</b> that provides two services <b>94</b> and <b>96</b>, while a UPnP device <b>98</b> comprises a single device <b>100</b> that provides a service <b>102</b>, and a UPnP device <b>104</b> that includes a root device <b>106</b> that provides a service <b>108</b> and an embedded device <b>110</b> providing services <b>112</b> and <b>114</b>. Different categories of UPnP devices will be associated with different sets of services and embedded devices. Information identifying a given device, its services, and any embedded devices and their services are provided by an XML description document that is hosted by that device.</p>
<p id="p-0032" num="0031">The smallest unit of control in a UPnP network is a service. A service exposes actions and models its state with state variables. For instance, a clock service could be modeled as having a state variable, current_time, which defines the state of the clock, and two actions, set_time and get_time, which allow control of the service. Similar to the device description, service information is part of an XML service description standardized by the UPnP forum. A pointer (URL) to these service descriptions is contained within the device description document.</p>
<p id="p-0033" num="0032">A control point in a UPnP network is a controller capable of discovering and controlling other devices. For example, as shown in <figref idref="DRAWINGS">FIG. 5</figref>, control points include devices used (e.g., solely) to control other devices, as depicted by a control point <b>114</b> (e.g., extended PC <b>38</b>), as well as controllers within devices that may be both controlled by other devices, as depicted by a control point <b>116</b>. After discovery, a control point may: retrieve the device description and get a list of associated services; retrieve service descriptions for interesting services; invoke actions to control the service; and/or subscribe to the service's event source.</p>
<p id="h-0005" num="0000">Addressing</p>
<p id="p-0034" num="0033">The foundation for UPnP networking is IP addressing, which comprises “step 0” in UPnP networking. In one embodiment, each device provides a Dynamic Host Configuration Protocol (DHCP) client that searches for a DHCP server when the device is first connected to the network. If a DHCP server is available (i.e., a managed network exists), the device will use the IP address assigned to it by the DHCP server. If no DHCP server is available (i.e., the network is unmanaged), the device must use automatic IP addressing (Auto-IP) to obtain an address. In brief, Auto IP defines how a device intelligently chooses an IP address from a set of reserved addresses and is able to move easily between managed and unmanaged networks. If during the DHCP transaction, the device obtains a domain name, e.g., through a DNS server or via DNS forwarding, the device should use that name in subsequent network operations; otherwise, the device should use its IP address.</p>
<p id="p-0035" num="0034">A device that supports AUTO-IP and is configured for dynamic address assignment begins by requesting an IP address via DHCP by sending out a DHCPDISCOVER message. The amount of time this DHCP Client should listen for DHCPOFFERS is implementation dependent. If a DHCPOFFER is received during this time, the device will continue the process of dynamic address assignment. If no valid DHCPOFFERS are received, the device may then auto-configure an IP address. To auto-configure an IP address using Auto-IP, the device uses an implementation-dependent algorithm for choosing an address in the 169.254/16 range. The first and last 256 addresses in this range are reserved and should not be used. The selected address should then be tested to determine if the address is already in use. If the address is in use by another device, another address must be chosen and tested, up to an implementation-dependent number of retries. Preferably, the address selection should be randomized to avoid collision when multiple devices are attempting to allocate addresses.</p>
<p id="p-0036" num="0035">Once a device has a valid IP address for the network, it can be located and referenced on that network through that address. There may be situations where an end user (e.g., a user of extended PC) needs to locate and identify a device. In these situations, a friendly name for the device is much easier for a human to use than an IP address. Moreover, names are much more static than IP addresses. Clients that refer to a device by name don't need to be modified when IP address of a device changes. Mapping of the device's DNS name to its IP address could be manually entered into DNS database or dynamically configured, if such a facility is provided by the extended PC. While computers and devices supporting dynamic DNS updates can register their DNS records directly in DNS, it is also possible to configure a DHCP server to register DNS records on behalf of these DHCP clients.</p>
<p id="h-0006" num="0000">Discovery</p>
<p id="p-0037" num="0036">Once an IP address is obtained, discovery (UPnP networking “step 1”) may be performed. When a device is added to the network, the UPnP discovery protocol allows that device to advertise its services to control points on the network, as shown in <figref idref="DRAWINGS">FIG. 6</figref>. Control points can also discover services. When a control point is added to the network, the UPnP discovery protocol allows that control point to search for devices of interest on the network. The fundamental exchange in both cases is a discovery message containing a few, essential specifics about the device or one of its services, e.g., its type, identifier, and a pointer to more detailed information.</p>
<p id="p-0038" num="0037">The UPnP discovery protocol is based on the Simple Service Discovery Protocol (SSDP). SSDP defines how network services can be discovered on the network. SDDP is built on HTTPU and HTTPMU (variants of HTTP defined to deliver messages on top of UDP/IP instead of TCP/IP) and defines methods both for a control point to locate resources of interest on the network, and for devices to announce their availability on the network.</p>
<p id="p-0039" num="0038">When a device is added to the network, it multicasts discovery messages to advertise its root device, any embedded devices, and its services. Each discovery message contains four major components:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0039">1. A potential search target (e.g., device type), sent in an NT header;</li>
        <li id="ul0002-0002" num="0040">2. A composite identifier for the advertisement, sent in a USN header;</li>
        <li id="ul0002-0003" num="0041">3. A URL for more information about the device (or enclosing device in the case of a service), sent in a LOCATION header; and</li>
        <li id="ul0002-0004" num="0042">4. A duration for which the advertisement is valid, sent in a CACHE-CONTROL header.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0040" num="0043">To advertise its capabilities, a device multicasts a number of discovery messages. With reference to <figref idref="DRAWINGS">FIG. 6</figref>, a root device will multicast three discovery messages <b>120</b> for the root device, two discovery messages <b>122</b> for each embedded device, and one discovery message <b>124</b> for each service. The content of these messages are shown in <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0041" num="0044">When a device is added to the network, it must send a multicast request with method NOTIFY and ssdp:alive in the NTS header in the following format, wherein values in italics are placeholders for actual values:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0045">NOTIFY*HTTP/1.1</li>
    <li id="ul0003-0002" num="0046">HOST: 239.255.255.250:1900</li>
    <li id="ul0003-0003" num="0047">CACHE-CONTROL: max-age=seconds until advertisement expires</li>
    <li id="ul0003-0004" num="0048">LOCATION: URL for UPnP description for root device</li>
    <li id="ul0003-0005" num="0049">NT: search target</li>
    <li id="ul0003-0006" num="0050">NTS: ssdp:alive</li>
    <li id="ul0003-0007" num="0051">SERVER: OS/version UPnP/1.0 product/version</li>
    <li id="ul0003-0008" num="0052">USN: advertisement UUID</li>
</ul>
</p>
<p id="p-0042" num="0053">The line HOST: 239.255.255.250:1900 specifies the multicast channel and port reserved for SSDP by the Internet Assigned Numbers Authority. The CACHE-CONTROL value specifies a duration during which the advertisement is valid.</p>
<p id="p-0043" num="0054">When a device and its services are going to be removed from the network, the device should multicast a ssdp:byebye message corresponding to each of the ssdp:alive messages it multicasted that have not already expired. The following format is used for each message, wherein placeholders for actual values are in italics:
<ul id="ul0004" list-style="none">
    <li id="ul0004-0001" num="0055">NOTIFY*HTTP/1.1</li>
    <li id="ul0004-0002" num="0056">HOST: 239.255.255.250:1900</li>
    <li id="ul0004-0003" num="0057">NT: search target</li>
    <li id="ul0004-0004" num="0058">NTS: ssdp:byebye</li>
    <li id="ul0004-0005" num="0059">USN: advertisement UUID</li>
</ul>
</p>
<p id="p-0044" num="0060">When a control point is added to the network, the UPnP discovery protocol allows that control point to search for devices of interest on the network. It does this by multicasting a search message <b>126</b> with a pattern, or target, equal to a type or identifier for a device or service, as shown in <figref idref="DRAWINGS">FIG. 6</figref>. Responses <b>128</b> from devices that respond to the search message contain discovery messages essentially identical to those advertised by newly connected devices, which are unicast.</p>
<p id="p-0045" num="0061">The multicast request is made with method M-SEARCH in the following format, wherein placeholders for actual values are in italics:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0062">M-SEARCH * HTTP/1.1</li>
    <li id="ul0005-0002" num="0063">HOST: 239.255.255.250:1900</li>
    <li id="ul0005-0003" num="0064">MAN: “ssdp:discover”</li>
    <li id="ul0005-0004" num="0065">MX: seconds to delay response</li>
    <li id="ul0005-0005" num="0066">ST: search target</li>
</ul>
</p>
<p id="p-0046" num="0067">The ST: value must be in one of the following formats:
<ul id="ul0006" list-style="none">
    <li id="ul0006-0001" num="0068">ssdp:all
    <ul id="ul0007" list-style="none">
        <li id="ul0007-0001" num="0069">Search for all devices and services.</li>
    </ul>
    </li>
    <li id="ul0006-0002" num="0070">upnp:rootdevice
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0071">Search for root devices only.</li>
    </ul>
    </li>
    <li id="ul0006-0003" num="0072">uuid:device-UUID
    <ul id="ul0009" list-style="none">
        <li id="ul0009-0001" num="0073">Search for a particular device. Device UUID specified by UPnP vendor.</li>
    </ul>
    </li>
    <li id="ul0006-0004" num="0074">urn:schemas-upnp-org:device:deviceType:v
    <ul id="ul0010" list-style="none">
        <li id="ul0010-0001" num="0075">Search for any device of this type. Device type and version defined by UPnP Forum working committee.</li>
    </ul>
    </li>
    <li id="ul0006-0005" num="0076">urn:schemas-upnp-org:service:serviceType:v
    <ul id="ul0011" list-style="none">
        <li id="ul0011-0001" num="0077">Search for any service of this type. Service type and version defined by UPnP Forum working committee.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0047" num="0078">To be found, a device must send a response to the source IP address and port that sent the request to the multicast channel. Responses to M-SEARCH are intentionally parallel to advertisements, and as such, follow the same pattern as listed for NOTIFY with ssdp:alive discussed above, except that the NT header is replaced with an ST header. The response is sent in the following format, wherein placeholders for actual values are in italics:
<ul id="ul0012" list-style="none">
    <li id="ul0012-0001" num="0079">HTTP/1.1 200 OK</li>
    <li id="ul0012-0002" num="0080">CACHE-CONTROL: max-age=seconds until advertisement expires</li>
    <li id="ul0012-0003" num="0081">DATA: when response was generated</li>
    <li id="ul0012-0004" num="0082">EXT:</li>
    <li id="ul0012-0005" num="0083">LOCATION: URL for UPnP description for root device</li>
    <li id="ul0012-0006" num="0084">SERVER: OS/version UPnP/1.0 product/version</li>
    <li id="ul0012-0007" num="0085">ST: search target</li>
    <li id="ul0012-0008" num="0086">USN: advertisement UUID</li>
</ul>
</p>
<p id="p-0048" num="0087">If the ST header in the request was:
<ul id="ul0013" list-style="none">
    <li id="ul0013-0001" num="0088">ssdp:all</li>
</ul>
</p>
<p id="p-0049" num="0089">Respond 3+2d+k times for a root device with d embedded devices and s embedded services but only k distinct service types. Value for ST header must be the same as the NT header in NOTIFY messages with ssdp:alive. Single URI.
<ul id="ul0014" list-style="none">
    <li id="ul0014-0001" num="0090">upnp:rootdevice</li>
</ul>
</p>
<p id="p-0050" num="0091">Respond once for root device. Must be upnp:rootdevice. Single URI
<ul id="ul0015" list-style="none">
    <li id="ul0015-0001" num="0092">uuid:device-UUID</li>
</ul>
</p>
<p id="p-0051" num="0093">Respond once for each device, root or embedded. Must be uuid:device-UUID. Device UUID specified by UPnP vendor. Single URI.
<ul id="ul0016" list-style="none">
    <li id="ul0016-0001" num="0094">urn: schemas-upnp-org:device:deviceType:v</li>
</ul>
</p>
<p id="p-0052" num="0095">Response once for each device, root or embedded. Must be in the form of urn:schemas-upnp-org:device:deviceType:v. Device type and version defined by UPnP Forum working committee.
<ul id="ul0017" list-style="none">
    <li id="ul0017-0001" num="0096">urn:schemas-upnp-org:service:serviceType:v</li>
</ul>
</p>
<p id="p-0053" num="0097">Response once for each device, root or embedded. Must be in the form of urn:schemas-upnp-org:service:serviceType:v. Service type and version defined by UPnP Forum working committee.</p>
<p id="h-0007" num="0000">Description</p>
<p id="p-0054" num="0098">The next step (2) in UPnP networking is description. After a control point has discovered a device, the control point still knows very little about the device. For the control point to learn more about the device and its capabilities, or to interact with the device, the control point must retrieve the device's description from the URL provided by the device in the discovery message. Devices may contain other, logical devices, as well as functional units, or services. The UPnP description for a device is expressed in XML and typically includes vendor-specific, manufacturer information like the model name and number, serial number, manufacturer name, URLs to vendor-specific Web sites, etc. The description also includes a list of any embedded devices or services, as well as URLs for control, eventing, and presentation. For each service, the description includes a list of the commands, or actions, the service responds to, and parameters, or arguments, for each action; the description for a service also includes a list of variables; these variables model the state of the service at run time, and are described in terms of their data type, range, and event characteristics.</p>
<p id="p-0055" num="0099">The UPnP description for a device is partitioned into two, logical parts: a device description describing the physical and logical containers, and one or more service descriptions describing the capabilities exposed by the device. A UPnP device description includes vendor-specific, manufacturer information like the model name and number, serial number, manufacturer name, URLs to vendor-specific Web sites, etc. (details below). For each service included in the device, the device description lists the service type, name, a URL for a service description, a URL for control, and a URL for eventing. A device description also includes a description of all embedded devices and a URL for presentation of the aggregate.</p>
<p id="p-0056" num="0100">Note that a single physical device may include multiple logical devices. Multiple logical devices can be modeled as a single root device with embedded devices (and services), as shown in <figref idref="DRAWINGS">FIG. 8</figref>, or as multiple root devices (perhaps with no embedded devices). In the former case, there is one UPnP device description for the root device, and that device description contains a description for all embedded devices. In the latter case, there are multiple UPnP device descriptions, one for each root device.</p>
<p id="p-0057" num="0101">A UPnP device description is written in XML syntax and is usually based on a standard UPnP Device Template. A UPnP service description includes a list of commands, or actions, the service responds to, and parameters, or arguments, for each action. A service description also includes a list of variables. These variables model the state of the service at run time, and are described in terms of their data type, range, and event characteristics. This section explains the description of actions, arguments, state variables, and the properties of those variables.</p>
<p id="p-0058" num="0102">Like a UPnP device description, a UPnP service description is written in XML syntax and is usually based on a standard UPnP Service Template. UPnP vendors can differentiate their devices by extending services, including additional UPnP services, or embedding additional devices. When a control point retrieves a particular device's description, these added features are exposed to the control point. The device and service descriptions authoritatively document the implementation of the device.</p>
<p id="p-0059" num="0103">Retrieving a UPnP device description is relatively simple: the control point issues an HTTP GET request on the URL in the discovery message, and the device returns the device description. Retrieving a UPnP service description is a similar process that uses a URL within the device description. The protocol stack, method, headers, and body for the response and request are explained in detail below.</p>
<p id="p-0060" num="0104">As long as the discovery advertisements from a device have not expired, a control point may assume that the device and its services are available. The device and service descriptions may be retrieved at any point since the device and service descriptions are static as long as the device and its services are available. If a device cancels its advertisements, a control point should assume the device and its services are no longer available.</p>
<p id="p-0061" num="0105">The UPnP description for a device contains several pieces of vendor-specific information, definitions of all embedded devices, URL for presentation of the device, and listings for all services, including URLs for control and eventing. In addition to defining non-standard devices, UPnP vendors may add embedded devices and services to standard devices. To illustrate these, below is a listing with placeholders in italics for actual elements and values corresponding to a device description.</p>
<p id="p-0062" num="0106">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&lt;?xml version=“1.0”?&gt;</entry>
</row>
<row>
<entry>&lt;root xmlns=“urn:schemas-upnp-org:device-1-0”&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;specVersion&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;minor&gt;1&lt;/major&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;minor&gt;0&lt;/minor&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/specVersion&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;URLBase&gt;base URL for all relative URLs&lt;/URLBase&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;device&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;deviceType&gt;urn:schemas-upnp-org:device:deviceType:v&lt;/deviceType&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;friendlyName&gt;short user-friendly title&lt;/freindlyName&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;manufacturer&gt;manufacturer name&lt;/manufacturer&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;manufacturerURL&gt;URL to manufacturer site&lt;/manufacturerURL&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;modelDescription&gt;long user-friendly title&lt;/modelDescription&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;modelName&gt;model name&lt;/modelName&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;modelNumber&gt;model number&lt;/modelNumber&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;modelURL&gt;URL to model site&lt;/modelURL&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;serialNumber&gt;manufacturer's serial number&lt;/serialNumber&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;UDN&gt;uuid:UUID&lt;/UDN&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;UPC&gt;Universal Product Code&lt;/UPC&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;iconList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;icon&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;mimetype&gt;image/format&lt;/mimetype&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;width&gt;horizontal pixels&lt;/width&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;height&gt;vertical pixels&lt;/height&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;depth&gt;color depth&lt;/depth&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;url&gt;URL to icon&lt;/url&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/icon&gt;</entry>
</row>
<row>
<entry/>
<entry>XML to declare other icons, if any, go here</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/iconList&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;serviceList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;service&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;serviceType&gt;urn:schemas-upnp-org:service:</entry>
</row>
<row>
<entry/>
<entry>serviceType:v&lt;/serviceType&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;serviceId&gt;urn:upnp-org:serviceId:serviceId&lt;/serviceId&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;SCPDURL&gt;URL for control&lt;/controlURL&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;controlURL&gt;URL for eventing&lt;/eventSubURL&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/service&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Declarations for other services defined by a UPnP Forum working</entry>
</row>
<row>
<entry/>
<entry>committee (if any) go here</entry>
</row>
<row>
<entry/>
<entry>Declarations for other services added by UPnP vendor (if any)</entry>
</row>
<row>
<entry/>
<entry>go here</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/serviceList&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;deviceList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Description of embedded devices defined by a UPnP Forum</entry>
</row>
<row>
<entry/>
<entry>working committee (if any) go here</entry>
</row>
<row>
<entry/>
<entry>Description of embedded devices added by UPnP vendor (if any)</entry>
</row>
<row>
<entry/>
<entry>go here</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/deviceList&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;presentationURL&gt;URL for presentation&lt;/presentationURL&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/device&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<tbody valign="top">
<row>
<entry>&lt;/root&gt;</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0063" num="0107">The UPnP description for a service defines actions and their arguments, and state variables and their data type, range, and event characteristics. Each service may have zero or more actions, while each action may have zero or more arguments. Any combination of these arguments may be input or output parameters. If an action has one or more output arguments, one of these arguments may be marked as a return value. Each argument should correspond to a state variable. Below is a listing with placeholders in italics for actual elements and values corresponding to a service description.</p>
<p id="p-0064" num="0108">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&lt;?xml version=“1.0”?&gt;</entry>
</row>
<row>
<entry>&lt;scpd xmlns=“urn:schemas-upnp-org:service-1.0”&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;specVersion&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;major&gt;1&lt;/major&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;minor&gt;0&lt;/minor&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/specVersion&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;actionList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;action&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;name&gt;actionName&lt;/name&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;argumentList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;argument&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;name&gt;formalParameterName&lt;/name&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;direction&gt;in xor out&lt;/direction&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;retval /&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;relatedStateVariable&gt;stateVariableName&lt;/</entry>
</row>
<row>
<entry/>
<entry>relatedStateVariable&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/argument&gt;</entry>
</row>
<row>
<entry/>
<entry>Declarations for other arguments defined by UPnP Forum</entry>
</row>
<row>
<entry/>
<entry>working committee (if any) go here</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;argumentList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/action&gt;</entry>
</row>
<row>
<entry/>
<entry>Declarations for other arguments defined by UPnP Forum</entry>
</row>
<row>
<entry/>
<entry>working committee (if any) go here</entry>
</row>
<row>
<entry/>
<entry>Declarations for other actions added by UPnP vendor (if</entry>
</row>
<row>
<entry/>
<entry>any) go here</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/actionList&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;serviceStateTable&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;stateVariable sendEvents=“yes”&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;name&gt;variableName&lt;/name&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;dataType&gt;variable data type&lt;/dataType&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;defaultValue&gt;default value&lt;/defaultValue&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;allowedValueList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;allowedValue&gt;enumerated value&lt;/allowed value&gt;</entry>
</row>
<row>
<entry/>
<entry>Other allowed values defined by UPnP Forum</entry>
</row>
<row>
<entry/>
<entry>working committee (if any) go here</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/allowedValueList&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;stateVariable&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;stateVariable sendEvents=“yes”&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;name&gt;variableName&lt;/name&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;dataType&gt;variable data type&lt;/dataType&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;defaultValue&gt;default value&lt;/defaultValue&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;allowedValueRange&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;minimum&gt;minimum value&lt;/minimum&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;maximum&gt;maximum value&lt;/maximum&gt;</entry>
</row>
<row>
<entry/>
<entry>&lt;step&gt;increment value&lt;/step&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/allowedValueRange&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/stateVariable&gt;</entry>
</row>
<row>
<entry/>
<entry>Declaration for other state variables by UPnP Forum working</entry>
</row>
<row>
<entry/>
<entry>committee (if any) go here</entry>
</row>
<row>
<entry/>
<entry>Declarations for other state variables added by UPnP vendor</entry>
</row>
<row>
<entry/>
<entry>(if any) go here</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&lt;/serviceStateTable&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<tbody valign="top">
<row>
<entry>&lt;/scpd&gt;</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0065" num="0109">Further details of how to implement addressing, discovery and description under UPnP are available through well-publicized documentation, such as that available at the UPnP forum working committee web site (www.upnp.org) and Microsoft's UPnP web site (www.upnp.com).</p>
<p id="p-0066" num="0110">At this point, the present invention departs from the standard techniques for controlling devices under UPnP, wherein interactions between devices are defined by generalized UPnP control and eventing protocols. Instead, the invention defines service-specific protocols to enable interaction between the extended PC and one or more remote devices that host the services used. In general, these services may include any service provided by a remote device, such as remote display, remote audio, remote input, and remote video; however, the invention is particularly advantageous when considering that in a typical implementation the majority of the hardware and software resources are hosted by the extended PC while the resources required for each remote device are typically “lightweight” in comparison.</p>
<p id="h-0008" num="0000">Lightweight Remote Display Service</p>
<p id="p-0067" num="0111">In accordance with one aspect of the invention, a protocol is provided that enables an extended PC to display content on a remote device using a “push” model, wherein the extended PC pushes data and control information to the remote device using a predefined set of commands, and the data is formatted to meet display capabilities advertised by the remote device via the discovery mechanism discussed above. The service provides a simple TCP connection port on which the extended PC sends a stream of “display this picture at position X, Y” type commands</p>
<p id="p-0068" num="0112">An exemplary set of protocol commands corresponding to a lightweight display service are shown below, with accompanying descriptions.</p>
<p id="h-0009" num="0000">Reset (Int Protocol Version)</p>
<p id="p-0069" num="0113">This primitive is used by the extended PC to reset the display on the remote device. The display must clear itself and await instructions. This primitive also clears any state the remote device may have. The protocol is defined with minimal state, but reset is defined such as to future proof the device. If future protocol versions are defined, this command can be used to set which protocol version is going to be used by the extended PC.</p>
<p id="h-0010" num="0000">Flush (Int TimeSinceLastSync)</p>
<p id="p-0070" num="0114">Some display devices may support double buffering, where the device writes images to a hidden buffer and only displays the hidden buffer to the screen when asked to do so. Double buffering results in less display flicker. The “TimeSinceLastSync” parameter specifies the number of refresh cycles to wait before issuing the Flush command.</p>
<p id="p-0071" num="0115">For example, suppose an NTSC TV adapter has double buffer support and it keeps track of the screen refresh (about 30 times per second). The device draws display data into its hidden buffer. When it receives a Flush(0) command, it displays the hidden buffer to the screen at the next screen refresh. If it is desired to animate a GIF at 15 frames per seconds, the extended PC will need to send an animation frame to the remote device followed by a Flush(2) command. This will instruct the device to wait 2 refresh cycles before executing the Flush command.</p>
<p id="h-0011" num="0000">FlushFailed( )</p>
<p id="p-0072" num="0116">This command allows the PC to kept track of the quality of the animated output and adjust it accordingly. If an animation frame is not received in time due to network and device loads, another mechanism comes into play to allow a PC to adaptively recover: If more than 2 refresh cycles occur before the reception of the Flush(2) command, a FlushFailed( ) command is returned to the PC. This allows the PC to adapt the frame rate and animation size to better fit the current network load and ability of the device.</p>
<p id="h-0012" num="0000">DrawFillBox (x1, y1, x2, y2, Color)</p>
<p id="p-0073" num="0117">Draw a fill box of the given color defined by the corner point (x1,y2) and (x2,y2).</p>
<p id="h-0013" num="0000">DrawImage (x, y, image)</p>
<p id="p-0074" num="0118">Draw an image at the (x, y) location. Here, the image can be in many different formats. When the PC discovers the remote device on the network, it will retrieve the screen size, color depth and supported image formats for the device's and/or the device service's description information. Information such as image width, height, and color are all encoded within the image format. The extended PC may use special features of some image types, such as alpha-blending and transparency, provided these capabilities are supported by the display device.</p>
<p id="h-0014" num="0000">Allocate(Area Name, x, y, width, height)</p>
<p id="p-0075" num="0119">This command may be used in cases where a remote device supports streaming video as a separate service. This command allows the PC to place the video in a portion of the screen. Generally, the PC will set up the position of the video window using a configuration service or protocol, and start streaming the video via a separate streaming service such as UPnP/AV as defined by the UPnP forum.</p>
<p id="h-0015" num="0000">Repaint ( )</p>
<p id="p-0076" num="0120">On occasion a device may lose the parts of the entire display content. To recover, the device can ask the extended PC to resend a complete update of the screen via the Repaint command.</p>
<p id="h-0016" num="0000">Move(x1, y1, x2, y2, Width, Height)</p>
<p id="p-0077" num="0121">This command moves a block from a portion of the frame buffer identified by (X1, Y1, Width, Height) to another portion of the frame buffer identified by (X2, Y2, Width, Height). When using this command, devices may or may not support overlapping areas. If a device does not support this command at all, DrawImage commands are used instead.</p>
<p id="p-0078" num="0122">In the most basic implementation, only Reset( ) and DrawImage( ) are required commands, while the remaining commands are optional. Perfectly synchronized animations can be played on a display device that supports the Flush( ) and FlushFailed( ) commands, since the device animates the frames based on its own clock. If these commands are not available, the extended PC can still push data and commands to perform an animation, but the quality of the animation is subject to network conditions.</p>
<p id="p-0079" num="0123">An exemplary software/hardware architecture that enables an extended PC <b>38</b> to drive a display on a remote display device <b>128</b> is shown in <figref idref="DRAWINGS">FIG. 9</figref>. As discussed above, the majority of the hardware and software resources used to implement the lightweight remote display resides on the extended PC. These include various software components <b>130</b>, including a picture application <b>58</b>, a UPnP device abstraction layer <b>62</b>, a UPnP module <b>64</b>, a display module <b>70</b>, and a network module <b>72</b>. Client-side software components <b>132</b>, depicted as a UPnP service module <b>40</b> and a display service module <b>48</b>, enable network communication and remote display and synchronization to be performed by the remote display device in response to data and commands sent over a network communications link <b>134</b> via a network interface <b>136</b>. In general, network interface <b>136</b> may comprise a network interface that supports one or more of the network interface protocols discussed above. Software components <b>132</b> will typically be stored as sets of machine instructions in a memory <b>140</b> that are executed by a controller <b>142</b> to perform the functions of each service. The remote display device also includes a display buffer <b>144</b> that stores display data that is read by a display driver <b>146</b> to drive a display <b>148</b>.</p>
<p id="p-0080" num="0124">Generally, controller <b>142</b> may comprise any component enabled to perform the lightweight remote display functions discussed above through execution of software components <b>132</b>. For example, such components include various types of microprocessors and microcontrollers. Furthermore, memory <b>140</b> will typically comprise some form of non-volatile memory, such as ROM, EPROM, Flash memory, etc. In one embodiment, the operations performed by two or more of the hardware components may be provided by an Application Specific Integrated Circuit (ASIC) that is specifically designed to support the services provided by the remote display device.</p>
<p id="p-0081" num="0125">As shown in <figref idref="DRAWINGS">FIG. 9</figref>, remote display device <b>128</b> comprises an integrated device that includes both hardware and software components, as well as display <b>148</b>. Optionally, the hardware and software components may be employed in a separate display adapter <b>150</b> that drives a display. For example, display <b>148</b> may comprise a television monitor <b>152</b> that receives input from a display adapter. Optionally, display <b>148</b> may represent a digital picture frame <b>154</b> that is driven by a display adapter.</p>
<p id="p-0082" num="0126">In most instances, the remote display device will be provided with data corresponding to a bitmap display. This enables the hardware on the display device to be minimized. However, since bitmaps take a large amount of memory and provide an inefficient means for storing image content, most image and video data are stored in some compressed format, such as JPEG and GIF for still images, and MPEG for video images. As a result, when using remote display devices that do not provide built-in decompression capabilities (either through built-in capabilities or provided via client-side software (e.g., display module <b>48</b>), it will be necessary to convert images from the compressed format into a bitmap format prior to sending the image data to the remote display device. Optionally, if the remote device supports image decompression (either through built-in hardware or the client side software), image data may be sent in a compressed format and decompressed at the remote display device. Compression, decompression, and sending these data are be performed on extended PC <b>38</b> through execution of display module <b>70</b>.</p>
<p id="h-0017" num="0000">Remote Audio</p>
<p id="p-0083" num="0127">In addition to driving still image and video displays, the present invention also supports remote audio capabilities. Typically, the UPnP description of an audio service will provide information pertaining to that device's audio capabilities, such as number of channels (i.e., speakers), playback rate, quality (e.g., number of bits), and supported sound format (e.g., PCM), voice input, etc.</p>
<p id="p-0084" num="0128">An exemplary architecture to enable an extended PC <b>38</b> to drive a remote audio device <b>156</b> and/or receive audio input from the remote audio device is shown in <figref idref="DRAWINGS">FIG. 10</figref>. A number of software and hardware components used in this architecture are substantially similar to those discussed above with reference to <figref idref="DRAWINGS">FIG. 9</figref>; these components share the same reference numbers in both Figures. A set of software components <b>158</b> are running on extended PC <b>38</b>, including a jukebox application <b>60</b> and a sound module <b>66</b> in addition to UPnP device abstraction layer <b>62</b>, UPnP module <b>64</b> and network module <b>72</b> discussed above. Remote audio device <b>156</b> includes an audio adapter <b>160</b> that includes software <b>162</b> stored in memory <b>140</b> that includes a sound service module <b>46</b>. In addition to network interface <b>136</b> and controller <b>142</b>, the remote audio device also includes an audio driver <b>164</b> that reads audio data stored in an audio buffer <b>166</b>, and converts the audio data into an amplified audio signal that drives speakers <b>168</b>.</p>
<p id="p-0085" num="0129">In one embodiment, sound input services are additionally provided by remote audio device <b>156</b>. In this instance, a user may provide verbal input via a microphone <b>165</b>, which produces an analog audio signal that is received by an audio input block <b>167</b> and converted into audio data having a digital format. Optionally, microphone <b>165</b> may directly convert verbal input into the digitized audio data. In one embodiment, audio input block <b>167</b> will pass the digitized audio data to audio buffer <b>166</b>, wherein it will be read by controller <b>142</b> and sent to extended PC <b>38</b> via network interface <b>136</b>. Optionally, audio input block <b>167</b> may directly pass the digitized audio data to controller <b>142</b>.</p>
<p id="p-0086" num="0130">Typically, the user's verbal input will correspond to a set of command words (or a command language with a predefined syntax) that are used as verbal commands to control actions performed by extended PC <b>38</b>. Accordingly, sound module <b>66</b> will include voice recognition software that will be used to interpret the audio data it receives to determine what command(s) the verbal input corresponds to.</p>
<p id="p-0087" num="0131">In one embodiment, a TCP socket is opened to the remote audio device (via a port number provided by the service's UPnP description). Both the device and the extended PC TCP sockets can be optionally configured to buffer only a small amount of data (depending on desired sound quality, network latency, and/or audio latency). The device simply reads PCM sound from the TCP socket and fills its audio buffer. If the remote sound device cannot perform these operations, it notifies the extended PC that there is a problem. In one embodiment, sound module <b>66</b> includes one or more functions that enable the extended PC to adapt the sound quality (defined by its outgoing audio data stream) to meet a remote sound device's playback capabilities in consideration of initial and/or changed network conditions. In one embodiment, the IETF defined RTP protocol (RTP: A Transport Protocol for Real-Time Applications, RFC1889, January 1996) is used to carry PCM encoded audio in real time.</p>
<p id="h-0018" num="0000">Lightweight Remote Input Service</p>
<p id="p-0088" num="0132">Devices that may implement the invention can be built using various types of input, from no input at all to pen-input, keyboard, mouse, and button input. Each type of input will generally be handled by a respective input service, wherein the existence and capabilities of each input service will be described in that service's UPnP description information. This information may include type of input device, commands supported (buttons, positions (e.g., pen, mouse position in XY coordinates), clicks, z-axis position), etc.).</p>
<p id="p-0089" num="0133">Some devices, such as infrared remote controls, might require code running on the extended PC to interpret the time codes it receives from the remote control and convert them into button commands. In this instance, the corresponding UPnP service might also be used to advertise the presence of a custom input device and a URL link where the matching PC software required to support the device is located so that it can be downloaded to the extended PC over the Internet. Once downloaded, the extended PC can run the corresponding software component.</p>
<p id="p-0090" num="0134">A basic set of primitives is supported by this lightweight remote input service. In one embodiment, these primitives include:
<ul id="ul0018" list-style="none">
    <li id="ul0018-0001" num="0135">KeyDown(int keydata)</li>
    <li id="ul0018-0002" num="0136">KeyPress(int keydata)</li>
    <li id="ul0018-0003" num="0137">KeyUp(int keydata)</li>
</ul>
</p>
<p id="p-0091" num="0138">The three keyboard primitives match the well-known keyboard events used is almost all operating systems. KeyDown and KeyUp occur whenever a key is pushed or released, this generally includes all keys including control keys such as shift, ctrl, alt and function keys. The KeyPress event contains the resulting interpretation of the keystrokes such as small and large capitalization and keyboard repetitions.
<ul id="ul0019" list-style="none">
    <li id="ul0019-0001" num="0139">MouseDown(int x, int y, int buttondata)</li>
    <li id="ul0019-0002" num="0140">MouseMove(int x, int y, int buttondata)</li>
    <li id="ul0019-0003" num="0141">MouseUp(int x, int y, int buttondata)</li>
</ul>
</p>
<p id="p-0092" num="0142">The three pointer primitives match the well-known keyboard events used is almost all operating systems. These primitives are not limited to mouse movements, any other pointing device such as trackballs, movement keys, pen input, touch sensitive screen and magnetic screens can also use them. During input service discovery, the extended PC is informed of the maximum values of x and y. If the device has a display, these pointer primitives may have a different resolution that may not match the x and y of the display. In such instances, software residing on the extended PC may be used to scale the pointer position to the display.</p>
<p id="h-0019" num="0000">RemoteControlKey(int buttondata)</p>
<p id="p-0093" num="0143">The framework also supports a remote control primitive to send to applications button information that is not generally associated with a computer keyboard. These buttons include various buttons that are commonly found on remote control devices used to control audio and video equipment, such as VCRs, DVD players, CD players, jukeboxes, etc. Typically, these buttons will include: Play, Pause, Forward, Reverse, Next Track, VCR, DVD, CD, etc. In some frameworks, the designer may opt to not use this primitive and map these remote control keys to standard computer keyboard events via custom software running on the remote device and/or the extended PC.</p>
<p id="h-0020" num="0000">Custom(int channel_number, bytes[ ] custom_data)</p>
<p id="p-0094" num="0144">In general, all keyboard, mouse and possibly remote control primitives will be dispatched to applications as-is. For some devices, data processing will need to be performed before a keyboard or mouse event can be generated. In order to lower the cost of the device, it will be preferable that device use this custom primitive to send raw input data to the extended PC for interpretation. The extended PC then sends the raw data into the appropriate code module for interpretation; the code module will generally return mouse or keyboard primitives that can than by dispatched to the applications. In accordance with this primitive, each channel number can contain completely different raw data that may be sent to a different respective code module for interpretation.</p>
<p id="p-0095" num="0145">In general, a remote device does not have to use all of these primitives, but rather can use all or a subset of them. Some devices may opt to use only custom data as input. An XML file will describe how the input service behaves, what primitive, are used, data identifying the bounds of mouse coordinates, whether custom channels exist and where to obtain the code modules to interpret the raw input data. Preferably, the XML file will be written by the manufacturer of the device and validated using an XML-Schema file (XSD file). The Extended PC can also use the XSD file to validate the devices XML file before it is parsed.</p>
<p id="p-0096" num="0146">Preferably, the code modules that are loaded and run by the extended PC should be authenticated, especially in instances in which code modules are downloaded from an Internet site. For example, authentication techniques such as digital signatures may be used to authenticate the code modules. Techniques for authentication are well-known in the art, and so no further details are provided herein. The code modules should also be designed to provide system safety. For instance, custom input code modules should be “sand-boxed” such that they are prevented from tampering with system files and other software on the extended PC.</p>
<p id="p-0097" num="0147">Another instantiation of this remote input service would do a similar operation in reverse. A code module on the extended PC could be loaded to generate a custom command to a device. For example, if a device has an IR transmitter, the PC could load a code module that sends an array of IR pulse timings to the device to be used for re-transmission purposes.</p>
<p id="p-0098" num="0148">An exemplary architecture illustrating host-side and client-side software and hardware components to enable an extended PC <b>38</b> to receive input from a remote device <b>170</b> is shown in <figref idref="DRAWINGS">FIG. 11</figref>. As before, host-side software components include a UPnP device abstraction layer <b>62</b>, a UPnP module <b>64</b> and a network module <b>72</b>. New components that support remote device input services include an input module <b>68</b>, a custom input module <b>172</b>, an infra-red (IR) remote module <b>174</b>, a touch display module <b>176</b>, and a button map module <b>178</b>.</p>
<p id="p-0099" num="0149">In a typical implementation, input capabilities will be supported by an input adapter <b>180</b> provided for the remote device. The input adapter may comprise circuitry built into the remote device, or may comprise a separate add-on component. As with the display and audio adapters discussed above, the input adapter includes a network interface <b>136</b>, a controller <b>142</b>, and memory <b>140</b>. In this instance, memory <b>140</b> includes software <b>182</b> comprising a UPnP client-side module <b>40</b> and a client-side input module <b>50</b>. The input adapter further includes an input signal processing block <b>184</b>, which may be performed by hardware and/or software components that are well-known in the art for processing signals from input devices. Optionally, the input adapter may also include an input buffer <b>186</b>.</p>
<p id="p-0100" num="0150">Generally, input adapter <b>180</b> will be designed to receive input from one or more input devices <b>188</b>, which are exemplified by wired and wireless keyboards <b>190</b>, wired and wireless pointing devices <b>192</b>, and remote control devices <b>194</b>.</p>
<p id="p-0101" num="0151">An exemplary architecture provided by a PC/CE adapter <b>200</b> that implements a plurality of the services discussed above is shown in <figref idref="DRAWINGS">FIG. 12</figref>. In this instance, the PC/CE adapter includes various software components that enable the adapter to interact with an extended PC <b>38</b>, drive audio and video signals for a television (or television monitor) <b>202</b>, drive a digital picture frame <b>204</b>, and receive input from an IR remote control <b>206</b>. These software components include a UPnP module <b>40</b>, a sound service module <b>46</b>, a display service module <b>48</b>, and an input service module <b>50</b>. The sound and display service modules interact with appropriate hardware (not shown) to provide analog legacy audio and video signals <b>208</b> and <b>210</b> to a television <b>206</b>. Also, digital audio and video signals may be sent using a 1394 link. Display service module <b>48</b> also is used to provide bitmap data to digital picture frame <b>204</b> via a IEEE 1394 connection <b>212</b>. The PC/CE adapter is accessed via an IEEE 802.11a wireless connection <b>214</b> and provides a IEEE 1394 bridge <b>216</b> that enables IEEE 1394 signals to be interfaced with IEEE 802.11a signals.</p>
<p id="h-0021" num="0000">Exemplary Computer System for Practicing the Invention</p>
<p id="p-0102" num="0152">With reference to <figref idref="DRAWINGS">FIG. 13</figref>, a generally conventional computer <b>300</b> is illustrated, which is suitable for use as the extended PC in connection with practicing the present invention, and may be used for running host-side software comprising one or more software modules that implement the various host-side functions of the invention discussed above. Examples of computers that may be suitable for hosts as discussed above include PC-class systems operating the Windows XP, 2000, or NT operating systems, Sun workstations operating the UNIX-based Solaris operating system, and various computer architectures that implement LINUX operating systems. Computer <b>300</b> is also intended to encompass various server architectures, as well as computers having multiple processors.</p>
<p id="p-0103" num="0153">Computer <b>300</b> includes a processor chassis <b>302</b> in which are mounted a floppy disk drive <b>304</b>, a hard drive <b>306</b>, a motherboard <b>308</b> populated with appropriate integrated circuits including memory <b>310</b> and one or more processors (CPUs) <b>312</b>, and a power supply (not shown), as are generally well known to those of ordinary skill in the art. It will be understood that hard drive <b>106</b> may comprise a single unit, or multiple hard drives, and may optionally reside outside of computer <b>300</b>. A monitor <b>314</b> is included for displaying graphics and text generated by software programs and program modules that are run by the computer. A mouse <b>316</b> (or other pointing device) may be connected to a serial port (or to a bus port or USB port) on the rear of processor chassis <b>302</b>, and signals from mouse <b>316</b> are conveyed to the motherboard to control a cursor on the display and to select text, menu options, and graphic components displayed on monitor <b>316</b> by software programs and modules executing on the computer. In addition, a keyboard <b>318</b> is coupled to the motherboard for user entry of text and commands that affect the running of software programs executing on the computer. Computer <b>300</b> also includes a network interface card <b>320</b> or built in network adapter for connecting the computer to a computer network, such as a local area network, wide area network, or the Internet.</p>
<p id="p-0104" num="0154">Computer <b>300</b> may also optionally include a compact disk-read only memory (CD-ROM) drive <b>322</b> into which a CD-ROM disk may be inserted so that executable files and data on the disk can be read for transfer into the memory and/or into storage on hard drive <b>306</b> of computer <b>300</b>. Other mass memory storage devices such as an optical recorded medium or DVD drive may be included. The machine instructions comprising the software that causes the CPU to implement the functions of the present invention that have been discussed above will likely be distributed on floppy disks or CD-ROMs (or other memory media) and stored in the hard drive until loaded into random access memory (RAM) for execution by the CPU. Optionally, all or a portion of the machine instructions may be loaded via a computer network.</p>
<p id="p-0105" num="0155">Although the present invention has been described in connection with a preferred form of practicing it and modifications thereto, those of ordinary skill in the art will understand that many other modifications can be made to the invention within the scope of the claims that follow. Accordingly, it is not intended that the scope of the invention in any way be limited by the above description, but instead be determined entirely by reference to the claims that follow.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for controlling a remote display device, comprising:
<claim-text>defining a service-specific protocol to facilitate remote control of a service provided by the remote display device, wherein the service-specific protocol defines display commands that are used to display content on the display device by sending display commands and data pertaining to the display content from the host computer to the remote device over the network communication link;</claim-text>
<claim-text>sending data corresponding to the service provided by the remote display device via a host-side software module running on the host computer in a format defined by the service-specific protocol from the host computer to the remote display device over a network communication link; and</claim-text>
<claim-text>sending control commands from the host computer to the remote display device based on the service-specific protocol to cause the remote display device to perform the service using the data that are sent to the remote display device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the network communication link is established by:
<claim-text>connecting the host computer to a network to which at least one remote device is already connected;</claim-text>
<claim-text>obtaining an IP address for the host computer;</claim-text>
<claim-text>broadcasting a search message over the network requesting that any device meeting a search criteria defined by data contained in the search message to contact the host computer using the IP address for the host computer;</claim-text>
<claim-text>listening for a response to the search message, and in response thereto:
<claim-text>retrieving a description of a service provided by a remote device that responds to the search message to obtain a port number that may be used to communicate with the service; and</claim-text>
<claim-text>opening a TCP (transmission control protocol) socket that uses the port number.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the service-specific protocol further defines commands that are used to display streaming video on the display device by sending streaming video commands and data pertaining to the streaming video content from the host computer to the remote device over the network communication link.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A machine-readable media on which a plurality of instructions are stored that when executed by the processor of a host computer perform the operations of:
<claim-text>interacting with a remote device to discover a service provided by the remote device, wherein the remote device comprises an input service;</claim-text>
<claim-text>interacting with the remote device to establish a network communication link between the remote device and the host computer;</claim-text>
<claim-text>sending data corresponding to the service from the host computer to the remote device over the network communication link;</claim-text>
<claim-text>sending commands from the host computer to the remote device over the network communication link based on a service protocol that is specific to the service provided by the remote device to cause the remote device to perform service operations specified by the commands that employ the data sent to the remote device, wherein the service protocol includes input primitives to enable input data to be sent from the remote device to be interpreted by the host-side software module running on the host computer.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The machine-readable media of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the plurality of input primitives are further to:
<claim-text>listen for input data from the remote device, wherein the input data has a format corresponds to said plurality of input primitives; and</claim-text>
<claim-text>interpret the input data to generate input commands based on the input protocol.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The machine-readable media of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein establishing the network communication link comprises performing the operation of:
<claim-text>broadcasting a search message from the host computer over the network requesting that any device meeting a search criteria defined by data contained in the search message to contact the host computer using a network address assigned to the host computer;</claim-text>
<claim-text>retrieving a description of a service provided by a remote device that responds to the search message to obtain a port number that may be used to communicate with the service; and</claim-text>
<claim-text>opening a TCP (transmission control protocol) socket that uses the port number.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A device comprising:
<claim-text>a network interface;</claim-text>
<claim-text>a memory in which a plurality of machine instructions are stored comprising a set of client-side software to control a service provided by the device in response to service protocol specific data and commands received by the device having a format defined by a protocol specific to the service; and</claim-text>
<claim-text>a controller, coupled to the network interface and the memory, to execute said plurality of machine instructions to perform the operations of:
<claim-text>interacting with a remote host computer to establish a network communication link via the network interface with the remote host computer; and</claim-text>
<claim-text>in response to receiving service protocol specific data and commands that are pushed to the device from the remote host computer over the network communications link, performing service operations specified by the commands that employ the data,</claim-text>
</claim-text>
<claim-text>wherein the device further includes a display coupled to the controller, and the service provided by the device comprises a streaming video service that is driven by commands defined by the service specific protocol to cause the device to display streaming video on the display in response to receiving data and display commands from the remote host computer over the network communication link.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The device of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the network communication link is established by performing the operations of:
<claim-text>broadcasting device identification and service information identifying a service provided by the device and a communications port via which other devices connected to the network including the remote host computer may communicate with the device;</claim-text>
<claim-text>opening a TCP/IP socket via the communications port.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The device of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the service provided by the device further comprises a streaming video service that is driven by streaming video commands defined by the service specific protocol to cause the device to display streaming video content on the display in response to receiving data and streaming video commands from the remote host computer over the network communication link.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The device of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the device comprises a display adapter that further includes an interface to couple to a display, and the service provided by the device comprises a display service that is driven by display commands defined by the service specific protocol to cause the device send display content to the display in response to receiving data and display commands from the remote host computer over the network communication link.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The device of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising an audio driver coupled to the controller and speakers, and wherein the service specific protocol includes audio commands that are used to cause the device to playback audio content in response to receiving audio commands and audio data pertaining to the audio content from the remote host computer over the network communication link.</claim-text>
</claim>
</claims>
</us-patent-grant>
