<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299470-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299470</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>09951951</doc-number>
<date>20010913</date>
</document-id>
</application-reference>
<us-application-series-code>09</us-application-series-code>
<us-term-of-grant>
<us-term-extension>609</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>718107</main-classification>
<further-classification>719312</further-classification>
<further-classification>370230</further-classification>
</classification-national>
<invention-title id="d0e53">Method and system for regulating communication traffic using a limiter thread</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4930122</doc-number>
<kind>A</kind>
<name>Takahashi et al.</name>
<date>19900500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370473</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5649103</doc-number>
<kind>A</kind>
<name>Datta et al.</name>
<date>19970700</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>39520003</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5815727</doc-number>
<kind>A</kind>
<name>Motomura</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  1</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5907675</doc-number>
<kind>A</kind>
<name>Aahlad</name>
<date>19990500</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>39520033</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5951653</doc-number>
<kind>A</kind>
<name>Hill et al.</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719315</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5991286</doc-number>
<kind>A</kind>
<name>Labonte et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370337</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>5999538</doc-number>
<kind>A</kind>
<name>Haddock et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>370446</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6055578</doc-number>
<kind>A</kind>
<name>Williams et al.</name>
<date>20000400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709253</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6078591</doc-number>
<kind>A</kind>
<name>Kalkunte et al.</name>
<date>20000600</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>370448</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6088363</doc-number>
<kind>A</kind>
<name>Shiobara</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>370461</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6128644</doc-number>
<kind>A</kind>
<name>Nozaki</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>709203</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6154769</doc-number>
<kind>A</kind>
<name>Cherkasova et al.</name>
<date>20001100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>709207</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6178177</doc-number>
<kind>B1</kind>
<name>Vautey</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>370445</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6381649</doc-number>
<kind>B1</kind>
<name>Carlson</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709235</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6434651</doc-number>
<kind>B1</kind>
<name>Gentry, Jr.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710260</main-classification></classification-national>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>6631462</doc-number>
<kind>B1</kind>
<name>Wolrich et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712225</main-classification></classification-national>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>JP</country>
<doc-number>10-224356</doc-number>
<date>19980800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>7</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>718  1</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718107</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>719312</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370378-916</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370229-235</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709213</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709233</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>6</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030051064</doc-number>
<kind>A1</kind>
<date>20030313</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Curtis</last-name>
<first-name>Bryce Allen</first-name>
<address>
<city>Round Rock</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Yee</last-name>
<first-name>Duke W.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>LaBaw</last-name>
<first-name>Jeffrey S.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Thomson</last-name>
<first-name>William</first-name>
<department>2194</department>
</primary-examiner>
<assistant-examiner>
<last-name>Hoang</last-name>
<first-name>Phuong N</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A methodology for using multiple execution threads to regulate message traffic is presented. An application thread spawns a limiter thread, and each have access in shared memory to a message count that reflects a number of messages that are transmitted by the application thread within a regulated time period. The limiter thread cycles by entering a sleep state for the regulated time period, resetting the message count upon awakening, and then reentering a sleep state. The application thread executes a loop that compares the message count against a maximum number of messages for the regulated time period; if the comparison is favorable, then another message is transmitted and the message count is adjusted. If the comparison is not favorable, then the application thread enters a sleep state; after awakening, it repeats the comparison, and depending on the result, it transmits a message or reenters a sleep state.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="230.97mm" wi="175.01mm" file="US07299470-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="253.24mm" wi="167.81mm" file="US07299470-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="245.96mm" wi="178.22mm" file="US07299470-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="259.67mm" wi="171.37mm" file="US07299470-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="229.79mm" wi="181.53mm" file="US07299470-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="154.60mm" wi="127.17mm" file="US07299470-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention relates to an improved data processing system and, in particular, to a method and apparatus for input/output processing. Still more particularly, the present invention provides a method and apparatus for implementing a mechanism for transferred data counting.</p>
<p id="p-0004" num="0003">2. Description of Related Art</p>
<p id="p-0005" num="0004">In many computing environments, a client-server arrangement enables clients and servers to have specialized duties. By limiting the variety of computational tasks with which a client or a server is burdened, the client or the server can focus its resources on performing its tasks more efficiently. In particular, servers are usually configured to process large numbers of client transactions or to manage storage on behalf of many clients within a network. Although efficient computational management increases the maximum possible load on a server, its computational resources are not limitless, and typically the load on the server is limited in some manner.</p>
<p id="p-0006" num="0005">For a variety of reasons, it is often desirable to be able to control the amount of traffic that is initiated by a client application to a server. For example, in order to determine the load performance of a Web server, the Web server may be tested by bombarding it with a large number of Web-based requests over a period of time. The requests can originate from a predetermined number of client processes that simulate the data traffic that the Web server would experience from a large number of Web browser applications. In this scenario, it is important to be able to accurately control the rate of requests that are sent to the Web server, thereby controlling the load that is experienced by the Web server, in order to obtain numerically accurate and meaningful measurements that can be used to predict Web server load characteristics under varying, real-life conditions.</p>
<p id="p-0007" num="0006">As another example, a communication service provider may sell communication services on a subscription basis in which different charges apply to different subscription service levels. Each subscription service level may limit the number of requests from a subscriber's data device to the communication service provider's server below a certain number of requests per time unit, e.g., one hundred requests per second or one thousand requests per minute, even though the available bandwidth may be much greater. In order to provide accurate service, the communication service provider needs to be able to accurately limit the rate of requests that are transmitted by a subscriber.</p>
<p id="p-0008" num="0007">Therefore, it would be advantageous to have a methodology for accurately limiting the rate of requests that are transmitted from a client to a server.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0009" num="0008">A method, a system, an apparatus, and a computer program product are presented for using multiple execution threads in a data processing system to regulate an amount of communication traffic that is generated by an application. An application thread generates data packets or messages to be transmitted, such as client requests to a server. The application thread spawns a limiter thread, and the application thread and the limiter thread have access to a message count variable in shared memory. The message count variable reflects a number of messages that are transmitted by the application thread within a specific time period, e.g., one second; the message count variable can be initially set to zero and subsequently incremented to show the number of messages that have been sent within the specific time period, or the message count variable can be set to a non-zero number and subsequently decremented to show the number of messages that remain to be sent within the specific time period.</p>
<p id="p-0010" num="0009">After the limiter thread has been spawned, it executes independent of the application thread except for the coordination between the threads through the message count variable. The limiter thread executes in a permanent loop in which it enters a sleep state for a previously specified time period, resets the message count variable upon awakening, and then reenters a sleep state. The limiter thread preferably sleeps for a time period that is equal to a regulated time period; for example, if one hundred messages may be sent in seven seconds, then the limiter thread would sleep for seven seconds. The limiter thread executes until it is killed by the application thread after the application thread has completed a phase in which it is attempting to transmit messages in a regulated fashion.</p>
<p id="p-0011" num="0010">While the limiter thread is cycling, the application thread is also executing a loop in which it is attempting to transmit messages. The application thread adjusts the message count variable for each message that is transmitted.</p>
<p id="p-0012" num="0011">However, before a message is transmitted, the application thread checks whether it is allowed to transmit another message by comparing the message count variable with a predetermined value that represents the maximum number of messages that may be sent within the predetermined regulated time period. If the comparison is favorable for transmitting another message, then the application thread transmits another message.</p>
<p id="p-0013" num="0012">If the comparison is not favorable for transmitting another message, then the application thread waits to transmit another message by entering a sleep state. The application thread preferably sleeps for a time period that is substantially shorter than the regulated time period. When the application thread awakens, it repeats the comparison of the message count variable and the maximum value. Depending on the result of the comparison, the application thread again performs the appropriate action.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, further objectives, and advantages thereof, will be best understood by reference to the following detailed description when read in conjunction with the accompanying drawings, wherein:</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1A</figref> is a block diagram that depicts a typical distributed data processing system in which the present invention may be implemented;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1B</figref> is a block diagram that depicts a typical computer architecture that may be used within a data processing system in which the present invention may be implemented;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> is a flowchart that depicts a methodology for implementing a communication traffic limiter that regulates the rate of transmission of messages from an application in accordance with the present invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> is a set of timelines that depict the manner in which an application thread and a limiter thread interoperate through the message count variable in shared memory to establish a limiter mechanism in accordance with the present invention;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> is a set of Java language statements that depict an example of a Limiter class that may be used to implement a limiter mechanism in accordance with an embodiment of the present invention; and</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 5</figref> depicts a set of Java language statements that show the use of a limiter mechanism in accordance with an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0021" num="0020">The present invention is directed to a system and a methodology for controlling the rate of communication traffic from an application to another application or system. As background, a typical organization of hardware and software components within a distributed data processing system is described prior to describing the present invention in more detail.</p>
<p id="p-0022" num="0021">With reference now to the figures, <figref idref="DRAWINGS">FIG. 1A</figref> depicts a typical network of data processing systems, each of which may contain and/or operate the present invention. Distributed data processing system <b>100</b> contains network <b>101</b>, which is a medium that may be used to provide communications links between various devices and computers connected together within distributed data processing system <b>100</b>. Network <b>101</b> may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone or wireless communications. In the depicted example, server <b>102</b> and server <b>103</b> are connected to network <b>101</b> along with storage unit <b>104</b>. In addition, clients <b>105</b>-<b>107</b> also are connected to network <b>101</b>. Clients <b>105</b>-<b>107</b> and servers <b>102</b>-<b>103</b> may be represented by a variety of computing devices, such as mainframes, personal computers, personal digital assistants (PDAs), etc. Distributed data processing system <b>100</b> may include additional servers, clients, routers, other devices, and peer-to-peer architectures that are not shown.</p>
<p id="p-0023" num="0022">In the depicted example, distributed data processing system <b>100</b> may include the Internet with network <b>101</b> representing a worldwide collection of networks and gateways that use various protocols to communicate with one another, such as Lightweight Directory Access Protocol (LDAP), Transport Control Protocol/Internet Protocol (TCP/IP), Hypertext Transport Protocol (HTTP), Wireless Application Protocol (WAP), etc. Of course, distributed data processing system <b>100</b> may also include a number of different types of networks, such as, for example, an intranet, a local area network (LAN), or a wide area network (WAN). For example, server <b>102</b> directly supports client <b>109</b> and network <b>110</b>, which incorporates wireless communication links. Network-enabled phone <b>111</b> connects to network <b>110</b> through wireless link <b>112</b>, and PDA <b>113</b> connects to network <b>110</b> through wireless link <b>114</b>. Phone <b>111</b> and PDA <b>113</b> can also directly transfer data between themselves across wireless link <b>115</b> using an appropriate technology, such as Bluetooth™ wireless technology, to create so-called personal area networks (PAN) or personal ad-hoc networks. In a similar manner, PDA <b>113</b> can transfer data to PDA <b>107</b> via wireless communication link <b>116</b>.</p>
<p id="p-0024" num="0023">The present invention could be implemented on a variety of hardware platforms; <figref idref="DRAWINGS">FIG. 1A</figref> is intended as an example of a heterogeneous computing environment and not as an architectural limitation for the present invention.</p>
<p id="p-0025" num="0024">With reference now to <figref idref="DRAWINGS">FIG. 1B</figref>, a diagram depicts a typical computer architecture of a data processing system, such as those shown in <figref idref="DRAWINGS">FIG. 1A</figref>, in which the present invention may be implemented. Data processing system <b>120</b> contains one or more central processing units (CPUs) <b>122</b> connected to internal system bus <b>123</b>, which interconnects random access memory (RAM) <b>124</b>, read-only memory <b>126</b>, and input/output adapter <b>128</b>, which supports various I/O devices, such as printer <b>130</b>, disk units <b>132</b>, or other devices not shown, such as a audio output system, etc. system bus <b>123</b> also connects communication adapter <b>134</b> that provides access to communication link <b>136</b>. User interface adapter <b>148</b> connects various user devices, such as keyboard <b>140</b> and mouse <b>142</b>, or other devices not shown, such as a touch screen, stylus, microphone, etc. Display adapter <b>144</b> connects system bus <b>123</b> to display device <b>146</b>.</p>
<p id="p-0026" num="0025">Those of ordinary skill in the art will appreciate that the hardware in <figref idref="DRAWINGS">FIG. 1B</figref> may vary depending on the system implementation. For example, the system may have one or more processors, including a digital signal processor (DSP) and other types of special purpose processors, and one or more types of volatile and non-volatile memory. Other peripheral devices may be used in addition to or in place of the hardware depicted in <figref idref="DRAWINGS">FIG. 1B</figref>. The depicted examples are not meant to imply architectural limitations with respect to the present invention.</p>
<p id="p-0027" num="0026">In addition to being able to be implemented on a variety of hardware platforms, the present invention may be implemented in a variety of software environments. A typical operating system may be used to control program execution within each data processing system. For example, one device may run a Unix® operating system, while another device may contain a simple Java® runtime environment. A representative computer platform may include a browser, which is a well known software application for accessing hypertext documents in a variety of formats, such as graphic files, word processing files, Extensible Markup Language (XML), Hypertext Markup Language (HTML), Handheld Device Markup Language (HDML), Wireless Markup Language (WML), and various other formats and types of files.</p>
<p id="p-0028" num="0027">The present invention may be implemented on a variety of hardware and software platforms, as described above. More specifically, though, the present invention is directed to a system and a methodology for controlling the rate of communication traffic that is transmitted by an application, as described in more detail below. In the following examples, an application is shown that generates a series or sequence of messages for one or more different purposes. The application can be understood to be a general-purpose application, but it should also be understood that the application may be constructed specifically for communication tasks. For example, the application could be specifically configured for simulating the transmission of requests from a Web browser application that is operating on a client device to a server that responds to the requests, in which case the limiter mechanism of the present invention could be employed in conjunction with the application to precisely control the rate of requests from the application. In another example, the application may be a Web browser application, and the limiter mechanism of the present invention may be employed in conjunction with the Web browser application as required by a communication service provider to control the rate of requests from the Web browser application in accordance with a subscribed level of service provided by the communication service provider to the Web browser's user.</p>
<p id="p-0029" num="0028">Messages from the application may be formatted in a proprietary manner or in accordance with well-known standards, e.g., HTTP Request messages. More generally, a message may be a simple data packet or a coordinated set of data packets that are transmitted by the application.</p>
<p id="p-0030" num="0029">The described application that uses the present invention operates in a computational environment that supports multiple threads of execution, multiple processes, or multiple tasks. For simplicity of discussion, the following examples are directed to a discussion of multiple threads, but it should be understood that the present invention may also be implemented in an operational environment with process management or task management. The application may comprise an application thread that generates message traffic, and the limiter mechanism of the present invention operates in conjunction with the application thread. Moreover, the present application may be implemented in an environment in which an operating system and/or a central processing unit (CPU) allow multiple simultaneous execution paths without regard to thread or process management.</p>
<p id="p-0031" num="0030">Alternatively, the application may comprise multiple threads of execution, a plurality of which generate message traffic, and multiple instances of the limited mechanism of the present invention could be implemented in conjunction with multiple application threads of execution. For simplicity of presentation, the following examples depict only a single application thread.</p>
<p id="p-0032" num="0031">With reference now to <figref idref="DRAWINGS">FIG. 2</figref>, a flowchart depicts a methodology for implementing a communication traffic limiter that regulates the rate of transmission of messages from an application in accordance with the present invention. The flowchart shown in <figref idref="DRAWINGS">FIG. 2</figref> differs from typical flowcharts in that two simultaneous processes are potentially executing during a given time period. The operations that are shown in <figref idref="DRAWINGS">FIG. 2</figref> center on an application thread that generates data packets or messages to be transmitted, such as client requests to a server. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, it is possible that the application thread has already been executing for some period of time, including a period of time in which the application thread has already transmitting some number of messages in a regulated fashion.</p>
<p id="p-0033" num="0032">The application thread spawns a limiter thread (step <b>202</b>), after which the application thread and the limiter thread have access to a message count variable in shared memory. The message count variable reflects a number of messages that have been transmitted by the application thread within a specific time period, e.g., one second. Alternatively, the message count variable reflects a number of messages that remain to be transmitted by the application thread within a specific time period. In other words, the message count variable can be initially set to zero and subsequently incremented to show the number of messages that have been sent within the specific time period, or the message count variable can be set to a maximum, non-zero number and subsequently decremented to show the number of messages that remain to be sent within the specific time period. In the following examples, it is assumed that the message count variable is incremented and then compared to a maximum value.</p>
<p id="p-0034" num="0033">The limiter mechanism of the present invention limits an application's message traffic based on its rate of transmission, i.e. number of messages per unit of time. The specific time value that is used as the regulated period may be statically or dynamically determined or adjusted based on configuration parameters, operating conditions, user input, or other considerations. For simplicity of presentation, the following examples assume that the regulated time period is one second.</p>
<p id="p-0035" num="0034">The maximum number of messages that may be transmitted per time unit may be statically or dynamically determined or adjusted based on configuration parameters, operating conditions, user input, or other considerations. For simplicity of presentation, the following examples assume that the maximum number of messages per time unit has been previously determined and is static during the time period of interest.</p>
<p id="p-0036" num="0035">After the limiter thread has been spawned, it executes independent of the application thread except for the coordination between the threads through the message count variable. The limiter thread executes in a permanent loop in which it enters a sleep state for a previously specified time period (step <b>204</b>), resets the message count variable upon awakening (step <b>206</b>), and then reenters a sleep state. The limiter thread preferably sleeps for a time period that is equal to a regulated time period; for example, if ten messages may be sent in one second, then the limiter thread would sleep for one second. The limiter thread executes until it is killed by the application thread after the application thread has completed a phase in which it is attempting to transmit messages in a regulated fashion.</p>
<p id="p-0037" num="0036">After an optional phase in which the application performs some type of initialization for the next round of message transmission (step <b>208</b>), the application thread is also executing a loop in which it is attempting to transmit messages while the limiter thread is cycling. The application thread adjusts the message count variable for each message that is transmitted. In <figref idref="DRAWINGS">FIG. 2</figref>, the message count variable is incremented prior to transmitting a message (step <b>210</b>); alternatively, the message count variable may be incremented after a message is transmitted.</p>
<p id="p-0038" num="0037">However, before a message is transmitted, the application thread checks whether it is allowed to transmit another message by comparing the message count variable with a predetermined value that represents the maximum number of messages that may be sent within the predetermined regulated time period (step <b>212</b>). If the comparison is favorable for transmitting another message, which in the example of <figref idref="DRAWINGS">FIG. 2</figref> means that the number of transmitted messages is less than the maximum threshold, then the application thread transmits another message (step <b>214</b>).</p>
<p id="p-0039" num="0038">If the comparison is not favorable for transmitting another message, then the application thread waits to transmit another message by entering a sleep state (step <b>216</b>). The application thread preferably sleeps for a time period that is substantially shorter than the regulated time period, i.e. a relatively short time period. For example, if the regulated time period is one second, then the application thread may sleep for one millisecond. When the application thread awakens, it repeats the comparison of the message count variable and the maximum value by looping back to step <b>212</b>. Depending on the result of the comparison, the application thread again performs the appropriate action.</p>
<p id="p-0040" num="0039">After transmitting a message at step <b>214</b>, a determination is made as to whether or not the application thread should continue to transmit messages (step <b>218</b>). For example, the application thread may have been tasked to transmit messages for a particular period of time, e.g. one hour, and the application thread could check a timer condition to determine whether it has exceeded the time period. As another example, the application thread may have been tasked to send a particular number of messages, and the application thread could check some type of counter condition to determine whether it has exceeded this number. Other conditions for limiting the operation of the application thread may be employed, and these conditions may be statically or dynamically determined or adjusted based on configuration parameters, operating conditions, user input, or other considerations.</p>
<p id="p-0041" num="0040">If the application thread should continue to send messages, then it branches back to step <b>210</b> to send at least one more message. If the application thread should not continue to send messages, then the application thread kills the limiter thread that it previously spawned (step <b>220</b>), and the process is complete.</p>
<p id="p-0042" num="0041">As mentioned briefly above, the examples herein depict only a single application thread. However, it should also be understood that the application thread and the limiter thread should not be restricted to being interpreted as existing in the execution space of a single process or of a single application. For example, in the embodiment described above, an application thread spawns a limiter thread so that the application may use the limiter mechanism of the present invention. In an alternative embodiment, the limiter thread may be spawned by an application or process other than the application that is using the limiter mechanism of the present invention. In this alternative scenario, a separate process may control one or more limiter threads for the use of applications that need a limiter mechanism. In this alternative embodiment, the application that is using the limiter mechanism can discover or be provided with the address of its message count variable in shared memory by the application or process that is controlling the limiter thread, thereby implying that the controlling application communicates or coordinates with the using application in some manner. In this manner, the application thread and the limiter thread may exist in different process spaces, and the message count variable may be interpreted as existing in shared memory that is accessible system-wide and not merely within a single process space.</p>
<p id="p-0043" num="0042">With reference now to <figref idref="DRAWINGS">FIG. 3</figref>, a set of timelines depict the manner in which an application thread and a limiter thread interoperate through the message count variable in shared memory to establish a limiter mechanism in accordance with the present invention. <figref idref="DRAWINGS">FIG. 3</figref> depicts some of the results of the actions that were described above with respect to <figref idref="DRAWINGS">FIG. 2</figref> by showing the application thread, the limiter thread, and the message count variable over a period of time; time increases from the top of <figref idref="DRAWINGS">FIG. 3</figref> to the bottom of <figref idref="DRAWINGS">FIG. 3</figref>. It should be noted that the timelines are not shown to scale.</p>
<p id="p-0044" num="0043">Message count <b>302</b> shows the values that the message count variable in shared memory may have over a period of time. In this example, the maximum number of messages that may be sent per time unit is “N”, and the limiter mechanism increments the message count variable. Hence, the message count begins at zero and increases to “N+1”, which is held for some period of time during which the transmission of messages ceases. After the transmission of messages resumes, then the incremental increase of the message count begins anew.</p>
<p id="p-0045" num="0044">The execution of application thread <b>304</b> is separated into two sets of time periods in accordance with a specific implementation of the present invention. In this example, it is assumed that generator/transmitter <b>306</b> of the application is responsible for the generation and transmission of messages <b>310</b>-<b>316</b>, whereas counter/delayer <b>320</b> is responsible for tracking the number of messages that have been transmitted while also delaying the further transmission of messages if the number of messages for the current time period would exceed the allowable threshold value. <figref idref="DRAWINGS">FIGS. 4-5</figref> show Java language statements that may be used to implement the present invention in accordance with the generator/transmitter and counter/delayer configuration shown in <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0046" num="0045">During time period <b>322</b>, generator/transmitter <b>306</b> calls a routine in counter/delayer <b>320</b> that initializes the message count variable in shared memory while also spawning limiter thread <b>324</b>. In a fashion similar to that described with respect to <figref idref="DRAWINGS">FIG. 2</figref>, limiter thread <b>324</b> enters its loop of execution in which relatively long periods of thread sleep, such as thread sleep periods <b>326</b> and <b>328</b>, are interrupted by short periods of execution in which the limiter thread resets the message count variable, such as write action <b>330</b>. In this manner, the message count variable can be accurately reset at the end or beginning of every regulated time period.</p>
<p id="p-0047" num="0046">Meanwhile, application thread <b>304</b> attempts to send messages without violating its specified rate of transmission. Prior to sending a message, the generator/transmitter checks with the counter/delay, which increments the message count variable, e.g., represented by write action <b>332</b>. As long as the message count has not exceeded the maximum threshold “N” during the given time period that is being tracked by the limiter thread, then the counter/delayer does not insert any delays into the transmission process, and the generator/transmitter can generate and transmit another message, such as message <b>314</b>.</p>
<p id="p-0048" num="0047">However, after write action <b>334</b>, the counter/delayer discovers that the message count has reached “N+1”, i.e. that another message transmission would violate the specified threshold “N”. Hence, the counter/delayer inserts a delay into the generation/transmission process by entering a relatively short thread sleep <b>336</b> that holds the operation of the generator/transmitter.</p>
<p id="p-0049" num="0048">Upon awakening of the application thread, the counter/delayer again checks the message count variable, and because the limiter thread has not yet reset the message count variable, the counter/delayer again enters another thread sleep period, shown as thread sleep <b>338</b>. The counter/delayer continues this cycle until the limiter thread has reset the message count with write action <b>330</b>.</p>
<p id="p-0050" num="0049">Write action <b>330</b> essentially indicates that the previous time period has ended and the application has entered a new time period to be considered as the current time period. Hence, upon awakening after write action <b>330</b>, the counter/delayer finds that the message count is not greater than the maximum message count for the current time period, and the counter/delayer does not enter a thread sleep. The counter/delayer returns execution control to the generator/transmitter, which is then free to generate and transmit message <b>315</b>. This cycling process may continue until the application thread determines that no further messages should be transmitted, as explained with respect to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0051" num="0050">With reference now to <figref idref="DRAWINGS">FIG. 4</figref>, a set of Java language statements depicts an example of a Limiter class that may be used to implement a limiter mechanism in accordance with an embodiment of the present invention. Statement <b>402</b> declares the Limiter class; Limiter objects of this class are shown in use in <figref idref="DRAWINGS">FIG. 5</figref>, which is described in more detail further below. The statements shown in <figref idref="DRAWINGS">FIG. 4</figref> merely illustrate some of the functionality that could be incorporated into a Limiter class, which may comprise additional attributes and methods other than those shown in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0052" num="0051">Statement <b>404</b> declares a “limiterThread” attribute for referencing the child thread to be spawned by the application thread. Statement <b>406</b> declares a “maxMessagesPerTimeUnit” attribute that reflects the maximum number of messages that can be transmitted by the application in a given period of time, i.e. the maximum allowable rate. Statement <b>408</b> declares a “messagecounter” variable that stores the number of messages that have been sent by the application; the “static” keyword ensures that the message count variable is a class variable, i.e. there is only one copy of the variable associated with the class rather than many copies of the variable associated with each instance of the class.</p>
<p id="p-0053" num="0052">Statement <b>410</b> defines a method for setting the maximum number of messages that can be transmitted by the application in a given period of time. Statement <b>412</b> defines a method to be called by the generator/transmitter portion of the code when it desires to spawn the limiter thread and start the limiter mechanism, whereas statement <b>414</b> defines a method to be called to kill the limiter thread and stop the limiter mechanism.</p>
<p id="p-0054" num="0053">Statement <b>416</b> defines a “counterDelayer” method for counting and delaying message transmission. Statement <b>418</b> increments the message count variable, whereas statement <b>420</b> determines if the message counter exceeds the maximum threshold for the current time period. If the threshold has been exceeded, then statement <b>422</b> causes the thread to enter a one millisecond sleep period.</p>
<p id="p-0055" num="0054">Statement <b>424</b> defines the “run( )” method for the Limiter class. Statement <b>402</b> declares that the Limiter class implements the “Runnable” interface. To create a thread, one can pass a “Runnable” object, i.e. an object that implements the “Runnable” interface by defining a “run( )” method, to the “Thread” constructor. A “run( )” method of a “Runnable” object is the “body” of the thread; it begins executing when the “start( )” method of the “Thread” object is called and continues to run until it returns or until the “stop( )” method of its “Thread” object is called. Statement <b>426</b> ensures that the “run( )” method enters an infinite “while” loop and does not return; hence, the method can only be halted by calling “stop( )” on the thread instance. Within this loop, statement <b>428</b> causes the “Thread” object to enter a one second (one thousand milliseconds) thread sleep; after exiting the thread sleep, statement <b>430</b> resets the message counter variable to zero.</p>
<p id="p-0056" num="0055">With reference now to <figref idref="DRAWINGS">FIG. 5</figref>, a set of Java language statements depicts the use of a limiter mechanism in accordance with an embodiment of the present invention. <figref idref="DRAWINGS">FIG. 5</figref> shows the use of a limiter mechanism as implemented in the Limiter class shown in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0057" num="0056">An application that implements the present invention uses at least two threads of execution: an application thread and a limiter thread. As mentioned briefly with respect to <figref idref="DRAWINGS">FIG. 3</figref>, with respect to execution flow, the application thread can be considered to be divided into a message generator/transmitter and a counter/delayer. As shown in <figref idref="DRAWINGS">FIG. 4</figref>, most of the functionality with respect to the limiter mechanism of the present invention can be embodied into a single limiter class: the functionality for the counter/delayer; the functionality for spawning a limiter thread; and the functionality for the body of the limiter thread.</p>
<p id="p-0058" num="0057">After an optional initialization phase or possibly a prior message transmission phase in the application, statement <b>502</b> instantiates a new Limiter object, and statement <b>504</b> calls its “start( )” method, which spawns the limiter thread. At this point, the application now has a distinct application thread and a distinct limiter thread, and the limiter thread is executing the its “run( )” method.</p>
<p id="p-0059" num="0058">The application thread continues execution with statement <b>506</b>, which sets the maximum number of messages that may be transmitted in a given time period.</p>
<p id="p-0060" num="0059">The application thread then enters an execution loop that can be considered to be the generator/transmitter portion of the application thread. Statement <b>508</b> checks a “done” variable to determine whether the application should cease generating and transmitting messages; as explained with respect to <figref idref="DRAWINGS">FIG. 2</figref>, there may be many conditions that are placed on the application as to the manner in which message transmission is controlled in a greater sense. Within this execution loop, statement <b>510</b> calls the routine within the limiter object created by statement <b>502</b>. The call to the “counterDelayer( )” method essentially notifies the method that another message needs to be transmitted, thereby allowing the “counterDelayer( )” method to increment the message count variable and to determine whether it should stall the transmission of messages by entering a series of short thread sleeps. When statement <b>512</b> is reached, the application has no restrictions on its message transmission ability, so the next message is generated and transmitted.</p>
<p id="p-0061" num="0060">Statement <b>514</b> can be used to catch an exception that could be thrown by the “counterDelayer( )” routine; for example, the “counterDelayer( )” method could be alternatively written to throw an exception when the expiration of an additional, relatively long timer indicates a condition in which the application has stalled for too long while waiting for the limiter thread to reset the message count variable. Other potential error conditions may also be considered within the Limiter object.</p>
<p id="p-0062" num="0061">At some point in time, the application thread will exit the execution loop controlled by statement <b>508</b>, at which point the limiter thread is no longer needed. Statement <b>516</b> kills the limiter thread by calling the “stop( )” method of the limiter object.</p>
<p id="p-0063" num="0062">The advantages of the present invention should be apparent in view of the detailed description of the invention that is provided above. The present invention allows the message traffic from a client to be regulated by controlling the rate of requests, i.e. the number of requests per time unit, that are issued by a client application. The number of requests per time unit is controlled by a limiter thread that is separate from the application thread that is generating the communication traffic. The two threads may spend a majority of their existence in a sleep state, thereby conserving execution time for other processes.</p>
<p id="p-0064" num="0063">The regulator mechanism of the present invention can be implemented in scenarios for which there is a desire to limit communication traffic at the application level, whether between two applications or between two systems. In one example scenario, a Web-server-load-test application can be constructed by employing a plurality of Web browser simulators, each of which generate and send requests to a server, and the rate of requests from each simulator can be accurately controlled by the limiter of the present invention. By increasing the accuracy of the simulation of client communication traffic, the accuracy of the entire load-test simulation can be increased.</p>
<p id="p-0065" num="0064">It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that some of the processes associated with the present invention are capable of being distributed in the form of instructions in a computer readable medium and a variety of other forms, regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include media such as EPROM, ROM, tape, paper, floppy disc, hard disk drive, RAM, and CD-ROMs and transmission-type media, such as digital and analog communications links.</p>
<p id="p-0066" num="0065">The description of the present invention has been presented for purposes of illustration but is not intended to be exhaustive or limited to the disclosed embodiments. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiments were chosen to explain the principles of the invention and its practical applications and to enable others of ordinary skill in the art to understand the invention in order to implement various embodiments with various modifications as might be suited to other contemplated uses.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method in a data processing system for regulating an amount of generated communication traffic using multiple execution threads or processes in a data processing system, the method comprising:
<claim-text>starting a first thread or process and a second thread or process, wherein the first thread or process and the second thread or process access a message count variable in shared memory, wherein the message count variable represents a number of messages that are transmitted by the first thread or process within a first time unit;</claim-text>
<claim-text>sleeping the second thread or process for the first time unit;</claim-text>
<claim-text>in response to an awakening of the second thread or process, resetting the message count variable by the second thread or process and re-sleeping the second thread or process for the first time unit;</claim-text>
<claim-text>comparing the message count variable with a predetermined count value on the first thread or process;
<claim-text>in response to a first comparative result, sleeping the first thread or process for a second time unit;</claim-text>
<claim-text>in response to an awakening of the first thread or process, repeating the comparison step on the first thread or process; and</claim-text>
<claim-text>in response to a second comparative result, adjusting the message count variable and transmitting a message on the first thread or process.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>stopping the second thread or process after the first thread or process has completed its transmission of messages.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the second time unit is shorter than the first time unit.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the second thread or process resets the message count variable to zero and the first thread or process adjusts the message count variable by incrementing the message count variable.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the second thread or process resets the message count variable to a non-zero number and the first thread or process adjusts the message count variable by decrementing the message count variable.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. An apparatus for regulating an amount of generated communication traffic using multiple execution threads, the apparatus comprising:
<claim-text>means for starting a first thread and a second thread, wherein the first thread and the second thread access a message count variable in shared memory, wherein the message count variable represents a number of messages that are transmitted by the first thread within a first time unit;</claim-text>
<claim-text>means for comparing the message count variable with a predetermined count value on the first thread;</claim-text>
<claim-text>means for sleeping the first thread for a second time unit in response to a first comparative result;</claim-text>
<claim-text>means for repeating the comparison step on the first thread in response to an awakening of the first thread or process;</claim-text>
<claim-text>means for adjusting the message count variable in response to a second comparative result; and</claim-text>
<claim-text>means for transmitting a message on the first thread in response to a second comparative result.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref> further comprising:
<claim-text>means for sleeping the second thread for the first time unit;</claim-text>
<claim-text>means for resetting the message count variable by the second thread in response to an awakening of the second thread; and</claim-text>
<claim-text>means for re-sleeping the second thread for the first time unit in response to an awakening of the second thread.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
