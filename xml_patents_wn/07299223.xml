<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299223-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299223</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10893547</doc-number>
<date>20040715</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>566</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707  4</main-classification>
<further-classification>707  3</further-classification>
<further-classification>707101</further-classification>
</classification-national>
<invention-title id="d0e53">Spreadsheet to SQL translation</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6385604</doc-number>
<kind>B1</kind>
<name>Bakalash et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6631497</doc-number>
<kind>B1</kind>
<name>Jamshidi et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2005/0187952</doc-number>
<kind>A1</kind>
<name>Werner</name>
<date>20050800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00004">
<othercit>Witkowski et al. (“Spreadsheets in RDBMS for Olap”, ACM, Jun. 2003, pp. 52-63).</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00005">
<othercit>Oracle User's Guide, Release 6.3, Oct. 1999, Part No. A73223<sub>—</sub>01, Oracle Express Spreadsheet Add-In (42 pgs).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00006">
<othercit>Hyperion Solutions Corporation, “Hyperion Analyzer Release 6.5, Managing OLAP and Relational Data with SQL Queries” (2003) (33 pgs).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>SAP, “SAP and Microsoft announce their first joint product. Microsoft and SAP: Revolutionizing How Information Workers Access Enterprise Business Applications” http://www.sap.com/solutions/mendocino/index.epx, printed Jul. 19, 2005 (2 pgs).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>Microsoft Office, “Mendocino Version 1.0 (features, functionality and timing of the release can change without notice) Improve the efficiency of your organization's decision making process, utilize and interact with SAP data, seamlessly participate in best-practice mySAP ERP processes—all from a familiar Microsoft Office Professional 2003 user Interface” (2 pgs).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00009">
<othercit>“Providing Microsoft-SAP Technical Guidance”, http://www.microsoft-sap.com/technology/aspx, printed Jul. 19, 2005 (1 pg).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00010">
<othercit>“Introducing the Microsoft Office Information Bridge Framework”, http://msdn.microsoft.com/office/understanding/ibframework/gettingstarted/default.aspx?p. . . , printed Jul. 19, 2005 (10 pgs).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00011">
<othercit>“SAPGenie.com -&gt; Interfaces -&gt; Interfaces -&gt; The Mendocino Project”, http://www.sapgenie.com/interfaces/mendocino.htm, printed Jul. 19, 2005 (2 pgs).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00012">
<othercit>Witkowski, Andrew et al.; “Business Modeling Using SQL Spreadsheets”; 2003, <i>Proceedings of the 29th VLDB Conference</i>, pp. 1-4.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60487685</doc-number>
<kind>00</kind>
<date>20030716</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050039114</doc-number>
<kind>A1</kind>
<date>20050217</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Namait</last-name>
<first-name>Aman</first-name>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Waingold</last-name>
<first-name>Allison</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Roth</last-name>
<first-name>Martin</first-name>
<address>
<city>Ashland</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Witkowski</last-name>
<first-name>Andrew</first-name>
<address>
<city>Foster City</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Young Law Firm, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle International Corporation</orgname>
<role>02</role>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Hwang</last-name>
<first-name>Joon Hwan</first-name>
<department>2166</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Users can create computational models in a spreadsheet application and automatically apply the model to data stored in a relational database. By importing a sample of the data from a database table into the spreadsheet application, users can build spreadsheet models that perform analysis and computations on the sample data. Once the model is complete, the spreadsheet model is translated into an SQL format model understood by the database. The SQL model can operate on the entire data set in the database, rather than just the sample data used to construct the model. The SQL model and its associated data are stored in the database, and the model can be executed on a different sets of data. A web browser based front-end allows model users to access the SQL model via a web browser, eliminating the need for model users to have a spreadsheet application.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="214.55mm" wi="171.87mm" file="US07299223-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="251.71mm" wi="172.64mm" file="US07299223-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="198.80mm" wi="165.61mm" file="US07299223-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="234.19mm" wi="173.06mm" file="US07299223-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="240.62mm" wi="79.16mm" file="US07299223-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims priority to U.S. Provisional Patent Application No. 60/487,685, entitled “Spreadsheet to SQL Translation” and filed Jul. 16, 2003, and incorporates by reference this provisional patent application for all purposes.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates to the field of software applications generally, and specifically to the implementation of financial applications. Enterprise businesses store large amounts of financial data in relational databases and analysis models in spreadsheet programs, like Microsoft Excel. Enterprise business often need to analyze the data in their database. Financial models are widely used in businesses to evaluate business transactions, project feasibility, management decisions, and potential sales or purchases.</p>
<p id="p-0004" num="0003">One standard technique for performing data analysis is to import data from a relational database into a spreadsheet to create analytical models and reports. Spreadsheet applications are relatively simple to learn and are widely used by businesspeople for a variety of applications. Despite their advantages, spreadsheet-based financial models have numerous limitations:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0004">Data may change in the relational database due to transactions. Each time data in the database changes, the data must be reimported to spreadsheet so that the model reflects the new data. Additionally, the financial data often needs to be transformed or summarized from its from its native form in the database into a format used by the spreadsheet model. This process of transforming and importing is not only time consuming but often requires additional programming.</li>
    <li id="ul0001-0002" num="0005">Spreadsheet programs typically have a limit on the amount of data that can be imported and manipulated. For instance, Microsoft Excel only allows 65535 rows of data. This is far smaller than the amount of data that may potentially reside in a relational database table, which can have millions of rows of data. For large data sets, users cannot operate spreadsheet models directly on raw transactional data.</li>
    <li id="ul0001-0003" num="0006">There is no centralized repository for models, so spreadsheets may be segmented and isolated throughout a company. They may be lying around on file servers, local disks, emails, etc and they are difficult to manage. There is no way to separate out the logic in terms of the computational model of the spreadsheet represented by formulas from its data content.</li>
    <li id="ul0001-0004" num="0007">There are no programs that automatically map the free-form spreadsheet view of data into the more structured format of a relational database.</li>
    <li id="ul0001-0005" num="0008">Model designers have no control over users changing the computation model.</li>
    <li id="ul0001-0006" num="0009">Each user of a spreadsheet model must have their own licensed copy of the spreadsheet application, making it very expensive to deploy models to a large number of users.</li>
</ul>
</p>
<p id="p-0005" num="0010">To combat these problems, analysis tools have been created that allow users to model analyses on relation databases, outside of a spreadsheet program. However, this requires a user to learn to use a new tool which is much more complex than a spreadsheet.</p>
<p id="p-0006" num="0011">It is desirable to develop a system for creating financial models that combines the ease of use of spreadsheet-based models with the full capabilities of a relational database. It is further desirable for the resulting model to be able to be rapidly and inexpensively distributed to model users and to store model data values for analysis by managers and model designers.</p>
<heading id="h-0003" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0007" num="0012">The invention allows users to create computational models in a spreadsheet application using a familiar language/tool on data stored in a relational database. A user can import a sample of the data from a database table into the spreadsheet application. Users can then build spreadsheet models that perform analysis and computations on the sample data. Once the model is complete, the spreadsheet model can be translated into an SQL format model understood by the database. The SQL model can operate on the entire data set in the database, rather than just the sample data used to construct the model. The SQL model and its associated data are stored separately in the database, allowing the model to be executed on a different set of data. In a further embodiment, a web browser based front-end allows model users to access the SQL model via a web browser, eliminating the need to purchase large numbers of spreadsheet licenses.</p>
<p id="p-0008" num="0013">The invention has the advantages of the ease of use associated with using spreadsheet applications to build models combined with the capabilities of a relational database to operate on large data sets. During model construction, users can quickly model computations on small sets of data to ensure the model is operating correctly and then automatically scale the model to large data sets when the model is complete. As the SQL model operates directly on the data in the database, there is no need for any time-consuming importation of large volumes of data or data conversion. Storing the model in the database allows for a centralized repository of models and model data. Further, model designers can prevent users from changing the model.</p>
<p id="p-0009" num="0014">In an embodiment, a system for implementing a spreadsheet model in a database comprises a modeling module adapted to interface with a spreadsheet application and to retrieve a set of sample data from a database. The set of sample data corresponds with a portion of a full data set within the database. A persistence module adapted to interface with the spreadsheet application and to store a set of spreadsheet operations referencing the set of sample data in the database. A translation module adapted to translate the set of spreadsheet operations into a model database query, such that the model database query performs the set of spreadsheet operations on a full data set in the database.</p>
<p id="p-0010" num="0015">In a further embodiment, the translation module is further adapted to store the model database query in the database. In another embodiment, the modeling module is adapted to associate a name and a database query specifying the full data set within the database with the set of sample data. In an additional embodiment, the system includes a web front-end adapted to create a web page from the results of the model database query on the database. The web page includes a user interface adapted to collect input data from a model user. In still another embodiment, an instance generator is adapted to create an instance of the model from the model database query and to store the instance of the model and the input data in the database.</p>
<p id="p-0011" num="0016">In an additional embodiment, the set of spreadsheet operations include a reference to the name associated with the set of sample data, and the translation module is further adapted to match the name associated with the set of sample data with the database query specifying the full data set. The translation model then creates a model database query applying the set of operations to the full data set specified by the database query. In yet another embodiment, the model database query is an SQL spreadsheet rule.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0017">The invention will be described with reference to the drawings, in which:</p>
<p id="p-0013" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a example system suitable for implementing an embodiment of the invention;</p>
<p id="p-0014" num="0019"><figref idref="DRAWINGS">FIG. 2</figref> illustrates the different components of an embodiment of the invention;</p>
<p id="p-0015" num="0020"><figref idref="DRAWINGS">FIG. 3</figref> illustrates the database tables used as a data model for an embodiment of the invention; and</p>
<p id="p-0016" num="0021"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a method for displaying a model as a web page according to an embodiment of the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0017" num="0022"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a system <b>100</b> for implementing the web front-end <b>240</b> according to an embodiment of the invention. In this embodiment, system <b>100</b> includes a model designer computer <b>105</b>. Model designer computer <b>105</b> can be a general purpose personal computer having a spreadsheet application, for example Microsoft Excel™, for creating a spreadsheet model. Model designer computer <b>105</b> can also include other software applications, such as web browsers, word processors, and/or web page design application, used to create the spreadsheet model and any associated templates.</p>
<p id="p-0018" num="0023">System <b>100</b> also includes user computers <b>110</b> and <b>115</b>. User computers <b>110</b> and <b>115</b> can be general purpose personal computers having web browser applications. Alternatively, user computers <b>110</b> and <b>115</b> can be any other electronic device, such as a thin-client computer, Internet-enabled mobile telephone, or personal digital assistant, capable of displaying and navigating web pages or other types of electronic documents. Although system <b>100</b> is shown with two user computers, any number of user computers can be supported.</p>
<p id="p-0019" num="0024">A web server <b>125</b> is used to process requests for web pages or other electronic documents from user computers <b>110</b> and <b>115</b>. In an embodiment of the invention, all model user interaction with the web front-end <b>240</b> is via web pages sent to user computers via the web server <b>125</b>. In a further embodiment, the model designer computer <b>105</b> transfers the completed spreadsheet model to the web front-end generator via a web page provided by the web server <b>125</b>.</p>
<p id="p-0020" num="0025">Web front-end server <b>130</b> operates the web front-end. In an embodiment, the web front-end server <b>130</b> is a general purpose computer capable of executing programs or scripts in response to the user computers <b>110</b> and <b>115</b>, as well as model designer computer <b>105</b>. The web front-end <b>240</b> can be implemented as one or more scripts or programs written in any programming language, such as Java™, C, or C++, or any scripting language, such as Perl, Python, or TCL.</p>
<p id="p-0021" num="0026">In an embodiment, the web front-end server <b>130</b> dynamically creates web pages for collecting input data and displaying output data. The web pages created by the web front-end server <b>130</b> are forwarded to the user computers via web server <b>125</b>. Similarly, web server <b>125</b> receives web page requests and input data from the user computers <b>110</b> and <b>115</b>, and forwards the web page requests and input data to web front-end server <b>130</b>.</p>
<p id="p-0022" num="0027">As the web front-end <b>240</b> on web front-end server <b>130</b> processes model data and user computer requests, model data can be stored or retrieved from model database <b>135</b>. Model database <b>135</b> stores the model and its associated data objects, such as calculator objects, and the set of cell objects. Model database <b>135</b> also stores model data values associated with each model instance of the web front-end <b>240</b> and reports created by the model application. In an embodiment, the web front-end <b>240</b> on the web front-end server <b>130</b> can retrieve any previously stored data, including models, model data, and reports from the model database <b>135</b> at any time. This allows model users to modify or update model data, and further permits managers and model designers to analyze model data.</p>
<p id="p-0023" num="0028">An electronic communication network <b>120</b> enables communication between computers <b>105</b>, <b>110</b>, and <b>115</b>, web server <b>125</b>, web front-end server <b>130</b>, and model database <b>135</b>. In an embodiment, network <b>120</b> may further include any form of electrical or optical communication devices, including wireless and wired networks. Network <b>120</b> may also incorporate one or more local-area networks, such as an Ethernet network; wide-area networks, such as the Internet; and virtual networks, such as a virtual private network.</p>
<p id="p-0024" num="0029">The system <b>100</b> is one example of executing a software application for visualizing visitor usage information according to an embodiment of the invention. In another embodiment, web front-end server <b>130</b>, web server <b>125</b>, and optionally model database <b>135</b> can be combined into a single server computer system. In alternate embodiment, all or a portion of the web front-end functions may be integrated into an application running on the model designer computer or the user computer. For example, the web front-end generator can be integrated into a spreadsheet application on the model designer computer. In another example, a Java™ or JavaScript™ application on the user computer is used to compute model data or display portions of the web front-end.</p>
<p id="p-0025" num="0030"><figref idref="DRAWINGS">FIG. 2</figref> shows the organization of the components of an embodiment of the invention. In this embodiment, a model designer user <b>200</b> creates a model using a spreadsheet application <b>205</b>, for example Microsoft Excel or any other spreadsheet application. The spreadsheet application <b>205</b> can be hosted on the computer of the model designer user <b>200</b> or on another computer connected via a data network.</p>
<p id="p-0026" num="0031">The spreadsheet application <b>205</b> is interfaced with a modeling add-on component <b>210</b>. The modeling add-on component <b>210</b> allows users to model using a sample of data from a relational database. The imported data can be filtered using spreadsheet application's <b>205</b> advanced filtering criteria. Users can then create models on the sample data using the usual spreadsheet formulas. The modeling component <b>210</b> uses spreadsheet named ranges to bridge the positional aspects of spreadsheet application <b>205</b> to the relational model of a relational database <b>225</b>.</p>
<p id="p-0027" num="0032">The spreadsheet application <b>205</b> is also interfaced with a persistence component <b>220</b>. The persistence component <b>220</b> persists metadata about the imported and filtered data in the spreadsheet application <b>205</b>. The persistence component also persists the model created by the user <b>200</b> in the spreadsheet application <b>205</b>, which includes the user-defined formulas and additional data values. The persistence component <b>220</b> stores this metadata in the relational database <b>225</b>.</p>
<p id="p-0028" num="0033">A spreadsheet to SQL translator <b>230</b> is interfaced with the relational database <b>225</b>. The translator <b>230</b> reads from the relational database <b>225</b> the stored metadata representing the model, for example the user-defined formulas and additional data, and translates them to one or more SQL spreadsheet queries. This translation allows a relational database to understand the computational model created by the user <b>200</b> in the spreadsheet application <b>205</b>.</p>
<p id="p-0029" num="0034">After a model designer has persisted a spreadsheet model, model users can create separate instances of the spreadsheet model with their own model data. This allows users to execute a copy of the model with their own specific inputs and outputs.</p>
<p id="p-0030" num="0035">In an embodiment, a web front-end <b>240</b> allows a model user to view and manipulate data in the model. When a model user accesses the model for the first time, the instance generator <b>235</b> creates a new instance of the model to store the model user's specific inputs and outputs. The instance generator <b>235</b> can create additional instances of the model to store additional sets of model data for a model user. Values that are computed from formulas can be viewed, and the input values to those formulas can be edited. Furthermore, the model users do not require an spreadsheet application (or the expense of its associated license) to view and manipulate the model.</p>
<p id="p-0031" num="0036">In an embodiment, the web front end <b>240</b> creates a web page, which is then sent to a model user's web browser by web server <b>245</b>. The web server <b>245</b> may be hosted on a separate system than the model user's web browser. In response to a model user request, the web server <b>245</b> accesses the instance generator <b>235</b> to create a new instance of the model. The web server <b>245</b> also accesses the translator <b>230</b> to store model user inputs values for a model user's instance of the model, to compute the results of formulas from the model user's input values, and to retrieve model outputs for the model user's instance.</p>
<p id="p-0032" num="0037">Thus, the system of <figref idref="DRAWINGS">FIG. 2</figref> allows model designer users to create computational models in the spreadsheet application <b>205</b> on data stored in a relational database. A user <b>200</b> can import a sample of the data from the relational database <b>225</b> into the spreadsheet application <b>205</b> via the modeling component <b>210</b>. The sample data may only be a small portion of the data stored in the relational database <b>225</b>. The model designer user <b>200</b> creates the model computations on the sample data and persists to the relational database <b>225</b>. Once persisted in the relational database <b>225</b>, the model computations can be applied to the entire table or set of data in the relational database <b>225</b> as a SQL query. This embodiment of the invention also allows model users to view the result of the computation from a web front-end <b>240</b>.</p>
<p id="p-0033" num="0038">The modeling and persistence component <b>210</b> is an add-on to a spreadsheet application. Model designer users <b>200</b> can import and filter database data using the modeling add-on. Model designer users <b>200</b> can write formulas using the imported data as well as user-entered spreadsheet data in the manner typically used in spreadsheet applications. The Model designer users <b>200</b> can then save the model to the database using the persistence add-on <b>220</b>. The persistence component <b>220</b> stores the formulas defining the model to the relational database <b>225</b>, as well as information about the imported and filtered data. The translation component <b>230</b> translates this stored spreadsheet model into a relational SQL statement, or clause, and stores the clause in the database as well.</p>
<p id="p-0034" num="0039">When a model user wants to view or manipulate the model from the web, the web front-end <b>240</b> generates an instance of the model. In an embodiment, the instance generator <b>235</b> is interfaced with the relational database <b>225</b>. It uses the stored SQL MODEL clause to generate a view of the database data for a particular instance. Then the web front-end <b>240</b> reads the data from the view, and displays to the model user. For example, cells containing numeric values are rendered as inputs. The model user can change these values and recompute the spreadsheet. When they recompute the spreadsheet, the values are stored to the database and the view is recomputed.</p>
<p id="p-0035" num="0040">The implementation of the components of this embodiment of the invention are discussed in more detail as follows. In an embodiment, the modeling component <b>210</b> is an spreadsheet add-on written in VBA (Visual Basic for Applications). This component <b>210</b> allows users to import a sample of data from a relational database <b>225</b>. The imported data can be filtered using spreadsheet's <b>205</b> advanced filtering criteria. Users can then create models on the sample data using the spreadsheet formula capabilities built into the spreadsheet application <b>205</b>.</p>
<p id="p-0036" num="0041">To import data from a relational database <b>225</b>, a user specifies a name for the imported data, a sample size, and a SQL query. Based on the sample size and SQL query, a portion of data from the relational database <b>225</b> is imported into the currently opened workbook in the spreadsheet application <b>205</b>. The cell range containing that data is named by the name provided, using spreadsheet's named cells capability. The named cells capability allows the spreadsheet application <b>205</b> to access cells by referencing a name, rather than row and column information. Further, each column of the imported data is given a name based on the provided name and the column name for the data from the database <b>225</b> (name column).</p>
<p id="p-0037" num="0042">For instance, a user might want to import a sample of 10 rows from the sales table, and call the range “sales”. In this case, the user would provide the data:
<ul id="ul0002" list-style="none">
    <li id="ul0002-0001" num="0043">Sample size: 10</li>
    <li id="ul0002-0002" num="0044">Name: sales</li>
    <li id="ul0002-0003" num="0045">SQL Query: select*from sales</li>
</ul>
</p>
<p id="p-0038" num="0046">Continuing with this example, suppose that the sales table in the database <b>225</b> contained columns called ID, PRODUCT, REGION, QTY, LIST_PRICE, and SUBTOTAL. Then the import would create a named range “sales” for the entire range of data, as well as named ranges “sales.id”, “sales.product”, “sales.subtotal”, etc. Each named range in the spreadsheet application <b>205</b> corresponds to one of the columns in the sales table in the database <b>225</b>. In creating the model, model designer users <b>200</b> can refer to the data in the subtotal column (as an aggregate) as “sales.subtotal”. To sum up all of the sales data, the model designer user <b>200</b> could enter the spreadsheet formula “=sum(sales.subtotal)” into a cell of the spreadsheet in the spreadsheet application <b>205</b>. Within the spreadsheet, this formula would compute the sum for the imported sample data.</p>
<p id="p-0039" num="0047">Model designer users <b>200</b> can also filter imported data, using criteria supported by spreadsheet's advanced filtering feature. To filter data, the user <b>200</b> supplies a name for the filtered data, the named range to filter, the criteria to filter by, and a location to store the filtered data. This is similar to the spreadsheet applications <b>205</b> advanced filtering mechanism, except that the input data must be a named range from either imported data or previously filtered imported data. The input range is filtered according to the specified criteria, and the output cell range is given the specified name. In addition, each column in the output range is given a name (name column) as described above.</p>
<p id="p-0040" num="0048">For example, a model designer user <b>205</b> might want to filter the imported sales data to only include sales for EMEA region (that is, rows where REGION=“EMEA”), and call the resulting data “EMEASales”. After applying this filter, the user <b>200</b> can sum up the subtotals for all EMEA sales with the formula “=sum(EMEASales.subtotal)”. In the spreadsheet application <b>205</b>, this formula will show the sum of the EMEA data in the sample.</p>
<p id="p-0041" num="0049">Another feature supports pivot operations, like the spreadsheet pivot table feature. This allows model designer users <b>200</b> to compute aggregate functions on the data in a range, grouped by a particular column's value. This is similar to a GROUP BY clause in SQL. This allows, for example, a user <b>200</b> to compute sales subtotals for each region.</p>
<p id="p-0042" num="0050">After importing, filtering and pivoting data, the model designer user <b>200</b> can apply aggregate functions to the data by using the range names. When the model is persisted in the database <b>225</b> and executed, the same functions defined in the model in the spreadsheet application will be applied to the entire data set in the database <b>225</b>. In other words, the execution of the model will behave as if the entire table were imported rather than just a sample. Continuing with the example discussed above, the formula “=sum(sales.subtotal)” statement in the spreadsheet would be executed in the database to compute the sum of all subtotals in the sales table, not merely the 10 entries selected as the sample size.</p>
<p id="p-0043" num="0051">The persistence component <b>220</b> persists information about the imported and filtered data, and the additional formulas and data values in the spreadsheet. It also keeps track of all the named ranges created by the user, corresponding SQL, and its location. When a model designer user persists a model, several steps take place:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0052">1. A new spreadsheet entry is inserted into the spreadsheets table. The title of the model is the name of the persisted file, and the owner is the Windows username that the file belongs to.</li>
    <li id="ul0003-0002" num="0053">2. Each cell in the spreadsheet that was not imported from a database is persisted to the cells table. The location, formula, and value of the cell are stored.</li>
    <li id="ul0003-0003" num="0054">3. Each named range that was created by importing or filtering data is persisted. For imports, the name and SQL query are stored. For filtered data, the name, parent data (the named range that was filtered), and the SQL condition are stored. The SQL condition is computed from the Spreadsheet filter criteria. Some additional data is persisted that allows the state of the Spreadsheet to be recreated from the database.</li>
    <li id="ul0003-0004" num="0055">4. The Spreadsheet to SQL translator <b>230</b> is invoked.</li>
</ul>
</p>
<p id="p-0044" num="0056">As discussed above, the spreadsheet to SQL translator <b>230</b> reads the persisted formulas and import/filter data, and translates it to a SQL spreadsheet query. In an embodiment, the translator <b>230</b> is implemented as a Java stored procedure. After a spreadsheet model is persisted, the persistence component <b>220</b> invokes the translator <b>230</b>. The translator <b>230</b> reads and parses the cell formulas, and named range information, and generates a SQL spreadsheet query that represents the formula computation. The generated query is not a complete query, because the full query depends on the values stored for a particular spreadsheet instance. This partial query is stored in the spreadsheet_view_text table, which is discussed below with reference to <figref idref="DRAWINGS">FIG. 3</figref>. This allows for reusability of the generated SQL to prevents reparsing when another user requests an instance of the model. The translation from spreadsheet formulas to a SQL spreadsheet query is described in more detail below.</p>
<p id="p-0045" num="0057">After a model designer has persisted a spreadsheet model, other model users can create an instance of the spreadsheet. Initially an instance of the spreadsheet contains all of the data entered by the model designer, and the computed values from the formulas in the model. Then the model user can replace input values in the model and recompute the computed values of the model.</p>
<p id="p-0046" num="0058">In an embodiment, the instance generator <b>235</b> is implemented as a Java stored procedure in the relational database <b>225</b>. Creating an instance involves the following steps:
<ul id="ul0004" list-style="none">
    <li id="ul0004-0001" num="0059">1. Insert a row into spreadsheet_instances, containing the title and owner, and which spreadsheet it is an instance of.</li>
    <li id="ul0004-0002" num="0060">2. Create entries in cell_values for each cell in the spreadsheet. The values of the cell_values initially are the default_value for the corresponding cell.</li>
    <li id="ul0004-0003" num="0061">3. Create a view containing the SQL MODEL clause to compute the formulas. The partial SQL query for the spreadsheet is retrieved, and used to create a view specifically for the instance.</li>
</ul>
</p>
<p id="p-0047" num="0062">The web front-end <b>240</b> allows an instance user to view and manipulate data in the model using a web browser. Values that are computed from formulas can be viewed, and the input values to those formulas can be edited. This allows users to edit input values without any potential for changes to the underlying model (formulas) being introduced. Furthermore, the model user does not require an spreadsheet license to view and manipulate the model. In an embodiment, the web front-end <b>240</b> is implemented as a JSPs and Java classes.</p>
<p id="p-0048" num="0063">The web front-end <b>240</b> allows a user to create an instance of a spreadsheet model. Once the instance is created, the sheets of the instance are rendered as a sequence of pages. Each sheet shows a two-dimensional grid containing the cells from that sheet. Numeric input values (cells containing no formula) are rendered as text input boxes. Users can enter new data values and recompute the model. When a user enters a new value, the value in cell_values is updated.</p>
<p id="p-0049" num="0064"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a method <b>400</b> of creating a web page display of a model according to an embodiment of the invention. At step <b>405</b>, the web front-end <b>240</b> selects a worksheet for display as a web page. Step <b>405</b> includes selecting a worksheet from the model, the cell value instances for the cells on the worksheet, and the corresponding set of cell objects associated with the cells on the worksheet. In an embodiment of the invention, worksheets in the model are processed sequentially to provide a guided data entry process to model users.</p>
<p id="p-0050" num="0065">At step <b>410</b>, the web front-end <b>240</b> initializes the page for display. Step <b>410</b> creates an HTML format source file and includes HTML source code for any headers, title bars, menus, status information, navigation controls, and/or other page attributes, such as fonts, colors, and backgrounds.</p>
<p id="p-0051" num="0066">Typically, the order of HTML elements in an HTML source file determines the relative display position of these elements. An embodiment of method <b>400</b> creates an HTML source file by generating the source code for HTML elements in the order they are to be displayed, thereby “drawing” the page in the HTML format source file. In this embodiment, step <b>410</b> creates HTML source code for the top portion of a page, above the portion of the page displaying the model.</p>
<p id="p-0052" num="0067">The web front-end <b>240</b> renders the model as a web page. In an embodiment, the web front-end <b>240</b> processes the cells in the view. For each cell in the model, the layout manager retrieves the cell value and a corresponding cell object from the appropriate table. The web front-end <b>240</b> then invokes the cell object with the cell value to produce the display information determining the appearance of the cell.</p>
<p id="p-0053" num="0068">In an embodiment, each cell object has a method creating HTML source code for displaying the cell. This method is invoked with the cell value to create the HTML source code for the cell displaying the cell value. In this embodiment, the web front-end <b>240</b> processes cells in the order they are to be displayed on the desired web page, so that the HTML source code of each cell is automatically located in the proper position on the page. The web front-end <b>240</b> may further insert additional HTML source code for page navigation (e.g. between screens of a wizard), status information, headers and/or footers, and initialization and/or closing the web page.</p>
<p id="p-0054" num="0069">At step <b>415</b>, the web front-end <b>240</b> processes the cells of the selected worksheet and creates HTML source code for displaying the cells on the web page given the cell values of a particular model instance. As discussed above, each cell on the worksheet is associated with a cell object and a cell value instance. The cell object includes a display method for creating HTML source code to display the cell, and the cell value instance includes the actual value of the cell. The web front-end <b>240</b> invokes each cell object's display method together with its cell value instance to create HTML source code for displaying the cell. The HTML source code associated with each cell is then added to the HTML format source file, so that the cells are integrated into the final web page.</p>
<p id="p-0055" num="0070">An embodiment of step <b>415</b> processes the cells of the selected worksheet in the order that they are to be displayed. For example, step <b>415</b> processes cells in rows from left to right, and processes rows of cells from top to bottom. For each cell, step <b>415</b> invokes the display method of the associated cell object and then integrates the resulting HTML source code into the HTML format source file. In a further embodiment, step <b>415</b> also creates additional HTML source code to more precisely define the position of cells on the page. For example, step <b>415</b> can create an HTML table that arranges the cells in regular rows and columns.</p>
<p id="p-0056" num="0071">Following the completion of step <b>415</b> for all of the cells on the selected worksheet, at step <b>420</b> the web front-end <b>240</b> closes the page. Step <b>420</b> adds HTML source code to the HTML format source file to complete the web page. Step <b>420</b> can optionally add footers, menus, status information, navigation controls, and/or other additional user interface controls to the page. In an embodiment, step <b>420</b> adds HTML source code for any HTML elements positioned on the portion of the page located below the cells of the worksheet. Step <b>420</b> then communicates the completed HTML format source file to the model user's web browser for display.</p>
<p id="p-0057" num="0072"><figref idref="DRAWINGS">FIG. 3</figref> shows an ER diagram of the database schema <b>300</b> used to store the model in the relational database <b>225</b>. The schema <b>300</b> consists of the following tables:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0073">spreadsheets <b>305</b>—contains title and owner of a spreadsheet and a synthetic primary key</li>
    <li id="ul0005-0002" num="0074">cells <b>310</b>—stores the cells of a spreadsheet, including the location (sheet,rw,col), what spreadsheet it belongs to (spreadsheet_id), the name of the sheet the cell is on, the formula in that cell, the default value (value in the Spreadsheet when the cell is persisted), and a synthetic primary key</li>
    <li id="ul0005-0003" num="0075">spreadsheet_instances <b>315</b>—contains title and owner of a spreadsheet instance, a reference to the spreadsheet it is an instance of, and a synthetic primary key</li>
    <li id="ul0005-0004" num="0076">cell_values <b>320</b>—contains a reference to the instance containing the value, the cell the value represents, the value, and a synthetic primary key</li>
    <li id="ul0005-0005" num="0077">spreadsheet_view_text <b>325</b>—contains the SQL MODEL clause to compute the formulas for a spreadsheet</li>
    <li id="ul0005-0006" num="0078">named_ranges <b>330</b>—stores information about imported and filtered data (described in Modeling section). sql_query contains the query or clause corresponding to the import or filter, and parent_range_id specifies the base data that is filtered, in the case of a filter.</li>
</ul>
</p>
<p id="p-0058" num="0079">The translation between the spreadsheet formulas and the SQL statement used by the database to execute the persisted model is done using a number of different algorithms, depending on the type of formula used in the spreadsheet model and the capabilities of the database. In an embodiment, the database supports the use of an SQL “MODEL” clause in SQL SELECT statements. For basic spreadsheet functions, each cell in a spreadsheet is stored to a table by the spreadsheet add-on, which stores the location and formula or value of the cell. When an instance of the spreadsheet is created, a cell value corresponding to each cell is created. A view is generated which computes the values of the cells, as a MODEL clause dimensioned on the sheet, row and column of the cells. The MODEL clause's measure is the value in the cell, which defaults to the stored cell value in the case of a cell containing a constant. For cells containing formulas, an update rule encodes the computation necessary for that cell.</p>
<p id="h-0006" num="0000">For example, a spreadsheet has the formula:</p>
<p id="p-0059" num="0080">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>A</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="77pt" align="left"/>
<colspec colname="1" colwidth="14pt" align="center"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>2</entry>
<entry>2</entry>
</row>
<row>
<entry/>
<entry>3</entry>
<entry>= A1 + A2</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
When this spreadsheet is persisted, three cells are stored to the cells table. Since A<b>1</b> and A<b>2</b> contain constants, the SQL spreadsheet query will not contain an update rule for those cells. For A<b>3</b>, an update rule is present:
</p>
<p id="p-0060" num="0081">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>spreadsheet</entry>
</row>
<row>
<entry/>
<entry>dimension by (sheet,rw,col)</entry>
</row>
<row>
<entry/>
<entry>measures (value s)</entry>
</row>
<row>
<entry/>
<entry>rules (</entry>
</row>
<row>
<entry/>
<entry>  s[0,2,0] = s[0,0,0] + s[0,1,0]</entry>
</row>
<row>
<entry/>
<entry>)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0061" num="0082">In this example, the MODEL clause is dimensioned by the sheet, row and column attributes of a cell. Thus, s[0,2,0] refers to the value in A<b>3</b>, s[0,0,0] refers to the value in A<b>1</b>, and s[0,1,0] refers to the value in A<b>2</b>. So in the result of executing the query, the cell representing A<b>3</b> contains the sum of the values in A<b>1</b> and A2.</p>
<p id="p-0062" num="0083">Table 1 contains the rules for translation from an spreadsheet formula to a SQL spreadsheet rule. Most of the rules are fairly straightforward, but a few require discussion.
<ul id="ul0006" list-style="none">
    <li id="ul0006-0001" num="0084">cell_ref —A cell reference is computed by looking up the measure's value by the indices of the cell reference. The translated spreadsheet query uses AUTOMATIC ordering for rule execution, so the value at that reference is computed before the lookup takes place. The helper functions sheet, row, and column return a zero-based index for the corresponding dimension of the reference. For example,
    <ul id="ul0007" list-style="none">
        <li id="ul0007-0001" num="0085">sheet(Sheet1!A<b>1</b>)=0 (where Sheet1 is the first sheet)</li>
        <li id="ul0007-0002" num="0086">row(Sheet<b>1</b>!A<b>1</b>)=0</li>
        <li id="ul0007-0003" num="0087">column(Sheet1!A<b>1</b>)=0</li>
    </ul>
    </li>
    <li id="ul0006-0002" num="0088">cell_range and cell_range_in_list—The translation of a cell range reference depends on the context that that cell range appears in. If a cell range appears in an aggregate function, then those cells are expanded into a set of rows that a SQL aggregate function is applied to. If a cell range appears as an argument to any other function, then the cell range is expanded into a list of cells (e.g. “A<b>1</b>:A<b>3</b>” expands to “A<b>1</b>,A<b>2</b>,A<b>3</b>”), and then the function is translated.</li>
    <li id="ul0006-0003" num="0089">*junction—There are three different rewrite rules for functions:
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0090">Some Spreadsheet functions correspond to SQL aggregate functions. These rules must be translated to aggregate over a set of rows in the SQL query, and are translated according to aggregate_function.</li>
        <li id="ul0008-0002" num="0091">Other Spreadsheet functions correspond directly to SQL functions. For instance, the Spreadsheet function INT(x) corresponds directly to SQL TRUNC(x). These functions are translated according to other_function.</li>
        <li id="ul0008-0003" num="0092">Some Spreadsheet functions do not translate to SQL functions, but to infix SQL operators. For instance, PRODUCT( . . . ) translates to the infix operator *. These functions are translated according to operator_function.</li>
        <li id="ul0008-0004" num="0093">Some functions can act as aggregates or non-aggregates. For instance, SUM(A<b>1</b>:F<b>1</b>) is an aggregate, but SUM(<b>1</b>,<b>2</b>,<b>3</b>) is not. In the former case (when there is a single argument that is a cell range), the aggregate translation is used. In the latter case, the infix operator + is used to translate SUM.</li>
    </ul>
    </li>
    <li id="ul0006-0004" num="0094">Some other helper functions are used in the rules:
    <ul id="ul0009" list-style="none">
        <li id="ul0009-0001" num="0095">sqlFcn(spreadsheetFcnName) returns the name of the SQL function corresponding to the specified Spreadsheet function.</li>
        <li id="ul0009-0002" num="0096">op(spreadsheetFcnName) returns the SQL infix operator corresponding to the specified Spreadsheet function.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0063" num="0097">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 1</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Spreadsheet to SQL Translation Rules</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="147pt" align="left"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<tbody valign="top">
<row>
<entry>Spreadsheet Expression</entry>
<entry>Expression Type</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>R[ e1 op e2 ] = R[e1] op R[e2]</entry>
<entry>[operator]</entry>
</row>
<row>
<entry>R[ const ] = ‘const’</entry>
<entry>[const]</entry>
</row>
<row>
<entry>R[ cellRef] = s[sheet(cellRef),</entry>
<entry>[cell_ref]</entry>
</row>
<row>
<entry>row(cellRef), column(cellRef)]</entry>
</row>
<row>
<entry>R[ cellRef1 : cellRef2 ] = s[ sheet(cellRef1),</entry>
<entry>[cell_range]</entry>
</row>
<row>
<entry>    rw between row(cellRef1) and</entry>
</row>
<row>
<entry>row(cellRef2),</entry>
</row>
<row>
<entry>    col between column(cellRef1) and</entry>
</row>
<row>
<entry>column(cellRef2) ]</entry>
</row>
<row>
<entry>R[ fcnAgg ( cellRef1 : cellRef2 ) ] =</entry>
<entry>[aggregate_function]</entry>
</row>
<row>
<entry>  sqlFcn(fcnAgg) ( s ) [ sheet(cellRef1),</entry>
</row>
<row>
<entry>    rw between row(cellRef1) and</entry>
</row>
<row>
<entry>row(cellRef2),</entry>
</row>
<row>
<entry>    col between column(cellRef1) and</entry>
</row>
<row>
<entry>column(cellRef2) ]</entry>
</row>
<row>
<entry>R[ fcnOp ( e1 , e2 , ... ) ] = R[ e1′ ] op(fcnOp)</entry>
<entry>[operator_function]</entry>
</row>
<row>
<entry>R[ e2′ ] op(fcnOp) ...</entry>
</row>
<row>
<entry>    where R[ e1, e2, ... ] = (e1′, e2′, ... )</entry>
</row>
<row>
<entry>R[ fcn ( exprList ) ] = sqlFcn(fcn)</entry>
<entry>[other_function]</entry>
</row>
<row>
<entry>( R[ exprList ] )</entry>
</row>
<row>
<entry>R[ e1 , e2 , ... ] = L[e1] , L[e2] , ...</entry>
<entry>[expr_list]</entry>
</row>
<row>
<entry>L[ cellRef1 : cellRef2 ] = s [ cellRef1 ] , ... ,</entry>
<entry>[cell_range_in_list]</entry>
</row>
<row>
<entry>s [ cellRef2 ]</entry>
</row>
<row>
<entry>L[ e ] = R [ e ] , where e is not a cell range</entry>
<entry>[other_expr_in_list]</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0064" num="0098">Vlookup is another type of spreadsheet function that can be translated into SQL by an embodiment of the invention. A Vlookup is a spreadsheet function that supports content-addressable memory, similar to a hash coded table. A user specifies a range of cells, which column to lookup, and the key value to match against. The key value is matched against the first column (the key column), and the corresponding value (in the same row) in the lookup column is returned.</p>
<p id="p-0065" num="0099">There is no simple translation from vlookup to a SQL function, so the basic translation is not useful. Vlookups are, however, very similar to a SQL select statement. This means we can use SQL spreadsheet's reference spreadsheets to implement vlookup. The translation of a vlookup results in a SQL reference spreadsheet like:</p>
<p id="p-0066" num="0100">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>reference vlookup_ref on</entry>
</row>
<row>
<entry/>
<entry>(select k.default_value key, v.default_value value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>from cells k, cells v</entry>
</row>
<row>
<entry/>
<entry>where k.col = &lt;start_column&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>and v.col = &lt;start_column&gt;+&lt;column_offset&gt;−1</entry>
</row>
<row>
<entry/>
<entry>and k.rw &gt;= &lt;start_row&gt;</entry>
</row>
<row>
<entry/>
<entry>and k.rw &lt;= &lt;end_row&gt;</entry>
</row>
<row>
<entry/>
<entry>and k.sheet = &lt;sheet&gt;</entry>
</row>
<row>
<entry/>
<entry>and v.sheet = &lt;sheet&gt;</entry>
</row>
<row>
<entry/>
<entry>and v.rw = k.rw</entry>
</row>
<row>
<entry/>
<entry>and k.spreadsheet_id = &lt;spreadsheet_id&gt;</entry>
</row>
<row>
<entry/>
<entry>and v.spreadsheet_id = &lt;spreadsheet_id&gt; )</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>dimension by (key) measures (value)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0067" num="0101">In other words, the key is in the first column of the range (start_column), the value is in the lookup column, the key and value are in the same row on the same sheet, and that row is in the specified range (start_row to end_row). This reference spreadsheet creates a mapping from keys (first column values) to values (lookup column values). Any vlookups over the specified range, on the specified lookup column, with key value K is translated to:
<ul id="ul0010" list-style="none">
    <li id="ul0010-0001" num="0000">
    <ul id="ul0011" list-style="none">
        <li id="ul0011-0001" num="0102">vlookup_ref.value[K]</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0068" num="0103">Vlookup translation is different from the basic translation, because the spreadsheet function is not just translated to a SQL spreadsheet rule. It is translated to a reference spreadsheet and a rule. This translation only works for vlookup's on static data. That is, since the key and value are the default values from the cells (rather than the value from the cell values), changes in the referenced data are not reflected in the vlookup.</p>
<p id="p-0069" num="0104">In a further embodiment, the reference data could potentially include formulas that reference other data in the spreadsheet. This embodiment requires that the reference spreadsheet pull in the SQL rules corresponding to those formulas and any dependent cells.</p>
<p id="p-0070" num="0105">As discussed above, one of the features of the present invention is the ability to build a spreadsheet model using only a small portion, or sample, of the data set in the database, and then automatically scale the completed model to operate on the full data set. This translation between sample data and corresponding full data sets is performed as follows.</p>
<p id="p-0071" num="0106">As discussed above, the modeling tools introduce named references for cells and cell ranges. When the spreadsheet model is persisted into the database, the persisted functions include the named references of the named ranges imported and filtered by the modeling tools. Because these named ranges represent data from external tables, a SQL reference spreadsheet is an appropriate representation.</p>
<p id="p-0072" num="0107">For example, suppose sample data were imported from the SALES table, and the user summed up the subtotals for all of the entries in the sales table. This corresponds to an spreadsheet formula:
<ul id="ul0012" list-style="none">
    <li id="ul0012-0001" num="0000">
    <ul id="ul0013" list-style="none">
        <li id="ul0013-0001" num="0108">=SUM(sales.subtotal)
<br/>
This could be translated to a SQL reference spreadsheet:
</li>
        <li id="ul0013-0002" num="0109">reference named_range on</li>
        <li id="ul0013-0003" num="0110">(select id, s from sales)</li>
        <li id="ul0013-0004" num="0111">dimension by (rownum id)</li>
        <li id="ul0013-0005" num="0112">measures (subtotal s)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0073" num="0113">The formula would be represented as an update rule:
<ul id="ul0014" list-style="none">
    <li id="ul0014-0001" num="0000">
    <ul id="ul0015" list-style="none">
        <li id="ul0015-0001" num="0114">. . . =sum(named_range.s)[ANY]</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0074" num="0115">In an embodiment, SQL spreadsheets do not support aggregate functions over reference spreadsheet data. To compensate, an embodiment includes the aggregate clause as part of the MODEL clause. There are a variety of ways to translate this, each with performance tradeoffs. One implementation of this translation is</p>
<p id="p-0075" num="0116">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>reference named_range on</entry>
</row>
<row>
<entry/>
<entry>(select t,s from</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(select id, t, s</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>from (select * from sales)</entry>
</row>
<row>
<entry/>
<entry>spreadsheet</entry>
</row>
<row>
<entry/>
<entry>dimension by (rownum id, −1 as t)</entry>
</row>
<row>
<entry/>
<entry>measures (1 s,subtotal s1)</entry>
</row>
<row>
<entry/>
<entry>rules (</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>s[NULL,0] = SUM(s1) [ANY,−1]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>) where id is null</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>)</entry>
</row>
<row>
<entry/>
<entry>dimension by (t) measures (s)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0076" num="0117">In this implementation, the reference spreadsheet is on a query that itself contains a MODEL clause. The idea behind this translation is that the desired column (subtotal) is one measure, and another measure contains the computed aggregate. The column t is a dummy column to keep track of whether the value is a computed aggregate or a value from the sales table. The aggregate functions are computed by update rules for NULL rownum, and then only these values are selected by the outer query. The result of this reference spreadsheet is a mapping from 0 to the sum over all subtotals in sales.</p>
<p id="p-0077" num="0118">Continuing with this example, the formula would be represented as an update rule:
<ul id="ul0016" list-style="none">
    <li id="ul0016-0001" num="0000">
    <ul id="ul0017" list-style="none">
        <li id="ul0017-0001" num="0119">. . . =named range.s[0]
<br/>
This translation allows us to include multiple aggregate functions over the same column of the same named range to be represented by one reference spreadsheet. For instance, consider a spreadsheet model that contains the following formulas:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0078" num="0120">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mtable>
        <mtr>
          <mtd>
            <mrow>
              <mo>=</mo>
              <mrow>
                <mi>sum</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>sales</mi>
                    <mo>.</mo>
                    <mi>subtotal</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mo>=</mo>
              <mrow>
                <mi>count</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>sales</mi>
                    <mo>.</mo>
                    <mi>subtotal</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mi>average</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>sales</mi>
                <mo>.</mo>
                <mi>subtotal</mi>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>.</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
This can be translated to the reference spreadsheet below:
</p>
<p id="p-0079" num="0121">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>reference named_range on</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(select t,s from</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(select id, t, s</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>from (select * from sales)</entry>
</row>
<row>
<entry/>
<entry>spreadsheet</entry>
</row>
<row>
<entry/>
<entry>dimension by (rownum id, −1 as t)</entry>
</row>
<row>
<entry/>
<entry>measures (1 s,subtotal s1)</entry>
</row>
<row>
<entry/>
<entry>rules (</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>s[NULL,0] = SUM(s1) [ANY,−1],</entry>
</row>
<row>
<entry/>
<entry>s[NULL,1] = COUNT(s1) [ANY,−1],</entry>
</row>
<row>
<entry/>
<entry>s[NULL,2] = AVG(s1) [ANY,−1]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>) where id is null</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>)</entry>
</row>
<row>
<entry/>
<entry>dimension by (t) measures (s)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
The three formulas would be translated to:
</p>
<p id="p-0080" num="0122">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mtable>
        <mtr>
          <mtd>
            <mrow>
              <mi>…</mi>
              <mo>=</mo>
              <mrow>
                <mi>named_range</mi>
                <mo>.</mo>
                <mrow>
                  <mi>s</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>[</mo>
                    <mn>0</mn>
                    <mo>]</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mi>…</mi>
              <mo>=</mo>
              <mrow>
                <mi>named_range</mi>
                <mo>.</mo>
                <mrow>
                  <mi>s</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>[</mo>
                    <mn>1</mn>
                    <mo>]</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mi>…</mi>
        <mo>=</mo>
        <mrow>
          <mi>named_range</mi>
          <mo>.</mo>
          <mrow>
            <mi>s</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>[</mo>
              <mn>2</mn>
              <mo>]</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0081" num="0123">This translation is more efficient than other options in cases when the select query takes time, because it only needs to be executed once. This could be the case since the user can specify any SQL query for a data import.</p>
<p id="p-0082" num="0124">This translation can be extended to support aggregates on different columns in the same import or filter, by adding a measure per column to the inner MODEL clause, e.g.:</p>
<p id="p-0083" num="0125">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>...</entry>
</row>
<row>
<entry/>
<entry>measures (1 s,subtotal s1, id s2)</entry>
</row>
<row>
<entry/>
<entry>rules (</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>s[NULL,0] = SUM(s1) [ANY,−1],</entry>
</row>
<row>
<entry/>
<entry>s[NULL,1] = COUNT(s2) [ANY,−1]</entry>
</row>
<row>
<entry/>
<entry>...</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
This MODEL clause can be used to represent both =SUM(sales.subtotal) and =COUNT(sales.id) in one reference spreadsheet, which means the select query (select * from sales) only needs to be executed once.
</p>
<p id="p-0084" num="0126">In addition to the above discussed trade-offs in the translation of named ranges, there are other optimizations to the translation. First, when two spreadsheet formulas are equivalent to each other in the relative references that they have, the formula can be encoded as one rule. For example, consider the following spreadsheet:</p>
<p id="p-0085" num="0127">
<tables id="TABLE-US-00008" num="00008">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="14pt" align="center"/>
<colspec colname="2" colwidth="91pt" align="center"/>
<colspec colname="3" colwidth="70pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry/>
<entry>A</entry>
<entry>B</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>1</entry>
<entry>1</entry>
<entry>=A1*5</entry>
</row>
<row>
<entry/>
<entry>2</entry>
<entry>2</entry>
<entry>=A2*5</entry>
</row>
<row>
<entry/>
<entry>3</entry>
<entry>3</entry>
<entry>=A3*5</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0086" num="0128">This spreadsheet would be translated into a SQL MODEL clause with three rules, one per formula. In fact the three formulas are equivalent, given that the cell references are relative. These three rules can be replaced by one rule instead:
<ul id="ul0018" list-style="none">
    <li id="ul0018-0001" num="0129">s[0, for rw from 0 to 2 increment 1, 1]=s[0, currentv( )−1, 0]</li>
</ul>
</p>
<p id="p-0087" num="0130">An embodiment of the invention uses this optimization to coalesce equivalent formulas in a contiguous range of cells (in a row or column). It also reduces the size of the view generated for each instance.</p>
<p id="p-0088" num="0131">Second, if the initial translation expanded a cell range to
<ul id="ul0019" list-style="none">
    <li id="ul0019-0001" num="0000">
    <ul id="ul0020" list-style="none">
        <li id="ul0020-0001" num="0132">s[ . . . , rw between . . . , col between . . . ]</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0089" num="0133">This caused performance problems, since between results in a scan of all data. An embodiment of the invention uses the for looping construct instead.</p>
<p id="p-0090" num="0134">Although the invention has been discussed with respect to specific embodiments thereof, these embodiments are merely illustrative, and not restrictive, of the invention. For example, although the invention is discussed with reference to financial models, the invention can be used to implement a web front-end <b>240</b> from any use of a spreadsheet application.</p>
<p id="p-0091" num="0135">In a further embodiment of the invention, the display methods associated with the cell objects can be interfaced with XML documents, XForms documents, or other formats of electronic documents. Thus, the scope of the invention is to be determined solely by the claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US07299223-20071120-M00001.NB">
<img id="EMI-M00001" he="11.26mm" wi="76.20mm" file="US07299223-20071120-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US07299223-20071120-M00002.NB">
<img id="EMI-M00002" he="11.26mm" wi="76.20mm" file="US07299223-20071120-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for querying a database, the computer-implemented method comprising:
<claim-text>importing a set of sample data from a database into a spreadsheet application;</claim-text>
<claim-text>associating a set of spreadsheet operations comprising a spreadsheet model with the set of sample data;</claim-text>
<claim-text>translating the set of spreadsheet operations into a model database query, such that the model database query performs the set of spreadsheet operations on a full data set in the database, and</claim-text>
<claim-text>performing the model database query on the full data set in the database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the sample data is a copy of a portion of the full data set.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein translating comprises matching the set of sample data to a second database query defining the full data set within the database.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising creating a web page from results of the model database query on the database.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein importing the set of sample data comprises:
<claim-text>receiving a database query specifying the full data set in the database;</claim-text>
<claim-text>receiving a sample size value; and</claim-text>
<claim-text>querying the database to retrieve the set of sample data corresponding to a portion of the full data set and having a size of the sample size value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising:
<claim-text>receiving a name for the set of sample data; and</claim-text>
<claim-text>associating the name with the set of sample data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the set of sample data includes a plurality of sample data subsets, each sample data subset corresponding to a subset of the full data set.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein associating the name with the set of sample data includes associating the name and a subset name derived from the corresponding subset of the full data set with each of the plurality of sample data subsets.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein, in associating the set of spreadsheet operations with the set of sample data, the set of spreadsheet operations includes references to the name associated with the set of sample data.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein translating comprises matching the set of sample data to the database query defining the full data set within the database using the name associated with the set of sample data for each of the set of operations.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A computer-implemented system for querying a database, the computer-implemented system comprising:
<claim-text>a processor;</claim-text>
<claim-text>a storage coupled to the processor;</claim-text>
<claim-text>a modeling module, stored in the storage, interfacing with a spreadsheet application and retrieving a set of sample data from a database, wherein the set of sample data corresponds with a portion of a full data set within the database;</claim-text>
<claim-text>a persistence module, stored in the storage, interfacing with the spreadsheet application and storing a set of spreadsheet operations referencing the set of sample data in the database; and</claim-text>
<claim-text>a translation module, stored in the storage, translating the set of spreadsheet operations into a model database query, such that the model database query performs the set of spreadsheet operations on the full data set in the database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the translation module further stores the model database query in the database.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the modeling module associates a name and a database query specifying the full data set within the database with the set of sample data.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the set of spreadsheet operations include a reference to name associated with the set of sample data; and
<claim-text>wherein the translation module further matches the name associated with the set of sample data with the database query specifying the full data set and creates a model database query applying the set of operations to the full data set specified by the database query.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:
<claim-text>an instance generator creating an instance of a model from the model database query and storing the instance of the model and a set of model input data in the database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the instance generator stores a set of output data resulting from an execution of the model database query on the set of model input data in the database.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the instance generator receives the set of model input data from a model user application.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising:
<claim-text>a web front-end creating a web page from results of the model database query on the database; and</claim-text>
<claim-text>wherein the model user application is a web browser.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the web page includes a user interface collecting the set of model input data from a model user.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the model database query is an SQL MODEL rule.</claim-text>
</claim>
</claims>
</us-patent-grant>
