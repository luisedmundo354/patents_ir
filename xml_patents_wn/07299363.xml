<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299363-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299363</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10608113</doc-number>
<date>20030630</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>JP</country>
<doc-number>2002-192422</doc-number>
<date>20020701</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>737</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>14</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>713189</main-classification>
<further-classification>713164</further-classification>
</classification-national>
<invention-title id="d0e71">Method for using shared library in tamper resistant microprocessor</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4558176</doc-number>
<kind>A</kind>
<name>Arnold et al.</name>
<date>19851200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5666411</doc-number>
<kind>A</kind>
<name>McCarty</name>
<date>19970900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6044442</doc-number>
<kind>A</kind>
<name>Jesionowski</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711153</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6385722</doc-number>
<kind>B1</kind>
<name>Connelly et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6405316</doc-number>
<kind>B1</kind>
<name>Krishnan et al.</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713190</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6876996</doc-number>
<kind>B2</kind>
<name>Czajkowski et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6925569</doc-number>
<kind>B2</kind>
<name>Wuidart</name>
<date>20050800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713193</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2003/0131153</doc-number>
<kind>A1</kind>
<name>Vu</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709331</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2004/0111720</doc-number>
<kind>A1</kind>
<name>Vertes</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717164</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2004/0139341</doc-number>
<kind>A1</kind>
<name>Yamaguchi et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>JP</country>
<doc-number>11-110193</doc-number>
<date>19990400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00012">
<othercit>D. Lie, et al.,Proceedings of ASPLOS 2000, 10 pages, “Architectural Support for Copy and Tamper Resistant Software”, Nov. 2000.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00013">
<othercit>U.S. Appl. No. 11/060,704, filed Feb. 18, 2005, Haruki et al.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00014">
<othercit>U.S. Appl. No. 10/608/113, filed Jun. 30, 2003, Yamaguchi et al.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00015">
<othercit>U.S. Appl. No. 10/948,313, filed Sep. 24, 2004, Hashimoto.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00016">
<othercit>U.S. Appl. No. 10/913,537, filed Aug. 9, 2004. Hashimoto et al.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>U.S. Appl. No. 10/608,113, filed Jun. 30, 2003, Yamaguchi et al.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>U.S. Appl. No. 10/754,571, filed Jan. 12, 2004, Yamaguchi et al.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>U.S. Appl. No. 10/434,082, filed May 9, 2003, Isozaki et al.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00020">
<othercit>David Lie, et al., “Separating Protection and Resource Management in Operating Systems”, Stanford University, http://mos.stanford.edu/papers/dl<sub>—</sub>osdi<sub>—</sub>02.pdf, May 17, 2002, pp. 1-14.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>7</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>713164</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713167</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713189</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713194</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713165</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713166</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>11</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040139341</doc-number>
<kind>A1</kind>
<date>20040715</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Yamaguchi</last-name>
<first-name>Kensaku</first-name>
<address>
<city>Yokohama</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Hashimoto</last-name>
<first-name>Mikio</first-name>
<address>
<city>Yokohama</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Oblon, Spivak, McClelland, Maier &amp; Neustadt, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Kabushiki Kaisha Toshiba</orgname>
<role>03</role>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Smithers</last-name>
<first-name>Matthew B</first-name>
<department>2137</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">In a method for using the shared library in a tamper resistant microprocessor, the execution code of the shared library is protected because the shared library itself is processed as a task which has a single identifier, and the instruction key for encrypting/decrypting the shared library is recorded at a location within the microprocessor corresponding to that identifier.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="143.09mm" wi="242.40mm" file="US07299363-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="243.33mm" wi="150.37mm" orientation="landscape" file="US07299363-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="168.06mm" wi="164.42mm" file="US07299363-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="212.60mm" wi="102.02mm" file="US07299363-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="212.17mm" wi="105.58mm" file="US07299363-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="192.19mm" wi="124.80mm" file="US07299363-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="244.52mm" wi="132.33mm" file="US07299363-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="238.42mm" wi="150.96mm" orientation="landscape" file="US07299363-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="145.63mm" wi="147.07mm" file="US07299363-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="255.10mm" wi="171.11mm" file="US07299363-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="250.70mm" wi="162.14mm" file="US07299363-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="252.73mm" wi="176.28mm" orientation="landscape" file="US07299363-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention relates to a method for using a shared library in a microprocessor having a function for supporting the multi-task program execution environment and program and data encryption/decryption function so as to realize the protection of secrecy and the prevention of alteration for the execution codes of the programs and the processing target data.</p>
<p id="p-0004" num="0003">2. Description of the Related Art</p>
<p id="p-0005" num="0004">In the computer systems of recent years, the open system constructed by combining hardware and software of various makers has been widespread, as in the case of PCs. In the open system, the information on hardware and system program (or operating system (OS)) is publicly disclosed so that it is in principle possible for an end user to modify or alter the system program according to this information</p>
<p id="p-0006" num="0005">In the application program to be executed in such an environment, it is difficult for a provider of the application program to completely protect the program from the analysis and the alteration. The application program is operated under the management of the OS, so that there is no way of escaping from the attack when the OS itself is altered and used as means for attacking.</p>
<p id="p-0007" num="0006">For this reason, there is a method to encrypt the application program in advance, in order to prevent the analysis of the application program to be operated in the open system. When the program is encrypted, not only the analysis becomes difficult but also the prediction of the operation in the case where the program is altered also becomes difficult so that it is also effective for the prevention of the alteration. However, the encrypted application program cannot be executed as it is by the existing computer, so that there is a need for a microprocessor which can execute the program while decrypting the program. This microprocessor must protect the secrecy of the program on the presumption that the OS may carry out hostile operations against the application program.</p>
<p id="p-0008" num="0007">A microprocessor that can satisfy these requirements includes one proposed in commonly assigned co-pending U.S. patent application Ser. Nos. 09/781,158 and 09/781,284, and one disclosed in Lie et al., “Architectural Support for Copy and Tamper Resistant Software”, Proceedings of ASPLOS-IX 2000, November, 2000. These proposed microprocessors have a function for encrypting not just programs but also information and data to be handled by the programs as a protection against the analysis and the alteration. They also provides the multi-task program execution environment for executing a plurality of programs simultaneously in a pseudo-parallel manner. In the following such a microprocessor will be referred to as a tamper resistant microprocessor.</p>
<p id="p-0009" num="0008">In the conventionally proposed tamper resistant microprocessor, it is assumed that the application program is operated singly and all the necessary processing can be realized by its execution code alone. A method for sharing the data region in order to realize the cooperative operations by a plurality of programs has also been proposed in commonly assigned co-pending U.S. patent application Ser. No. 10/028,794. However, even in this case, the programs that are carrying out the cooperative operations are mutually independent individual programs.</p>
<p id="p-0010" num="0009">On the other hand, the current OS often utilizes the shared library. Here, the library is a collection of sub-programs such as a sub-routine (a group of instructions which have a certain function in the program) which constitute the program. The programmer of the application program can rely on the sub-programs provided in the library for a part of functions of the application program, instead of implementing in the application program all the functions necessary for the operation of the application program. The library and the application program can be separately developed and then freely combined later on for use, so that they can make the software development more efficient.</p>
<p id="p-0011" num="0010">The classic library is linked to the application program at a time of producing the application program, and the sub-programs of the library are distributed integrally with the application program. On the other hand, the shared library that is widely in use today is distributed as a separate file independent from the application program.</p>
<p id="p-0012" num="0011">In the case of the shared library, the link to the application program is made when the user actually executes the program. Also, this linking operation is carried out with respect to an image of the application program on memory, rather than with respect to the executable object file of the application program. Once the linking between the application program and the shared library is carried out, it becomes possible to use the sub-programs of the shared library by freely calling them up from the application program, similarly as the sub-programs of an ordinary library.</p>
<p id="p-0013" num="0012">One of the advantages for using the shared library is that the necessary memory region can be reduced. A total size of one application program and the shared library to be used by that application program is always larger than the size in the case of not utilizing the shared library. However, when there are a plurality of application programs which use the same shared library, it suffices to have one copy of the shared library so that the necessary memory region can be reduced overall. This reduction of the necessary memory region is effective for both the secondary memory (external memory device such as disks) on which the distributed file of the application program is stored and the main memory of the computer on which the application program is stored at a time of its execution.</p>
<p id="p-0014" num="0013">Among the shared libraries, those known as a dynamic link type (dynamic link shared libraries) have a feature that the shared library can be changed without changing the application program. When the dynamic link shared library is used, it is possible to change a part of the functions of the application program or correct errors in the application program, without changing the application program itself, by replacing one shared library with another shared library. Also, in the case where the application program searches the available shared library after the execution starts and loads the shared library found by the search, it is possible to add functions to the application program without changing the application program itself, by separately providing the shared library alone. The shared library designed to be used in this manner is often referred to as a plug-in.</p>
<p id="p-0015" num="0014">So far there has been no proposition for an architecture that can enable the use of the shared library on the tamper resistant microprocessor described above.</p>
<p id="p-0016" num="0015">In order to implement the shared library on the tamper resistant microprocessor, there is a need to satisfy the following requirements. Namely, it is required that the routines of the shared library can be called up from the application program, and that data may be passed to the routine at a time of calling up the routine, and data of the processing result can be returned to the called source when the processing returns from the routine.</p>
<p id="p-0017" num="0016">In addition, in order to maintain the protection function for data, etc. that is provided by the tamper resistant microprocessor effectively functional, there is a need to protect the secrecy of the information to be exchanged between the application program and the shared library from the OS, etc. In the case of exchanging data to be kept secret at a time of calling up the routine, there is a need to authenticate the correspondent in order to check whether it is a trustworthy correspondent or not (Whether the shared library has been replaced with another malicious shared library by the OS, etc. or not). There is also a need to prevent a secret substitution of another routine into the call up target routine after this authentication is finished. In the case where the shared library are to be used simultaneously from a plurality of application programs, the leakage of a secret of one program to another program by the shared library must be prevented.</p>
<p id="p-0018" num="0017">Also, the shared library must be usable from arbitrary application. In other words, if the shared library is usable only from a specific application program as a result of the authentication, it would be insufficient as the shared library because its use is limited. On the other hand, from a viewpoint of the application program that uses the shared library, it is preferable to be able to confirm that the shared library will not leak data to the others, before giving data to be kept secret to the shared library.</p>
<p id="p-0019" num="0018">For these reasons, there is a need to provide a mechanism by which the application program can authenticate the shared library.</p>
<p id="p-0020" num="0019">The operation of the shared library is to receive data from the application program, apply some processing on the data, and return the processing result to the application program. Here, the data received from the application program and the processing result should not be leaked to the third party other than the application program and the shared library. Namely, not only the data exchange must be carried out by applying the encryption, but there is also a need to check that the program to which the processing result corresponding to the received data is going to be returned is the same application program which originally provided the data.</p>
<p id="p-0021" num="0020">Also, anyone can write an application program that uses the shared library, so that there is a possibility of being used from a malicious application program. Even in such a case, it must be capable of protecting the internal operation of the shared library from the analysis. In other words, it must be capable of preventing the reading of the execution code of the shared library by the application program and the peeping of the intermediate data during the processing of the data given to the shared library by the application program.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0022" num="0021">It is therefore an object of the present invention to provide a method for using a shared library and a computer program product for such a method, which are capable of enabling the use of the shared library on the tamper resistant microprocessor which has been impossible conventionally, while satisfying the above described requirements and providing the above described advantages.</p>
<p id="p-0023" num="0022">According to one aspect of the present invention there is provided a method for using a shared library called up from a calling source program in a tamper resistant microprocessor which has a function for decrypting and executing encrypted codes and a table formed by a plurality of regions for storing a plurality of encryption keys corresponding to at least one program and at least one shared library to be called up by the at least one program, the method comprising: creating a task for the shared library; allocating a task identifier to the task; acquiring an instruction key from a header of the shared library; storing the instruction key into a region of the table corresponding to the task identifier allocated to the task for the shared library in the microprocessor; initializing by executing a loader in the shared library; and returning a control to the calling source program via an entry point in the shared library.</p>
<p id="p-0024" num="0023">According to another aspect of the present invention there is provided a computer program product for causing a tamper resistant microprocessor which has a function for decrypting and executing encrypted codes and a table formed by a plurality of regions for storing a plurality of encryption keys corresponding to at least one program and at least one shared library to be called up by the at least one program, to use a shared library called up from a calling source program, the computer program product comprising: a first computer program code for causing the tamper resistant microprocessor to create a task for the shared library; a second computer program code for causing the tamper resistant microprocessor to allocate a task identifier to the task; a third computer program code for causing the tamper resistant microprocessor to acquire an instruction key from a header of the shared library; a fourth computer program code for causing the tamper resistant microprocessor to store the instruction key into a region of the table corresponding to the task identifier allocated to the task for the shared library in the microprocessor; a fifth computer program code for causing the tamper resistant microprocessor to initialize by executing a loader in the shared library; and a sixth computer program code for causing the tamper resistant microprocessor to return a control to the calling source program via an entry point in the shared library.</p>
<p id="p-0025" num="0024">Other features and advantages of the present invention will become apparent from the following description taken in conjunction with the accompanying drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram showing a configuration of a microprocessor in which a shared library is to be used according to one embodiment of the present invention.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram showing a key value table provided inside the microprocessor of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram showing an application program used in one embodiment of the present invention.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram showing a shared library used in one embodiment of the present invention.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 5</figref> is a flow chart showing a procedure for task execution start according to one embodiment of the present invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 6</figref> is a flow chart showing a procedure for shared library loading according to one embodiment of the present invention.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 7</figref> is a sequence chart showing a procedure for calling up a sub-routine of a shared library according to one embodiment of the present invention.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram showing a sub-routine call up parameter block according to one embodiment of the present invention.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 9</figref> is a flow chart showing a procedure of a shared library side at a time of using a shared library from a program according to one embodiment of the present invention.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 10</figref> is a flow chart showing a procedure of a program side at a time of using a shared library from a program according to one embodiment of the present invention.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 11</figref> is a diagram showing an arrangement of memory address spaces of a program and a shared library according to one embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0037" num="0036">Referring now to <figref idref="DRAWINGS">FIG. 1</figref> to <figref idref="DRAWINGS">FIG. 11</figref>, one embodiment of a method for using a shared library according to the present invention will be described in detail.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 1</figref> shows a basic hardware configuration of a microprocessor (tamper resistant microprocessor <b>1</b> to which the present invention is applied. The microprocessor <b>1</b> has a processor core <b>10</b>, a code and data encryption/decryption processing unit <b>11</b>, a key value table <b>13</b>, a task ID storing register <b>14</b>, a random number generation unit <b>15</b>, and an external bus interface <b>12</b>.</p>
<p id="p-0039" num="0038">The microprocessor <b>1</b> to be used as the tamper resistant microprocessor differs significantly from the ordinary microprocessor in that it internally has the code and data encryption/decryption processing unit <b>11</b>. The execution code and data to be inputted into the processor core <b>10</b> are inputted after being decrypted by the code and data encryption/decryption processing unit <b>11</b>. Also, when the data flows out on the bus from the processor core <b>10</b>, the data are outputted after being encrypted by the code and data encryption/decryption processing unit <b>11</b>. The code and data encryption/decryption processing unit <b>11</b> uses an encryption key in the encryption processing and the decryption processing. This encryption key is acquired from the key value table <b>13</b> inside the same microprocessor <b>1</b>. Also, the task ID storing register <b>14</b> is used in selecting and acquiring the encryption key to be used among those in the key value table <b>13</b>.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 2</figref> shows a configuration of the key value table <b>13</b>. In the key value table <b>13</b>, a plurality of key value table entries <b>130</b> formed by registers for storing values of the encryption keys are arranged. The key value table entries can be provided as many as the number (n+1) of task IDs ranging from 0 to n as will be described below. The key value table entries <b>130</b> are identified each other as <b>130</b><sub>0</sub>, <b>130</b><sub>1</sub>, <b>130</b><sub>2</sub>, . . . , <b>130</b><sub>n </sub>for different task IDs. The key value table entry <b>130</b><sub>i </sub>(0≦i≦1) can store an instruction key k<b>1</b> which is a key for encrypting/decrypting the execution code <b>32</b> of the program <b>3</b>, a data key k<b>2</b> which is a key for encrypting/decrypting data to be handled by the program <b>3</b>, and an address information <b>13</b><i>a </i>which indicates a memory range to which the instruction key k<b>1</b> and the data key k<b>2</b> will be applied.</p>
<p id="p-0041" num="0040">As a plurality of key value table entries <b>130</b><sub>0</sub>, <b>130</b><sub>1</sub>, <b>130</b><sub>2</sub>, . . . , <b>130</b><sub>n </sub>are arranged in the key value table <b>13</b>, the instruction keys of different programs <b>3</b> can be stored into different key value table entries <b>130</b><sub>i </sub>(0≦i≦1). In this way, it is possible to deal with the multi-task operation in which instances (processes or the like) of a plurality of programs encrypted by different encryption keys are operated in a pseudo-parallel manner.</p>
<p id="p-0042" num="0041">The task ID storing register <b>14</b> is a register for storing one task ID. The task ID storing register <b>14</b> will be used in identifying the task that is currently executed by the microprocessor <b>1</b> in multi-task operation, in which multiple tasks are operated in a pseudo-parallel manner. A task may be an instance of a single-threaded process, or one thread within a multi-threaded process, or an instance of a shared library that is being called by another task.</p>
<p id="p-0043" num="0042">The random number generation unit <b>15</b> provides a different random number with respect to each occasion of reading from the processor core <b>10</b>. This random number generation unit <b>15</b> can be used in generating a random number that is necessary for the key by which the program carries out the encryption or for the authentication.</p>
<p id="p-0044" num="0043">The software operated on the microprocessor to which the present invention is applied comprises a system software (OS), the application program <b>3</b> (hereafter simply referred to as program), and the shared library <b>4</b>.</p>
<p id="p-0045" num="0044">In the following, the configurations of the program <b>3</b> and the shared library <b>4</b> will be described.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 3</figref> shows a configuration of the program <b>3</b> in this embodiment. The program <b>3</b> is formed by a header <b>31</b>, an execution code <b>32</b>, an initialized data <b>33</b>, and an import table <b>34</b>. The header <b>31</b> contains the instruction key K<b>31</b> for decrypting the execution code <b>32</b> of the program <b>3</b>. The import table <b>34</b> specifies the shared library <b>4</b> to be used by the program <b>3</b> and symbols contained in the shared library <b>4</b> (symbols are identifiers for identifying sub-routines or the like contained in the shared library as will be described below), which are information necessary in loading the shared library <b>4</b>.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 4</figref> shows a configuration of the shared library <b>4</b> in this embodiment. The shared library <b>4</b> is formed by a header <b>41</b>, an execution code <b>42</b>, an initialized data <b>43</b>, and an import table <b>44</b>, similarly as the program <b>3</b>. The import table <b>44</b> of the shared library <b>4</b> contains information necessary in the case where this shared library <b>4</b> itself uses another shared library. The execution code <b>42</b> of the shared library <b>4</b> is formed by a bootstrap routine <b>42</b><i>a</i>, an entry point code <b>42</b><i>b</i>, and a number of sub-routines <b>42</b><i>c </i>having respective functions. In <figref idref="DRAWINGS">FIG. 4</figref>, a plurality of sub-routines are distinguished by a subscript i (1≦i≦n) as <b>42</b><i>c</i><sub>1</sub>, <b>42</b><i>c</i><sub>2</sub>, . . . , <b>42</b><i>c</i><sub>n</sub>.</p>
<p id="p-0048" num="0047">The bootstrap routine (loader) <b>42</b><i>a </i>is used in carrying out the processing necessary when the shared library <b>4</b> is loaded by the calling source program <b>3</b>. The entry point code <b>42</b><i>b </i>indicates an entry point of the shared library <b>4</b> with respect to the program <b>3</b> which will be a call up target when the shared library <b>4</b> is to be used from the calling source program <b>3</b>. The other sub-routines <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> are codes implementing functions to be actually used by the program <b>3</b>. Each sub-routines <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> is assigned with an identifier for identifying it in the shared library <b>4</b>.</p>
<p id="p-0049" num="0048">Also, the execution code <b>42</b> of the shared library <b>4</b> contains the data key K<b>42</b> for encrypting data to be used in carrying out the requested processing, when the shared library <b>4</b> carries out a processing according to the call from the program <b>3</b> as will be described below.</p>
<p id="p-0050" num="0049">(Start of the Task)</p>
<p id="p-0051" num="0050">Next, with reference to <figref idref="DRAWINGS">FIG. 5</figref>, a procedure by which the OS starts the execution of the task in response to a request for executing the program from the user or a request for creating a new process or a new thread from the existing process will be described.</p>
<p id="p-0052" num="0051">First, the OS creates the task (step S<b>51</b>). This includes a securing of a memory region and a creation of a data structure for the purpose of managing the task. The OS also carries out the allocation of a task ID to the new task.</p>
<p id="p-0053" num="0052">Next, the OS acquires the instruction key K<b>31</b> from the header <b>31</b> of the program <b>3</b>, and stores the instruction key K<b>31</b> into the key value table entry <b>130</b><sub>i </sub>(0≦i≦1) corresponding to the task ID allocated earlier (step S<b>52</b>).</p>
<p id="p-0054" num="0053">Also, the OS refers to the import table <b>34</b> of the program <b>3</b> and loads each shared library <b>4</b> described therein by using a mechanism to be described below (step S<b>53</b>). Any number of shared libraries <b>4</b> may be described in the import table <b>34</b>. Consequently, the OS carries out the loading operation separately for each shared library <b>4</b> described in the import table <b>34</b>. Note that the shared library <b>4</b> may be loaded in response to a request from the task after the task is started, instead of loading the shared library <b>4</b> before the task starts.</p>
<p id="p-0055" num="0054">When the loading of all the requested shared libraries <b>4</b> is completed, the OS carries out the switching of the context to the new task (here the context is data in which the processing state and the environment of the process are described), and starts the execution of the task (step S<b>54</b>). At a time of this task switching, the task ID of the program is stored into the task ID storing register <b>14</b>.</p>
<p id="p-0056" num="0055">In the tamper resistant microprocessor <b>1</b>, the execution code <b>32</b> of the program is executed as follows. When the external bus interface acquires the instruction code from the external memory, the code and data encryption/decryption processing unit <b>11</b> refers to the content of the key value table <b>13</b> corresponding to the task ID stored in the task ID storing register <b>14</b>, and decrypts the execution code <b>32</b> by using the instruction key K<b>31</b> of the program <b>3</b> stored there. Then, the decrypted execution code <b>32</b> is given to the processor core <b>10</b> and executed there.</p>
<p id="p-0057" num="0056">(Loading of the Shared Library)</p>
<p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. 6</figref> shows a procedure by which the OS loads the shared library. The ordinary microprocessor does not create another task for the shared library separately from the calling source program. However, the tamper resistant microprocessor <b>1</b> creates another task for the shared library <b>4</b>, in order to account for the security in the case where the program <b>3</b> or the shared library <b>4</b> happens to be malicious. For this reason, the first operation to be carried out by the OS at a time of loading the shared library <b>4</b> is the creation of a task and the allocation of the task ID to the new task (step S<b>61</b>).</p>
<p id="p-0059" num="0058">Next, the OS acquires the instruction key K<b>41</b> from the header <b>41</b> of the shared library <b>4</b>, and stores the instruction key K<b>41</b> into the key value table entry <b>130</b><sub>i </sub>(0≦i≦1) corresponding to the task ID allocated earlier (step S<b>62</b>). By this step, it becomes possible for the microprocessor <b>1</b> to decrypt the shared library <b>4</b> that is encrypted by using the instruction key K<b>41</b> in advance, and the different instruction keys K<b>41</b> are stored into different key value table entries <b>130</b><sub>i </sub>(0≦i≦1). Consequently, even when a plurality of the shared libraries <b>4</b> exist, it becomes possible to identify them so that it is secure.</p>
<p id="p-0060" num="0059">Also, the OS refers to the import table <b>44</b> of the shared library <b>4</b> according to the need, and loads the other shared library <b>4</b> described therein (step S<b>63</b>). The procedure of this loading is the same as the procedure in the case of loading the shared library <b>4</b> according to the import table <b>34</b> of the program <b>3</b>.</p>
<p id="p-0061" num="0060">Next, the OS executes the bootstrap routine (loader) <b>42</b><i>a </i>of the shared library <b>4</b> (step S<b>64</b>). The bootstrap routine <b>42</b><i>a </i>carries out the necessary initialization processing, and then gives the control to the entry point code <b>42</b><i>b </i>(step S<b>65</b>). Then, the entry point code <b>42</b><i>b </i>returns the control to the OS. When the control is returned to the OS, the shared library <b>4</b> is shifted into a standby state (step S<b>66</b>).</p>
<p id="p-0062" num="0061">Note that, even in the case where the shared library <b>4</b> to be loaded is currently used by the other task already in a process of its execution, the loading of the shared library <b>4</b> is carried out at each occasion for each calling source task. As a result, as many task IDs as the number of calling source tasks are allocated with respect to the same shared library <b>4</b>. Here the execution code <b>42</b> of the shared library <b>4</b> can be loaded into the memory only once even when there are a plurality of calling source tasks, by utilizing the mechanism of the virtual memory of the microprocessor <b>1</b> and the OS.</p>
<p id="p-0063" num="0062">(Call Up of the Sub-Routine in the Shared Library)</p>
<p id="p-0064" num="0063">When there is a need to call up the sub-routine <b>42</b><i>c </i>(1≦i≦n) of the shared library <b>4</b> in a middle of the execution of the task, the processing for calling up the sub-routine <b>42</b><i>c</i><sub>1 </sub>(1≦i≦n) is carried out according to a sequence shown in <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 8</figref> shows a structure of a sub-routine call up parameter block <b>8</b>. The calling source task stores a shared library identifier <b>81</b> of the call up target shared library <b>4</b>, a subroutine identifier <b>82</b> of the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) to be called up, and parameters <b>83</b> to be given to the sub-routine <b>42</b><i>c</i>; (1≦i≦n), into the sub-routine call up parameter block <b>8</b>. After producing the sub-routine call up parameter block <b>8</b>, the calling source task gives the sub-routine call up parameter block <b>8</b> and makes a request for the sub-routine call up to the OS, by using a system call.</p>
<p id="p-0066" num="0065">Upon receiving this request, the OS stops the calling source task, selects the task of the call up target shared library <b>4</b> by referring to the shared library identifier <b>81</b> of the sub-routine call up parameter block <b>8</b>, and carries out the switching of the task to that shared library <b>4</b>. At this point, the sub-routine call up parameter block <b>8</b> is given to the task of the shared library <b>4</b>. When the switching of the task to the shared library <b>4</b> is carried out, the task ID of the shared library <b>4</b> is stored into the task ID storing register <b>14</b>. Then, the execution of the entry point code <b>42</b><i>b </i>of the shared library <b>4</b> that has been in the standby state until then is resumed.</p>
<p id="p-0067" num="0066">The procedure for executing the encrypted execution code <b>42</b> of the shared library <b>4</b> is the same as the procedure for executing the program execution code <b>32</b> described above.</p>
<p id="p-0068" num="0067">When the execution is resumed, the entry point code <b>42</b><i>b </i>of the shared library <b>4</b> refers to the content of the sub-routine call up parameter block <b>8</b>, and calls up the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) corresponding to the sub-routine identifier <b>81</b> specified therein. The called up sub-routine <b>42</b><i>c</i><sub>1 </sub>(1≦i≦n) refers to the parameters <b>83</b> in the sub-routine call up parameter block <b>8</b>, and carries out the requested processing. The data to be returned as the processing result is stored into the sub-routine call up parameter block <b>8</b>, and when the processing is completed, the processing returns to the entry point code <b>42</b><i>b </i>and then to the OS from there. When the processing returns to the OS, the shared library <b>4</b> is set back to the standby state, and the OS returns the sub-routine call up parameter block <b>8</b> to the calling source task and resumes the execution of the calling source task.</p>
<p id="p-0069" num="0068">(Multi-Thread Operation)</p>
<p id="p-0070" num="0069">In the case where the program <b>3</b> that is the calling source of the shared library <b>4</b> carries out the multi-thread operation, a plurality of threads cannot use the task of the shared library <b>4</b> simultaneously.</p>
<p id="p-0071" num="0070">For this reason, when the calling source program <b>3</b> requests a creation of a new thread during its execution, the OS carries out the processing for loading once again for all the shared libraries <b>4</b> used by the calling source program <b>3</b>. As a result, each shared library <b>4</b> is allocated with as many task IDs as the number of threads of the respective calling source program <b>3</b>. When the call up of the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> is requested from the thread, the OS selects an unused task ID that is allocated to that shared library <b>4</b>, and calls up the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> by using this task ID.</p>
<p id="p-0072" num="0071">Also, in order to reduce the number of task IDs to be used, the OS may carry out the loading of the shared library <b>4</b> when there is a shortage of the task IDs at a time of calling up the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n), rather than at a time of creating the task.</p>
<p id="p-0073" num="0072">(Method for Maintaining Secret Data Unique to the Shared Library)</p>
<p id="p-0074" num="0073">The sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> maintains the secret data such as a processing progress and a processing method inside the shared library <b>4</b> as follows.</p>
<p id="p-0075" num="0074">The creator of the shared library <b>4</b> produces one data key K<b>42</b> which is an encryption key for encrypting the secret data, and embeds the data key K<b>42</b> into the execution code <b>42</b> (see <figref idref="DRAWINGS">FIG. 4</figref>). A value of this data key K<b>42</b> is embedded in the execution code <b>42</b>, and the execution code <b>42</b> is encrypted by using the instruction key K<b>41</b>, so that those who do not know the instruction key K<b>41</b> of the shared library <b>4</b> cannot take out the data key K<b>42</b> from the shared library <b>4</b>. In order to encrypt the data to be kept secret, a value of this data key K<b>42</b> and an address of the memory region to be encrypted are stored into the key value table <b>13</b>. Then, the data to be read/written with respect to the specified memory region is encrypted/decrypted by the code and data encryption/decryption processing unit <b>11</b>. It is also possible to distribute the data encrypted by using this data key K<b>42</b> in advance as the initialized data <b>43</b> of the shared library <b>4</b>, such that the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> uses it by decrypting it as described above.</p>
<p id="p-0076" num="0075">After the data are written into the above described memory region and the processing is returned to the calling source once, when there is a need to read this data upon being called up again, it suffices to store the same data key K<b>42</b> into the key value table <b>13</b> again.</p>
<p id="p-0077" num="0076">However, according to the above described method, as long as the same shared library <b>4</b> is used, the data key K<b>42</b> of the same value will be used every time no matter how many times the shared library <b>4</b> is loaded. In other words, When the same data key K<b>42</b> is used, it becomes possible to store the encrypted data at a time of the one program execution, and write this data into the same memory region at a time of the another program execution, such that the state at a time of the previous execution can be reproduced. If such a re-utilization of the data is allowed, there is a possibility that this fact may be used as a way of attacking against the operation of the shared library <b>4</b>, so that this fact can be inconvenient in some cases.</p>
<p id="p-0078" num="0077">In such a case, as described in the commonly assigned co-pending U.S. patent application Ser. No. 09/984,407, it suffices to use the random number generated by the random number generation unit <b>15</b> of the microprocessor <b>1</b> as the data key K<b>42</b>, by regarding the instruction key and the data key as a key pair. The task of the shared library <b>4</b> acquires the random number from the random number generation unit <b>15</b> at a time of the execution, and stores this as the data key K<b>42</b> along with an address of the memory region to be encrypted by using this data key K<b>42</b>, into the key value table <b>13</b>. When the data key K<b>42</b> which is generated by the random number generation unit <b>15</b> for each task of the shared library <b>4</b> is used, the data key K<b>42</b> of different values will be used for different tasks. Consequently, it becomes impossible to re-utilize the data encrypted by using the data key K<b>42</b> which is obtained as described above.</p>
<p id="p-0079" num="0078">The content of the pair of the instruction key K<b>41</b> and the data key K<b>42</b> will not be lost even when the processing returns to the calling source, so that when the sub-routine of the shared library <b>4</b> is called up again, it is still possible to read the data encrypted by using this data key K<b>42</b>.</p>
<p id="p-0080" num="0079">(Exchange of Data)</p>
<p id="p-0081" num="0080">The shared library <b>4</b> and its calling source (program or another shared library) can exchange data with each other by using the sub-routine call up parameter block <b>8</b> described above. However, the content of this sub-routine call up parameter block <b>8</b> is not encrypted, so that there is a possibility for the OS to peep its content.</p>
<p id="p-0082" num="0081">In order for the shared library <b>4</b> and its calling source to exchange the secret data with each other, as proposed in commonly assigned co-pending U.S. patent application Ser. No. 10/028,794, it suffices to carry out the key generation using the Diffie-Hellman key exchange sequence between them. The key generated by the Diffie-Hellman key exchange sequence can be calculated only by two sides which carried out the key exchange. Namely, even the OS which can observe the exchange between them cannot learn the value of this key. In the following, this key will be referred to as a common key ck.</p>
<p id="p-0083" num="0082">As a memory region for exchanging the secret data, a memory region shared between them is allocated by the memory sharing mechanism provided by the OS. When each of the shared library <b>4</b> and the calling source registers the common key into the key value table entry <b>130</b><sub>i </sub>(0≦i≦1) of the respective task, for this memory region, it becomes possible for each of them to decrypt and read the content encrypted and written into this memory region by the other one of them. The memory region prepared in this way will be referred to as a shared encrypted data region in the following.</p>
<p id="p-0084" num="0083">In the case where there is a need for the shared library <b>4</b> and its calling source to authenticate each other as an intended correspondent program <b>3</b> or shared library <b>4</b>, this can be done by attaching a signature according to the public key cryptosystem to a message of the above described key exchange sequence.</p>
<p id="p-0085" num="0084">For example, in the case where there is a need for the program <b>3</b> to authenticate the shared library <b>4</b>, a pair of the public key and the secret key is given to the shared library <b>4</b> in advance, and the public key of the shared library <b>4</b> is distributed to the creator of the program <b>3</b> in advance. The authentication is realized by attaching the signature based on the secret key of the shared library <b>4</b> to the message to be sent by the shared library <b>4</b> to the program <b>3</b> for the purpose of the key exchange, and verifying this signature at the program <b>3</b> by using the public key of the shared library <b>4</b>.</p>
<p id="p-0086" num="0085">On the other hand, in the case where there is a need for the shared library <b>4</b> to authenticate the program <b>3</b>, a pair of the public key and the secret key is given to the program <b>3</b> in advance, and the public key of the program <b>3</b> is distributed to the creator of the shared library <b>4</b> in advance. The authentication is realized by attaching the signature based on the secret key of the program <b>3</b> to the message to be sent by the program <b>3</b> to the shared library <b>4</b> for the purpose of the key exchange, and verifying this signature at the shared library <b>4</b> by using the public key of the program <b>3</b>.</p>
<p id="p-0087" num="0086">Note that the authentication and the key exchange are carried out simultaneously in these schemes, because if they are carried out separately, there would be no method for confirming that the correspondent with whom the authentication is carried out and the correspondent with whom the key exchange is carried out are the same one, so that the pretending of the correspondent by the malicious program would become possible and the authentication could not be done correctly.</p>
<p id="p-0088" num="0087">(Operation of the Shared Library)</p>
<p id="p-0089" num="0088">Using the basic operation of each part described above, the operation of the actual shared library <b>4</b> according to this embodiment will be described.</p>
<p id="p-0090" num="0089"><figref idref="DRAWINGS">FIG. 9</figref> shows an operation on the shared library <b>4</b> side in a procedure by which the program <b>3</b> to be described here uses the shared library <b>4</b>. <figref idref="DRAWINGS">FIG. 10</figref> shows an operation on the program <b>3</b> side at that time. Also, <figref idref="DRAWINGS">FIG. 11</figref> shows an arrangement of memory address spaces of the program <b>3</b> and the shared library <b>4</b> at that time.</p>
<p id="p-0091" num="0090">The shared library <b>4</b> to be described here provides a routine for the operation to receive data from the program <b>3</b>, carry out some processing and return the processing result. Besides that, an assistant routine for carrying out the Diffie-Hellman key exchange sequence is also available from the program <b>3</b>. Also, it is assumed that the public key and the secret key for the authentication described above are given to the shared library <b>4</b> in advance, such that the shared library <b>4</b> can be authenticated from the program <b>3</b> side. Among them, the public key is distributed along with the shared library <b>4</b> such that a programmer who wishes to use this shared library <b>4</b> can incorporate this public key into the program to be created by the programmer.</p>
<p id="p-0092" num="0091">When the program <b>3</b> that uses the shared library <b>4</b> is executed, the loading of the shared library <b>4</b> is carried out, as described above with reference to <figref idref="DRAWINGS">FIG. 6</figref> (step S<b>91</b>). At a time of the loading, the bootstrap routine <b>42</b><i>a </i>(see <figref idref="DRAWINGS">FIG. 6</figref>) of the shared library <b>4</b> is executed. At this point, the random number is acquired from the random number generation unit <b>15</b> of the microprocessor <b>1</b>, and the data key K<b>42</b> is generated by using the random number and stored into the key value table <b>13</b> as the data key K<b>42</b> of the shared library <b>4</b>. When the loading is completed, the shared library <b>4</b> is set in the standby state, and the execution of the program <b>3</b> is started. Similarly as the shared library <b>4</b>, the program <b>3</b> also acquires the random number from the random number generation unit <b>15</b> in order to encrypt the memory region to be used by the program <b>3</b>, and the data key K<b>32</b> is generated and stored into the key value table <b>13</b> as the data key K<b>32</b> of the program <b>3</b> (step S<b>101</b>).</p>
<p id="p-0093" num="0092">Before using the function of the shared library <b>4</b>, the program <b>3</b> prepares the shared encrypted data region <b>115</b> for the purpose of the data exchange (step S<b>102</b>). Then, the routine of the shared library <b>4</b> for carrying out the Diffie-Hellman key exchange sequence is called up (step S<b>103</b>). In conjunction with this, the shared library <b>4</b> side also executes the Diffie-Hellman key exchange sequence (step S<b>92</b>).</p>
<p id="p-0094" num="0093">At a time of the key exchange, the signature using the secret key for the authentication of the shared library <b>4</b> is attached to the message to be sent from the shared library <b>4</b> to the program <b>3</b>, and this authentication information is sent to the program <b>3</b> (step S<b>93</b>). The program <b>3</b> receives this authentication information from the shared library <b>4</b> (step S<b>104</b>). Here, the verification of the signature by using the public key for the authentication of the shared library <b>4</b> is carried out (step S<b>105</b>). The key exchange sequence is finished only when this authentication succeeds (step S<b>106</b>). By this verification of the signature, it is possible to confirm that the shared library <b>4</b> which is the correspondent with whom the key exchange is carried out is the intended correct shared library <b>4</b>.</p>
<p id="p-0095" num="0094">On the program <b>3</b> side, the value of the common key ck generated as a result of the key exchange is encrypted by using the data key K<b>32</b> of the program <b>3</b> and written into the secret data region <b>112</b> which cannot be read by anything other than the program <b>3</b>. Similarly, on the shared library <b>4</b> side, the above described common key ck is encrypted by using the data key K<b>42</b> of the shared library <b>4</b> and written into the secret data region <b>114</b> which cannot be read by anything other than the shared library <b>4</b> (step S<b>94</b>). Next, the program <b>3</b> makes a request to the OS and secures the shared memory region for the purpose of the data exchange, and sets the common key ck in the key value table <b>13</b> such that it is applied to this shared memory region (step S<b>107</b>). Also, the address of this shared memory region is notified to the shared library <b>4</b>, and the shared library <b>4</b> side also sets the common key ck in the key value table <b>13</b> such that it is applied to the same shared memory region. On the other hand, the shared library <b>4</b> receives the address of this shared memory region and carries out the key setting (step S<b>95</b>). As a result, it becomes possible to use this shared memory region as the shared encrypted data region <b>115</b>.</p>
<p id="p-0096" num="0095">When the program <b>3</b> actually calls up the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> for carrying out the desired processing, the data to be given is entered into the shared encrypted data region <b>115</b>, and a checksum <b>111</b> of this data is calculated and attached to the data. Then, the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> is called up (step S<b>109</b>). When this call up signal is received (step S<b>96</b>), the sub-routine <b>42</b><i>c</i><sub>i </sub>(1≦i≦n) of the shared library <b>4</b> checks the checksum <b>111</b> first (step S<b>97</b>). When the checksum <b>111</b> does not match the data content, the processing is finished as an error (step S<b>971</b>). When the checksum matches, the data and the request from the calling source side are read out from the shared encrypted data region <b>115</b> next (step S<b>98</b>). In the case where a work memory region is necessary in a process of this processing, the shared library <b>4</b> may create and use its own memory region (work region) <b>116</b> which is encrypted by using the data key K<b>42</b> (step S<b>99</b>).</p>
<p id="p-0097" num="0096">Next, the processing requested for this data is carried out (step S<b>990</b>). When the requested processing is completed, the processing result is stored into the shared encrypted data region <b>115</b>, the checksum <b>111</b> is attached, and the processing returns to the program <b>3</b> (step S<b>991</b>). When the processing returns, the program <b>3</b> checks the checksum <b>111</b> (steps S<b>110</b>, S<b>111</b>). When the checksum matches the data content, the processing is continued by using the returned data (step S<b>112</b>). When the checksum does not match, the error is returned and the processing is finished (step S<b>113</b>).</p>
<p id="p-0098" num="0097">As long as the procedure for the key exchange and the format of the data exchange are disclosed publicly, anyone can create the program <b>3</b> that uses the shared library <b>4</b> described above. The fact that this shared library <b>4</b> satisfies the requirements regarding the security can be confirmed as follows.</p>
<p id="p-0099" num="0098">The secrecy of the data given from the program <b>3</b> can be guaranteed by the fact that the shared encrypted data region <b>115</b> shared between the program <b>3</b> and the shared library <b>4</b> is encrypted by using the common key ck.</p>
<p id="p-0100" num="0099">Here, the common key ck used for the encryption is generated by the Diffie-Hellman key exchange. Consequently, the value of the common key ck will not be known by anything other than the program <b>3</b> and the shared library <b>4</b>, unless either one of them intentionally or accidentally disclose this common key ck publicly. Also, the same shared encrypted data region <b>115</b> is used at a time of returning the processing result, so that this content can be viewed only by the program <b>3</b> and the shared library <b>4</b>. Even if the other program attempts to read the processing result, the other program does not know the value of the common key ck according to the original Diffie-Hellman key exchange so that the content cannot be decrypted.</p>
<p id="p-0101" num="0100">It is possible to consider an attack in which the OS fraudulently substitute another program into the calling source program <b>3</b>, and the program <b>3</b> after the substitution steals the processing result returned from the shared library <b>4</b>, However, the calling source program would be the program <b>3</b> of the instruction key K<b>31</b> which is different before and after the fraudulent substitution so that the contents of the instruction key K<b>31</b> and the data key K<b>32</b> that are managed as a pair in the key value table <b>13</b> would both be changed, The common key ck is stored in the shared encrypted data region <b>115</b> which is encrypted by the data key K<b>32</b> before the fraudulent substitution, but the value of the data key K<b>32</b> in the key value table <b>13</b> after the fraudulent substitution is changed so that the program <b>3</b> after the fraudulent substitution cannot read the common key ck. For this reason, it is in principle impossible for the program <b>3</b> after the fraudulent substitution to decrypt the data returned from the shared library <b>4</b>.</p>
<p id="p-0102" num="0101">It is also possible to consider another attack in which the erroneous operation is induced as another program <b>3</b> alters the content of the data exchanged between the program <b>3</b> and the shared library <b>4</b> in a course of the data exchange between them. However, the program <b>3</b> on the side of altering the data does not know the value of the common key ck used in encrypting this data so that it cannot predict a result of decrypting the altered result. Consequently, the decrypted result of the data becomes random if the alteration is made and the alteration will be detected by the checking of the compatibility according to the checksum <b>111</b>.</p>
<p id="p-0103" num="0102">Even in the case where a plurality of tasks are using the same shared library <b>4</b> simultaneously, a different task is allocated to the shared library <b>4</b> for a different calling source task, so that a respective shared library <b>4</b> will use a respectively different data key K<b>42</b>. For this reason, the case of erroneously giving the data received by each shared library <b>4</b> from some calling source to another calling source will not occur.</p>
<p id="p-0104" num="0103">It is impossible for the program <b>3</b> that calls up the shared library <b>4</b> itself to see the execution code <b>42</b> of the shared library <b>4</b> because the shared library <b>4</b> is encrypted by its own unique instruction key K<b>41</b>. Also, the content of the work memory used in a process of the processing by the shared library <b>4</b> uses the secret data region <b>114</b> which is encrypted by using the data key K<b>42</b> that is known only by the shared library <b>4</b>, so that it is impossible to peep this content.</p>
<p id="p-0105" num="0104">Note that the shared library <b>4</b> described above has the secret key for the authentication in advance. For this reason, the third party who does not know this secret key cannot create the shared library that can be substituted into this shared library <b>4</b> at his own will. This goes against the characteristic that the shared library compatible with the existing shared library can be created freely, which is an advantage of the dynamic link shared library. However, this is the limiting factor which is indispensable in guaranteeing the security of the operation of the shared library <b>4</b> to the program <b>3</b>. When a developer other than the original provider of the shared library <b>4</b> needs to create a new shared library <b>4</b> which is compatible with this shared library <b>4</b> in order to add some function, it suffices to ask the provider of the original shared library <b>4</b> to confirm the security of the new shared library <b>4</b> and ask him to embed the secret key into the new shared library <b>4</b>.</p>
<p id="p-0106" num="0105">As described above, according to the present invention, it becomes possible to use the protected shared library from a protected application program operated on the tamper resistant microprocessor. By using the shared library, it becomes possible to improve the program development efficiency and the ability to enhance the function of the program. It is also possible to protect the secrecy of the data such as the processing result, and the processing method inside the encrypted program and the shared library, by enabling the exchange of the secret data and the mutual authentication.</p>
<p id="p-0107" num="0106">According to the method for using the shared library realized in this way, the execution code of the shared library is protected because the shared library itself is processed as a task which has a single identifier, and the instruction key for encrypting/decrypting the shared library is recorded at a location within the microprocessor corresponding to that identifier.</p>
<p id="p-0108" num="0107">In such a shared library, the processing result and the data of the processing result are encrypted by using the data key of the shared library when the shared library carries out the processing requested from the program. For this reason, in addition to the encrypting of the code of the shared library itself, it is possible to prevent the leakage to the external of the internal processing method and processing result. Also, it is possible to surely protect the processing content and the processing result within the shared library even in the case where the calling source is changed before and after the processing by the OS or the like, as the checksum matches or nor is checked each other when the request for processing is received and the processing result is returned to the calling source. In addition, it is also possible to use one shared library from a plurality of calling sources because the loading is carried out as many times as the number of the calling sources.</p>
<p id="p-0109" num="0108">It is also to be noted that, besides those already mentioned above, many modifications and variations of the above embodiments may be made without departing from the novel and advantageous features of the present invention. Accordingly, all such modifications and variations are intended to be included within the scope of the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for using a shared library called up from a calling source program in a tamper resistant microprocessor which has a function for decrypting and executing encrypted codes and a table formed by a plurality of regions for storing a plurality of encryption keys corresponding to at least one program and at least one shared library to be called up by the at least one program, the method comprising:
<claim-text>creating a task for the shared library;</claim-text>
<claim-text>allocating a task identifier to the task;</claim-text>
<claim-text>acquiring an instruction key from a header of the shared library;</claim-text>
<claim-text>storing the instruction key into a region of the table corresponding to the task identifier allocated to the task for the shared library in the microprocessor;</claim-text>
<claim-text>initializing by executing a loader in the shared library; and</claim-text>
<claim-text>returning a control to the calling source program via an entry point in the shared library.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>loading another shared library by referring to an import table in the shared library, after storing the instruction key into the table in the microprocessor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the initializing step executes as many loaders in the shared library as a number of calling source programs, and the method further comprising:
<claim-text>producing as many data keys as the number of calling source programs for encrypting data to be used by the shared library, before the returning step;</claim-text>
<claim-text>storing the data keys into a region of the table to which the task identifier of the task for the shared library is allocated in the microprocessor, before the returning step;</claim-text>
<claim-text>setting the shared library in a standby state waiting for a call up from the calling source program, after the returning step;</claim-text>
<claim-text>having the shared library authenticated by the calling source program;</claim-text>
<claim-text>receiving an address of a shared memory region produced by the calling source program;</claim-text>
<claim-text>setting the shared memory region as a shared encrypted data region to be used in data exchange between the calling source program and the shared library;</claim-text>
<claim-text>controlling the shared library to receive a signal for calling up a sub-routine in the shared library from the calling source program;</claim-text>
<claim-text>verifying a checksum of data of the calling source program;</claim-text>
<claim-text>carrying out a processing requested from the calling source program when the checksum of the data of the calling source program matches the data; and</claim-text>
<claim-text>sending a result of the requested processing by adding the checksum into the shared encrypted data region.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:
<claim-text>encrypting a work memory region for carrying out the processing requested from the calling source program by using one of the data keys of the shared library, after the verifying step;</claim-text>
<claim-text>wherein the carrying out step carries out the processing requested from the calling source program in the work memory region encrypted by the encrypting step.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the authenticating step carries out an authentication by sending to the calling source program an authentication information to which a signature according to a secret key stored in the shared library in advance is attached, and producing a common key to be used between the calling source program and the shared library.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising:
<claim-text>encrypting the common key by using one of the data keys of the shared library, after the authenticating step; and</claim-text>
<claim-text>storing the common key encrypted by the encrypting step into a secret data region of the shared library.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>generating a data key for encrypting a work memory region of the shared library from a random number from a random number generation unit in the microprocessor before the returning step; and</claim-text>
<claim-text>setting the shared library in a standby state waiting for a call up from the calling source program, after the returning step.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
