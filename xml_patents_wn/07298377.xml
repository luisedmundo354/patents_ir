<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298377-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298377</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10875955</doc-number>
<date>20040624</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>284</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>09</class>
<subclass>G</subclass>
<main-group>5</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>16</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>167</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>345584</main-classification>
<further-classification>345502</further-classification>
<further-classification>345541</further-classification>
</classification-national>
<invention-title id="d0e53">System and method for cache optimized data formatting</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5517587</doc-number>
<kind>A</kind>
<name>Baker et al.</name>
<date>19960500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>382296</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5761516</doc-number>
<kind>A</kind>
<name>Rostoker et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710260</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6005582</doc-number>
<kind>A</kind>
<name>Gabriel et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345586</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6441816</doc-number>
<kind>B1</kind>
<name>Nguyen et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345420</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6674430</doc-number>
<kind>B1</kind>
<name>Kaufman et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345419</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2002/0080143</doc-number>
<kind>A1</kind>
<name>Morgan et al.</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345581</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00007">
<othercit>Fuchs, H. et al., “Pixel-Planes 5: A Heterogeneous Multiprocessor Graphics System Using Processor-Enhanced Memories,” SIGGRAPH 1989 Conference Proceedings, pp. 79-88, 1989.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>Sato, H. et al., “Fast Image Generation of Constructive Solid Geometry Using A Cellular Array Processor,” SIGGRAPH 1985 Conference Proceedings, pp. 95-102, 1985.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00009">
<othercit>“Cell (microprocessor),” http://en.wikipedia.org/wiki/Cell<sub>—</sub>(microprocessor).</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00010">
<othercit>“Non-volatile memory,” http://en.wikipedia.org/wiki/Non-volatile<sub>—</sub>storage.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
</references-cited>
<number-of-claims>15</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>345502</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345501</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345584</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345582</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345581</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345418</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345419</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345423</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345541</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345530</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>382282</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>16</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050285859</doc-number>
<kind>A1</kind>
<date>20051229</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Fossum</last-name>
<first-name>Gordon Clyde</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Minor</last-name>
<first-name>Barry L</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Van Leeuwen &amp; Van Leeuwen</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Rifai</last-name>
<first-name>D'Ann N.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Tung</last-name>
<first-name>Kee M.</first-name>
<department>2628</department>
</primary-examiner>
<assistant-examiner>
<last-name>Hsu</last-name>
<first-name>Joni</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system and method for cache optimized data formatting is presented. A processor generates images by calculating a plurality of image point values using height data, color data, and normal data. Normal data is computed for a particular image point using pixel data adjacent to the image point. The computed normalized data, along with corresponding height data and color data, are included in a limited space data stream and sent to a processor to generate an image. The normalized data may be computed using adjacent pixel data at any time prior to inserting the normalized data in the limited space data stream.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="135.97mm" wi="186.01mm" file="US07298377-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="187.37mm" wi="182.63mm" file="US07298377-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="219.54mm" wi="165.78mm" file="US07298377-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="209.30mm" wi="134.37mm" file="US07298377-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="185.50mm" wi="155.53mm" file="US07298377-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="241.55mm" wi="156.72mm" file="US07298377-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="222.50mm" wi="148.25mm" file="US07298377-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="241.89mm" wi="174.24mm" file="US07298377-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="137.67mm" wi="164.34mm" file="US07298377-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="240.45mm" wi="177.21mm" file="US07298377-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="202.69mm" wi="183.47mm" file="US07298377-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="225.47mm" wi="187.79mm" file="US07298377-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="241.05mm" wi="180.51mm" file="US07298377-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Technical Field</p>
<p id="p-0003" num="0002">The present invention relates in general to a system and method for a cache optimized data format. More particularly, the present invention relates to a system and method for including normalized data in a data stream that is optimized to a processor's memory capability.</p>
<p id="p-0004" num="0003">2. Description of the Related Art</p>
<p id="p-0005" num="0004">The increase of computer system processing speeds has allowed today's computer systems to perform fairly accurate terrain rendering. In the computer gaming industry, for example, three dimensional terrain rendering is an essential element for providing a “visual reality” to computer games. In addition to the gaming industry, three-dimensional terrain rendering is utilized in other fields, such as flight simulation and environmental planning.</p>
<p id="p-0006" num="0005">Software developers may use “ray casting” for terrain rendering, which produces realistic images. However, ray casting algorithms are inherently complex, and, therefore, require excessive processing time. As an alternative, software developers may use vertical ray coherence for terrain rendering. Vertical ray coherence is an algorithm that exploits the geometric fact that if a plane containing two rays is vertical to a plane of a height map, the two rays may be processed using the same small subset of data from a digital terrain model.</p>
<p id="p-0007" num="0006">While performing vertical ray coherence, a computer system uses vertical half planes to identify vertical rays, such as height map vertical rays, and computes image values along the height map vertical ray. A challenge found, however, is that a processor is required to quickly generate image values for a large amount of data points along the height map vertical ray and, with the limited memory space and processing power of personal computers and portable gaming devices, image generation speed may be slow.</p>
<p id="p-0008" num="0007">What is needed, therefore, is a system and method to optimize a data's format that is particular to a processor's execution environment in order to increase image generation performance.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0009" num="0008">It has been discovered that the aforementioned challenges are resolved by including normalized data in a data stream whereby the data stream is optimized to a processor's memory configuration. A processor generates an image by calculating a plurality of image point values using height data, color data, and normal data. Normal data is computed for a particular image point using data that is adjacent to the image point. The computed normalized data, along with corresponding height data and color data, are included in a limited space data stream and sent to a processor, which generates an image. The normalized data may be computed using adjacent data at any time prior to inserting the normalized data in the limited space data stream.</p>
<p id="p-0010" num="0009">A processor identifies a height map intersection point, and retrieves adjacent data points that correspond to the height map intersection point. The height map intersection point has two corresponding adjacent data points that are a left data point and a right data point. The processor extracts normalized data from the left adjacent data point. The left adjacent data point's normalized data may be calculated prior to identifying the adjacent data points. For example, when a software program initializes, the software program may generate normalized data for each data point using their adjacent data points, and then store the normalized data in each data point.</p>
<p id="p-0011" num="0010">In addition, the processor extracts height and color data from the left adjacent data point. The height data may be two bytes in length and the color may be three bytes in length whereby each color byte corresponds to a red color, a green color, and a blue color. The processor stores the left adjacent data point's normalized data, height data, and color data in a data stream. The data stream is specifically designed to function with a particular processor's limited cache size.</p>
<p id="p-0012" num="0011">The processor extracts the same data from the right data point, stores the data in the data stream, and sends the data stream to a second processor, which has a limited cache size. The second processor uses the data that is included in the data stream to generate image values.</p>
<p id="p-0013" num="0012">The foregoing is a summary and thus contains, by necessity, simplifications, generalizations, and omissions of detail; consequently, those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects, inventive features, and advantages of the present invention, as defined solely by the claims, will become apparent in the non-limiting detailed description set forth below.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The present invention may be better understood, and its numerous objects, features, and advantages made apparent to those skilled in the art by referencing the accompanying drawings. The use of the same reference symbols in different drawings indicates similar or identical items.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram showing a plurality of rays that originate from an eye point, tracing through a view screen, and intersecting a height map;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2A</figref> is diagram showing a plurality of height map vertical rays transposed along a height map;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2B</figref> is diagram showing adjacent data points that correspond to a particular height map vertical ray;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 2C</figref> is diagram showing scan-line intersection points that correspond to a height map vertical ray;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 3A</figref> is a diagram showing a quadrilateral approach to data value calculations;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 3B</figref> is a diagram showing a triangular approach to data value calculations;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram showing when a processor blends quadrilateral and triangular data values to generate image values for height map intersection points that lie on a height map vertical ray;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart showing steps taken in generating an image value using a plurality of vertical half planes;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart showing steps taken in collecting adjacent data points for a particular height map vertical ray;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart showing steps taken in generating image values for height map intersection points;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram of a cache optimized data format;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart showing steps taken in storing data in a cache optimized data stream and sending the data stream to a processor for processing;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram showing a processor element architecture that includes a plurality of heterogeneous processors;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 11A</figref> is a block diagram of a first information handling system capable of implementing the present invention;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 11B</figref> is a diagram showing a local storage area divided into private memory and non-private memory; and</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 12</figref> is a block diagram of a second information handling system capable of implementing the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0031" num="0030">The following is intended to provide a detailed description of an example of the invention and should not be taken to be limiting of the invention itself. Rather, any number of variations may fall within the scope of the invention which is defined in the claims following the description.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram showing a plurality of rays that originate from an eye point, tracing through a view screen, and intersecting a height map. A processor generates images that correspond to the height map intersections using a limited memory footprint. Height map <b>110</b> includes a plurality of data points that are organized by a grid, whereby each data point includes height data.</p>
<p id="p-0033" num="0032">During terrain rendering, a processor identifies eye point <b>100</b> and a look-at vector. Eye point <b>100</b> corresponds to a location at which a user views view screen <b>120</b> and the look-at vector is a vector that originates at eye point <b>100</b> and pierces the center of view screen <b>120</b>. Using eye point <b>100</b>, the processor derives the location of down point <b>130</b>. Down point <b>130</b> may land either on or off height map <b>110</b>. In addition, the processor derives view screen <b>120</b>, such as its location from eye point <b>100</b>, its size, and its angle relative to height map <b>110</b>.</p>
<p id="p-0034" num="0033">Once the processor derives view screen <b>120</b>, the processor selects a vertical plane sampling density and identifies a list of interesting vertical half planes. An interesting vertical half plane is a half plane that is perpendicular to height map <b>110</b>, travels through down point <b>130</b>, and travels through view screen <b>120</b>. A processor is not required to generate image pixels that correspond to vertical half planes that do not travel through view screen <b>120</b>.</p>
<p id="p-0035" num="0034">The place at which an interesting vertical half plane intersects height map <b>110</b> creates a height map vertical ray, such as height map vertical ray <b>135</b>. In addition, the place at which the interesting vertical half plane intersects view screen <b>120</b> creates a view screen vertical ray, such as view screen vertical ray <b>125</b>.</p>
<p id="p-0036" num="0035">The processor uses view screen vertical ray <b>125</b> and eye point <b>100</b> to identify a memory footprint starting point and a memory footprint ending point that corresponds to height map vertical ray <b>135</b>. The processor generates ray <b>140</b> which originates at eye point <b>100</b>, travels through view screen vertical ray <b>125</b> at the bottom of view screen <b>120</b> (point <b>145</b>), and intersects height map <b>110</b> along height map vertical ray <b>135</b> at start point <b>150</b>. Data below start point <b>150</b> is inconsequential to generating a view in the particular example shown in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0037" num="0036">In addition, the processor generates ray <b>180</b> which originates at eye point <b>100</b>, travels through view screen vertical ray <b>125</b> at the top of view screen <b>120</b> (point <b>185</b>), and intersects height map <b>110</b> along height map vertical ray <b>135</b> at end point <b>190</b>. Data above end point <b>190</b> is inconsequential to generating a view in the particular example shown in <figref idref="DRAWINGS">FIG. 1</figref>. If end point <b>190</b> falls outside of height map <b>110</b>, the processor uses visibility settings (i.e. cloud coverage) in order to generate images between the end of height map <b>110</b> and end point <b>190</b> along height map vertical ray <b>135</b>.</p>
<p id="p-0038" num="0037">Once start point <b>150</b> and end point <b>190</b> are identified, the processor collects data points that are adjacent to height map vertical ray <b>135</b> and between start point <b>150</b> and end point <b>190</b>, creating a memory footprint subset (see <figref idref="DRAWINGS">FIGS. 2B</figref>, <b>2</b>C, <b>6</b>, and corresponding text for further details regarding adjacent data point collection).</p>
<p id="p-0039" num="0038">Once the processor collects the memory footprint subset, the processor is ready to generate image values using the memory footprint subset. The processor uses quadrilateral data value calculations and triangular data value calculations in order to generate a blended image value. The processor identifies height map vertical ray <b>135</b>'s minor step, and computes a quadrilateral weighting factor and a triangular weighting factor that the processor uses when it generates a blended image value (see <figref idref="DRAWINGS">FIG. 4</figref> and corresponding text for further details regarding blending techniques).</p>
<p id="p-0040" num="0039">The processor selects a pixel sampling density that determines the number of rays that correspond to each pixel that is located along view screen vertical ray <b>125</b>. For example, the pixel sampling density may be “4” whereby four rays, each starting at eye point <b>100</b>, are shot at ¼ increments through each view screen pixel. In effect, the rays intersect height map vertical ray <b>135</b> at four separate locations. Once the processor selects a pixel sampling density, the processor shoots a ray (i.e. ray <b>160</b>) through a view screen intersection point (i.e. view screen intersection point <b>165</b>) along view screen vertical ray <b>125</b>. In turn, ray <b>160</b> intersects height map vertical ray <b>135</b> at height map intersection point <b>170</b>.</p>
<p id="p-0041" num="0040">Once the processor identifies the location of height map intersection point <b>170</b>, the processor identifies data points that are adjacent to height map intersection point <b>170</b>. The adjacent data points are included in the memory footprint subset that the processor previously collected. The processor uses the adjacent data points, the quadrilateral weighting factor, and the triangular weighting factor in order to generate an image value for height map intersection point <b>170</b> (see <figref idref="DRAWINGS">FIG. 7</figref> and corresponding text for further details regarding image generation). The processor generates images for each height map intersection point along each height map vertical ray in order to generate a full image to display on view screen <b>120</b>.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 2A</figref> is diagram showing a plurality of height map vertical rays transposed along a height map. Height map <b>110</b> includes data points <b>200</b> which are organized in a grid. Height map <b>110</b> is the same as that shown in <figref idref="DRAWINGS">FIG. 1</figref>. When interesting vertical half planes intersect height map <b>110</b>, height map vertical rays are generated (see <figref idref="DRAWINGS">FIG. 1</figref> and corresponding text for further details regarding height map vertical ray generation).</p>
<p id="p-0043" num="0042">Vertical ray <b>135</b> is the same as that shown in <figref idref="DRAWINGS">FIG. 1</figref>, and originates at a particular down point. Height map vertical rays <b>205</b> through <b>230</b> also originate at the same down point but correspond to different interesting vertical half planes. For each height map vertical ray, the processor identifies adjacent data points and stores the adjacent data points in a memory footprint subset (see <figref idref="DRAWINGS">FIG. 2B</figref> and corresponding text for further details regarding adjacent data points.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 2B</figref> is diagram showing adjacent data points that correspond to a particular height map vertical ray. <figref idref="DRAWINGS">FIG. 2B</figref> is the same as <figref idref="DRAWINGS">FIG. 2A</figref> except that it shows only the adjacent data points included in height map <b>110</b> that are adjacent to height map vertical ray <b>135</b>. In addition, the processor may collect only adjacent data points that are between a memory footprint start point and a memory footprint end point (see <figref idref="DRAWINGS">FIG. 1</figref> and corresponding text for further details regarding start points and end points).</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 2C</figref> is diagram showing scan-line intersection points that correspond to a height map vertical ray. Height map vertical ray <b>135</b> intersects height map <b>110</b> at particular “scan-lines.” These scan-lines correspond to the data point “grid.” A processor calculates scan-line intersection points upfront using a well-known Bresenham line drawing algorithm. The scan-line intersection points are calculated in order to determine which data points are adjacent to a particular height map vertical ray. <figref idref="DRAWINGS">FIG. 2C</figref> shows that height map vertical ray <b>135</b> intersects the shown scan-lines in four points which are point <b>282</b>, <b>287</b>, <b>292</b>, and <b>297</b>.</p>
<p id="p-0046" num="0045">Data points <b>250</b> through <b>275</b> are data points that are adjacent to height map vertical ray <b>135</b>. A processor uses data points <b>250</b> through <b>275</b> in order to calculate quadrilateral data values and triangular data values for height map intersection points along height map vertical ray <b>135</b>.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 3A</figref> is a diagram showing a quadrilateral approach to data value calculations. <figref idref="DRAWINGS">FIG. 3A</figref> shows four adjacent data points that correspond to height map vertical ray <b>300</b>. The four data points are data points <b>305</b> (“A”), <b>310</b> (“B”), <b>320</b> (“C”), and <b>330</b> (“D”). Height map vertical ray <b>300</b> intersects two scan lines at scan line intersection points <b>340</b> (“t1”) and <b>350</b> (“t2”). Point <b>360</b> is a height map vertical intersection point in which a processor calculates an image values using the data values that correspond to data points <b>305</b> through <b>330</b>. Using standard quadrilateral calculation techniques, the quadrilateral value of point <b>360</b> with coordinates “x,y” is calculated as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V</i><sub>top</sub><i>=t</i><sub>1</sub><i>*B</i>+(1<i>−t</i><sub>1</sub>)*<i>A</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V</i><sub>bottom</sub><i>=t</i><sub>2</sub><i>*D</i>+(1<i>−t</i><sub>2</sub>)*<i>C</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V</i><sub>Quad</sub><i>=Y*V</i><sub>top</sub>+(1<i>−Y</i>)*<i>V</i><sub>bottom</sub><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0048" num="0047">The value of V<sub>Quad </sub>is used in conjunction with a triangular data value in order to generate a blended data value for point <b>360</b> (see <figref idref="DRAWINGS">FIG. 3B</figref> and corresponding text for further details regarding triangular calculations.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 3B</figref> is a diagram showing a triangular approach to data value calculations. <figref idref="DRAWINGS">FIG. 3B</figref> shows four adjacent data points that correspond to height map vertical ray <b>380</b>. The four data points are data points <b>365</b> (“D”), <b>370</b> (“E”), <b>375</b> (“F”), and <b>380</b> (“G”). Height map vertical ray <b>385</b> includes point <b>390</b>, which is a height map vertical intersection point in which a processor calculates an image using the data values that correspond to data points <b>365</b> through <b>380</b>. Using standard barycentric interpolation, the triangular value of point <b>390</b> with coordinates “x,y” is calculated as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V</i><sub>1</sub><i>=y*D</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V</i><sub>2</sub>=(1<i>−X</i>)*<i>F</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V</i><sub>3</sub>=(<i>x−y</i>)*<i>G</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V</i><sub>tri</sub><i>=V</i><sub>1</sub><i>+V</i><sub>2</sub><i>+V</i><sub>3</sub><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0050" num="0049">The value of V<sub>tri </sub>is combined with a quadrilateral value in order to generate a blended value for point <b>390</b> (see <figref idref="DRAWINGS">FIGS. 4</figref>, <b>7</b>, and corresponding text for further details regarding blended data value generation).</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram showing when a processor blends quadrilateral and triangular data values to generate image values for height map intersection points that lie on a height map vertical ray. In addition, guide <b>400</b> includes areas where a processor uses only quadrilateral data values and areas where a processor only uses triangular data values in order to generate image values.</p>
<p id="p-0052" num="0051">A height map vertical ray has a corresponding major step and minor step. The major step may be “Y” major or “X” major, depending upon the “angle” of the height map vertical ray. A height map vertical ray is considered “Y” major when the height map vertical ray travels in the “Y” direction more than it travels in the “X” direction. In this situation, the height map vertical ray's minor step equals the amount that the ray travels in the “X” direction for every step in the “Y” direction. For example, if a height map vertical ray travels two steps in the “Y” direction for every one step in the “X” direction, the height map vertical ray would be considered “Y” major, and its corresponding minor step is 0.5 (½ step in the “X” direction for every one step in the “Y” direction). Arc <b>490</b> and <b>499</b> indicate where a height map vertical ray is considered “Y” major.</p>
<p id="p-0053" num="0052">Conversely, a height map vertical ray is considered “X” major when the height map vertical ray travels in the “X” direction more than it does in the “Y” direction. In this situation, the height map vertical ray's minor step equals the amount that the ray travels in the “Y” direction for every step in the “X” direction. Arc <b>485</b> and <b>495</b> indicate where a height map vertical ray is considered “X” major. A processor uses the absolute value of a ray's minor step as a weighting factor in order to generate image values. For example, if a height map vertical ray's minor step is −0.6, the processor uses 0.6 as a weighting factor. In this example, if T is the value computed through triangular (barycentric) interpolation, and Q is the value computed through quadrilateral interpolation, the final value would thus be:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>V=</i>0.6<i>*T</i>+(1.0−0.6)*<i>Q</i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0054" num="0053">Guide <b>400</b> includes eight axes that are axis <b>410</b> through axis <b>480</b>. Axis <b>410</b> corresponds to a height map vertical ray traveling zero steps in the “Y” direction for every one step in the “X” direction. In this situation, a processor uses only quadrilateral values to calculate image values that lie along the particular height map vertical ray. Axis <b>420</b> corresponds to a height map vertical ray that travels one step in the “Y” direction for every one step in the “X” direction. In this situation, the height map vertical ray is neither “X” major nor “Y” major, and a processor uses only triangular values to calculate image values that lie along the particular height map vertical ray.</p>
<p id="p-0055" num="0054">Axis <b>430</b> corresponds to a height map vertical ray traveling zero steps in the “X” direction for every one step in the “Y” direction. In this situation, a processor uses only quadrilateral values to calculate image values that lie along the particular height map vertical ray. Axis <b>440</b> corresponds to a height map vertical ray traveling minus one step in the “X” direction for every one step in the “Y” direction. In this situation, the height map vertical ray is neither “X” major nor “Y” major, and a processor uses only triangular values to calculate image values that lie along the particular height map vertical ray.</p>
<p id="p-0056" num="0055">Axis <b>450</b> corresponds to a height map vertical ray traveling zero steps in the “Y” direction for every one step in the “X” direction. In this situation, a processor uses only quadrilateral values to calculate image values that lie along the particular height map vertical ray. Axis <b>460</b> corresponds to a height map vertical ray traveling minus one step in the “X” direction for every minus one step in the “Y” direction. In this situation, the height map vertical ray is neither “X” major nor “Y” major, and a processor uses only triangular values to calculate image values that lie along the particular height map vertical ray.</p>
<p id="p-0057" num="0056">Axis <b>470</b> corresponds to a height map vertical ray traveling zero steps in the “X” direction for every minus one step in the “Y” direction. In this situation, a processor uses only quadrilateral values to calculate image values that lie along the particular height map vertical ray. Axis <b>480</b> corresponds to a height map vertical ray traveling minus one step in the “X” direction for every minus one step in the “Y” direction. In this situation, the height map vertical ray is neither “X” major nor “Y” major, and a processor uses only triangular values to calculate image values that lie along the particular height map vertical ray.</p>
<p id="p-0058" num="0057">When a height map vertical ray's minor step lies between axes <b>410</b> through <b>480</b>, a processor uses quadrilateral values and triangular values to generate a blended image value (see <figref idref="DRAWINGS">FIG. 7</figref> and corresponding text for further details regarding blended data value calculations).</p>
<p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart showing steps taken in generating an image value using a plurality of vertical half planes. Processing commences at <b>500</b>, whereupon processing identifies an eye point and a look at vector (step <b>510</b>). The eye point is a point that corresponds to the location of a user, and the look at vector is a vector that starts at the eye point and travels perpendicular to a view screen. At step <b>520</b>, processing derives a down point and view screen from the eye point and the look-at vector using standard known techniques (see <figref idref="DRAWINGS">FIG. 1</figref> and corresponding text for further details regarding eye point, down point, and view screen establishment).</p>
<p id="p-0060" num="0059">At step <b>530</b>, processing selects a vertical plane sampling density. The vertical plane sampling density corresponds to how many “slices” are used through the view screen which, in turn, corresponds to how many height map vertical rays are used when generating an image. The higher the vertical plane sampling density, the more height map vertical rays which, in turn, create a higher quality image. Processing identifies a list of interesting vertical half planes at step <b>540</b>. The interesting vertical half planes are vertical half planes that intersect the view screen.</p>
<p id="p-0061" num="0060">At step <b>550</b>, processing identifies a height map vertical ray that corresponds to the first interesting vertical half plane. A height map vertical ray is a ray on a height map that corresponds to the vertical half plane (see <figref idref="DRAWINGS">FIG. 1</figref> and corresponding text for further details regarding height map vertical rays). Processing identifies and stores data points that are adjacent to the height map vertical ray (pre-defined process block <b>560</b>, see <figref idref="DRAWINGS">FIG. 6</figref> and corresponding text for further details). Processing then generates an image for a plurality of height map intersection points using the stored adjacent data points (pre-defined process block <b>570</b>, see <figref idref="DRAWINGS">FIG. 7</figref> and corresponding text for further details).</p>
<p id="p-0062" num="0061">A determination is made as to whether there are more interesting vertical half planes to process (decision <b>580</b>). If there are more interesting vertical half planes, decision <b>580</b> branches to “Yes” branch <b>582</b> which loops back to select (step <b>590</b>) and process the next vertical plane. This looping continues until there are no more vertical half planes to process, at which point decision <b>580</b> branches to “No” branch <b>588</b>, and processing ends at <b>595</b>.</p>
<p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart showing steps taken in collecting adjacent data points for a particular height map vertical ray. Processing commences at <b>600</b>, whereupon processing identifies a height map vertical ray's memory footprint start point (i.e. start point). The start point is typically defined by the location at which a ray intersects a height map, whereby the ray originates from an eye point and travels through the bottom of a view screen (see <figref idref="DRAWINGS">FIG. 1</figref> and corresponding text for further details regarding start point identification).</p>
<p id="p-0064" num="0063">Processing identifies the height map vertical ray's memory footprint end point (i.e. end point) at step <b>620</b>. The end point is defined either by the location at which the height map ends or the location at which a ray intersects a height map, whereby the ray originates from an eye point and travels through the top of a view screen (see <figref idref="DRAWINGS">FIG. 1</figref> and corresponding text for further details regarding end point identification).</p>
<p id="p-0065" num="0064">Processing selects a first scan-line intersection point on the height map vertical ray that is in between the start point and end point (step <b>630</b>). A scan-line intersection point is a point on the height map vertical ray that intersects a scan-line on the height map (see <figref idref="DRAWINGS">FIG. 2C</figref> and corresponding text for further details regarding scan-lines). Processing identifies data points that are adjacent to the first scan-line intersection point at step <b>640</b>, and stores the adjacent data points in subset store <b>660</b> at step <b>650</b>. In one embodiment, instead of storing the actual adjacent data points, processing stores the location of the adjacent data points (e.g. a pointer). Subset store <b>660</b> may be stored on a nonvolatile storage area, such as a computer hard drive.</p>
<p id="p-0066" num="0065">A determination is made as to whether there are more scan-line intersection points to process that are between the start point and the end point (decision <b>670</b>). If there are more scan-line intersection points to process, decision <b>670</b> branches to “Yes” branch <b>672</b> which loops back to select (step <b>680</b>) and process the next scan-line intersection point. This looping continues until there are no more scan-line intersection points to process, at which point decision <b>670</b> branches to “No” branch <b>678</b> whereupon processing returns at <b>690</b>.</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart showing steps taken in generating image values for height map intersection points. Processing commences at <b>700</b>, whereupon processing identifies a height map vertical ray's minor step (step <b>705</b>). A vertical ray has a corresponding major step and minor step. If a vertical ray travels in the Y direction more than the X direction, the ray is considered Y major and the minor step is how much the vertical ray travels in the X direction for every one step in the Y direction (i.e. major step). Conversely, if a vertical ray travels in the X direction more than the Y direction, the ray is considered X major and the minor step is how much the vertical ray travels in the Y direction for every one step in the X direction (i.e. major step) (see <figref idref="DRAWINGS">FIG. 4</figref> and corresponding text for further details regarding minor steps).</p>
<p id="p-0068" num="0067">Processing computes a quadrilateral weighting factor and a triangular weighting factor using the minor step at step <b>710</b>. The association between the minor step, the quadrilateral weighting factor and the triangular weighting factor is as follows:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0068">triangular weighting factor=minor step</li>
        <li id="ul0002-0002" num="0069">quadrilateral weighting factor=1−minor step</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0069" num="0070">Therefore, the following conditions apply to the minor step (ms) in relation to quadrilateral and triangular weighting:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0071">If ms=0, then only quadrilateral weighting</li>
        <li id="ul0004-0002" num="0072">If 0&lt;ms&lt;0.5, then more quadrilateral weighting</li>
        <li id="ul0004-0003" num="0073">If ms=0.5, then equal quadrilateral and triangular weighting</li>
        <li id="ul0004-0004" num="0074">If 0.5&lt;ms&lt;1, then more triangular weighting</li>
        <li id="ul0004-0005" num="0075">If ms=1, then only triangular weighting</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0070" num="0076">At step <b>715</b>, processing selects an initial pixel sampling density along a view screen vertical ray. A view screen vertical ray is a ray along a view screen that corresponds to a vertical half plane. The pixel sampling density corresponds to how many view screen intersection points on a per pixel basis that processing should identify corresponding height map intersection points (see <figref idref="DRAWINGS">FIG. 1</figref> and corresponding text for further details regarding view screen vertical rays, view screen intersection points, and height map intersection points).</p>
<p id="p-0071" num="0077">Processing selects a first view screen intersection point at step <b>720</b>. In one embodiment, processing selects a plurality of view screen intersection points. In this embodiment, a heterogeneous computer system may be used, such as that shown in <figref idref="DRAWINGS">FIGS. 10 and 11</figref>, in order to process four view screen intersection points in parallel.</p>
<p id="p-0072" num="0078">At step <b>725</b>, processing uses the selected view screen intersection point to calculate a height map intersection point. As one skilled in the art can appreciate, well know ray tracing techniques may be used to perform the calculation. Processing retrieves adjacent data points from subset store <b>660</b> that correspond to the calculated height map intersection point (step <b>730</b>). The adjacent data points were previously stored in subset store <b>660</b> during adjacent data point collection (see <figref idref="DRAWINGS">FIG. 6</figref> and corresponding text for further details).</p>
<p id="p-0073" num="0079">At step <b>735</b>, processing uses the adjacent data points to calculate a quadrilateral data value. The quadrilateral data value includes both a normal value and a color value (see <figref idref="DRAWINGS">FIG. 3A</figref> and corresponding text for further details regarding quadrilateral data value calculations). At step <b>740</b>, processing uses the adjacent data points to calculate a triangular data value. The triangular data value also includes both a normal value and a color value (see <figref idref="DRAWINGS">FIG. 3B</figref> and corresponding text for further details regarding triangular data value calculations).</p>
<p id="p-0074" num="0080">Processing computes a blended data value using the triangular weighting factor (twf), the quadrilateral weighting factor (twf), the quadrilateral data value (qdv) and the triangular data value (tdv) as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Blended Data Value=<i>twf*tdv+qwf*qdv</i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0075" num="0081">Processing calculates a blended data value for both normal values and color values. Processing computes an aggregate color value using the blended normal values and the blended color values at step <b>750</b>, and stores the aggregate blended data value in image store <b>760</b> at step <b>755</b>. Image store <b>760</b> may be stored on a nonvolatile storage area, such as a computer hard drive.</p>
<p id="p-0076" num="0082">At step <b>770</b>, processing adjusts the pixel sampling density based upon the location of the previously used height map intersection points. For example, if the height map intersection points were far apart, processing increases the pixel sampling density, which results in increased (and closer) height map intersection points.</p>
<p id="p-0077" num="0083">A determination is made as to whether there are more view screen intersection points to process (step <b>780</b>). If there are more view screen intersection points to process, decision <b>780</b> branches to “Yes” branch <b>782</b> which loops back to select (step <b>785</b>) and process the next view screen intersection point. This looping continues until there are no more view screen intersection points to process, at which point decision <b>780</b> branches to “No” branch <b>788</b> whereupon processing returns at <b>790</b>.</p>
<p id="p-0078" num="0084"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram of a cache optimized data format. Data stream <b>800</b> is specifically designed to include normalized data, whereby the data stream is optimized to a processor's memory configuration for the processor to generate image values, such as one of the synergistic processing complexes that are shown in <figref idref="DRAWINGS">FIGS. 10 and 11</figref>.</p>
<p id="p-0079" num="0085">Data stream <b>800</b> includes data values for two adjacent data points, which are included in left data point <b>810</b> and right data point <b>850</b>. Left data point <b>810</b> includes height data in bytes <b>815</b> and <b>820</b>. Bytes <b>825</b> and <b>830</b> include normalized x and y data values, respectively, for left data point <b>810</b>. The normalized data values may be generated for left data point <b>810</b> during system initialization so as to not require computation time when the system generates image values. Bytes <b>835</b>, <b>840</b>, and <b>845</b> include color data for red color, green color, and blue color, respectively.</p>
<p id="p-0080" num="0086">Right data point <b>850</b> includes the same byte locations as left data point <b>810</b>. Right data point <b>850</b>'s height data is included in bytes <b>855</b> and <b>860</b>. Bytes <b>865</b> and <b>870</b> include normalized x and y data values, respectively, for right data point <b>850</b>. Again, the normalized data may be generated for right data point <b>850</b> during system initialization so as to not require computation time when the system generates image values. Bytes <b>875</b>, <b>880</b>, and <b>885</b> include color data for red color, green color, and blue color, respectively.</p>
<p id="p-0081" num="0087"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart showing steps taken in storing data in a cache optimized data stream and sending the data stream to a processor for processing. Processing commences at <b>900</b>, whereupon processing retrieves adjacent data points that correspond to a height map intersection point (step <b>905</b>). The height map intersection point has two corresponding adjacent data points which are a left data point and a right data point. In one embodiment, a height map intersection point may have four adjacent data points which are an upper left, and upper right, a lower left, and a lower right data point.</p>
<p id="p-0082" num="0088">At step <b>910</b>, processing extracts normalized data from the left adjacent data point. The left adjacent data point's normalized data may be calculated prior to identifying the adjacent data points. For example, when a software program initializes, the software program may generate normalized data for each height map data point using their adjacent data points, and then storing the normalized data in each data point.</p>
<p id="p-0083" num="0089">Processing extracts height and color data from the left adjacent data point at step <b>915</b>. The height data may be two bytes in length and the color may be three bytes in length whereby each color byte corresponds to a red color, a green color, and a blue color. At step <b>920</b>, processing stores the left adjacent data point's normalized data, height data, and color data in data stream <b>800</b>. Data stream <b>800</b> is specifically designed to function with processor <b>975</b>'s limited cache size and is the same as that shown in <figref idref="DRAWINGS">FIG. 8</figref>.</p>
<p id="p-0084" num="0090">At step <b>940</b>, processing extracts normalized data from the right adjacent data point. Again, the right adjacent data point's normalized data may be calculated prior to identifying the adjacent data points. Processing extracts height and color data from the right adjacent data point at step <b>950</b> and, at step <b>960</b>, processing stores the right adjacent data point's normalized data, height data, and color data in data stream <b>800</b>.</p>
<p id="p-0085" num="0091">Processing sends data stream <b>800</b> to processor <b>975</b> at step <b>970</b>. Processor <b>975</b> has a limited cache size such as one of the synergistic processing complexes shown in <figref idref="DRAWINGS">FIGS. 10 and 11</figref>. Processor <b>975</b> calculates a height map intersection point image value using the data that is included in data stream <b>800</b> (see <figref idref="DRAWINGS">FIG. 7</figref> and corresponding text for further details regarding height map intersection point image value generation). Processing receives the height map intersection point image values from processor <b>975</b> at step <b>980</b>, and stores the image values in image store <b>760</b>. Image store <b>760</b> is the same as that shown in <figref idref="DRAWINGS">FIG. 7</figref>, and may be stored on a nonvolatile storage area, such as a computer hard drive. Processing ends at <b>995</b>.</p>
<p id="p-0086" num="0092"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram showing a processor element architecture that includes a plurality of heterogeneous processors. The heterogeneous processors share a common memory and a common bus. Processor element architecture (PEA) <b>1000</b> sends and receives information to/from external devices through input output <b>1070</b>, and distributes the information to control plane <b>1010</b> and data plane <b>1040</b> using processor element bus <b>1060</b>. Control plane <b>1010</b> manages PEA <b>1000</b> and distributes work to data plane <b>1040</b>.</p>
<p id="p-0087" num="0093">Control plane <b>1010</b> includes processing unit <b>1020</b> which runs operating system (OS) <b>1025</b>. For example, processing unit <b>1020</b> may be a Power PC core that is embedded in PEA <b>1000</b> and OS <b>1025</b> may be a Linux operating system. Processing unit <b>1020</b> manages a common memory map table for PEA <b>1000</b>. The memory map table corresponds to memory locations included in PEA <b>1000</b>, such as L2 memory <b>1030</b> as well as non-private memory included in data plane <b>1040</b> (see <figref idref="DRAWINGS">FIGS. 11A</figref>, <b>11</b>B, and corresponding text for further details regarding memory mapping).</p>
<p id="p-0088" num="0094">Data plane <b>1040</b> includes Synergistic Processing Complex's (SPC) <b>1045</b>, <b>1050</b>, and <b>1055</b>. Each SPC is used to process data information and each SPC may have different instruction sets. For example, PEA <b>1000</b> may be used in a wireless communications system and each SPC may be responsible for separate processing tasks, such as modulation, chip rate processing, encoding, and network interfacing. In another example, each SPC may have identical instruction sets and may be used in parallel to perform operations benefiting from parallel processes. Each SPC includes a synergistic processing unit (SPU) which is a processing core, such as a digital signal processor, a microcontroller, a microprocessor, or a combination of these cores.</p>
<p id="p-0089" num="0095">SPC <b>1045</b>, <b>1050</b>, and <b>1055</b> are connected to processor element bus <b>1060</b> which passes information between control plane <b>1010</b>, data plane <b>1040</b>, and input/output <b>1070</b>. Bus <b>1060</b> is an on-chip coherent multi-processor bus that passes information between I/O <b>1070</b>, control plane <b>1010</b>, and data plane <b>1040</b>. Input/output <b>1070</b> includes flexible input-output logic which dynamically assigns interface pins to input output controllers based upon peripheral devices that are connected to PEA <b>1000</b>. For example, PEA <b>1000</b> may be connected to two peripheral devices, such as peripheral A and peripheral B, whereby each peripheral connects to a particular number of input and output pins on PEA <b>1000</b>. In this example, the flexible input-output logic is configured to route PEA <b>1000</b>'s external input and output pins that are connected to peripheral A to a first input output controller (i.e. IOC A) and route PEA <b>1000</b>'s external input and output pins that are connected to peripheral B to a second input output controller (i.e. IOC B).</p>
<p id="p-0090" num="0096"><figref idref="DRAWINGS">FIG. 11A</figref> illustrates a first information handling system which is a simplified example of a computer system capable of performing the computing operations described herein. The example in <figref idref="DRAWINGS">FIG. 11A</figref> shows a plurality of heterogeneous processors using a common memory map in order to share memory between the heterogeneous processors. Device <b>1100</b> includes processing unit <b>1130</b> which executes an operating system for device <b>1100</b>. Processing unit <b>1130</b> is similar to processing unit <b>4320</b> shown in <figref idref="DRAWINGS">FIG. 10</figref>. Processing unit <b>1130</b> uses system memory map <b>1120</b> to allocate memory space throughout device <b>1100</b>. For example, processing unit <b>1130</b> uses system memory map <b>1120</b> to identify and allocate memory areas when processing unit <b>1130</b> receives a memory request. Processing unit <b>1130</b> access L2 memory <b>1125</b> for retrieving application and data information. L2 memory <b>1125</b> is similar to L2 memory <b>1030</b> shown in <figref idref="DRAWINGS">FIG. 10</figref>.</p>
<p id="p-0091" num="0097">System memory map <b>1120</b> separates memory mapping areas into regions which are regions <b>1135</b>, <b>1145</b>, <b>1150</b>, <b>1155</b>, and <b>1160</b>. Region <b>1135</b> is a mapping region for external system memory which may be controlled by a separate input output device. Region <b>1145</b> is a mapping region for non-private storage locations corresponding to one or more synergistic processing complexes, such as SPC <b>1102</b>. SPC <b>1102</b> is similar to the SPC's shown in <figref idref="DRAWINGS">FIG. 10</figref>, such as SPC A <b>1045</b>. SPC <b>1102</b> includes local memory, such as local store <b>1110</b>, whereby portions of the local memory may be allocated to the overall system memory for other processors to access. For example, 1 MB of local store <b>1110</b> may be allocated to non-private storage whereby it becomes accessible by other heterogeneous processors. In this example, local storage aliases <b>1145</b> manages the 1 MB of nonprivate storage located in local store <b>1110</b>.</p>
<p id="p-0092" num="0098">Region <b>1150</b> is a mapping region for translation lookaside buffer's (TLB's) and memory flow control (MFC registers. A translation lookaside buffer includes cross-references between virtual address and real addresses of recently referenced pages of memory. The memory flow control provides interface functions between the processor and the bus such as DMA control and synchronization.</p>
<p id="p-0093" num="0099">Region <b>1155</b> is a mapping region for the operating system and is pinned system memory with bandwidth and latency guarantees. Region <b>1160</b> is a mapping region for input output devices that are external to device <b>1100</b> and are defined by system and input output architectures.</p>
<p id="p-0094" num="0100">Synergistic processing complex (SPC) <b>1102</b> includes synergistic processing unit (SPU) <b>1105</b>, local store <b>1110</b>, and memory management unit (MMU) <b>1115</b>. Processing unit <b>1130</b> manages SPU <b>1105</b> and processes data in response to processing unit <b>1130</b>'s direction. For example SPU <b>1105</b> may be a digital signaling processing core, a microprocessor core, a micro controller core, or a combination of these cores. Local store <b>1110</b> is a storage area that SPU <b>1105</b> configures for a private storage area and a non-private storage area. For example, if SPU <b>1105</b> requires a substantial amount, of local memory, SPU <b>1105</b> may allocate 100% of local store <b>1110</b> to private memory. In another example, if SPU <b>1105</b> requires a minimal amount of local memory, SPU <b>1105</b> may allocate 10% of local store <b>1110</b> to private memory and allocate the remaining 90% of local store <b>1110</b> to non-private memory (see <figref idref="DRAWINGS">FIG. 11B</figref> and corresponding text for further details regarding local store configuration).</p>
<p id="p-0095" num="0101">The portions of local store <b>1110</b> that are allocated to non-private memory are managed by system memory map <b>1120</b> in region <b>1145</b>. These non-private memory regions may be accessed by other SPU's or by processing unit <b>1130</b>. MMU <b>1115</b> includes a direct memory access (DMA) function and passes information from local store <b>1110</b> to other memory locations within device <b>1100</b>.</p>
<p id="p-0096" num="0102"><figref idref="DRAWINGS">FIG. 11B</figref> is a diagram showing a local storage area divided into private memory and non-private memory. During system boot, synergistic processing unit (SPU) <b>1160</b> partitions local store <b>1170</b> into two regions which are private store <b>1175</b> and non-private store <b>1180</b>. SPU <b>1160</b> is similar to SPU <b>1105</b> and local store <b>1170</b> is similar to local store <b>1110</b> that are shown in <figref idref="DRAWINGS">FIG. 11A</figref>. Private store <b>1175</b> is accessible by SPU <b>1160</b> whereas non-private store <b>1180</b> is accessible by SPU <b>1160</b> as well as other processing units within a particular device. SPU <b>1160</b> uses private store <b>1175</b> for fast access to data. For example, SPU <b>1160</b> may be responsible for complex computations that require SPU <b>1160</b> to quickly access extensive amounts of data that is stored in memory. In this example, SPU <b>1160</b> may allocate 100% of local store <b>1170</b> to private store <b>1175</b> in order to ensure that SPU <b>1160</b> has enough local memory to access. In another example, SPU <b>1160</b> may not require a large amount of local memory and therefore, may allocate 10% of local store <b>1170</b> to private store <b>1175</b> and allocate the remaining 90% of local store <b>1170</b> to non-private store <b>1180</b>.</p>
<p id="p-0097" num="0103">A system memory mapping region, such as local storage aliases <b>1190</b>, manages portions of local store <b>1170</b> that are allocated to non-private storage. Local storage aliases <b>1190</b> is similar to local storage aliases <b>1145</b> that is shown in <figref idref="DRAWINGS">FIG. 11A</figref>. Local storage aliases <b>1190</b> manages non-private storage for each SPU and allows other SPU's to access the non-private storage as well as a device's control processing unit.</p>
<p id="p-0098" num="0104"><figref idref="DRAWINGS">FIG. 12</figref> illustrates a second information handling system <b>1201</b> which is a simplified example of a computer system capable of performing the computing operations described herein. Computer system <b>1201</b> includes processor <b>1200</b> which is coupled to host bus <b>1202</b>. A level two (L2) cache memory <b>1204</b> is also coupled to host bus <b>1202</b>. Host-to-PCI bridge <b>1206</b> is coupled to main memory <b>1208</b>, includes cache memory and main memory control functions, and provides bus control to handle transfers among PCI bus <b>1210</b>, processor <b>1200</b>, L2 cache <b>1204</b>, main memory <b>1208</b>, and host bus <b>1202</b>. Main memory <b>1208</b> is coupled to Host-to-PCI bridge <b>1206</b> as well as host bus <b>1202</b>. Devices used solely by host processor(s) <b>1200</b>, such as LAN card <b>1230</b>, are coupled to PCI bus <b>1210</b>. Service Processor Interface and ISA Access Pass-through <b>1212</b> provides an interface between PCI bus <b>1210</b> and PCI bus <b>1214</b>. In this manner, PCI bus <b>1214</b> is insulated from PCI bus <b>1210</b>. Devices, such as flash memory <b>1218</b>, are coupled to PCI bus <b>1214</b>. In one implementation, flash memory <b>1218</b> includes BIOS code that incorporates the necessary processor executable code for a variety of low-level system functions and system boot functions.</p>
<p id="p-0099" num="0105">PCI bus <b>1214</b> provides an interface for a variety of devices that are shared by host processor(s) <b>1200</b> and Service Processor <b>1216</b> including, for example, flash memory <b>1218</b>. PCI-to-ISA bridge <b>1235</b> provides bus control to handle transfers between PCI bus <b>1214</b> and ISA bus <b>1240</b>, universal serial bus (USB) functionality <b>1245</b>, power management functionality <b>1255</b>, and can include other functional elements not shown, such as a real-time clock (RTC), DMA control, interrupt support, and system management bus support. Nonvolatile RAM <b>1220</b> is attached to ISA Bus <b>1240</b>. Service Processor <b>1216</b> includes JTAG and I2C busses <b>1222</b> for communication with processor(s) <b>1200</b> during initialization steps. JTAG/I2C busses <b>1222</b> are also coupled to L2 cache <b>1204</b>, Host-to-PCI bridge <b>1206</b>, and main memory <b>1208</b> providing a communications path between the processor, the Service Processor, the L2 cache, the Host-to-PCI bridge, and the main memory. Service Processor <b>1216</b> also has access to system power resources for powering down information handling device <b>1201</b>.</p>
<p id="p-0100" num="0106">Peripheral devices and input/output (I/O) devices can be attached to various interfaces (e.g., parallel interface <b>1262</b>, serial interface <b>1264</b>, keyboard interface <b>1268</b>, and mouse interface <b>1270</b> coupled to ISA bus <b>1240</b>. Alternatively, many I/O devices can be accommodated by a super I/O controller (not shown) attached to ISA bus <b>1240</b>.</p>
<p id="p-0101" num="0107">In order to attach computer system <b>1201</b> to another computer system to copy files over a network, LAN card <b>1230</b> is coupled to PCI bus <b>1210</b>. Similarly, to connect computer system <b>1201</b> to an ISP to connect to the Internet using a telephone line connection, modem <b>1275</b> is connected to serial port <b>1264</b> and PCI-to-ISA Bridge <b>1235</b>.</p>
<p id="p-0102" num="0108">While the computer system described in <figref idref="DRAWINGS">FIG. 12</figref> is capable of executing the processes described herein, this computer system is simply one example of a computer system. Those skilled in the art will appreciate that many other computer system designs are capable of performing the processes described herein.</p>
<p id="p-0103" num="0109">One of the preferred implementations of the invention is an application, namely, a set of instructions (program code) in a code module which may, for example, be resident in the random access memory of the computer. Until required by the computer, the set of instructions may be stored in another computer memory, for example, on a hard disk drive, or in removable storage such as an optical disk (for eventual use in a CD ROM) or floppy disk (for eventual use in a floppy disk drive), or downloaded via the Internet or other computer network. Thus, the present invention may be implemented as a computer program product for use in a computer. In addition, although the various methods described are conveniently implemented in a general purpose computer selectively activated or reconfigured by software, one of ordinary skill in the art would also recognize that such methods may be carried out in hardware, in firmware, or in more specialized apparatus constructed to perform the required method steps.</p>
<p id="p-0104" num="0110">While particular embodiments of the present invention have been shown and described, it will be obvious to those skilled in the art that, based upon the teachings herein, changes and modifications may be made without departing from this invention and its broader aspects and, therefore, the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore, it is to be understood that the invention is solely defined by the appended claims. It will be understood by those with skill in the art that if a specific number of an introduced claim element is intended, such intent will be explicitly recited in the claim, and in the absence of such recitation no such limitation is present. For a non-limiting example, as an aid to understanding, the following appended claims contain usage of the introductory phrases “at least one” and “one or more” to introduce claim elements. However, the use of such phrases should not be construed to imply that the introduction of a claim element by the indefinite articles “a” or “an” limits any particular claim containing such introduced claim element to inventions containing only one such element, even when the same claim includes the introductory phrases “one or more” or “at least one” and indefinite articles such as “a” or “an”; the same holds true for the use in the claims of definite articles.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method comprising:
<claim-text>selecting, by a first processor having a first instruction set, a height map intersection point;</claim-text>
<claim-text>identifying a first data point and a second data point that are adjacent to the height map intersection point;</claim-text>
<claim-text>retrieving normalized data corresponding to the first data point and the second data point;</claim-text>
<claim-text>including the normalized data in a data stream;</claim-text>
<claim-text>sending, by the first processor, the data stream to a second processor having a second instruction set, via an on-chip multi-processor bus, wherein the second processor is adapted to generate one or more image values corresponding to the height map intersection point using the normalized data, wherein the first and second processors share the on-chip multi-processor bus, and the first instruction set is different from the second instruction set, and wherein the first and second processors use a common memory map to access a shared memory;</claim-text>
<claim-text>identifying a minor step that corresponds to a height map vertical ray; and</claim-text>
<claim-text>calculating a first weighting factor and a second weighting factor using the minor step, the first weighting factor corresponding to a first sampling technique and the second weighting factor corresponding to a second sampling technique, wherein the second processor is adapted to use the first weighting factor and the second weighting factor during the image generation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the data stream includes height and color data.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the normalized data is calculated prior to selecting the height map intersection point.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>identifying a memory footprint starting point, the memory footprint starting point corresponding to the start of a viewable range;</claim-text>
<claim-text>selecting a memory footprint ending point using one or more visibility settings; and</claim-text>
<claim-text>retrieving a plurality of adjacent data points that are adjacent to a height map vertical ray that intersects the memory footprint starting point and the memory footprint ending point, wherein the first data point and the second data point are included in the plurality of adjacent data points.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the sending further comprises:
<claim-text>writing, by the first processor, the data stream to the shared memory, wherein the shared memory is an on-chip memory component; and</claim-text>
<claim-text>reading, by the second processor, the data stream from the shared memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A program product comprising:
<claim-text>computer readable medium having computer program code, the computer program code which when executed by a computer system causes the computer system to implement a method comprising:
<claim-text>selecting, by a first processor having a first instruction set, a height map intersection point;</claim-text>
<claim-text>identifying a first data point and a second data point that are adjacent to the height map intersection point;</claim-text>
<claim-text>retrieving normalized data corresponding to the first data point and the second data point;</claim-text>
<claim-text>including the normalized data in a data stream;</claim-text>
<claim-text>sending, by the first processor, the data stream to a second processor having a second instruction set, via an on-chip multi-processor bus, wherein the second processor is adapted to generate one or more image values corresponding to the height map intersection point using the normalized data, wherein the first and second processors share the on-chip multi-processor bus, and the first instruction set is different from the second instruction set, and wherein the first and second processors use a common memory map to access a shared memory;</claim-text>
<claim-text>identifying a minor step that corresponds to a height map vertical ray; and</claim-text>
<claim-text>calculating a first weighting factor and a second weighting factor using the minor step, the first weighting factor corresponding to a first sampling technique and the second weighting factor corresponding to a second sampling technique, wherein the second processor is adapted to use the first weighting factor and the second weighting factor during the image generation.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The program product of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the data stream includes height and color data.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The program product of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the normalized data is calculated prior to selecting the height map intersection point.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The program product of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the computer program code when executed by the computer system further causes the computer system to implement the method comprising:
<claim-text>identifying a memory footprint starting point, the memory footprint starting point corresponding to the start of a viewable range;</claim-text>
<claim-text>selecting a memory footprint ending point using one or more visibility settings; and</claim-text>
<claim-text>retrieving a plurality of adjacent data points that are adjacent to a height map vertical ray that intersects the memory footprint starting point and the memory footprint ending point, wherein the first data point and the second data point are included in the plurality of adjacent data points.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The program product of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the computer program code that performs the sending, when executed by the computer system further causes the computer system to implement the method comprising:
<claim-text>writing, by the first processor, the data stream to the shared memory, wherein the shared memory is an on-chip memory component; and</claim-text>
<claim-text>reading, by the second processor, the data stream from the shared memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. An information handling system comprising:
<claim-text>a display;</claim-text>
<claim-text>a plurality of processors that include a first processor that uses a first instruction set and a second processor that uses a second instruction set, the first and second instruction sets being different from one another;</claim-text>
<claim-text>an on-chip multi-processor bus shared by the first and second processors;</claim-text>
<claim-text>a shared memory accessible by the first and second processors, wherein the first and second processors use a common memory map to access the shared memory;</claim-text>
<claim-text>one or more nonvolatile storage devices accessible by the processors; and</claim-text>
<claim-text>a data-optimizing tool for data stream optimization, the data-optimizing tool comprising software code effective to:
<claim-text>select a height map intersection point from one of the nonvolatile storage devices using the first processor;</claim-text>
<claim-text>identify a first data point and a second data point that are adjacent to the height map intersection point and located in one of the nonvolatile storage devices;</claim-text>
<claim-text>retrieve normalized data from one of the nonvolatile storage devices that corresponds to the first data point and the second data point;</claim-text>
<claim-text>include the normalized data in the data stream; and</claim-text>
<claim-text>send the data stream to the second processor via the on-chip multi-processor bus, wherein the second processor is adapted to generate one or more image values corresponding to the height map intersection point using the normalized data;</claim-text>
<claim-text>identify a minor step that is located in one of the nonvolatile storage devices that corresponds to a height map vertical ray; and</claim-text>
<claim-text>calculate a first weighting factor and a second weighting factor using the minor step, the first weighting factor corresponding to a first sampling technique and the second weighting factor corresponding to a second sampling technique, wherein the second processor is adapted to use the first weighting factor and the second weighting factor during the image generation.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The information handling system of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein the data stream includes height and color data.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The information handling system of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein the normalized data is calculated prior to selecting the height map intersection point.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The information handling system of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein the software code is further effective to:
<claim-text>identify a memory footprint starting point, the memory footprint starting point corresponding to the start of a viewable range and located in one of the nonvolatile storage devices;</claim-text>
<claim-text>select a memory footprint ending point located in one of the nonvolatile storage devices using one or more visibility settings; and</claim-text>
<claim-text>retrieve a plurality of adjacent data points from one of the nonvolatile storage devices that are adjacent to a height map vertical ray that intersects the memory footprint starting point and the memory footprint ending point, wherein the first data point and the second data point are included in the plurality of adjacent data points.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The information handling system of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein the software code that performs the sending is further effective to:
<claim-text>write, by the first processor, the data stream to the shared memory, wherein the shared memory is an on-chip memory component; and</claim-text>
<claim-text>read, by the second processor, the data stream from the shared memory.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
