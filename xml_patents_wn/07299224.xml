<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299224-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299224</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10926591</doc-number>
<date>20040826</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="regional">
<country>EP</country>
<doc-number>03104840</doc-number>
<date>20031219</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>418</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707  4</main-classification>
</classification-national>
<invention-title id="d0e71">Method and infrastructure for processing queries in a database</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6546381</doc-number>
<kind>B1</kind>
<name>Subramanian et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
</references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707  1</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  2</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  3</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707 10</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707200</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  4</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>3</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050138024</doc-number>
<kind>A1</kind>
<date>20050623</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Doerre</last-name>
<first-name>Jochen</first-name>
<address>
<city>Boeblingen</city>
<country>DE</country>
</address>
</addressbook>
<nationality>
<country>DE</country>
</nationality>
<residence>
<country>DE</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Matschke</last-name>
<first-name>Monika</first-name>
<address>
<city>Calw</city>
<country>DE</country>
</address>
</addressbook>
<nationality>
<country>DE</country>
</nationality>
<residence>
<country>DE</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Seiffert</last-name>
<first-name>Roland</first-name>
<address>
<city>Herrenberg</city>
<country>DE</country>
</address>
</addressbook>
<nationality>
<country>DE</country>
</nationality>
<residence>
<country>DE</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Tschaffler</last-name>
<first-name>Matthias</first-name>
<address>
<city>Herrenberg</city>
<country>DE</country>
</address>
</addressbook>
<nationality>
<country>DE</country>
</nationality>
<residence>
<country>DE</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Walker</last-name>
<first-name>Mark S.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Goshorn</last-name>
<first-name>Gregory K.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="03" rep-type="attorney">
<addressbook>
<orgname>Greg Goshorn, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Leroux</last-name>
<first-name>Etienne</first-name>
<department>2161</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Provided is a method for processing queries in a database in which data records have a parametric object and an extension of a nonparametric data type. A query includes a parametric condition for the parametric object of the data records and a nonparametric condition for the nonparametric extension of the data records. Parametric information of each data record is translated into constructs of the data type of the extension. A parametric result set of data records for the parametric condition is generated. The parametric condition of said query is translated into a filter condition for said constructs of the data type of the extension. The nonparametric condition of said query and said filter condition are employed to generate a nonparametric result set. The parametric result set and the nonparametric result set are joined to obtain a result set.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="177.88mm" wi="242.74mm" file="US07299224-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="254.85mm" wi="192.70mm" orientation="landscape" file="US07299224-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="243.08mm" wi="174.84mm" orientation="landscape" file="US07299224-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="251.97mm" wi="164.42mm" orientation="landscape" file="US07299224-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention relates to a method and an infrastructure for processing queries in a database. Particularly, the present invention relates to a method and an infrastructure for processing queries in standard relational database management systems (DBMSs) having at least one extension of objects of a nonparametric datatype, like text, images, audio and video.</p>
<p id="p-0004" num="0003">2. Description of the Related Art</p>
<p id="p-0005" num="0004">Object-relational extensions to DBMSs are state of the art. They allow the extension of a standard relational database system with specialized support for new, nonparametric types of objects. Important examples of such new datatypes include text, images, audio and video.</p>
<p id="p-0006" num="0005">By now, the only provision to add support for a new datatype, e.g. “text”, is to make this datatype known to the database system. Then, the data records of the database system may contain objects of this new datatype. The database will store these objects—but it does not know how to “process” them. So they are considered as unstructured binary data. Additional methods have to be provided to implement functionality, e.g. an equality predicate”, for these objects of a new datatype. The database system needs this functionality for any query including a condition for the objects of the new datatype. In general, the database query language, i.e. SQL in relational DBMSs, will be extended to provide means for searching on objects of the new datatypes. E.g. SQL/MM is an extension of SQL for relational DBMSs with multimedia extensions. For example, in case of the datatype “text”, there may be a new predicate “CONTAINS(column, word)” that returns true, if the “text” in the record/column under consideration actually contains the specified word.</p>
<p id="p-0007" num="0006">As usual in DBMSs, the efficient execution of such a query, e.g. “CONTAINS”, requires an index for the data. These indexes are usually **not** native DBMS indexes, but they are special purpose indexes designed to provide high performance query processing for the new datatype they apply to. In case of “text”, such an index usually has an “inverted structure”, i.e. for each word occurring in all indexed text, there is a “list” of the actual occurrences, for example a TextIndexID for the record that contains the word and even position information within the text object. These indexes can now perform text searches very fast.</p>
<p id="p-0008" num="0007">In order to explain the problem addressed in the invention, the state of the art for processing a query which combines conditions on objects of a new datatype with conditions on regular parametric objects will be described by means of the following example in conjunction with <figref idref="DRAWINGS">FIGS. 1 and 2</figref> of the drawings.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> shows a database <b>10</b> called NEWS table. Each data record of database <b>10</b> comprises a RecordID, a Title, a Text object and a Date. The block diagram of <figref idref="DRAWINGS">FIG. 1</figref> illustrates the processing of the following query on database <b>10</b>, as it is state of the art.</p>
<p id="p-0010" num="0009">SELECT title, date FROM news WHERE
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0010">date&lt;“01-01-2001” AND CONTAINS(text, “IBM”)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0011" num="0011">ORDER BY date INCREASING</p>
<p id="p-0012" num="0012">This query combines a text search, representing a condition on the text objects of the data records, with a numeric condition, which means a condition on the regular parametric objects of the data records. Besides, the result set of said query has to be sorted by the parametric data.</p>
<p id="p-0013" num="0013">By now, the query processing has to implement the following steps:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0014">1. SELECT A={records X|date(X)&lt;‘01-01-2001’} The DBMS computes a Result set 20 for the parametric condition ‘date&lt;“01-01-2001”’.</li>
        <li id="ul0004-0002" num="0015">2. SELECT B={records X|CONTAINS(X, text, ‘IBM’)} The text extension engine computes a result set for ‘CONTAINS(text, “IBM”)’—in the here described example—as in most cases—this result set is a Text index list <b>30</b> of text-internal IDs, therefore</li>
        <li id="ul0004-0003" num="0016">3. these text-internal IDs of Text index list <b>30</b> have to be mapped to the RecordIDs of the DBMS by using an ID map <b>40</b>.</li>
        <li id="ul0004-0004" num="0017">4. As result of this mapping an intermediate result table <b>50</b> is constructed.</li>
        <li id="ul0004-0005" num="0018">5. The parametric Result set <b>20</b> and the intermediate result table <b>50</b>, representing the text result set, have to be joined which means intersected. The join function is indicated by arrow <b>60</b> of <figref idref="DRAWINGS">FIG. 1</figref>.</li>
        <li id="ul0004-0006" num="0019">6. The result of this step has to be ordered and the data requested in SELECT(title, date) has to be fetched from the intermediate result table <b>50</b>.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0014" num="0020">It is also possible to do the sorting before joining the two result sets to order the parametric Result set <b>20</b> and the TVF result table <b>50</b> separately.</p>
<p id="p-0015" num="0021">The diagram of <figref idref="DRAWINGS">FIG. 2</figref> illustrates the different result sets of the processing steps described above. Set <b>1</b> represents all data records of NEWS table <b>10</b>. Subset <b>2</b> represents the parametric Result set <b>20</b> obtained in step 2 of the query processing, while subset <b>3</b> represents the text result set obtained in steps 2 to 4 of the query processing. Subset <b>4</b> is the intersection of subsets <b>2</b> and <b>3</b> and represents the result of the join operation <b>60</b> in step 5 of the query processing.</p>
<p id="p-0016" num="0022">The completely independent processing of the “parametric” and “text” subqueries and especially the joining of their result sets causes severe performance problems, as in most cases the intermediate result sets are large on either side. This is especially on the “text” side disadvantageous, because the performance of text search engines usually depends more on the size of the result set than on the overall amount of text indexed.</p>
<p id="p-0017" num="0023">In order to tune this model of processing, it has been proposed to enhance the extension engine for the new datatype with full support for at least the most commonly used existing DBMS data types. This would allow to push down the parametric constraint into the external query. However, this approach has many severe drawbacks:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0024">1. It requires a fully redundant implementation of DBMS-internal datatypes in the extension engine which should focus on the aspects of the new datatype. This makes the extension engine much more complex and violates the idea of encapsulation of precisely the functionality related to the new datatype.</li>
        <li id="ul0006-0002" num="0025">2. Index structures in the extension are chosen to reflect the properties of the object types represented. The index structures needed to support regular datatypes are not necessarily available in this context. Besides, the processing of additional parametric constraints inside the extension is not in any case very efficient. E.g. inverted indexes and standard B-trees for numeric data are handled and processed quite differently. So a lot of complexity has to be added to implement a combination. DBMSs have many different ways to optimally implement combined queries of their indexes, e.g. different join strategies, etc. It seems hopeless to rebuild all that outside the database.</li>
        <li id="ul0006-0003" num="0026">3. Indexes maintained by the extension are usually not managed by the DBMS. Therefore, advantages that the DBMS can use for query processing, e.g. caching in the DBMS buffer pool, are lost. This is already an issue for the new data types and their indexes themselves, but now even indexes already present inside the DBMS are fully replicated and processed outside.</li>
        <li id="ul0006-0004" num="0027">4. This work has to be repeated for each datatype added as an extension.</li>
    </ul>
    </li>
</ul>
</p>
<heading id="h-0002" level="1">OBJECT OF THE INVENTION</heading>
<p id="p-0018" num="0028">Starting from this, the object of the present invention is to provide a method and an infrastructure for processing such combined queries in a DBMS with an extension of a new datatype, wherein the problem of joining the result sets of the parametric and the nonparametric subqueries is significantly reduced without adding the complexity of the DBMS to the extension engine.</p>
<heading id="h-0003" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0019" num="0029">The foregoing object is achieved by a method and an infrastructure as laid out in the independent claims. Further advantageous embodiments of the present invention are described in the subclaims and are taught in the following description.</p>
<p id="p-0020" num="0030">As mentioned above, the present invention relates to a method for processing queries in a database of data records, wherein each data record comprises at least one parametric object with parametric information and at least one extension of a nonparametric datatype. According to the present invention, at least parts of the parametric information of each data record are translated into constructs of the datatype of the extension. The present invention applies to queries comprising at least one parametric condition for the parametric object of the data records and at least one nonparametric condition for the nonparametric extension of the data records. For processing this kind of queries, the parametric condition is translated into at least one filter condition for said constructs of the datatype of the extension. Then, a nonparametric result set of data records is computed considering both, the nonparametric condition of said query and said filter condition. Besides, a parametric result set of data records is computed for the parametric condition. Finally, the parametric result set and the nonparametric result set are joined to obtain a result set for the query as a whole.</p>
<p id="p-0021" num="0031">One key aspect of the present invention is the so-called translation of the parametric information into appropriate constructs, which can be processed by means of the extension engine using the properties and index structures of the corresponding new datatype. In an advantageous embodiment of the invention the constructs produced by the corresponding translation function are added to the index supporting query processing of the extension.</p>
<p id="p-0022" num="0032">Another key aspect of the present invention is the so-called translation of the parametric conditions of a query. The corresponding translation function produces filter conditions which can operate upon the newly created constructs of the extension.</p>
<p id="p-0023" num="0033">The so-created filter conditions can be handled separately by the extension engine processing a query. Another possibility providing good processing performance is to include the filter conditions in the nonparametric condition of a query.</p>
<p id="p-0024" num="0034">Theoretically, the method according to the present invention could use a translation function that creates constructs of the datatype of the extension representing the whole parametric information of the corresponding data records. As the complexity of the translation function and the complexity of the resultant constructs would increase dramatically with the amount of parametric information to be translated, a very advantages embodiment of the present invention uses a translation function which only provides an approximation instead of an exact translation of the parametric information. In this case the resultant constructs only provide an approximation of the corresponding parametric information. This kind of translation leads to a classification of the data records according to their parametric information.</p>
<p id="p-0025" num="0035">In order to enhance the processing performance, the translation function for translating the parametric information can consider the distribution of the data records in the database with respect to their parametric information to obtain an approximately equal number of data records in each resulting class of data records.</p>
<p id="p-0026" num="0036">Only if said constructs of the extension represent the whole corresponding parametric information of the data records an exact translation of the parametric conditions of a query makes sense. Therefore, in most cases also the filter conditions only provide an approximation of the corresponding parametric condition.</p>
<p id="p-0027" num="0037">One major advantage of the present invention is that the translation of at least parts of the parametric information of a data record has only to be done once. As the resultant constructs are then stored they are immediately available for each query. The creation of said constructs can easily be done together with indexing of the corresponding data records, for example during loading of the database or when the corresponding data records are added to the database.</p>
<p id="p-0028" num="0038">Besides, the present invention provides an infrastructure for processing combined queries, as described above. Therefore the infrastructure comprises at least a database management system (DBMS) for handling the parametric objects of the data records and at least one extension engine for handling the extensions of the data records. This extension engine provides at least one first translation function for translating at least parts of the parametric information of the data records into constructs supported by said extension engine and at least one second translation function for translating parametric conditions of queries into filter conditions for said constructs.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0029" num="0039">The novel features of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives, and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p>
<p id="p-0030" num="0040"><figref idref="DRAWINGS">FIG. 1</figref> shows a block diagram illustrating the state of the art for processing a query in a database, wherein each data record comprises a text object in addition to parametric objects and wherein the query combines conditions on the text objects with conditions on the parametric objects;</p>
<p id="p-0031" num="0041"><figref idref="DRAWINGS">FIG. 2</figref> shows a diagram illustrating the different result sets of the processing steps explained in conjunction with <figref idref="DRAWINGS">FIG. 1</figref>; and</p>
<p id="p-0032" num="0042"><figref idref="DRAWINGS">FIG. 3</figref> shows a diagram, which illustrates the different result sets, when processing the query of <figref idref="DRAWINGS">FIG. 1</figref> according to the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0033" num="0043">The invention and especially the differences between query processing according to the invention and query processing, as it is state of the art, will be explained by means of the query</p>
<p id="p-0034" num="0044">SELECT title, date FROM news WHERE
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0000">
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0045">date&lt;“01-01-2001” AND CONTAINS(text, “IBM”)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0035" num="0046">ORDER BY date INCREASING</p>
<p id="p-0036" num="0047">exemplified in conjunction with <figref idref="DRAWINGS">FIGS. 1 and 2</figref>. As mentioned above, the data records of the corresponding database NEWS table <b>10</b> comprise a RecordID and a regular parametric object representing a Date. Besides, the data records comprise two extensions of a nonparametric datatype, a first Text object and a second text object representing the Title of said Text object. The query, here explained, combines a text search, representing a condition on the text objects of the data records, with a numeric condition, which means a condition on the regular parametric object Date of the data records. In addition, the result set of said query has to be sorted by the parametric data.</p>
<p id="p-0037" num="0048">Implementation of the invention comprises the following steps:
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0000">
    <ul id="ul0010" list-style="none">
        <li id="ul0010-0001" num="0049">1. The columns containing the text objects have to be made known to the DBMS for appropriate handling during indexing and querying.</li>
        <li id="ul0010-0002" num="0050">2. A translation function for the parametric data “Date” has to be provided by the implementation of the extension engine, since only the extension engine knows appropriate translations of parametric approximation to its actual data structures.</li>
        <li id="ul0010-0003" num="0051">3. This translation function will be called during indexing of the text objects for translation of all additional parametric data items in the data record that should participate in the optimization of a query. The result of that translation will be included in the TEXT data passed to the extension engine for indexing.</li>
        <li id="ul0010-0004" num="0052">4. During query optimization, the DBMS optimizer detects situations in which parametric conditions are combined, especially intersected and joined, with conditions on the text objects, as in the here described example.</li>
        <li id="ul0010-0005" num="0053">5. Therefore, a translation function for parametric conditions is provided by the implementation of the extension engine which generates corresponding filter conditions for the translated parametric data items. It should be mentioned here, that the translation of parametric conditions can also be done manually.</li>
        <li id="ul0010-0006" num="0054">6. In case of the query, here exemplified, this translation function is called and will then re-write the text condition ‘CONTAINS’ to a new modified text condition ‘NEW-CONTAINS’ including the generated filter condition for the translation of the parametric objects “Date”. The resulting query will be:</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0038" num="0055">SELECT title, date FROM news WHERE
<ul id="ul0011" list-style="none">
    <li id="ul0011-0001" num="0000">
    <ul id="ul0012" list-style="none">
        <li id="ul0012-0001" num="0056">date&lt;“01-01-2001” AND</li>
        <li id="ul0012-0002" num="0057">NEW—CONTAINS(mod-text,
        <ul id="ul0013" list-style="none">
            <li id="ul0013-0001" num="0058">“‘IBM’ AND date-constraint:‘before(01-01-2001)’”)</li>
        </ul>
        </li>
        <li id="ul0012-0003" num="0059">ORDER BY date INCREASING</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0039" num="0060">The translation of the parametric condition of a query can be pushed down mostly into the ‘CONTAINS’ function itself. Then, the actual generation of the resulting query will be done as part of the text engine query processing.</p>
<p id="p-0040" num="0061">One aspect of the invention is, how parametric information is translated into easily supported constructs in the new datatype extension. This depends largely on the structure of the index that supports the new datatype. In the case of text, it is advantageous to exploit the “inverted structure” by adding additional index terms that represent the parametric value. If, for example, an “integer” parametric attribute has to be represented in the text index for filtering and the actual range in the parametric data is MIN to MAX, this interval can recursively be split into equal length sub-intervals. Then, each interval can be represented by a token or index term at each level. This can be done up to the level of granularity required for effective filtering.</p>
<p id="p-0041" num="0062">The idea of effective filtering by processing a query is to reduce the partial result of the nonparametric subquery so much, that based on the filter condition, representing a parametric constraint, there are so few “non-hits” in it, that the overhead of processing them is minimal in relation to the overall query cost.</p>
<p id="p-0042" num="0063">The translation of parametric information into constructs of a text extension engine will be explained by means of the following example.</p>
<p id="p-0043" num="0064">A numeric field NUM shall be used for filtering and has the range 0 to 100.000. There are 100 million data records to be indexed. Assuming equal distribution of values, each value occurs 1000 times. Then, the following range splitting can be done:</p>
<p id="p-0044" num="0065">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="91pt" align="left"/>
<colspec colname="4" colwidth="28pt" align="right"/>
<colspec colname="5" colwidth="35pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Level 1:</entry>
<entry>   0-50.000</entry>
<entry>NUM-0</entry>
<entry>50M</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry> 50.001-100.000</entry>
<entry>NUM-1</entry>
</row>
<row>
<entry>Level 2:</entry>
<entry>   0-25.000</entry>
<entry>NUM-0-0</entry>
<entry>25M</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>25.001-50.000</entry>
<entry>NUM-0-1</entry>
</row>
<row>
<entry/>
<entry>50.001-75.000</entry>
<entry>NUM-1-0</entry>
</row>
<row>
<entry/>
<entry> 75.001-100.000</entry>
<entry>NUM-1-1</entry>
</row>
<row>
<entry>Level 3:</entry>
<entry>   0-12.500</entry>
<entry>NUM-0-0-0</entry>
<entry>12.5M</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 4:</entry>
<entry>   0-6.250</entry>
<entry>NUM-0-0-0-0</entry>
<entry>6.25M</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 5:</entry>
<entry>   0-3.125</entry>
<entry>NUM-0-0-0-0-0</entry>
<entry>3.125M</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 6:</entry>
<entry>   0-1.560</entry>
<entry>NUM-0-0-0-0-0-0</entry>
<entry>1.56M</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 7:</entry>
<entry> 0-780</entry>
<entry>NUM-0-0-0-0-0-0-0</entry>
<entry>780k</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 8:</entry>
<entry> 0-390</entry>
<entry>NUM-0-0-0-0-0-0-0-0</entry>
<entry>390k</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 9:</entry>
<entry> 0-195</entry>
<entry>NUM-0-0-0-0-0-0-0-0-0</entry>
<entry>195k</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 10:</entry>
<entry> 0-97</entry>
<entry>NUM-0-0-0-0-0-0-0-0-0-0</entry>
<entry>97k</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry>Level 11:</entry>
<entry> 0-48</entry>
<entry>NUM-0-0-0-0-0-0-0-0-0-0-0</entry>
<entry>48k</entry>
<entry>records</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry/>
<entry>.</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0045" num="0066">For each record, that is indexed, index terms are added, that represent the actual value of NUM in this record. Therefore, the tokens for all intervals the number lies in are added. Thus, e.g. the encoding for the numeric value “5” would be</p>
<p id="p-0046" num="0067">NUM-0 NUM-0-0 NUM-0-0-0 NUM-0-0-0-0 NUM-0-0-0-0-0</p>
<p id="p-0047" num="0068">NUM-0-0-0-0-0-0 NUM-0-0-0-0-0-0-0 NUM-0-0-0-0-0-0-0-0</p>
<p id="p-0048" num="0069">NUM-0-0-0-0-0-0-0-0-0 NUM-0-0-0-0-0-0-0-0</p>
<p id="p-0049" num="0070">NUM-0-0-0-0-0-0-0-0-0-0-0</p>
<p id="p-0050" num="0071">This simple scheme can be optimized further by performing a distribution analysis over the parametric attribute. Then, the ranges can be split so that they represent approximately equal numbers of data points.</p>
<p id="p-0051" num="0072">In query processing according to the invention a numeric condition of a query, e.g. a range expression, will be mapped to a minimal disjunction of index terms that covers the range as precisely as possible given the encoding chosen above.</p>
<p id="p-0052" num="0073">Then, the encoding of a range constraint for NUM[10.000 . . . 25.000] would be</p>
<p id="p-0053" num="0074">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56pt" align="center"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<colspec colname="3" colwidth="91pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>NUM-0- . . .</entry>
<entry>for [12.501-25.000]</entry>
</row>
<row>
<entry>OR</entry>
<entry>NUM-0- . . .</entry>
<entry>for [10.937-12.500]</entry>
</row>
<row>
<entry>OR</entry>
<entry>NUM-0- . . .</entry>
<entry>for [10.157-10.936]</entry>
</row>
<row>
<entry>.</entry>
</row>
<row>
<entry>.</entry>
</row>
<row>
<entry>.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0054" num="0075">Further down in the above list of OR terms, the actual number of occurrences of the term becomes smaller. So, adding more of these terms to the disjunction does not present a performance issue for the text engine.</p>
<p id="p-0055" num="0076">Thus, the overall query the text engine has to evaluate in the example discussed in conjunction with <figref idref="DRAWINGS">FIG. 1</figref> has the following structure
<ul id="ul0014" list-style="none">
    <li id="ul0014-0001" num="0000">
    <ul id="ul0015" list-style="none">
        <li id="ul0015-0001" num="0077">‘IBM’ AND (‘NUM-0- . . . ’ OR ‘NUM-0- . . . ’ OR ‘NUM-0- . . . ’)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0056" num="0078">Assume ‘IBM’ is a very frequently used word in the collection of 100 million documents being searched, e.g. it occurs in about 20% of all documents. The values for NUM are equally distributed, so the range constraint selects 15% of the records. Then, the total result set comprises 3 million data records assuming statistical independence of the two parts.</p>
<p id="p-0057" num="0079">By query processing, as it is state of the art, 15 million data records are selected by the numeric range constraint and have to be intersected with 20 million data records selected by the text extension engine. This will be done by the DBMS join function after creating an intermediate table (ID map 40) of 20 million entries. As usually this intermediate table is not indexed it has to be sorted for execution of the join function. If the intersection leaves only 3 million data records, then 17 million data records have been materialized in the temp space, have been sorted, etc. just to be removed again.</p>
<p id="p-0058" num="0080">According to the invention, the text extension engine can filter its result significantly. The encoding of the numeric information chosen in the here described example has 11 levels and goes down to a granularity of 48 k records. This results in a maximum “error” of delivering 48.000 records through the temp table that are not actually part of the result.</p>
<p id="p-0059" num="0081">This aspect of the invention is also illustrated in the diagram of <figref idref="DRAWINGS">FIG. 3</figref>. As in <figref idref="DRAWINGS">FIG. 2</figref>, set <b>1</b> represents all data records of NEWS table <b>10</b>. Subset <b>2</b> represents the result set for the numeric condition ‘date&lt;“01-01-2001”’ and subset <b>3</b> represents the result set of the text search ‘CONTAINS(text, “IBM”)’. In addition to <figref idref="DRAWINGS">FIG. 2</figref>, the diagram of <figref idref="DRAWINGS">FIG. 3</figref> shows a third subset <b>5</b> representing the result set of the re-written text condition ‘NEW-CONTAINS(mod-text, “‘IBM’ AND date-constraint: ‘before(01-01-2001)’”). Therefore, the parametric condition ‘date&lt;“01-01-2001”’ has been copied as a filter constraint to the text search condition. This kind of filter acts like a Boolean “AND”. It produces a nonparametric result set, namely subset <b>5</b>, which is far smaller than subset <b>3</b>. According to the invention, it is not required that the text extension engine implements the parametric condition of a query fully. It may approximate the parametric condition with internal filters that can be efficiently implemented on the text index structures. That is the reason, why subset <b>5</b> is not identical to result set <b>4</b> but a superset of result set <b>4</b> of the query as a whole. It can now easily be evaluated as intersection of subsets <b>2</b> and <b>5</b> which is identical with the intersection of subsets <b>2</b> and <b>3</b>.</p>
<p id="p-0060" num="0082">Finally, it shall be pointed out, that the invention also applies to other nonparametric datatypes than TEXT. For example, in an IMAGE extension numeric ranges could be encoded as simple, easy to process “image patterns” that are made part of the actual image to be indexed. The core idea remains to do “approximations” for parametric conditions with index structures already available in the extension engine.</p>
<p id="p-0061" num="0083">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Parts List</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77pt" align="char" char="."/>
<colspec colname="2" colwidth="140pt" align="left"/>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>Set of all data records of database 10</entry>
</row>
<row>
<entry>2</entry>
<entry>Subset - parametric result set 20</entry>
</row>
<row>
<entry>3</entry>
<entry>Subset - text result set</entry>
</row>
<row>
<entry>4</entry>
<entry>Intersection of subsets 2 and 3</entry>
</row>
<row>
<entry>5</entry>
<entry>Subset - result set of the filtering</entry>
</row>
<row>
<entry>10</entry>
<entry>database NEWS table</entry>
</row>
<row>
<entry>20</entry>
<entry>parametric Result set</entry>
</row>
<row>
<entry>30</entry>
<entry>Text index list</entry>
</row>
<row>
<entry>40</entry>
<entry>ID map</entry>
</row>
<row>
<entry>50</entry>
<entry>result table</entry>
</row>
<row>
<entry>60</entry>
<entry>join function</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for processing queries in a database, comprising:
<claim-text>computing a parametric result set, corresponding to a parametric condition, from a set of parametric data records of the database;</claim-text>
<claim-text>translating the parametric condition into a filter condition corresponding to a data type construct of a set of nonparametric data records of a nonparametric extension of the database;</claim-text>
<claim-text>computing a nonparametric result set, based on both a nonparametric condition and the filter condition, from the set of nonparametric data records of the database corresponding to the nonparametric extension of the database; and
<claim-text>joining the parametric result set and the nonparametric result set to obtain a joined result set.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising indexing based upon the data type construct to support the computing of the nonparametric result set.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the construct of the extension provides an approximation of the corresponding parametric information so that the translation of the parametric information leads to a classification of the nonparametric data records into classes according to their parametric information.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the translation function for translating the parametric information considers the distribution of the data records in the database with respect to their parametric information to obtain an approximately equal number of data records in each resulting class of nonparametric data records.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said filter condition is based upon an approximation of the corresponding parametric condition.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the translation of the parametric information of a data record into constructs of the extension is executed with indexing of the nonparametric data records.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method according to <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the translation is executed when a nonparametric data record is added to the nonparametric extension of the database.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A database management system (DBMS) for processing queries in a database, comprising:
<claim-text>parametric data records stored in the database;</claim-text>
<claim-text>nonparametric data records stored in an extension of the database;</claim-text>
<claim-text>logic for computing a parametric result set, corresponding to a parametric</claim-text>
<claim-text>condition, from the parametric data records of the database;</claim-text>
<claim-text>logic for translating the parametric condition into a filter condition corresponding to a data type construct of the nonparametric data records;</claim-text>
<claim-text>logic for computing a nonparametric result set, based on both a nonparametric condition and the filter condition, from the set of nonparametric data records; and</claim-text>
<claim-text>logic for joining the parametric result set and the nonparametric result set to obtain a joined result set.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The DBMS of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising an index based upon the data type construct to support the logic for computing of the nonparametric result set.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The DBMS according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising an approximation of the corresponding parametric information for classifying the nonparametric data records into classes according to their parametric information.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The DBMS according to <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the translation function for translating the parametric information considers the distribution of the data records in the database with respect to their parametric information to obtain an approximately equal number of data records in each resulting class of nonparametric data records.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The DBSM according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the filter condition is based upon an approximation of the corresponding parametric condition.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The DBMS according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the translation of the parametric information of a data record into constructs of the extension is executed with indexing of the nonparametric data records.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The DBMS according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the translation is executed when a nonparametric data record is added to the nonparametric extension of the database.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A computer programming product for processing queries in a database, comprising:
<claim-text>a memory;</claim-text>
<claim-text>logic, stored on the memory for execution on a processor, for computing a parametric result set, corresponding to a parametric condition, from a set of parametric data records of the database;</claim-text>
<claim-text>logic, stored on the memory for execution on the processor, for translating the parametric condition into a filter condition corresponding to a data type construct of a set of nonparametric data records of a nonparametric extension of the database;</claim-text>
<claim-text>logic, stored on the memory for execution on the processor, for computing a nonparametric result set, based on both a nonparametric condition and the filter condition, from the set of nonparametric data records of the database corresponding to the nonparametric extension of the database; and</claim-text>
<claim-text>logic, stored on the memory for execution on the processor, for joining the parametric result set and the nonparametric result set to obtain a joined result set.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer programming product according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising logic, stored on the memory for execution on the processor, for indexing based upon the data type construct to support the computing of the nonparametric result set.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer programming product according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the construct of the extension provides an approximation of the corresponding parametric information so that the translation of the parametric information leads to a classification of the nonparametric data records into classes according to their parametric information.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer programming product according to <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the translation function for translating the parametric information considers the distribution of the data records in the database with respect to their parametric information to obtain an approximately equal number of data records in each resulting class of nonparametric data records.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer programming product according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein said filter condition is based upon an approximation of the corresponding parametric condition.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer programming product according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the translation of the parametric information of a data record into constructs of the extension is excuted with indexing of the nonparametric data records.</claim-text>
</claim>
</claims>
</us-patent-grant>
