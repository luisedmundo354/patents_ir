<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299475-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299475</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11192585</doc-number>
<date>20050729</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>167</us-term-extension>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>48</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>76</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>719311</main-classification>
<further-classification>709238</further-classification>
<further-classification>709236</further-classification>
<further-classification>709223</further-classification>
<further-classification>709224</further-classification>
<further-classification>709225</further-classification>
<further-classification>709226</further-classification>
</classification-national>
<invention-title id="d0e55">System and related interfaces supporting the processing of media content</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5187589</doc-number>
<kind>A</kind>
<name>Kono et al.</name>
<date>19930200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5194952</doc-number>
<kind>A</kind>
<name>Pelley</name>
<date>19930300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5377313</doc-number>
<kind>A</kind>
<name>Scheibl</name>
<date>19941200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345422</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5760767</doc-number>
<kind>A</kind>
<name>Shore et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5781188</doc-number>
<kind>A</kind>
<name>Amiot et al.</name>
<date>19980700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5861880</doc-number>
<kind>A</kind>
<name>Shimizu et al.</name>
<date>19990100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>5877781</doc-number>
<kind>A</kind>
<name>Tomizawa et al.</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>5930446</doc-number>
<kind>A</kind>
<name>Kanda</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6005560</doc-number>
<kind>A</kind>
<name>Gill et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6026439</doc-number>
<kind>A</kind>
<name>Chowdhury et al.</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6038425</doc-number>
<kind>A</kind>
<name>Jeffrey</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6069688</doc-number>
<kind>A</kind>
<name>Millar et al.</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6081262</doc-number>
<kind>A</kind>
<name>Gill et al.</name>
<date>20000600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6088018</doc-number>
<kind>A</kind>
<name>DeLeeuw et al.</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345156</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6167083</doc-number>
<kind>A</kind>
<name>Sporer et al.</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>37524001</main-classification></classification-national>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>6173336</doc-number>
<kind>B1</kind>
<name>Stoeckl et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>6243143</doc-number>
<kind>B1</kind>
<name>Hatalsky et al.</name>
<date>20010600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>6266053</doc-number>
<kind>B1</kind>
<name>French et al.</name>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>6275864</doc-number>
<kind>B1</kind>
<name>Mancusi et al.</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>6292187</doc-number>
<kind>B1</kind>
<name>Gibbs et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>6356701</doc-number>
<kind>B1</kind>
<name>Tanizawa et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>6362854</doc-number>
<kind>B1</kind>
<name>Fierke et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>6400378</doc-number>
<kind>B1</kind>
<name>Snook</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>6414686</doc-number>
<kind>B1</kind>
<name>Protheroe et al.</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>6519540</doc-number>
<kind>B1</kind>
<name>Salandro</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>6581102</doc-number>
<kind>B1</kind>
<name>Amini et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709231</main-classification></classification-national>
</citation>
<citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>6675386</doc-number>
<kind>B1</kind>
<name>Hendricks et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>6681261</doc-number>
<kind>B2</kind>
<name>Mancusi et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>6714216</doc-number>
<kind>B2</kind>
<name>Abe</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>6768499</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>6774919</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>6882891</doc-number>
<kind>B2</kind>
<name>Rudolph</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>6912717</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>6954581</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>6959438</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00036">
<document-id>
<country>US</country>
<doc-number>7047554</doc-number>
<kind>B1</kind>
<name>Lortz</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>725149</main-classification></classification-national>
</citation>
<citation>
<patcit num="00037">
<document-id>
<country>US</country>
<doc-number>7062567</doc-number>
<kind>B2</kind>
<name>Benitez et al.</name>
<date>20060600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00038">
<document-id>
<country>US</country>
<doc-number>7073179</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00039">
<document-id>
<country>US</country>
<doc-number>7206495</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00040">
<document-id>
<country>US</country>
<doc-number>7228056</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00041">
<document-id>
<country>US</country>
<doc-number>7237038</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00042">
<document-id>
<country>US</country>
<doc-number>7237244</doc-number>
<kind>B2</kind>
<name>Miller et al.</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00043">
<document-id>
<country>US</country>
<doc-number>2002/0023103</doc-number>
<kind>A1</kind>
<name>Gagne</name>
<date>20020200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00044">
<othercit>Luling, “Static and Dynamic Mapping of Media Assets on a Network of Distributed Multimedia Information Servers”, retrieved on Aug. 14, 2006 at &lt;&lt;http://ieeexplore.ieee.org/search/srchabstract.jsp?arnumber+776527&amp;isnumber+16865&amp;punumber+6307&gt;&gt;, 19th IEEE International Conference, Distributing Computing Systems, Proceedings, 1999, pp. 1-8.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00045">
<othercit>Lee, et al., “Negotiated Disks Admission Control in Video Streamin”, <i>Electronics Letters</i>, vol. 35, No. 21,(Oct. 14, 1999),3 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00046">
<othercit>Nutt, et al., “Dynamically Negotiated Resouce Management for Data Intersive Application”, <i>IEEE Transactions on Knowledge and Data Engineering</i>, vol. 12, No. 1,(Jan./Feb. 2000),pp. 78-95.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00047">
<othercit>Zhang, Junbiao “Static and Dynamic resource Allocation Algorithms”, (Sep. 1997).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00048">
<othercit>Bandhauer, John “XPco XPConnect Scriptable Proposal”, http://www.mozilla.org/scriptable/scriptable-proposal.html.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>10</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>20</number-of-drawing-sheets>
<number-of-figures>40</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>10883455</doc-number>
<kind>00</kind>
<date>20040701</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>6947990</doc-number>
<kind>A </kind>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>11192585</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>09732084</doc-number>
<kind>00</kind>
<date>20001206</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>6834390</doc-number>
<kind>A </kind>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>10883455</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050283787</doc-number>
<kind>A1</kind>
<date>20051222</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Miller</last-name>
<first-name>Daniel J.</first-name>
<address>
<city>Carnation</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Rudolph</last-name>
<first-name>Eric H.</first-name>
<address>
<city>Woodinville</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Thomson</last-name>
<first-name>William</first-name>
<department>2194</department>
</primary-examiner>
<assistant-examiner>
<last-name>Seye</last-name>
<first-name>Abdou K.</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A software enabled, matrix switch is presented wherein a scalable plurality of inputs, coupled to media content sources, provide media content which is recursively routed through select media processing object(s) coupled to a scalable plurality of matrix switch outputs in accordance with a user-defined media processing project.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="123.95mm" wi="184.15mm" file="US07299475-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="240.54mm" wi="209.72mm" file="US07299475-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="247.23mm" wi="192.79mm" orientation="landscape" file="US07299475-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="103.46mm" wi="135.21mm" file="US07299475-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="254.93mm" wi="186.69mm" orientation="landscape" file="US07299475-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="250.19mm" wi="117.60mm" file="US07299475-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="186.94mm" wi="172.38mm" file="US07299475-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="231.48mm" wi="200.83mm" file="US07299475-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="214.46mm" wi="128.78mm" file="US07299475-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="222.84mm" wi="136.40mm" file="US07299475-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="141.90mm" wi="141.05mm" file="US07299475-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="138.77mm" wi="127.42mm" file="US07299475-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="197.53mm" wi="186.27mm" file="US07299475-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="243.42mm" wi="149.69mm" file="US07299475-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="236.22mm" wi="199.81mm" file="US07299475-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="198.29mm" wi="141.56mm" file="US07299475-20071120-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="240.62mm" wi="181.02mm" file="US07299475-20071120-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="220.81mm" wi="137.67mm" file="US07299475-20071120-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="213.44mm" wi="133.01mm" file="US07299475-20071120-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="232.66mm" wi="124.63mm" file="US07299475-20071120-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="121.33mm" wi="157.48mm" file="US07299475-20071120-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">RELATED APPLICATION</heading>
<p id="p-0002" num="0001">This application is a continuation of and claims priority to U.S. patent application Ser. No. 10/883,455, filed Jul. 1, 2004 now U.S. Pat. No. 6,947,990, which, in turn, is a continuation of and claims priority to U.S. patent application Ser. No. 09/732,084, now U.S. Pat. No. 6,834,390, filed on Dec. 6, 2000, the disclosures of which are incorporated by reference herein. This application is also related to and claims priority to U.S. patent applications Ser. Nos. 10/980,712; 10/980,514; 11/071,290; and 11/134,181, the disclosures of which are incorporated by reference herein.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">TECHNICAL FIELD</heading>
<p id="p-0003" num="0002">This invention generally relates to processing media content and, more particularly, to a system and related interfaces facilitating the processing of media content.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">Recent advances in computing power and related technology have fostered the development of a new generation of powerful software applications. Gaming applications, communications applications, and multimedia applications have particularly benefited from increased processing power and clocking speeds. Indeed, once the province of dedicated, specialty workstations, many personal computing systems now have the capacity to receive, process and render multimedia objects (e.g., audio and video content). While the ability to display (receive, process and render) multimedia content has been around for a while, the ability for a standard computing system to support true multimedia editing applications is relatively new.</p>
<p id="p-0005" num="0004">In an effort to satisfy this need, Microsoft Corporation introduced an innovative development system supporting advanced user-defined multimedia editing functions. An example of this architecture is presented in U.S. Pat. No. 5,913,038 issued to Griffiths and commonly owned by the assignee of the present invention, the disclosure of which is expressly incorporated herein by reference.</p>
<p id="p-0006" num="0005">In the '038 patent, Griffiths introduced the an application program interface which, when exposed to higher-level development applications, enables a user to graphically construct a multimedia processing project by piecing together a collection of “filters” exposed by the interface. The interface described therein is referred to as a filter graph manager. The filter graph manager controls the data structure of the filter graph and the way data moves through the filter graph. The filter graph manager provides a set of component object model (COM) interfaces for communication between a filter graph and its application. Filters of a filter graph architecture are preferably implemented as COM objects, each implementing one or more interfaces, each of which contains a predefined set of functions, called methods. Methods are called by an application program or other component objects in order to communicate with the object exposing the interface. The application program can also call methods or interfaces exposed by the filter graph manager object.</p>
<p id="p-0007" num="0006">Filter graphs work with data representing a variety of media (or non-media) data types, each type characterized by a data stream that is processed by the filter components comprising the filter graph. A filter positioned closer to the source of the data is referred to as an upstream filter, while those further down the processing chain is referred to as a downstream filter. For each data stream that the filter handles it exposes at least one virtual pin (i.e., distinguished from a physical pin such as one might find on an integrated circuit). A virtual pin can be implemented as a COM object that represents a point of connection for a unidirectional data stream on a filter. Input pins represent inputs and accept data into the filter, while output pins represent outputs and provide data to other filters. Each of the filters include at least one memory buffer, wherein communication of the media stream between filters is often accomplished by a series of “copy” operations from one filter to another.</p>
<p id="p-0008" num="0007">As introduced in Griffiths, a filter graph has three different types of filters: source filters, transform filters, and rendering filters. A source filter is used to load data from some source; a transform filter processes and passes data; and a rendering filter renders data to a hardware device or other locations (e.g., saved to a file, etc.). An example of a filter graph for a simplistic media rendering process is presented with reference to <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> graphically illustrates an example filter graph for rendering media content. As shown, the filter graph <b>100</b> is comprised of a plurality of filters <b>102</b>-<b>114</b>,  which read, process (transform) and render media content from a selected source file. As shown, the filter graph includes each of the types of filters described above, interconnected in a linear fashion.</p>
<p id="p-0010" num="0009">Products utilizing the filter graph have been well received in the market as it has opened the door to multimedia editing using otherwise standard computing systems. It is to be appreciated, however, that the construction and implementation of the filter graphs are computationally intensive and expensive in terms of memory usage. Even the most simple of filter graphs requires and abundance of memory to facilitate the copy operations required to move data between filters. Complex filter graphs can become unwieldy, due in part to the linear nature of prior art filter graph architecture. Moreover, it is to be appreciated that the filter graphs themselves consume memory resources, thereby compounding the issue introduced above.</p>
<p id="p-0011" num="0010">Thus, what is required is a filter graph architecture which reduces the computational and memory resources required to support even the most complex of multimedia projects. Indeed, what is required is a dynamically reconfigurable multimedia editing system and related methods, unencumbered by the limitations described above. Just such a system and methods are disclosed below.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011">The same reference numbers are used throughout the figures to reference like components and features.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a graphical representation of a conventional filter graph representing a user-defined development project.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a computing system incorporating the teachings of the described embodiment.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of an example software architecture incorporating the teachings of the described embodiment.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 4</figref> is a graphical illustration of an example software-enabled matrix switch, according to an exemplary embodiment.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 5</figref> is a graphical representation of a data structure comprising a programming grid to selectively couple one or more of a scalable plurality of input pins to a scalable plurality of output pins of the matrix switch filter, in accordance with one aspect of the described embodiment.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 6</figref> is a graphical illustration denoting shared buffer memory between filters, according to one aspect of the described embodiment.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 7</figref> is a flow chart of an example method for generating a filter graph, in accordance with one aspect of the described embodiment.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 8</figref> is a flow chart of an example method for negotiating buffer requirements between at least two adjacent filters, according to one aspect of the described embodiment.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 9</figref> graphically illustrates an overview of a process that takes a user-defined editing project and composites a data structure that can be used to program the matrix switch.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 10</figref> graphically illustrates the project of <figref idref="DRAWINGS">FIG. 9</figref> in greater detail.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 11</figref> shows an exemplary matrix switch dynamically generated in support of the project developed in <figref idref="DRAWINGS">FIGS. 9 and 10</figref>, according to one described embodiment.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 12</figref> illustrates a graphic representation of an exemplary data structure that represents the project of <figref idref="DRAWINGS">FIG. 10</figref>, according to one described embodiment.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIGS. 13-18</figref> graphically illustrate various states of a matrix switch programming grid at select points in processing the project of <figref idref="DRAWINGS">FIGS. 9 and 10</figref> through the matrix switch, in accordance with one described embodiment.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 19</figref> is a flow chart of an example method for processing media content, in accordance with one described embodiment.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 20</figref> illustrates an example project with a transition and an effect, in accordance with one described embodiment.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 21</figref> shows an exemplary data structure in the form of a hierarchical tree that represents the project of <figref idref="DRAWINGS">FIG. 20</figref>.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIGS. 22 and 23</figref> graphically illustrate an example matrix switch programming grid associated with the project of <figref idref="DRAWINGS">FIG. 20</figref> at select points in time, according to one described embodiment.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 24</figref> shows an example matrix switch dynamically generated and configured as the grid of <figref idref="DRAWINGS">FIGS. 22 and 23</figref> was being processed, in accordance with one described embodiment.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 25</figref> shows an exemplary project in accordance with one described embodiment.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 26</figref> graphically illustrates an example audio editing project, according to one described embodiment.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 27</figref> depicts an example matrix switch programming grid associated with the project of <figref idref="DRAWINGS">FIG. 26</figref>.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 28</figref> shows an example matrix switch dynamically generated and configured in accordance with the programming grid of <figref idref="DRAWINGS">FIG. 27</figref> to perform the project of <figref idref="DRAWINGS">FIG. 26</figref>, according to one described embodiment.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 29</figref> illustrates an exemplary media processing project incorporating another media processing project as a composite, according to yet another described embodiment.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIGS. 31-37</figref> graphically illustrate various matrix switch programming grid states at select points in generating and configuring the matrix switch to implement the media processing of <figref idref="DRAWINGS">FIG. 29</figref>.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 38</figref> illustrates an example matrix switch suitable for use in the media processing project of <figref idref="DRAWINGS">FIG. 29</figref>, according to one described embodiment.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 38</figref><i>a </i>graphically illustrates an example data structure in the form of a hierarchical tree structure that represents a project that is useful in understanding composites in accordance with the described embodiments.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 39</figref> is a flow diagram that describes steps in a method in accordance with one described embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0040" num="0039">Related Applications</p>
<p id="p-0041" num="0040">This application is related to the following commonly-filed U.S. Patent Applications, all of which are commonly assigned to Microsoft Corp., the disclosures of which are incorporated by reference herein: application Ser. No. 09/731,560, now U.S. Pat. No. 6,774,919, entitled “An Interface and Related Methods for Reducing Source Accesses in a Development System”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/731,490, now U.S. Pat. No. 6,983,466, entitled “A System and Related Methods for Reducing Source Filter Invocation in a Development Project”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and; application Ser. No. 09/732,452, now U.S. Pat. No. 7,114,161, entitled “A System and Related Methods for Reducing Memory Requirements of a Media Processing System”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/731,529, now U.S. Pat. No. 6,961,943, entitled “A System and Related Methods for Reducing the Instances of Source Files in a Filter Graph”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/732,087, now U.S. Pat. No. 6,959,438, entitled “An Interface and Related Methods for Dynamically Generating a Filter Graph in a Development System”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/732,090, now U.S. Pat. No. 6,611,215, entitled “A System and Related Methods for Processing Audio Content in a Filter Graph”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/732,085, now U.S. Pat. No. 7,114,162, entitled “A System and Methods for Generating an Managing Filter Strings in a Filter Graph”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/731,491, now U.S. Pat. No. 6,768,499, entitled “Methods and Systems for Processing Media Content”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/731,563, now U.S. Pat. No. 6,954,581, entitled “Systems for Managing Multiple Inputs and Methods and Systems for Processing Media Content”, naming Daniel S. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/731,892, now U.S. Pat. No. 6,912,717, entitled “Methods and Systems for Implementing Dynamic Properties on Objects that Support Only Static Properties”, naming Daniel J. Miller and David Maymudes as inventors, and bearing; application Ser. No. 09/732,089, now U.S. Pat. No. 7,103,677, entitled “Methods and Systems for Efficiently Processing Compressed and Uncompressed Media Content”, naming Daniel J. Miller and Eric H. Rudolph as inventors, and bearing; application Ser. No. 09/731,581, entitled “Methods and Systems for Effecting Video Transitions Represented By Bitmaps”, naming Daniel J. Miller and David Maymudes as inventors, and bearing; application Ser. No 09/732,372, now U.S. Pat. No. 6,882,891, entitled “Methods and Systems for Mixing Digital Audio Signals”, naming Eric H. Rudolph as inventor, and bearing; and application Ser. No. 09/732,086, entitled “Methods and Systems for Processing Multi-media Editing Projects”, naming Eric H. Rudolph as inventor, and bearing.</p>
<p id="p-0042" num="0041">Various described embodiments concern an application program interface associated with a development system. According to one example implementation, the interface is exposed to a media processing application to enable a user to dynamically generate complex media processing tasks, e.g., editing projects. In the discussion herein, aspects of the invention are developed within the general context of computer-executable instructions, such as program modules, being executed by one or more conventional computers. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, personal digital assistants, multiprocessor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. In a distributed computer environment, program modules may be located in both local and remote memory storage devices. It is noted, however, that modification to the architecture and methods described herein may well be made without deviating from spirit and scope of the present invention. Moreover, although developed within the context of a media processing system paradigm, those skilled in the art will appreciate, from the discussion to follow, that the application program interface may well be applied to other development system implementations. Thus, the media processing system described below is but one illustrative implementation of a broader inventive concept.</p>
<p id="h-0006" num="0000">Example System Architecture</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 2</figref> illustrates an example of a suitable computing environment <b>200</b> on which the system and related methods for processing media content may be implemented.</p>
<p id="p-0044" num="0043">It is to be appreciated that computing environment <b>200</b> is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the media processing system. Neither should the computing environment <b>200</b> be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computing environment <b>200</b>.</p>
<p id="p-0045" num="0044">The media processing system is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and/or configurations that may be suitable for use with the media processing system include, but are not limited to, personal computers, server computers, thin clients, thick clients, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.</p>
<p id="p-0046" num="0045">In certain implementations, the system and related methods for processing media content may well be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The media processing system may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.</p>
<p id="p-0047" num="0046">In accordance with the illustrated example embodiment of <figref idref="DRAWINGS">FIG. 2</figref> computing system <b>200</b> is shown comprising one or more processors or processing units <b>202</b>, a system memory <b>204</b>, and a bus <b>206</b> that couples various system components including the system memory <b>204</b> to the processor <b>202</b>.</p>
<p id="p-0048" num="0047">Bus <b>206</b> is intended to represent one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnects (PCI) buss also known as Mezzanine bus.</p>
<p id="p-0049" num="0048">Computer <b>200</b> typically includes a variety of computer readable media. Such media may be any available media that is locally and/or remotely accessible by computer <b>200</b>, and it includes both volatile and non-volatile media, removable and non-removable media.</p>
<p id="p-0050" num="0049">In <figref idref="DRAWINGS">FIG. 2</figref>, the system memory <b>204</b> includes computer readable media in the form of volatile, such as random access memory (RAM) <b>210</b>, and/or non-volatile memory, such as read only memory (ROM) <b>208</b>. A basic input/output system (BIOS) <b>212</b>, containing the basic routines that help to transfer information between elements within computer <b>200</b>, such as during start-up, is stored in ROM <b>208</b>. RAM <b>210</b> typically contains data and/or program modules that are immediately accessible to and/or presently be operated on by processing unit(s) <b>202</b>.</p>
<p id="p-0051" num="0050">Computer <b>200</b> may further include other removable/non-removable, volatile/non-volatile computer storage media. By way of example only, <figref idref="DRAWINGS">FIG. 2</figref> illustrates a hard disk drive <b>228</b> for reading from and writing to a non-removable, non-volatile magnetic media (not shown and typically called a “hard drive”), a magnetic disk drive <b>230</b> for reading from and writing to a removable, non-volatile magnetic disk <b>232</b> (e.g., a “floppy disk”), and an optical disk drive <b>234</b> for reading from or writing to a removable, non-volatile optical disk <b>236</b> such as a CD-ROM, DVD-ROM or other optical media. The hard disk drive <b>228</b>, magnetic disk drive <b>230</b>, and optical disk drive <b>234</b> are each connected to bus <b>206</b> by one or more interfaces <b>226</b>.</p>
<p id="p-0052" num="0051">The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules, and other data for computer <b>200</b>. Although the exemplary environment described herein employs a hard disk <b>228</b>, a removable magnetic disk <b>232</b> and a removable optical disk <b>236</b>, it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROM), and the like, may also be used in the exemplary operating environment.</p>
<p id="p-0053" num="0052">A number of program modules may be stored on the hard disk <b>228</b>, magnetic disk <b>232</b>, optical disk <b>236</b>, ROM <b>208</b>, or RAM <b>210</b>, including, by way of example, and not limitation, an operating system <b>214</b>, one or more application programs <b>216</b> (e.g., multimedia application program <b>224</b>), other program modules <b>218</b>, and program data <b>220</b>. In accordance with the illustrated example embodiment of <figref idref="DRAWINGS">FIG. 2</figref>, operating system <b>214</b> includes an application program interface embodied as a render engine <b>222</b>. As will be developed more fully below, render engine <b>222</b> is exposed to higher-level applications (e.g., <b>216</b>) to automatically assemble filter graphs in support of user-defined development projects, e.g., media processing projects. Unlike conventional media processing systems, however, render engine <b>222</b> utilizes a scalable, dynamically reconfigurable matrix switch to reduce filter graph complexity, thereby reducing the computational and memory resources required to complete a development project. Various aspects of the innovative media processing system represented by a computer <b>200</b> implementing the innovative render engine <b>222</b> will be developed further, below.</p>
<p id="p-0054" num="0053">Continuing with <figref idref="DRAWINGS">FIG. 2</figref>, a user may enter commands and information into computer <b>200</b> through input devices such as keyboard <b>238</b> and pointing device <b>240</b> (such as a “mouse”). Other input devices may include a audio/video input device(s) <b>253</b>, a microphone, joystick, game pad, satellite dish, serial port, scanner, or the like (not shown). These and other input devices are connected to the processing unit(s) <b>202</b> through input interface(s) <b>242</b> that is coupled to bus <b>206</b>, but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).</p>
<p id="p-0055" num="0054">A monitor <b>256</b> or other type of display device is also connected to bus <b>206</b> via an interface, such as a video adapter <b>244</b>. In addition to the monitor, personal computers typically include other peripheral output devices (not shown), such as speakers and printers, which may be connected through output peripheral interface <b>246</b>.</p>
<p id="p-0056" num="0055">Computer <b>200</b> may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer <b>250</b>. Remote computer <b>250</b> may include many or all of the elements and features described herein relative to computer <b>200</b> including, for example, render engine <b>222</b> and one or more development applications <b>216</b> utilizing the resources of render engine <b>222</b>.</p>
<p id="p-0057" num="0056">As shown in <figref idref="DRAWINGS">FIG. 2</figref>. computing system <b>200</b> is communicatively coupled to remote devices (e.g., remote computer <b>250</b>) through a local area network (LAN) <b>251</b> and a general wide area network (WAN) <b>252</b>. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.</p>
<p id="p-0058" num="0057">When used in a LAN networking environment, the computer <b>200</b> is connected to LAN <b>251</b> through a suitable network interface or adapter <b>248</b>. When used in a WAN networking environment, the computer <b>200</b> typically includes a modem <b>254</b> or other means for establishing communications over the WAN <b>252</b>. The modem <b>254</b>, which may be internal or external, may be connected to the system bus <b>206</b> via the user input interface <b>242</b>, or other appropriate mechanism.</p>
<p id="p-0059" num="0058">In a networked environment, program modules depicted relative to the personal computer <b>200</b>, or portions thereof, may be stored in a remote memory storage device. By way of example, and not limitation, <figref idref="DRAWINGS">FIG. 2</figref> illustrates remote application programs <b>216</b> as residing on a memory device of remote computer <b>250</b>. It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.</p>
<p id="p-0060" num="0059">Turning next to <figref idref="DRAWINGS">FIG. 3</figref>, a block diagram of an example development system architecture is presented, in accordance with one embodiment of the present invention. In accordance with the illustrated example embodiment of <figref idref="DRAWINGS">FIG. 3</figref>, development system <b>300</b> is shown comprising one or more application program(s) <b>216</b> coupled to render engine <b>222</b> via an appropriate communications interface <b>302</b>. As used herein, application program(s) <b>216</b> are intended to represent any of a wide variety of applications which may benefit from use of render engine <b>222</b> such as, for example a media processing application <b>224</b>.</p>
<p id="p-0061" num="0060">The communications interface <b>302</b> is intended to represent any of a number of alternate interfaces used by operating systems to expose application program interface(s) to applications. According to one example implementation, interface <b>302</b> is a component object model (COM) interface, as used by operating systems offered by Microsoft Corporation. As introduced above, COM interface <b>302</b> provides a means by which the features of the render engine <b>222</b>, to be described more fully below, are exposed to an application program <b>216</b>.</p>
<p id="p-0062" num="0061">In accordance with the illustrated example implementation of <figref idref="DRAWINGS">FIG. 3</figref>, render engine <b>222</b> is presented comprising source filter(s) <b>304</b>A-N, transform filter(s) <b>306</b>A-N and render filter <b>310</b>, coupled together utilizing virtual pins to facilitate a user-defined media processing project. According to one implementation, the filters of system <b>300</b> are similar to the filters exposed in conventional media processing systems. According to one implementation, however, filters are not coupled via such interface pins. Rather, alternate implementations are envisioned wherein individual filters (implemented as objects) make calls to other objects, under the control of the render engine <b>222</b>, for the desired input. Unlike conventional systems, however, render engine <b>222</b> exposes a scalable, dynamically reconfigurable matrix switch filter <b>308</b>, automatically generated and dynamically configured by render engine <b>222</b> to reduce the computational and memory resource requirements often associated with development projects. As introduced above, the pins (input and/or output) are application interface(s) designed to communicatively couple other objects (e.g., filters).</p>
<p id="p-0063" num="0062">In accordance with the example implementation of a media processing system, an application communicates with an instance of render engine <b>222</b> when the application <b>216</b> wants to process streaming media content. Render engine <b>222</b> selectively invokes and controls an instance of filter graph manager (not shown) to automatically create a filter graph by invoking the appropriate filters (e.g., source, transform and rendering). As introduced above, the communication of media content between filters is achieved by either (1) coupling virtual output pins of one filter to the virtual input pins of requesting filter; or (2) by scheduling object calls between appropriate filters to communicate the requested information. As shown, source filter <b>304</b> receives streaming data from the invoking application or an external source (not shown). It is to be appreciated that the streaming data can be obtained from a file on a disk, a network, a satellite feed, an Internet server, a video cassette recorder, or other source of media content. As introduced above, transform filter(s) <b>306</b> take the media content and processes it in some manner, before passing it along to render filter <b>310</b>. As used herein, transform filter(s) <b>306</b> are intended to represent a wide variety of processing methods or applications that can be performed on media content. In this regard, transform filter(s) <b>306</b> may well include a splitter, a decoder, a sizing filter, a transition filter, an effects filter, and the like. The function of each of these filters is described more fully in the Griffiths application, introduced above, and generally incorporated herein by reference. The transition filter, as used herein, is utilized by render engine <b>222</b> to transition the rendered output from a first source to a second source. The effect filter is selectively invoked to introduce a particular effect (e.g., fade, wipe, audio distortion, etc.) to a media stream.</p>
<p id="p-0064" num="0063">In accordance with one aspect of the embodiment, to be described more fully below, matrix switch filter <b>308</b> selectively passes media content from one or more of a scalable plurality of input(s) to a scalable plurality of output(s). Moreover, matrix switch <b>308</b> also supports implementation of a cascaded architecture utilizing feedback paths, i.e., wherein transform filters <b>306</b>B, <b>306</b>C, etc. coupled to the output of matrix switch <b>308</b> are dynamically coupled to one or more of the scalable plurality of matrix switch input(s). An example of this cascaded filter graph architecture is introduced in <figref idref="DRAWINGS">FIG. 3</figref>, and further explained in example implementations, below.</p>
<p id="p-0065" num="0064">Typically, media processed through source, transform and matrix switch filters are ultimately passed to render filter <b>310</b>, which provides the necessary interface to a hardware device, or other location that accepts the renderer output format, such as a memory or disk file, or a rendering device.</p>
<p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. 4</figref> is a graphical illustration of an example software-enabled matrix switch <b>308</b>, according to one example embodiment of the present invention. As shown, the matrix switch <b>308</b> is comprised of a scalable plurality of input(s) <b>402</b> and a scalable plurality of output(s) <b>404</b>, wherein any one or more of the input(s) <b>402</b> may be iteratively coupled to any one or more of the output(s) <b>404</b>, based on the content of the matrix switch programming grid <b>406</b>, automatically generated by render engine <b>222</b>. According to an alternate implementation introduced above, switch matrix <b>308</b> is programmed by render engine <b>222</b> to dynamically generate object calls to communicate media content between filters. In addition, according to one implementation, matrix switch <b>308</b> includes a plurality of input/output (I/O) buffers <b>408</b>, as well as means for maintaining source, or media time <b>410</b> and/or timeline, or project time <b>412</b>. It is to be appreciated, however, that in alternate implementations matrix switch <b>308</b> does not maintain both source and project times, relying on an upstream filter to convert between these times. As will be developed more fully below, matrix switch <b>308</b> dynamically couples one or more of the scalable plurality of inputs <b>402</b> to one or more of the scalable plurality of outputs <b>404</b> based, at least in part, on the media time <b>410</b> and/or the project time <b>412</b> and the content of matrix switch programming grid <b>406</b>. In this regard, matrix switch <b>308</b> may be characterized as time-aware, supporting such advanced editing features as searching/seeking to a particular point (e.g., media time) in the media content, facilitating an innovative buffering process utilizing I/O buffers <b>408</b> to facilitate look-ahead processing of media content, and the like. Thus, it will be appreciated given the discussion to follow that introduction of the matrix switch <b>308</b> provides a user with an editing flexibility that was heretofore unavailable in a personal computer-based media processing system.</p>
<p id="p-0067" num="0066">As introduced above, the inputs <b>402</b> and outputs <b>404</b> of matrix switch <b>308</b> are interfaces which facilitate the time-sensitive routing of data (e.g., media content) in accordance with a user-defined development project. Matrix switch <b>308</b> has a scalable plurality of inputs <b>402</b> and outputs <b>404</b>, meaning that the number of inputs <b>402</b> and outputs <b>404</b> are individually generated to satisfy a given editing project. Insofar as each of the inputs/outputs (I/O) has an associated transfer buffer (preferably shared with an adjacent filter) to communicate media content, the scalability of the input/output serves to reduce the overall buffer memory consumed by an editing project. According to one implementation, output <b>1</b> is generally reserved as a primary output, e.g., coupled to a rendering filter (not shown).</p>
<p id="p-0068" num="0067">According to one implementation, for each input <b>402</b> and output <b>404</b>, matrix switch <b>308</b> attempts to be the allocator, or manager of the buffer associated with the I/O(s) shared with adjacent filters. One reason is to ensure that all of the buffers are of the same size and share common attributes so that a buffer associated with any input <b>402</b> may be shared with any output <b>404</b>, thereby reducing the need to copy memory contents between individual buffers associated with such inputs/outputs. If matrix switch <b>308</b> cannot be an allocator for a given output (<b>404</b>), communication from an input (<b>402</b>) to that output is performed using a conventional memory copy operation between the individual buffers associated with the select input/output.</p>
<p id="p-0069" num="0068">As introduced above, the matrix switch programming grid <b>406</b> is dynamically generated by render engine <b>222</b> based, at least in part, on the user-defined development project. As will be developed below, render engine <b>222</b> invokes an instance of filter graph manager to assembles a tree structure of an editing project, noting dependencies between source, filters and time to dynamically generate the programming grid <b>406</b>. A data structure comprising an example programming grid <b>406</b> is introduced with reference to <figref idref="DRAWINGS">FIG. 5</figref>, below.</p>
<p id="p-0070" num="0069">Turning briefly to <figref idref="DRAWINGS">FIG. 5</figref>, a graphical representation of a data structure comprising an example programming grid <b>406</b> is presented, in accordance with one embodiment of the present invention. In accordance with the illustrated example embodiment of <figref idref="DRAWINGS">FIG. 5</figref>, programming grid <b>406</b> is depicted as a two-dimensional data structure comprising a column along the y-axis <b>502</b> of the grid denoting input pins associated with a content chain (e.g., series of filters to process media content) of the development project. The top row along the x-axis <b>504</b> of the data structure denotes project time. With these grid “borders”, the body <b>506</b> of the grid <b>406</b> is populated with output pin assignments, denoting which input pin is coupled to which output pin during execution of the development project. In this way, render engine <b>222</b> dynamically generates and facilitates matrix switch <b>308</b>. Those skilled in the art will appreciate, however, that data structures of greater or lesser complexity may well be used in support of the programming grid <b>406</b> without deviating from the spirit and scope of the present invention.</p>
<p id="p-0071" num="0070">Returning to <figref idref="DRAWINGS">FIG. 4</figref>, matrix switch <b>308</b> is also depicted with a plurality of input/output buffers <b>408</b>, shared among all of the input(s)/ouptut(s) (<b>402</b>, <b>404</b>) to facilitate advanced processing features. That is, while not required to implement the core features of matrix switch <b>308</b>, I/O buffers <b>408</b> facilitate a number of innovative performance enhancing features to improve the performance (or at least the user's perception of performance) of the processing system, thereby providing an improved user experience. According to one implementation, I/O buffers <b>408</b> are separate from the buffers assigned to each individual input and output pin in support of communication through the switch. According to one implementation, I/O buffers <b>408</b> are primarily used to foster look-ahead processing of the project. Assume, for example, that a large portion of the media processing project required only 50% of the available processing power, while some smaller portion required 150% of the available processing power. Implementation of the shared I/O buffers <b>408</b> enable filter graph manager to execute tasks ahead of schedule and buffer this content in the shared I/O buffers <b>408</b> until required. Thus, when execution of the filter graph reaches a point where more than 100% of the available processing power is required, the processing system can continue to supply content from the I/O buffers <b>408</b>, while the system completes execution of the CPU-intensive tasks. If enough shared buffer space is provided, the user should never know that some tasks were not performed in real-time. According to one implementation, shared buffers <b>408</b> are dynamically split into two groups by render engine <b>222</b>, a first group supports the input(s) <b>402</b>, while a second (often smaller) group is used in support of a primary output (e.g., output pin <b>1</b>) to facilitate a second, independent output processing thread. The use of an independent output buffers the render engine from processing delays that might occur in upstream and/or downstream filters, as discussed above. It will be appreciated by those skilled in the art that such that matrix switch <b>308</b> and the foregoing described architecture beneficially suited to support media streaming applications.</p>
<p id="p-0072" num="0071">As introduced above, the filter graph is time-aware in the sense that media (source) time and project execution time are maintained. According to one implementation, matrix switch <b>308</b> maintains at least the project clock, while an upstream filter maintains the source time, converting between source and project time for all downstream filters (i.e., including the matrix switch <b>308</b>). According to one implementation, the frame rate converter filter of a filter graph is responsible for converting source time to project time, and vice versa, i.e., supporting random seeks, etc. Alternatively, matrix switch <b>308</b> utilizes an integrated set of clock(s) to independently maintain project and media times.</p>
<p id="p-0073" num="0072">Having introduced the architectural and operational elements of matrix switch filter <b>308</b>, <figref idref="DRAWINGS">FIG. 6</figref> graphically illustrates an example filter graph implementation incorporating the innovative matrix switch <b>308</b>. In accordance with the illustrated example embodiment, filter graph <b>600</b> is generated by render engine <b>222</b> in response to a user defined development project. Unlike the lengthy linear filter graphs typical of convention development systems however, filter graph <b>600</b> is shown incorporating a matrix switch filter <b>308</b> to recursively route the pre-processed content (e.g., through filters <b>602</b>, <b>606</b>, <b>610</b>, <b>614</b> and <b>618</b>, described more fully below) through a user-defined number of transform filters including, for example, transition filter(s) <b>620</b> and effects filter(s) <b>622</b>. Moreover, as will be developed more fully below, the scalable nature of matrix switch filter <b>308</b> facilitates such iterative processing for any number of content threads, tracks or compositions.</p>
<p id="p-0074" num="0073">According to one implementation, a matrix switch filter <b>308</b> can only process one type of media content, of the same size and at the same frame-rate (video) or modulation type/schema (audio). Thus, <figref idref="DRAWINGS">FIG. 6</figref> is depicted comprising pre-processing filters with a parser filter <b>606</b> to separate, independent content type(s) (e.g., audio content and video content), wherein one of the media types would be processed along a different path including a separate instance of matrix switch <b>308</b>. Thus, in accordance with the illustrated example embodiment of a media processing system, processing multimedia content including audio and video would utilize two (2) matrix switch filters <b>308</b>, one dedicated to audio processing (not shown) and one dedicated to video processing. That is not to say, however, that multiple switch filters <b>308</b> could not be used (e.g., two each for audio and video) for each content type in alternate implementations. Similarly, it is anticipated that in alternate implementations a matrix switch <b>308</b> that accepts multiple media types could well be used without deviating from the spirit and scope of the present invention.</p>
<p id="p-0075" num="0074">In addition filter graph <b>600</b> includes a decoder filter <b>610</b> to decode the media content. Resize filter <b>614</b> is employed when matrix switch <b>308</b> is to receive content from multiple sources, ensuring that the size of the received content is the same, regardless of the source. According to one implementation, resize filter <b>614</b> is selectively employed in video processing paths to adjust the media size of content from one or more sources to a user-defined level. Alternatively, resizer filter <b>614</b> adjusts the media size to the largest size provided by any one or more media sources. That is, if, for example, render engine <b>222</b> identifies the largest required media size (e.g., 1270×1040 video pixels per frame) and, for any content source not providing content at this size, the content is modified (e.g., stretched, packed, etc.) to fill this size requirement. The frame rate converter (FRC) and pack filter <b>618</b>, introduced above, ensures that video content from the multiple sources is arriving at the same frame rate, e.g., ten (10) frames per second. As introduced above, the FRC also maintains the distinction between source time and project time.</p>
<p id="p-0076" num="0075">In accordance with one aspect of the present invention, filter graph <b>600</b> is depicted utilizing a single, negotiated buffer <b>604</b>, <b>608</b>, <b>612</b>, <b>616</b>, etc. between adjacent filters. In this regard, render engine <b>222</b> reduces the buffer memory requirements in support of a development project.</p>
<p id="p-0077" num="0076">From the point of pre-processing (filters <b>602</b>, <b>606</b>, <b>610</b>, <b>614</b>, <b>618</b>), rather than continue a linear filter graph incorporating all of the transition <b>620</b> and effect <b>622</b> filter(s), render engine <b>222</b> utilizes a cascade architecture, recursively passing media content through the matrix switch <b>308</b> to apply to the transform filter(s) (e.g., <b>620</b>, <b>622</b>, etc.) to complete the execution of the development project. It will be appreciated by those skilled in the art that the ability to recursively pass media content through one or more effect and/or transition filters provided by the matrix switch filter <b>308</b> greatly reduces the perceived complexity of otherwise large filter graphs, while reducing memory and computational overhead.</p>
<p id="p-0078" num="0077">Turning to <figref idref="DRAWINGS">FIG. 7</figref>, a flow chart of an example method for generating a filter graph is presented, in accordance with one aspect of the present invention. The method <b>700</b> begins with block <b>702</b> wherein render engine <b>222</b> receives an indication to generate a filter graph representing a user-defined development project (e.g., a media editing project). According to one example implementation, the indication is received from an application <b>224</b> via COM interface(s) <b>302</b>.</p>
<p id="p-0079" num="0078">In block <b>704</b>, render engine <b>222</b> facilitates generation of the editing project, identifying the number and type of media sources selected by the user. In block <b>706</b>, based at least in part on the number and/or type of media sources, filter graph manger <b>222</b> exposes source, transform and rendering filter(s) to effect a user defined media processing project, while beginning to establish a programming grid <b>406</b> for the matrix switch filter <b>308</b>.</p>
<p id="p-0080" num="0079">In block <b>708</b>, reflecting user editing instructions, render engine <b>222</b> completes the programming grid <b>406</b> for matrix switch <b>308</b>, identifying which inputs <b>402</b> are to be coupled to which outputs <b>404</b> at particular project times.</p>
<p id="p-0081" num="0080">Based, at least in part, on the programming grid <b>406</b> render engine <b>222</b> generates a matrix switch filter <b>308</b> with an appropriate number of input <b>402</b> and output <b>404</b> pins to effect the project, and assembles the filter graph, block <b>710</b>.</p>
<p id="p-0082" num="0081">In block <b>712</b>, to reduce the buffer memory requirements for the processing project, the render engine <b>222</b> instructs the filters populating the filter graph to (re)negotiate buffer memory requirements between filters. That is, adjacent filters attempt to negotiate a size and attribute standard so that a single buffer can be utilized to couple each an output pin of one filter to an input pin of a downstream filter. An example implementation of the buffer negotiation process of block <b>712</b> is presented in greater detail with reference to <figref idref="DRAWINGS">FIG. 8</figref>.</p>
<p id="p-0083" num="0082">Turning briefly to <figref idref="DRAWINGS">FIG. 8</figref>, an example method of negotiating buffer requirements between adjacent filters is presented, in accordance with one example implementation of the present invention. Once the final connection is established to matrix switch <b>308</b>, matrix switch <b>308</b> identifies the maximum buffer requirements for any filter coupled to any of its pins (input <b>402</b> and/or output <b>404</b>), block <b>802</b>. According to one implementation, the maximum buffer requirements are defined as the lowest common multiple of buffer alignment requirements, and the maximum of all the pre-fix requirements of the filter buffers.</p>
<p id="p-0084" num="0083">In block <b>804</b>, matrix switch <b>308</b> selectively removes one or more existing filter connections to adjacent filters. Matrix switch <b>308</b> then reconnects all of its pins to adjacent filters using a common buffer size between each of the pins, block <b>806</b>. In block <b>808</b>, matrix switch <b>308</b> negotiates to be the allocator for all of its pins (<b>402</b>, <b>404</b>). If the matrix switch <b>308</b> cannot, for whatever reason, be the allocator for any of its input pins <b>402</b> minimal loss to performance is encountered, as the buffer associated with the input pin will still be compatible with any downstream filter (i.e., coupled to an output pin) and, thus, the buffer can still be passed to the downstream filter without requiring a memory copy operation. If, however, matrix switch <b>308</b> cannot be an allocator for one of its output pins <b>404</b>, media content must then be transferred to at least the downstream filter associated with that output pin using a memory copy operation, block <b>810</b>.</p>
<p id="p-0085" num="0084">In block <b>812</b>, once the matrix switch <b>308</b> has re-established its connection to adjacent filters, render engine <b>222</b> restores the connection in remaining filters using negotiated buffer requirements emanating from the matrix switch filter <b>308</b> buffer negotiations. Once the connections throughout the filter graph have been reconnected, the process continues with block <b>714</b> of <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0086" num="0085">In block <b>714</b> (<figref idref="DRAWINGS">FIG. 7</figref>), have re-established the connections between filters, render engine <b>222</b> is ready to implement a user's instruction to execute the media processing project.</p>
<p id="h-0007" num="0000">Example Operation and Implementation(s)</p>
<p id="p-0087" num="0086">The matrix switch described above is quite useful in that it allows multiple inputs to be directed to multiple outputs at any one time. These input can compete for a matrix switch output. The embodiments described below permit these competing inputs to be organized so that the inputs smoothly flow through the matrix switch to provide a desired output. And, while the inventive programming techniques are described in connection with the matrix switch as such is employed in the context of multi-media editing projects, it should be clearly understood that application of the inventive programming techniques and structures should not be so limited only to application in the field of multi-media editing projects or, for that matter, multi-media applications or data streams. Accordingly, the principles about to be discussed can be applied to other fields of endeavor in which multiple inputs can be characterized as competing for a particular output during a common time period.</p>
<p id="p-0088" num="0087">In the multi-media example below, the primary output of the matrix switch is a data stream that defines an editing project that has been created by a user. Recall that this editing project can include multiple different sources that are combined in any number of different ways, and the sources that make up a project can comprise audio sources, video sources, or both. The organization of the inputs and outputs of the matrix switch are made manageable, in the examples described below, by a data structure that permits the matrix switch to be programmed.</p>
<p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. 9</figref> shows an overview of a process that takes a user-defined editing project and renders from it a data structure that can be used to program the matrix switch.</p>
<p id="p-0090" num="0089">Specifically, a user-defined editing project is shown generally at <b>900</b>. Typically, when a user creates an editing project, they can select from a number of different multimedia clips that they can then assemble into a unique presentation. Each individual clip represents a source of digital data or a source stream (e.g., multimedia content). Projects can include one or more sources <b>902</b>. In defining their project, a user can operate on sources in different ways. For example, video sources can have transitions <b>904</b> and effects <b>906</b> applied on them. A transition object is a way to change between two or more sources. As discussed above, a transition essentially receives as input, two or more streams, operates on them in some way, and produces a single output stream. An exemplary transition can comprise, for example, fading from one source to another. An effect object can operate on a single source or on a composite of sources. An effect essentially receives a single input stream, operates on it in some way, and produces a single output stream. An exemplary effect can comprise a black-and-white effect in which a video stream that is configured for presentation in color format is rendered into a video stream that is configured for presentation in black and white format. Unlike conventional effect filters, effect object <b>906</b> may well perform multiple effect tasks. That is, in accordance with one implementation, an effect object (e.g., <b>906</b>) may actually perform multiple tasks on the received input stream, wherein said tasks would require multiple effect filters in a conventional filter graph system.</p>
<p id="p-0091" num="0090">An exemplary user interface <b>908</b> is shown and represents what a user might see when they produce a multimedia project with software executing on a computer. In this example, the user has selected three sources A, B, and C, and has assembled the sources into a project timeline. The project timeline defines when the individual sources are to be rendered, as well as when any transitions and/or effects are to occur.</p>
<p id="p-0092" num="0091">In the discussion that follows, the notion of a track is introduced. A track can contain one or more sources or source clips. If a track contains more than one source clip, the source clips cannot overlap. If source clips are to overlap (e.g. fading from one source to another, or having one source obscure another), then multiple tracks are used. A track can thus logically represent a layer on which sequential video is produced. User interface <b>908</b> illustrates a project that utilizes three tracks, each of which contains a different source. In this particular project source A will show for a period of time. At a defined time in the presentation, source A is obscured by source B. At some later time, source B transitions to source C.</p>
<p id="p-0093" num="0092">In accordance with the described embodiment, the user-defined editing project <b>900</b> is translated into a data structure <b>910</b> that represents the project. In the illustrated and described example, this data structure <b>910</b> comprises a tree structure. It is to be understood, however, that other data structures could be used. The use of tree structures to represent editing projects is well-known and is not described here in any additional detail. Once the data structure <b>910</b> is defined, it is processed to provide a data structure <b>912</b> that is utilized to program the matrix switch. In the illustrated and described embodiment, data structure <b>912</b> comprises a grid from which the matrix switch can be programmed. It is to be understood and appreciated that other data structures and techniques could, however, be used to program the matrix switch without departing from the spirit and scope of the claimed subject matter.</p>
<p id="p-0094" num="0093">The processing that takes place to define data structures <b>910</b> and <b>912</b> can take place using any suitable hardware, software, firmware, or combination thereof. In the examples set forth below, the processing takes place utilizing software in the form of a video editing software package that is executable on a general purpose computer.</p>
<p id="p-0095" num="0094">Example Project</p>
<p id="p-0096" num="0095">For purposes of explanation, consider <figref idref="DRAWINGS">FIG. 10</figref> which shows project <b>908</b> from <figref idref="DRAWINGS">FIG. 9</figref> in a little additional detail. Here, a time line containing numbers 0-16 is provided adjacent the project to indicate when particular sources are to be seen and when transitions and effects (when present) are to occur. In the examples in this document, the following convention exists with respect to projects, such as project <b>908</b>. A priority exists for video portions of the project such that as one proceeds from top to bottom, the priority increases. Thus, in the <figref idref="DRAWINGS">FIG. 10</figref> example, source A has the lowest priority followed by source B and source C. Thus, if there is an overlap between higher and lower priority sources, the higher priority source will prevail. For example, source B will obscure source A from between t=4-8.</p>
<p id="p-0097" num="0096">In this example, the following can be ascertained from the project <b>908</b> and time line: from time t=0-4 source A should be routed to the matrix switch's primary output; from t=4-12 source B should be routed to the matrix switch's primary output; from t=12-14 there should be a transition between source B and source C which should be routed to the matrix switch's primary output; and from t=14-16 source C should be routed to the matrix switch's primary output. Thus, relative to the matrix switch, each of the sources and the transition can be characterized by where it is to be routed at any given time. Consider, for example, the table just below:</p>
<p id="p-0098" num="0097">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63pt" align="center"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>Object</entry>
<entry>Routing for a given time</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>C</entry>
<entry>t = 0-12 (nowhere); t = 12-14 (transition);</entry>
</row>
<row>
<entry/>
<entry>t = 14-16 (primary output)</entry>
</row>
<row>
<entry>B</entry>
<entry>t = 0-4 (nowhere); t = 4-12 (primary output);</entry>
</row>
<row>
<entry/>
<entry>t = 12-14 (transition); t = 14-16 (nowhere)</entry>
</row>
<row>
<entry>A</entry>
<entry>t = 0-4 (primary output); t = 4-16 (nowhere)</entry>
</row>
<row>
<entry>Transition</entry>
<entry>t = 0-12 (nowhere); t = 12-14 (primary output);</entry>
</row>
<row>
<entry/>
<entry>t = 14-16 (nowhere)</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. 11</figref> shows an exemplary matrix switch <b>1100</b> that can be utilized in the presentation of the user's project. Matrix switch <b>1100</b> comprises multiple inputs and multiple outputs. Recall that a characteristic of the matrix switch <b>1100</b> is that any of the inputs can be routed to any of the outputs at any given time. A transition element <b>1102</b> is provided and represents the transition that is to occur between sources B and C. Notice that the matrix switch includes four inputs numbered <b>0</b>-<b>3</b> and three outputs numbered <b>0</b>-<b>2</b>. Inputs <b>0</b>-<b>2</b> correspond respectively to sources A-C, while input <b>3</b> corresponds to the output of the transition element <b>1102</b>. Output <b>0</b> corresponds to the switch's primary output, while outputs <b>1</b> and <b>2</b> are routed to the transition element <b>1102</b>.</p>
<p id="p-0100" num="0099">The information that is contained in the table above is the information that is utilized to program the matrix switch. The discussion presented below describes but one implementation in which the information contained in the above table can be derived from the user's project time line.</p>
<p id="p-0101" num="0100">Recall that as a user edits or creates a project, software that comprises a part of their editing software builds a data structure that represents the project. In the <figref idref="DRAWINGS">FIG. 9</figref> overview, this was data structure <b>910</b>. In addition to building the data structure that represents the editing project, the software also builds and configures a matrix switch that is to be used to define the output stream that embodies the project. Building and configuring the matrix switch can include building the appropriate graphs (e.g., a collection of software objects, or filters) that are associated with each of the sources and associating those graphs with the correct inputs of the matrix switch. In addition, building and configuring the matrix switch can also include obtaining and incorporating additional appropriate filters with the matrix switch, e.g. filters for transitions, effects, and mixing (for audio streams). This will become more apparent below.</p>
<p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. 12</figref> shows a graphic representation of an exemplary data structure <b>1200</b> that represents the project of <figref idref="DRAWINGS">FIG. 10</figref>. Here, the data structure comprises a traditional hierarchical tree structure. Any suitable data structure can, however, be utilized. The top node <b>1202</b> constitutes a group node. A group encapsulates a type of media. For example, in the present example the media type comprises video. Another media type is audio. The group node can have child nodes that are either tracks or composites. In the present example, three track nodes <b>1204</b>, <b>1206</b>, and <b>1208</b> are shown. Recall that each track can have one or more sources. If a track comprises more than one source, the sources cannot overlap. Here, all of the sources (A, B, and C) overlap. Hence, three different tracks are utilized for the sources. In terms of priority, the lowest priority source is placed into the tree furthest from the left at <b>1204</b><i>a</i>. The other sources are similarly placed. Notice that source C (<b>1208</b><i>a</i>) has a transition <b>1210</b> associated with it. A transition object, in this example, defines a two-input/one output operation. When applied to a track or a composition (discussed below in more detail), the transition object will operate between the track to which it has been applied, and any objects that are beneath it in priority and at the same level in the tree. A “tree level” has a common depth within the tree and belongs to the same parent. Accordingly, in this example, the transition <b>1210</b> will operate on a source to the left of the track on which source C resides, and beneath it in priority, i.e. source B. If the transition is applied to any object that has nothing beneath it in the tree, it will transition from blackness (and/or silence if audio is included).</p>
<p id="p-0103" num="0102">Once a data structure representing the project has been built, in this case a hierarchical tree structure, a rendering engine processes the data structure to provide another data structure that is utilized to program the matrix switch. In the <figref idref="DRAWINGS">FIG. 9</figref> example, this additional data structure is represented at <b>912</b>. It will be appreciated and understood that the nodes of tree <b>1200</b> can include so-called meta information such as a name, ID, and a time value that represents when that particular node's object desires to be routed to the output, e.g. node <b>1204</b><i>a </i>would include an identifier for the node associating it with source A, as well as a time value that indicates that source A desires to be routed to the output from time t=0-8. This meta information is utilized to build the data structure that is, in turn, utilized to program the matrix switch.</p>
<p id="p-0104" num="0103">In the example about to be described below, a specific data structure in the form of a grid is utilized. In addition, certain specifics are described with respect to how the grid is processed so that the matrix switch can be programmed. It is to be understood that the specific described approach is for exemplary purposes only and is not intended to limit application of the claims. Rather, the specific approach constitutes but one way of implementing broader conceptual notions embodied by the inventive subject matter.</p>
<p id="p-0105" num="0104"><figref idref="DRAWINGS">FIGS. 13-18</figref> represent a process through which the inventive grid is built. In the grid about to be described, the x axis represents time, and the y axis represents layers in terms of priority that go from lowest (at the top of the grid) to highest (at the bottom of the grid). Every row in the grid represents the video layer. Additionally, entries made within the grid represent output pins of the matrix switch. This will become apparent below.</p>
<p id="p-0106" num="0105">The way that the grid is built in this example is that the rendering engine does a traversal operation on the tree <b>1200</b>. In this particular example, the traversal operation is known as a “depth-first, left-to-right” traversal. This operation will layerize the nodes so that the leftmost track or source has the lowest priority and so on. Doing the above-mentioned traversal on tree <b>1200</b> (<figref idref="DRAWINGS">FIG. 12</figref>), the first node encountered is node <b>1204</b> which is associated with source A. This is the lowest priority track or source. A first row is defined for the grid and is associated with source A. After the first grid row is defined, a grid entry is made and represents the time period for which source A desires to be routed to the matrix switch's primary output.</p>
<p id="p-0107" num="0106"><figref idref="DRAWINGS">FIG. 13</figref> shows the state of a grid <b>1300</b> after this first processing step. Notice that from time t=0-8, a “0” has been placed in the grid. The “0” represents the output pin of the matrix switch—in this case the primary output. Next, the traversal encounters node <b>1206</b> (<figref idref="DRAWINGS">FIG. 12</figref>) which is associated with source B. A second row is thus defined for the grid and is associated with source B. After the second grid row is defined, a grid entry is made and represents the time period for which source B desires to be routed to the matrix switch's primary output.</p>
<p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. 14</figref> shows the state of grid <b>1300</b> after this second processing step. Notice that from time t=4-14, a “0” has been placed in the grid. Notice at this point that something interesting has occurred which will be resolved below. Each of the layers has a common period of time (i.e. t=4-8) for which it desires to be routed to the matrix switch's primary output. However, because of the nature of the matrix switch, only one input can be routed to the primary output at a time. Next, the traversal encounters node <b>1208</b> (<figref idref="DRAWINGS">FIG. 12</figref>) which is associated with source C. In this particular processing example, a rule is defined that sources on tracks are processed before transitions on the tracks are processed because transitions operate on two objects that are beneath them. A third row is thus defined for the grid and is associated with source C. After the third row is defined, a grid entry is made and represents the time period for which source C desires to be routed to the matrix switch's primary output.</p>
<p id="p-0109" num="0108"><figref idref="DRAWINGS">FIG. 15</figref> shows the state of grid <b>1300</b> after this third processing step. Notice that from time t=12-16, a “0” has been placed in the grid. Next, the traversal encounters node <b>1210</b> (<figref idref="DRAWINGS">FIG. 12</figref>) which corresponds to the transition. Thus, a fourth row is defined in the grid and is associated with the transition. After the fourth row is defined, a grid entry is made and represents the time period for which the transition desires to be routed to the matrix switch's primary output.</p>
<p id="p-0110" num="0109"><figref idref="DRAWINGS">FIG. 16</figref> shows the state of grid <b>1300</b> after this fourth processing step. Notice that from time t=12-14, a “0” has been placed in the grid for the transition entry. The transition is a special grid entry. Recall that the transition is programmed to operate on two inputs and provide a single output. Accordingly, starting at the transition entry in the grid and working backward, each of the entries corresponding to the same tree level are examined to ascertain whether they contain entries that indicate that they want to be routed to the output during the same time that the transition is to be routed to the output. If grid entries are found that conflict with the transition's grid entry, the conflicting grid entry is changed to a value to corresponds to an output pin that serves as an input to the transition element <b>1102</b> (<figref idref="DRAWINGS">FIG. 11</figref>). This is essentially a redirection operation. In the illustrated grid example, the transition first finds the level that corresponds to source C. This level conflicts with the transition's grid entry for the time period t=12-14. Thus, for this time period, the grid entry for level C is changed to a switch output that corresponds to an input for the transition element. In this example, a “2” is placed in the grid to signify that for this given time period, this input is routed to output pin <b>2</b>. Similarly, continuing up the grid, the next level that conflicts with the transition's grid entry is the level that corresponds to source B. Thus, for the conflicting time period, the grid entry for level B is changed to a switch output that corresponds to an input for the transition element. In this example, a “1” is placed in the grid to signify that for this given time period, this input is routed to output pin <b>1</b> of the matrix switch.</p>
<p id="p-0111" num="0110"><figref idref="DRAWINGS">FIG. 17</figref> shows the state of the grid at this point in the processing. Next, a pruning function is implemented which removes any other lower priority entry that is contending for the output with a higher priority entry. In the example, the portion of A from t=4-8 gets removed because the higher priority B wants the output for that time.</p>
<p id="p-0112" num="0111"><figref idref="DRAWINGS">FIG. 18</figref> shows the grid with a cross-hatched area that signifies that portion of A's grid entry that has been removed.</p>
<p id="p-0113" num="0112">At this point, the grid is in a state in which it can be used to program the matrix switch. The left side entries—A, B, C, and TRANS represent input pin numbers 0, 1, 2, and 3 (as shown) respectively, on the matrix switch shown in <figref idref="DRAWINGS">FIG. 11</figref>. The output pin numbers of the matrix switch are designated at 0, 1, and 2 both on the switch in <figref idref="DRAWINGS">FIG. 11</figref> and within the grid in <figref idref="DRAWINGS">FIG. 18</figref>. As one proceeds through the grid, starting with source A, the programming of the matrix switch can be ascertained as follows: A is routed to output pin <b>0</b> of the matrix switch (the primary output) from t=0-4. From t=4-16, A is not routed to any output pins. From t=0-4, B is not routed to any of the output pins of the matrix switch. From t=4-12, B is routed to the primary output pin <b>0</b> of the matrix switch. From t=12-14, B is routed to output pin <b>1</b> of the matrix switch. Output pin <b>1</b> of the matrix switch corresponds to one of the input pins for the transition element <b>1102</b> (<figref idref="DRAWINGS">FIG. 11</figref>). From t=14-16, B is not routed to any of the output pins of the matrix switch. From t=0-12, C is not routed to any of the output pins of the matrix switch. From t=12-14, C is routed to output pin <b>2</b> of the matrix switch. Output pin <b>2</b> of the matrix switch corresponds to one of the input pins for the transition element <b>302</b> (<figref idref="DRAWINGS">FIG. 3</figref>). From t=12-14 the transition element (input pin <b>3</b>) is routed to output pin <b>0</b>. From t=14-16, C is routed to output pin <b>0</b> of the matrix switch.</p>
<p id="p-0114" num="0113">As alluded to above, one of the innovative aspects of the matrix switch <b>308</b> is its ability to seek to any point in a source, without having to process the intervening content serially through the filter. Rather, matrix switch <b>308</b> identifies an appropriate transition point and dumps at least a subset of the intervening content, and continues processing from the seeked point in the content.</p>
<p id="p-0115" num="0114">The ability of the matrix switch <b>308</b> to seek to any point in the media content gives rise to certain performance enhancement heretofore unavailable in computer implemented media processing systems. For example, generation of a filter graph by render engine <b>222</b> may take into account certain performance characteristics of the media processing system which will execute the user-defined media processing project. In accordance with this example implementation, render engine <b>222</b> may access and analyze the system registry of the operating system, for example, to ascertain the performance characteristics of hardware and/or software elements of the computing system implementing the media processing system, and adjust the filter graph construction to improve the perceived performance of the media processing system by the user. Nonetheless, there will always be a chance that a particular instance of a filter graph will not be able to process the media stream fast enough to provide the desired output at the desired time, i.e., processing of the media stream bogs down leading to delays at the rendering filter. In such a case, matrix switch <b>308</b> will recognize that it is not receiving media content at the appropriate project time, and may skip certain sections of the project in an effort to “catch-up” and continue the remainder of the project in real time. According to one implementation, when matrix switch <b>308</b> detects such a lag in processing, it will analyze the degree of the lag and issue a seek command to the source (through the source processing chain) to a future point in the project, where processing continues without processing any further content prior to the seeked point.</p>
<p id="p-0116" num="0115">Thus, for the editing project depicted in <figref idref="DRAWINGS">FIG. 10</figref>, the processing described above first builds a data structure (i.e. data structure <b>1200</b> in <figref idref="DRAWINGS">FIG. 12</figref>) that represents the project in hierarchical space, and then uses this data structure to define or create another data structure that can be utilized to program the matrix switch.</p>
<p id="p-0117" num="0116"><figref idref="DRAWINGS">FIG. 19</figref> is a flow diagram that describes steps in a method in accordance with the described embodiment. The method can be implemented in any suitable hardware, software, firmware, or combination thereof. In the illustrated and described embodiment, the method is implemented in software.</p>
<p id="p-0118" num="0117">Step <b>1900</b> provides a matrix switch. An exemplary matrix switch is described above. Step <b>1902</b> defines a first data structure that represents the editing project. Any suitable data structure can be used, as will be apparent to those of skill in the art. In the illustrated and described embodiment, the data structure comprises a hierarchical tree structure having nodes that can represent tracks (having one or more sources), composites, transitions and effects. Step <b>1904</b> processes the first data structure to provide a second data structure that is configured to program the matrix switch. Any suitable data structure can be utilized to implement the second data structure. In the illustrated and described embodiment, a grid structure is utilized. Exemplary processing techniques for processing the first data structure to provide the second data structure are described above. Step <b>1906</b> then uses the second data structure to program the matrix switch.</p>
<p id="p-0119" num="0118">Example Project with a Transition and an Effect</p>
<p id="p-0120" num="0119">Consider project <b>2000</b> depicted in <figref idref="DRAWINGS">FIG. 20</figref>. In this project there are three tracks, each of which contains a source, i.e. source A, B and C. This project includes an effect applied on source B and a transition between sources B and C. The times are indicated as shown.</p>
<p id="p-0121" num="0120">As the user creates their project, a data structure representing the project is built. <figref idref="DRAWINGS">FIG. 21</figref> shows an exemplary data structure in the form of a hierarchical tree <b>2100</b> that represents project <b>2000</b>. There, the data structure includes three tracks, each of which contains one of the sources. The sources are arranged in the tree structure in the order of their priority, starting with the lowest priority source on the left and proceeding to the right. There is an effect (i.e. “Fx”) that is attached to or otherwise associated with source B. Additionally, there is a transition attached to or otherwise associated with source C.</p>
<p id="p-0122" num="0121">In building the grid for project <b>2000</b>, the following rule is employed for effects. An effect, in this example, is a one-input/one-output object that is applied to one object—in this case source B. When the effect is inserted into the grid, it looks for any one object beneath it in priority that has a desire to be routed to the primary output of the matrix switch at the same time. When it finds a suitable object, it redirects that object's output from the matrix switch's primary output to an output associated with the effect.</p>
<p id="p-0123" num="0122">As an example, consider <figref idref="DRAWINGS">FIG. 22</figref> and the grid <b>2200</b>. At this point in the processing of tree <b>2100</b>, the rendering engine has incorporated entries in the grid corresponding to sources A, B and the effect. It has done so by traversing the tree <b>2100</b> in the above-described way. In this example, the effect has already looked for an object beneath it in priority that is competing for the primary output of the matrix switch. It found an entry for source B and then redirected B's grid entry to a matrix switch output pin that corresponds to the effect—here output pin <b>1</b>.</p>
<p id="p-0124" num="0123">As the render engine <b>222</b> completes its traversal of tree <b>2100</b>, it completes the grid. <figref idref="DRAWINGS">FIG. 23</figref> shows a completed grid <b>2200</b>. Processing of the grid after that which is indicated in <figref idref="DRAWINGS">FIG. 22</figref> takes place substantially as described above with respect to the first example. Summarizing, this processing though: after the effect is entered into the grid and processed as described above, the traversal of tree <b>2100</b> next encounters the node associated with source C. Thus, a row is added in the grid for source C and an entry is made to indicate that source C desires the output from t=12-16. Next, the tree traversal encounters the node associated with the transition. Accordingly, a row is added to the grid for the transition and a grid entry is made to indicate that the transition desires the output from t=12-14. Now, as described above, the grid is examined to find two entries, lower in priority than the transition and located at the same tree level as the transition, that compete for the primary output of the matrix switch. Here, those entries correspond to the grid entries for the effect and source C that occur from t=12-14. These grid entries are thus redirected to output pins of the matrix switch <b>308</b> that correspond to the transition—here pins <b>2</b> and <b>3</b> as indicated. Next, the grid is pruned which, in this example, removes a portion of the grid entry corresponding to source A for t=4-8 because of a conflict with the higher-priority entry for source B.</p>
<p id="p-0125" num="0124"><figref idref="DRAWINGS">FIG. 24</figref> shows the resultant matrix switch that has been built and configured as the grid was being processed above. At this point, the grid can be used to program the matrix switch. From the grid picture, it is very easy to see how the matrix switch <b>308</b> is going to be programmed. Source A will be routed to the matrix switch's primary output (pin <b>0</b>) from t=0-4; source B will be redirected to output pin <b>1</b> (effect) from t=4-14 and the effect on B will be routed to the output pin <b>0</b> from t=4-12. From t=12-14, the effect and source C will be routed to output pins corresponding to the transition (pins <b>2</b> and <b>3</b>) and, accordingly, during this time the transition (input pin <b>4</b>) will be routed to the primary output (output pin <b>0</b>) of the matrix switch. From t=14-16, source C will be routed to the primary output of the matrix switch.</p>
<p id="p-0126" num="0125">It will be appreciated that as the software, in this case the render engine <b>222</b>, traverses the tree structure that represents a project, it also builds the appropriate graphs and adds the appropriate filters and graphs to the matrix switch. Thus, for example, as the render engine <b>222</b> encounters a tree node associated with source A, in addition to adding an entry to the appropriate grid, the software builds the appropriate graphs (i.e. collection of linked filters), and associates those filters with an input of the matrix switch. Similarly, when the render engine <b>222</b> encounters an effect node in the tree, the software obtains an effect object or filter and associates it with the appropriate output of the matrix switch. Thus, in the above examples, traversal of the tree structure representing the project also enables the software to construct the appropriate graphs and obtain the appropriate objects and associate those items with the appropriate inputs/outputs of the matrix switch <b>308</b>. Upon completion of the tree traversal and processing of the grid, an appropriate matrix switch has been constructed, and the programming (i.e. timing) of inputs to outputs for the matrix switch has been completed.</p>
<p id="p-0127" num="0126">Treatment of “blanks” in a Project</p>
<p id="p-0128" num="0127">There may be instances in a project when a user leaves a blank in the project time line. During this blank period, no video or audio is scheduled for play.</p>
<p id="p-0129" num="0128"><figref idref="DRAWINGS">FIG. 25</figref> shows a project that has such a blank incorporated therein. If there is such a blank left in a project, the software is configured to obtain a “black” source and associate the source with the matrix switch at the appropriate input pin. The grid is then configured when it is built to route the black source to the output at the appropriate times and fade from the black (and silent) source to the next source at the appropriate times. The black source can also be used if there is a transition placed on a source for which there is no additional source from which to transition.</p>
<p id="p-0130" num="0129">Audio Mixing</p>
<p id="p-0131" num="0130">In the examples discussed above, sources comprising video streams were discussed. In those examples, at any one time, only two video streams were combined into one video stream. However, each project can, and usually does contain an audio component. Alternately, a project can contain only an audio component. The audio component can typically comprise a number of different audio streams that are combined. The discussion below sets forth but one way of processing and combining audio streams.</p>
<p id="p-0132" num="0131">In the illustrated example, there is no limit on the number of audio streams that can be combined at any one time.</p>
<p id="p-0133" num="0132">Suppose, for example, there is an audio project that comprises 5 tracks, A-E. <figref idref="DRAWINGS">FIG. 26</figref> shows an exemplary project. The shaded portions of each track represent the time during which the track is not playing. So, for example, at t=0-4, tracks B, D, and E are mixed together and will play. From t=4-10, tracks A-E are mixed together and will play, and the like.</p>
<p id="p-0134" num="0133"><figref idref="DRAWINGS">FIG. 27</figref> shows the grid for this project at <b>2700</b>. Since we are dealing with this composition now, all of the effects and transitions including the audio mixing are only allowed to affect things in this composition. Thus, there is the concept of a boundary <b>2702</b> that prevents any actions or operations in this composition from affecting any other grid entries. Note that there are other entries in the grid and that the presently-illustrated entries represent only those portions of the project that relate to the audio mixing function.</p>
<p id="p-0135" num="0134">Grid <b>2700</b> is essentially set up in a manner similar to that described above with respect to the video projects. That is, for each track, a row is added to the grid and a grid entry is made for the time period during which the source on that track desires to be routed to the primary output of the matrix switch. In the present example, grid entries are made for sources A-E. Next, in the same way that a transition or effect was allocated a row in the grid, a “mix” element is allocated a row in the grid as shown and a grid entry is made to indicate that the mix element desires to be routed to the primary output of the matrix switch for a period of time during which two or more sources compete for the matrix switch's primary output. Note that in this embodiment, allocation of a grid row for the mix element can be implied. Specifically, whereas in the case of a video project, overlapping sources simply result in playing the higher priority source (unless the user defines a transition between them), in the audio realm, overlapping sources are treated as an implicit request to mix them. Thus, the mix element is allocated a grid row any time there are two or more overlapping sources.</p>
<p id="p-0136" num="0135">Once the mix element is allocated into the grid, the grid is processed to redirect any conflicting source entries to matrix switch output pins that correspond to the mix element. In the above case, redirection of the grid entries starts with pin <b>3</b> and proceeds through to pin <b>7</b>. The corresponding matrix switch is shown in <figref idref="DRAWINGS">FIG. 28</figref>. Notice that all of the sources are now redirected through the mix element which is a multi-input/one output element. The mix element's output is fed back around and becomes input pin <b>15</b> of the matrix switch. All of the programming of the matrix switch is now reflected in the grid <b>2700</b>. Specifically, for the indicated time period in the grid, each of the sources is routed to the mix element which, in turn, mixes the appropriate audio streams and presents them to the primary output pin <b>0</b> of the matrix switch.</p>
<p id="p-0137" num="0136">Compositions</p>
<p id="p-0138" num="0137">There are situations that can arise when building an editing project where it would be desirable to apply an effect or a transition on just a subset of a particular project or track. Yet, there is no practicable way to incorporate the desired effect or transition. In the past, attempts to provide added flexibility for editing projects have been made in the form of so called “bounce tracks”, as will be appreciated and understood by those of skill in the art. The use of bounce tracks essentially involves processing various video layers (i.e. tracks), writing or moving the processed layers or tracks to another location, and retrieving the processed layers when later needed for additional processing with other layers or tracks. This type of processing can be slow and inefficient.</p>
<p id="p-0139" num="0138">To provide added flexibility and efficiency for multi-media editing projects, the notion of a composite or composition is introduced. A composite or composition can be considered as a representation of an editing project as a single track. Recall that editing projects can have one or more tracks, and each track can be associated with one or more sources that can have effects applied on them or transitions between them. In addition, compositions can be nested inside one another.</p>
<p id="p-0140" num="0139">Example Project with Composite</p>
<p id="p-0141" num="0140">Consider, for example, <figref idref="DRAWINGS">FIG. 29</figref> which illustrates an exemplary project <b>2900</b> having a composition <b>2902</b>. In this example, composition <b>2902</b> comprises sources B and C and a transition between B and C that occurs between t=12-14. This composition is treated as an individual track or layer. Project <b>2900</b> also includes a source A, and a transition between source A and composition <b>2902</b> at t=4-8. It will be appreciated that compositions can be much more complicated than the illustrated composition, which is provided for exemplary purposes only. Compositions are useful because they allow the grouping of a particular set of operations on one or more tracks. The operation set is performed on the grouping, and does not affect tracks that are not within the grouping. To draw an analogy, a composition is similar in principle to a mathematical parenthesis. Those operations that appear within the parenthesis are carried out in conjunction with those operations that are intended to operate of the subject matter of the parenthesis. The operations within the parenthesis do not affect tracks that do not appear within the parenthesis.</p>
<p id="p-0142" num="0141">In accordance with the processing that is described above in connection with <figref idref="DRAWINGS">FIG. 19</figref>, a first data structure is defined that represents the editing project. <figref idref="DRAWINGS">FIG. 30</figref> shows an exemplary data structure <b>3000</b> in the form of a hierarchical tree structure. In this example, group node <b>3002</b> includes two children—track node <b>3004</b> and composite node <b>3006</b>. Track node <b>3004</b> is associated with source A. Composite node <b>3006</b> includes two children—track nodes <b>3008</b> and <b>3010</b> that are respectively associated with sources B (<b>3008</b><i>a</i>) and C (<b>3010</b><i>a</i>). A transition T<b>2</b> (<b>3012</b>) is applied on source C and a transition Ti (<b>3014</b>) is applied on composition <b>3006</b>.</p>
<p id="p-0143" num="0142">Next, data structure <b>3000</b> is processed to provide a second data structure that is configured to program the matrix switch. Note that as the data structure is being programmed, a matrix switch is being built and configured at the same time. In this example, the second data structure comprises a grid structure that is assembled in much the same way as was described above. There are, however, some differences and, for purposes of understanding, the complete evolution of the grid structure is described here. In the discussion that follows, the completed matrix switch is shown in <figref idref="DRAWINGS">FIG. 38</figref>.</p>
<p id="p-0144" num="0143">When the rendering engine initiates the depth-first, left-to-right traversal of data structure <b>3000</b>, the first node it encounters is track node <b>3004</b> which is associated with source A. Thus, a first row of the grid is defined and a grid entry is made that represents the time period for which source A desires to be routed to the matrix switch's primary output pin.</p>
<p id="p-0145" num="0144"><figref idref="DRAWINGS">FIG. 31</figref> shows the state of a grid <b>3100</b> after this first processing step. Next the traversal of data structure <b>3000</b> encounters the composite node <b>3006</b>. The composite node is associated with two tracks—track <b>3008</b> and track <b>3010</b>. Track <b>3008</b> is associated with source B. Accordingly, a second row of the grid is defined and a grid entry is made that represents the time period for which source B desires to be routed to the matrix switch's primary output pin. Additionally, since B is a member of a composition, meta-information is contained in the grid that indicates that this grid row defines one boundary of the composition. This meta-information is graphically depicted with a bracket that appears to the left of the grid row.</p>
<p id="p-0146" num="0145"><figref idref="DRAWINGS">FIG. 32</figref> shows the state of grid <b>3100</b> after this processing step. Next, the traversal of data structure <b>3000</b> encounters node <b>3010</b> which is associated with source C. Thus, a third row of the grid is added and a grid entry is made that represents the time period for which source C desires to be routed to the matrix switch's primary output pin.</p>
<p id="p-0147" num="0146"><figref idref="DRAWINGS">FIG. 33</figref> shows the state of grid <b>3100</b> after this processing step. Notice that the bracket designating the composition now encompasses the grid row associated with source C. The traversal next encounters node <b>3012</b> which is the node associated with the second transition T<b>2</b>. Thus, as in the above example, a grid row is added for the transition and a grid entry is made that represents the time period for which the transition desires to be routed to the matrix switch's primary output pin.</p>
<p id="p-0148" num="0147"><figref idref="DRAWINGS">FIG. 34</figref> shows the state of grid <b>3100</b> after this processing step. Notice that the bracket designating the composition is now completed and encompasses grid row entries that correspond to sources B and C and the transition between them. Recall from the examples above that a transition, in this example, is programmed to operate on two inputs and provide a single output. In this instance, and because the transition occurs within a composition, the transition is constrained by a rule that does not allow it to operate on any elements outside of the composition. Thus, starting at the transition entry and working backward through the grid, entries at the same tree level and within the composition (as designated by the bracket) are examined to ascertain whether they contain entries that indicate that they want to be routed to the output during the same time that the transition is to be routed to the output. Here, both of the entries for sources B and C have portions that conflict with the transition's entry. Accordingly, those portions of the grid entries for sources B and C are redirected or changed to correspond to output pins that are associated with a transition element that corresponds to transition T<b>2</b>.</p>
<p id="p-0149" num="0148"><figref idref="DRAWINGS">FIG. 35</figref> shows the state of grid <b>3100</b> after this processing step. The traversal next encounters node <b>3014</b> which is the node that is associated with the transition that occurs between source A and composition <b>2902</b> (<figref idref="DRAWINGS">FIG. 29</figref>). Processing of this transition is similar to processing of the transition immediately above except for the fact that the transition does not occur within the composition. Because the transition occurs between the composition and another source, one of the inputs for the transition will be the composition, and one of the inputs will be source A (which is outside of the composition). Thus, a grid row is added for this transition and a grid entry is made that represents the time period for which the transition desires to be routed to the matrix switch's primary output pin.</p>
<p id="p-0150" num="0149"><figref idref="DRAWINGS">FIG. 36</figref> shows the state of grid <b>3100</b> after this processing step. At this point then, the grid is examined for entries that conflict with the entry for transition T<b>1</b>. One conflicting grid entry is found for the row that corresponds to source B (inside the composition) and one that corresponds to source A (outside the composition). Accordingly, those portions of the grid row that conflict with transition T<b>1</b> are changed or redirected to have values that are associated with output pins of the matrix switch that are themselves associated with a transition element T<b>1</b>. In this example, redirection causes an entry of “3” and “4” to be inserted as shown.</p>
<p id="p-0151" num="0150"><figref idref="DRAWINGS">FIG. 37</figref> shows the state of grid <b>3100</b> after this processing step. If necessary, a pruning operation would further ensure that the grid has no competing entries for the primary output of the matrix switch. The associated input pin numbers of the matrix switch are shown to the left of grid <b>3100</b>.</p>
<p id="p-0152" num="0151"><figref idref="DRAWINGS">FIG. 38</figref> shows a suitably configured matrix switch that has been build in accordance with the processing described above. Recall that, as data structure <b>3000</b> (<figref idref="DRAWINGS">FIG. 30</figref>) is processed by the rendering engine, a matrix switch is built and configured in parallel with the building and processing of the grid structure that is utilized to program the matrix switch. From the matrix switch and grid <b>3100</b> of <figref idref="DRAWINGS">FIG. 37</figref>, the programming of the switch can be easily ascertained.</p>
<p id="p-0153" num="0152"><figref idref="DRAWINGS">FIG. 38</figref><i>a </i>shows an exemplary data structure that represents a project that illustrates the usefulness of composites. In this example, the project can mathematically be represented as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(Fx-noisy (A Tx-Blend B)) Tx-Blend C<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0154" num="0153">Here, an effect (noisy) is applied to A blended with B, the result of which is applied to a blend with C. The composite in this example allows the grouping of the things beneath it so that the effect (noisy), when it is applied, is applied to everything that is beneath it. Notice that without the composite node, there is no node where an effect can be applied that will affect (A Tx-Blend B). Hence, in this example, operations that appear within the parenthesis are carried out on tracks that appear within the parenthesis. Those operations do not affect tracks that are not within the parenthesis.</p>
<p id="p-0155" num="0154"><figref idref="DRAWINGS">FIG. 39</figref> is a flow diagram that described steps in a method in accordance with one embodiment. The method can be implemented in any suitable hardware, software, firmware, or combination thereof. In the presently-described example, the method is implemented in software.</p>
<p id="p-0156" num="0155">Step <b>3900</b> defines a multimedia editing project that includes at least one composite. The composite represents multiple tracks as a single track for purposes of the processing described just below. It is important to note that, in the processing described just below, and because of the use of composites, the extra processing that is required by bounce tracks is avoided (i.e. operating on two tracks, moving the operation result to another location, and retrieving the operation result when later needed). This reduces the processing time that is required to render a multi-media project. Step <b>3902</b> defines a first data structure that represents the editing project. Any suitable data structure can be utilized. In the present example, a data structure in the form of a hierarchical tree is utilized. An exemplary tree is shown in <figref idref="DRAWINGS">FIG. 30</figref>. Step <b>3904</b> processes the first data structure to provide a second data structure that is configured to program a matrix switch. In the illustrated example, the second data structure comprises a grid structure. Exemplary processing is described in the context of <figref idref="DRAWINGS">FIGS. 30-37</figref>. Step <b>3906</b> then programs the matrix switch using the second data structure.</p>
<heading id="h-0008" level="1">CONCLUSION</heading>
<p id="p-0157" num="0156">The described embodiments can be used to provide improvements over previous multi-media editing systems. Various efficiencies are achieved that reduce the processing times and can thereby improve the user experience when using multi-media project editing software applications.</p>
<p id="p-0158" num="0157">Although the invention has been described in language specific to structural features and/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-readable storage media comprising a software enabled, matrix switch comprising:
<claim-text>a scalable plurality of inputs, dynamically coupled to select source(s) to receive media content; and</claim-text>
<claim-text>a scalable plurality of outputs, dynamically coupled to select software object(s), wherein the software enabled, matrix switch recursively routes media content through the select software object(s) to manipulate the received media content in accordance with a user-defined media processing project;</claim-text>
<claim-text>a programming grid, generated by a render engine in accordance with the user-defined media processing project, to control routing of the media content from the scalable plurality of one or more inputs to the scalable plurality of one or more outputs;</claim-text>
<claim-text>wherein the matrix switch is generated by the render engine in a media processing filter graph to selectively couple one or more inputs to one or more outputs recursively processing media content through a plurality of software objects in accordance with a user-defined media processing project, wherein the software objects include virtual pins that are used to couple the software objects together in a filter graph.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A computer-readable storage media comprising a software enabled, matrix switch comprising:
<claim-text>a scalable plurality of inputs, dynamically coupled to select source(s) to receive media content; and</claim-text>
<claim-text>a scalable plurality of outputs, dynamically coupled to select software object(s), wherein the software enabled, matrix switch recursively routes media content through the select software object(s) to manipulate the received media content in accordance wit a user-defined media processing project; and</claim-text>
<claim-text>a programming grid, generated by a render engine in accordance with a user-defined media processing project, to dynamically couple select ones of the scalable plurality of inputs to select ones of the scalable plurality of outputs, wherein the software objects include virtual pins that are used to couple the software objects together in a filter graph.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A media processing system comprising:
<claim-text>one or more computer-readable media;</claim-text>
<claim-text>one or more processors; and</claim-text>
<claim-text>computer-readable instructions on the one or more computer-readable media which, when executed by the one or more processors, cause the one or more processors to provide:
<claim-text>a source to provide media content; and</claim-text>
<claim-text>a software enabled, matrix switch filter, coupled to the source, to receive the media content on one or more of a scalable plurality of inputs and selectively route the content to object(s) coupled to one or more of a scalable plurality of output(s), to recursively transform the received content prior to rendering, wherein the matrix switch filter further comprising a programming grid, dynamically generated by the media processing system to recursively route media content from one or more of the scalable plurality of inputs to the objects coupled to one or more of the scalable plurality of outputs, in accordance with a user defined media processing project, wherein the software enabled, matrix switch is configured to be incorporated in a filter graph comprising multiple software objects that are coupled together via virtual pins.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A media processing system comprising:
<claim-text>one or more computer-readable media;</claim-text>
<claim-text>to one or more processors; and</claim-text>
<claim-text>computer-readable instructions on the one or more computer-readable media which, when executed by the one or more processors, cause the one or more processors to provide:
<claim-text>a source to provide media content; and</claim-text>
<claim-text>a software enabled, matrix switch filter, coupled to the source, to receive the media content on one or more of a scalable plurality of inputs and selectively route the content to object(s) coupled to one or more of a scalable plurality of output(s), to recursively transform the received content prior to rendering</claim-text>
<claim-text>a programming grid, automatically generated by the render engine, to define which of the scalable plurality of inputs are coupled to each of the scalable plurality of outputs during execution of the media processing project;</claim-text>
<claim-text>a render engine, exposing the source and the software enabled, matrix switch filter to higher-level applications, to enable a user to generate a media processing project, wherein the render engine automatically generates a filter graph reflecting a user-defined media processing project, wherein the filter graph includes multiple software objects that are coupled via virtual pins and wherein the software enabled, matrix switch comprises part of the filter graph.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A media processing system according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the render engine dynamically generates the programming grid to control the software enabled, matrix switch filter to recursively route media content through one or more of the multiple software objects coupled to the scalable plurality of output(s) in accordance with the user-defined media processing project.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A storage medium comprising a plurality of executable instructions which, when executed, implement a software enabled matrix switch in a media processing system to recursively route media content from one or more of a scalable plurality of inputs through media processing objects coupled to one or more of a scalable plurality of outputs, in accordance with a user defined media processing project, wherein the matrix switch includes a programming grid, dynamically generated to selectively couple one or more of the scalable plurality of inputs to one or more of the scalable plurality of outputs to recursively process media content through one or more media processing software objects coupled to the outputs, in accordance with the user-defined media processing project, wherein the one or more media processing software objects are coupled into a filter graph using virtual pins.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A storage medium according to <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein modifications to the user-defined media processing project are dynamically reflected in an updated version of the programming grid in the matrix switch, eliminating the need to tear down and reconstitute an entire filter graph to effect the modification.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A computing system implementing a media processing system, the computing system comprising:
<claim-text>one or more computer-readable media;</claim-text>
<claim-text>one or more processors; and</claim-text>
<claim-text>computer-readable instructions on the one or more computer-readable media which, when executed by the one or more processors, cause the one or more processors to provide:</claim-text>
<claim-text>a media content source; and</claim-text>
<claim-text>a render engine, coupled to the media content source, to generate a filter graph of media processing software objects including a matrix switch filter to recursively process media content through the media processing software objects in accordance with a user-defined media processing project, wherein the render engine dynamically generates a programming grid to control routing of media content through the matrix switch filter, and wherein the media processing software objects are coupled into the filter graph using virtual pins.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A computer-implemented method comprising:
<claim-text>implementing a software matrix switch for processing media content in accordance with a user-defined media processing project, the software matrix switch comprising:
<claim-text>a scalable plurality of inputs dynamically coupleable to select source(s) to receive media content; and</claim-text>
<claim-text>a scalable plurality of outputs dynamically coupleable to select object(s),</claim-text>
<claim-text>wherein said implementing comprises implementing the scalable plurality of inputs as software objects dedicated to communicating information from a software object to the software matrix switch and implementing the scalable plurality of outputs as software objects; and</claim-text>
<claim-text>wherein said implementing is performed, at least in part, by a render engine in a media processing filter graph that is configured to generate said matrix switch, and wherein the filter graph includes multiple software objects coupled together via virtual pins; processing the media content by;</claim-text>
<claim-text>dynamically coupling one or more of the inputs to one or more of the sources to receive the media content; and</claim-text>
<claim-text>dynamically coupling one or more of the outputs to the select object(s) to recursively route media content through the select software object(s) to manipulate the received media content in accordance with the user-defined media processing project;</claim-text>
<claim-text>generating a programming grid to control routing of the media content from the scalable plurality of inputs to the scalable plurality of outputs.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> further comprising dynamically updating the programming grid responsive to modifications to the user-defined media processing project without tearing down and reconstituting an entire filter graph to effect the modifications.</claim-text>
</claim>
</claims>
</us-patent-grant>
