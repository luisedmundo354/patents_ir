<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299466-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299466</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10251019</doc-number>
<date>20020919</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>651</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>46</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>50</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>16</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>718102</main-classification>
<further-classification>709201</further-classification>
<further-classification>718104</further-classification>
<further-classification>718106</further-classification>
</classification-national>
<invention-title id="d0e53">Mechanism for managing execution environments for aggregated processes</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4825354</doc-number>
<kind>A</kind>
<name>Agrawal et al.</name>
<date>19890400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707 10</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5319758</doc-number>
<kind>A</kind>
<name>Arai et al.</name>
<date>19940600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5806076</doc-number>
<kind>A</kind>
<name>Ngai et al.</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5903891</doc-number>
<kind>A</kind>
<name>Chen et al.</name>
<date>19990500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5999911</doc-number>
<kind>A</kind>
<name>Berg et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6006264</doc-number>
<kind>A</kind>
<name>Colby et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6044394</doc-number>
<kind>A</kind>
<name>Cadden et al.</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718107</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6182158</doc-number>
<kind>B1</kind>
<name>Kougiouris et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719328</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6247041</doc-number>
<kind>B1</kind>
<name>Krueger et al.</name>
<date>20010600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718104</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6282697</doc-number>
<kind>B1</kind>
<name>Fables et al.</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717107</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6418484</doc-number>
<kind>B1</kind>
<name>Radia</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719316</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6463527</doc-number>
<kind>B1</kind>
<name>Vishkin</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6574628</doc-number>
<kind>B1</kind>
<name>Kahn et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707 10</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6601057</doc-number>
<kind>B1</kind>
<name>Underwood et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  1</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6606742</doc-number>
<kind>B1</kind>
<name>Orton et al.</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717140</main-classification></classification-national>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>6647408</doc-number>
<kind>B1</kind>
<name>Ricart et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718105</main-classification></classification-national>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>6651047</doc-number>
<kind>B1</kind>
<name>Weschler</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>6684261</doc-number>
<kind>B1</kind>
<name>Orton et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719328</main-classification></classification-national>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>6687735</doc-number>
<kind>B1</kind>
<name>Logston et al.</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719328</main-classification></classification-national>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>6704806</doc-number>
<kind>B1</kind>
<name>Decker</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>6807572</doc-number>
<kind>B1</kind>
<name>Yu</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>6912719</doc-number>
<kind>B2</kind>
<name>Elderon et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>6996829</doc-number>
<kind>B2</kind>
<name>Meyer</name>
<date>20060200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719328</main-classification></classification-national>
</citation>
<citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2001/0039542</doc-number>
<kind>A1</kind>
<name>Okada et al.</name>
<date>20011100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</citation>
<citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2004/0205124</doc-number>
<kind>A1</kind>
<name>Limprecht et al.</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709204</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00026">
<othercit>Richard V. Dragan, “Sun ONE Grid Engine, Enterprise Edition Software,” Oct. 1, 2002, 3 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00027">
<othercit>Sun Microsystems, “SUN[tm] ONE Grid Engine, Enterprise Edition,” sun.com, 1994-2002, 2 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00028">
<othercit>Sun Microsystems, “SUN[tm] ONE Grid Engine 5.3,” sun.com, 1994-2002, 2 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00029">
<othercit>Reg Quinton, “How to write a Makefile,” date unknown, 7 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00030">
<othercit>Jeff Bailey, “GNU make,” Dec. 25, 2002, pp. 1-201.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00031">
<othercit>Platform Computing Corporation, “LSF Parallel User's Guide, Version 4.1,” Third Edition, Dec. 2000, 68 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00032">
<othercit>Platform Computing Corporation, “LSF Programmer's Guide, Version 4.1,” Fifth Edition, Dec. 2000, 156 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00033">
<othercit>Platform Computing Corporation, “LSF JobScheduler User's Guide,” Fourth Edition, Jan. 2000, 149 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00034">
<othercit>NPi Inc., “DRM Reference Model Document, Overview—Draft V 1.0,” Jul. 2001, 99 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00035">
<othercit>U.S. Appl. No. 09/574,334, filed May 19, 2000, entitled “Interaction Protocol for Managing Cross Company Processes Among Network-Distributed Applications”, applicants: Lakshmi Ankireddipally and Ryh-Wei Yeh.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00036">
<othercit>U.S. Appl. No. 09/574,335, filed May 19, 2000, entitled “Transaction Data Structure for Process Communications Among Network-Distributed Applications”, applicants: Lakshmi Ankireddipally, Ryh-Wei Yeh, Dan Nichols and Ravi Devesetti.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00037">
<othercit>U.S. Appl. No. 09/850,521, filed May 4, 2001, entitled “Distributed Transaction Processing System”, applicants: Lakshmi Ankireddipally, Ryh-Wei Yeh, Dan Nichols and Ravi Devesetti.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>43</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>718100-108</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718  1</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>719310-332</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709200-253</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>9</number-of-drawing-sheets>
<number-of-figures>9</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60342630</doc-number>
<kind>00</kind>
<date>20011220</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030120701</doc-number>
<kind>A1</kind>
<date>20030626</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Pulsipher</last-name>
<first-name>Darren</first-name>
<address>
<city>Tracy</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Hannaford</last-name>
<first-name>Nancy</first-name>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Truong</last-name>
<first-name>Bobby K.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Hickman Palermo Truong &amp; Becker LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Cadence Design Systems, Inc.</orgname>
<role>02</role>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Bullock, Jr.</last-name>
<first-name>Lewis A.</first-name>
<department>2195</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Workspace definitions, which define an execution environment, can be associated with jobs. A work request is processed to automatically determine that tasks that are progeny of a given job inherit the association with the workspace definition, and therefore, that the tasks should be executed using the execution environment defined in the workspace definition. However, different execution environments can be defined for progeny of a given parent job, essentially overriding the inheritance from the parent job. According to an embodiment, a set of resources associated with an execution environment is configured such that the resources are accessible by two or more computers of a group of networked computers, such as a server farm, without requiring configuring duplicate sets of the resources. Furthermore, in a server farm computing environment, an execution environment associated with one or more jobs is not reliant on being created on any given computer of the server farm.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="176.19mm" wi="150.37mm" file="US07299466-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="238.25mm" wi="164.59mm" orientation="landscape" file="US07299466-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="173.23mm" wi="100.84mm" orientation="landscape" file="US07299466-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="217.93mm" wi="141.48mm" orientation="landscape" file="US07299466-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="132.50mm" wi="143.34mm" file="US07299466-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="241.13mm" wi="164.25mm" file="US07299466-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="231.99mm" wi="166.71mm" file="US07299466-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="213.53mm" wi="175.51mm" file="US07299466-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="189.57mm" wi="153.08mm" file="US07299466-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="252.39mm" wi="166.29mm" orientation="landscape" file="US07299466-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims the benefit of priority to U.S. Provisional Patent Application No. 60/342,630 entitled “Server Farm Management Mechanism”, filed Dec. 20, 2001; and is related to U.S. patent application Ser. No. 10/247,970 now U.S. Pat. No. 7,159,217 entitled “Mechanism For Managing Parallel Execution Of Processes In A Distributed Computing Environment”, filed on Sep. 19, 2002; U.S. patent application Ser. No. 10/251,230 now U.S. Pat. No. 7,117,500 entitled “Mechanism For Managing Execution Of Interdependent Aggregated Processes”, filed on Sep. 19, 2002; and U.S. patent application Ser. No. 10/251,747 now U.S. Pat. No. 7,093,259 entitled “Hierarchically Structured Logging For Computer Work Processing”, filed on Sep. 19, 2002; all of which are incorporated by reference in their entirety for all purposes, as if fully set forth herein.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates generally to distributed computing and, more specifically, to a mechanism for managing execution environments for aggregated processes.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">A server farm can be defined generally as a group of networked servers or, alternatively, a networked multi-processor computing environment in which work is distributed between multiple processors. A server farm provides for more efficient processing by distributing the workload between individual components or processors of the farm and expedites execution of computing processes by utilizing the power of multiple processors. The networked servers constituent to a server farm are typically housed in a single location, however, they can be geographically dispersed such as in grid computing, which can be thought of as distributed and large-scale cluster computing and as a form of network-distributed parallel processing. Grid computing can be confined to a network of computer workstations within a company or it can be a public collaboration sometimes referred to as a form of peer-to-peer computing.</p>
<p id="p-0005" num="0004">Often, a server farm environment includes many different classes of resources, machine types and architectures, operating systems, storage facilities and specialized hardware. Server farms are typically coupled with a layer of load-balancing software to perform numerous tasks, such as tracking processing demand, selecting machines on which to run a given task or process, and prioritizing and scheduling tasks for execution. Other terms used for load-balancing include load sharing and distributed resource management (DRM). In general, DRM applications are used to manage the resources associated with a server farm. One example of a commercially available distributed resource management application is Platform LSF 5 available from Platform Computing Inc.</p>
<p id="p-0006" num="0005">Combining the processing power of servers into a single computing entity has been relatively common for years in the areas of research and academia. However, companies are increasingly utilizing server farms to efficiently perform the vast amount of task and service computing that they encounter in their respective businesses. For example, development of large-scale software platforms can benefit from use of networked multi-processor computing for repetitive processes associated with compiling, releasing and testing of software code.</p>
<p id="p-0007" num="0006">Prior approaches to using a server farm for compute-intensive software development tasks operate by executing many small programs, or scripts, to perform numerous functions, including the following: (1) establish run-time environments for executable task commands; (2) execute task commands to perform actual work, such as compile, release and test; (3) coordinate the execution and interdependencies of various task commands (e.g., high-level processes to coordinate low-level processes); and (4) generate reports regarding the execution of the task commands. Jobs typically implement the myriad of interwoven tasks/processes that perform the work. Often, developers within a working group of a company might create scripts for performing desired functions which are specifically tailored to group-specific operations, goals, computing platforms, etc. In practice, the processes that the developers use to complete their work functions are often not written down and much of the operational set-up involves manual processes.</p>
<p id="p-0008" num="0007">Additionally, different working groups within a single company, and even within a single company location, often procure, maintain and administer their respective computing environments and platforms separately and independently from other groups within the company. In such a scenario, a machine going off-line can result in having to modify many scripts that were tailored to that machine, platform, or environment. Not only does this manner of operating contribute to a waste of resources, such as unused processor capacity, but also the task of managing the large number of scripts and the computing resources on which the scripts run becomes a non-trivial, highly complex effort.</p>
<p id="p-0009" num="0008">Based on the foregoing, it is clearly desirable to provide a mechanism for managing the parallel execution of processes, including interdependent processes, in a networked multi-processor computing environment. Furthermore, it is clearly desirable to provide a mechanism for managing runtime execution environments for processes executing in a multi-processor computing environment. There are more specific needs associated with the foregoing needs, which include formalizing processes with respect to executing work across multiple processors whereby the type of platform on which the work runs is transparent to a user, and for providing a common control and management layer on which users can define and run their work.</p>
<p id="p-0010" num="0009">Computing platforms typically generate log files detailing various runtime and termination statistics associated with the execution of a command, task, job, process, or the like. Historically, a single log file (e.g., a “flat file”) is generated for a grouping of executable tasks, jobs, etc., that are run together as a unit of work on a computer or a networked multi-processor computing environment. In the context of complex, interdependent software development tasks running together as a unit of work, the number of different tasks that perform the work can be enormous. Since runtime and termination statistics are usually generated for each executable unit of work, a corresponding log file can likewise be enormous. Consequently, such a log file is not easy to analyze and to glean information from. Analysis of a very large log file (possibly thousands of lines of text) typically requires manual parsing or filtering or the like, to find the relevant information of interest to a user. Such a manual process is not an efficient use of time and resources.</p>
<p id="p-0011" num="0010">Hence, based on the foregoing, there is a clear need for a mechanism for providing log information related to processing in a more orderly and useful manner than in prior approaches. A more specific need exists for providing a logging mechanism that overcomes the shortcomings associated with prior approaches by facilitating rapidly locating information of interest.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011">The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram generally illustrating an environment in which embodiments of the invention may be implemented;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating states in which work can exist;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram graphically illustrating the timing of events with respect to a typical software Build and Release cycle;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating a first process for managing execution of work;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart illustrating a second process for managing execution of work;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating a third process for managing execution of work;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating a process for processing a work request;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram illustrating an operating configuration of a work control and management layer; and</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram that illustrates a computer system <b>900</b> upon which embodiments of the invention may be implemented.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0022" num="0021">A mechanism for managing execution environments for aggregated computing processes is described herein. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.</p>
<heading id="h-0006" level="1">Overview</heading>
<p id="p-0023" num="0022">According to one aspect, workspace definitions, which define an execution environment, can be associated with jobs. A work request is processed to automatically determine that tasks that are progeny of a given job inherit the association with the workspace definition, and therefore, that the tasks should be executed using the execution environment defined in the workspace definition. However, different execution environments can be defined for progeny of a given parent job, essentially overriding the inheritance from the parent job.</p>
<p id="p-0024" num="0023">In an embodiment, the execution environment is automatically purged from the one or more computers on which it was created, after execution of the relevant tasks. Thus, computing resources associated with the environment are available for other tasks or services.</p>
<p id="p-0025" num="0024">According to embodiments, causing an execution environment to be created can include, but is not limited to, causing software applications to be installed, such as a distributed resource management application; causing directories to be created for storage of information associated with execution of the task; populating directories with files; causing sets of data to be stored; and causing configuration parameters to be set, such as for hardware or software.</p>
<p id="p-0026" num="0025">According to an embodiment, a set of resources associated with an execution environment is configured such that the resources are accessible by two or more computers of a group of networked computers, such as a server farm, without requiring configuring duplicate sets of the resources. Furthermore, in a server farm computing environment, an execution environment associated with one or more jobs is not reliant on being created on any given computer of the server farm.</p>
<heading id="h-0007" level="1">Job Request Language</heading>
<p id="p-0027" num="0026">In an implementation of many of the processes disclosed herein, a Job Request (JR) language, in conjunction with a control and management layer (sometimes referred to as the “gridMatrix”), provides a common language and mechanism for managing the execution of work in a networked multi-processor computing environment in which work is distributed among multiple processors (referred to herein as a server farm). Users of a server farm, for example without limitation, software developers who use the server farm to compile, release and test their software code, define the work that they want performed on the server farm by creating JR files.</p>
<p id="p-0028" num="0027">The JR language enables users to define and automate repetitive processes, among other benefits. The gridMatrix serves the purpose of managing execution of work on a server farm by, for example without limitation, interpreting JR language work requests, instantiating distributed objects, invoking software servers to manage execution of commands, and interfacing with distributed resource management applications (possibly third party applications).</p>
<p id="p-0029" num="0028">Capabilities provided by a system that employs JR language work requests with the work control and management layer (see <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref>) described below, include but are not limited to, the following: (1) reduced cycle times with respect to performing the work, in part due to the formalization of processes with respect to submitting large complex jobs to server farms; and (2) lower support costs with respect to the server farm resources, in part due to the common work control and management layer used to interact with a distributed resource management application (see DRM <b>106</b> of <figref idref="DRAWINGS">FIG. 1</figref>) that submits jobs to a server farm.</p>
<p id="p-0030" num="0029">An artifact is a piece of data that is used, generated or discarded while working with a server farm. Four basic types of artifacts are utilized in the mechanisms described herein: work, jobs, tasks and workspaces.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram generally illustrating an environment <b>100</b> in which embodiments of the invention may be implemented. The environment <b>100</b> includes a workstation <b>101</b>, from which a user can create and submit one or more input files <b>102</b>, for example, JR files, that define a work request that specifies one or more jobs that each includes a set of one or more executable task commands. The workstation <b>101</b> is any conventional computing device, for example, the computer system <b>600</b> of <figref idref="DRAWINGS">FIG. 6</figref>. The input file <b>102</b> is submitted to a work control and management layer <b>104</b> (referred to at times herein as the management layer <b>104</b>) for, generally, interpretation, processing, control and management of the work request and its constituent jobs and tasks, as well as installation and configuration of any resources specified in a workspace definition that may be included in the input file <b>102</b>.</p>
<p id="p-0032" num="0031">The work control and management layer <b>104</b>, for example, the gridMatrix, which contributes to implementation of a number of the embodiments and features described herein, performs some of its functions (described below) before submitting commands and data to a distributed resource management application <b>106</b>. The commands and data correspond to the work that is defined in the input file <b>102</b>. Thus, the management layer <b>104</b> interprets and acts upon the input file <b>102</b> and causes the distributed resource management application to execute task commands on a server farm <b>108</b>, i.e., a networked multi-processor distributed computing environment.</p>
<p id="p-0033" num="0032">Furthermore, the environment <b>100</b> includes a database <b>110</b>, for storing information related to many of the processes described herein. For example, in one embodiment, task commands constituent to a piece of work are essentially instantiated into computing objects (as in object-oriented programming), which are maintained persistently in the database <b>110</b>, as described below. Hierarchical log files <b>112</b>, described below, are also stored in the database <b>110</b> for access by workstation <b>101</b>. <figref idref="DRAWINGS">FIG. 1</figref> is a general illustration used for an example, however, use of the invention is not limited to use in an environment as depicted in <figref idref="DRAWINGS">FIG. 1</figref>. Additionally, the management layer <b>104</b> may reside on a management server (not shown) or on workstation <b>101</b>. The workstation <b>101</b>, database <b>110</b>, and a management server, if any, may be connected to a local network for communication therebetween.</p>
<heading id="h-0008" level="1">Work</heading>
<p id="p-0034" num="0033">Work, and constituent jobs, can be defined with one or more JR files. The work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) interprets JR files and “compiles” them into objects, rather than machine code. The objects can actually execute on the server farm or invoke executables to be run on the server farm. Typically, the objects are passed through a distributed resource management (DRM) application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) that schedules and manages work to be run on the multiple processors of the server farm.</p>
<p id="p-0035" num="0034">Throughout this description, the term “work” is used to describe a top-level conglomeration of functions to be performed. Work is a generic term for anything that the work control and management layer <b>104</b> can control, execute, or cause to be executed. For example, work may include many processes required to compile (sometimes referred to as “build”) a software program or a portion of a software program. Work includes configuring and/or initializing any runtime environment resources, such as, for example, creating file directories and installing applications. Work also includes maintaining and applying dependencies among jobs and sub-works, which are jobs or tasks that are aggregated under a job. Work is not limited to any specific tasks or functions, but can encompass whatever a user needs to be performed or processed to attain a goal. Two general types of work are defined, which are also referred to as sub-works: jobs and tasks.</p>
<p id="p-0036" num="0035">Work has states in the work control and management layer <b>104</b>. Each state of work determines the behavior of the work and limits the subsequent states to which the work can transition. States can be indicated with different colors on a user interface.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating states in which work can exist. When work is first created, it is in the created state <b>202</b>. Created state <b>202</b> is the starting state for all work. Work moves from created state <b>202</b> to scheduled state <b>204</b> when it is scheduled for execution. For example, work is scheduled by distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) for execution on server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Furthermore, if the work is a sub-work, that is, if the work has a parent artifact such as a job or sub-job, then the work may be scheduled by its parent artifact. The scheduled state <b>204</b> denotes that the work has been scheduled, but it has not yet been sent to the server farm for execution.</p>
<p id="p-0038" num="0037">The pending state <b>206</b> denotes that the work has not yet met the criteria to actually execute. When work meets the criteria for executing, and thus leaving the pending state <b>206</b>, work moves into the active state <b>208</b>. The criteria for each type of work can vary, as described below in reference to jobs and tasks. The criteria that allow work to transition from a pending state <b>206</b> to an active state <b>208</b> may include, for example without limitation: completion of an interdependent work, job or task; termination of an interdependent work, job or task in a particular termination state; and creation of a runtime environment for the work.</p>
<p id="p-0039" num="0038">Work that completes its activity without warning, error or termination, transitions from the active state <b>208</b> to the completed state <b>210</b>. This state is also known as the successfully completed state. The activities for each specific type of work can vary, as described below in reference to jobs and tasks.</p>
<p id="p-0040" num="0039">Work that completes execution with some warning, but no error or premature termination, transitions from the active state <b>208</b> to a warning state <b>213</b>. Work that completes execution with some error, but does not terminate prematurely, transitions from the active state <b>208</b> to an error state <b>209</b>. The conditions for completion of work with warnings and/or errors is specific to the type of work and, thus, can vary, as described below in reference to jobs and tasks.</p>
<p id="p-0041" num="0040">Work that is terminated properly, using a command, after the created state <b>202</b> but before entering a finished state such as completed state <b>210</b>, warning state <b>213</b> and error state <b>209</b>, is set to the killed state <b>211</b>. The actions and conditions for a killed state <b>211</b> are also specific to different types of work, as described below in reference to jobs and tasks. Finally, work can be set to a suspended state <b>207</b> when it is in the pending state <b>206</b> or the active state <b>208</b>. The work can be suspended using a specific suspend command, and can be moved back into the pending state <b>206</b> using a specific resume command. The management layer <b>104</b> can then determine whether criteria have been met to move the work into an active state <b>208</b>.</p>
<heading id="h-0009" level="1">Jobs</heading>
<p id="p-0042" num="0041">A job is a type of work that can be executed, controlled and reported by the management layer <b>104</b>. More specifically, a job is an aggregation of jobs (sometimes referred to as sub-jobs if they are a child of a parent job) or executable tasks, i.e., task commands.</p>
<p id="p-0043" num="0042">Jobs are a fundamental mechanism for grouping work to be performed on a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Grouping jobs and tasks improves the overall performance of distributed resource managers, such as distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>), and the work performed on the server farm <b>108</b>. Jobs can have dependencies, on another job or a sub-job, as specified in a job definition of the work request, for example, in an input file <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Job dependencies contribute to a determination of an order in which jobs are executed on the server farm <b>108</b>, under the control of the management application <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>), described in more detail below.</p>
<p id="p-0044" num="0043">Jobs can have zero or more sub-works, which can be a task or another job (i.e., sub-job). Layering of jobs, akin to relating the jobs hierarchically, provides the ability to define complex, multi-leveled procedures. For example, a typical software Build and Release cycle is as follows:</p>
<p id="p-0045" num="0044">1. Gather Code
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0045">A. Merge code from development branches</li>
        <li id="ul0002-0002" num="0046">B. Download appropriate .tar (tape archive) files for third-party libraries for building code</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0046" num="0047">2. Build Product
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0048">A. Build third part dependencies
        <ul id="ul0005" list-style="none">
            <li id="ul0005-0001" num="0049">i. Third party tool <b>1</b></li>
            <li id="ul0005-0002" num="0050">Ii. Third party tool <b>2</b></li>
        </ul>
        </li>
        <li id="ul0004-0002" num="0051">B. Build component <b>1</b></li>
        <li id="ul0004-0003" num="0052">C. Build component <b>2</b></li>
        <li id="ul0004-0004" num="0053">D. Build component <b>3</b></li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0047" num="0054">3. Test product
<ul id="ul0006" list-style="none">
    <li id="ul0006-0001" num="0000">
    <ul id="ul0007" list-style="none">
        <li id="ul0007-0001" num="0055">A. Test components
        <ul id="ul0008" list-style="none">
            <li id="ul0008-0001" num="0056">i. Test component <b>1</b></li>
            <li id="ul0008-0002" num="0057">ii. Test component <b>2</b></li>
            <li id="ul0008-0003" num="0058">iii. Test component <b>3</b></li>
        </ul>
        </li>
        <li id="ul0007-0002" num="0059">B. Test system integration</li>
        <li id="ul0007-0003" num="0060">C. Test system flows
        <ul id="ul0009" list-style="none">
            <li id="ul0009-0001" num="0061">i. Run system flow test suite <b>1</b></li>
            <li id="ul0009-0002" num="0062">ii. Run system flow test suite <b>2</b></li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0048" num="0063">4. Package product
<ul id="ul0010" list-style="none">
    <li id="ul0010-0001" num="0000">
    <ul id="ul0011" list-style="none">
        <li id="ul0011-0001" num="0064">A. Gather third party deliverables</li>
        <li id="ul0011-0002" num="0065">B. Gather product binaries</li>
        <li id="ul0011-0003" num="0066">C. Create installation staging area</li>
        <li id="ul0011-0004" num="0067">D. Create tar file with installation</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0049" num="0068">The preceding example illustrates up to three levels of aggregation for incorporation into an associated job definition or work request. A user can submit one job with the job aggregation illustrated above included in the job definition. For example, a JR file can be constructed such that a separate job is created for each work <b>1</b>-<b>4</b>, and a separate job is created for each sub-work of work <b>1</b>-<b>4</b>, respectively, down through the various layers of aggregation. The job definition is submitted as a work request and typically includes a master, or root, job.</p>
<p id="p-0050" num="0069">In one embodiment, all jobs defined under a work request are inherently run in parallel. That is, the default order of execution of jobs on the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) is to execute them concurrently. For example, if no dependencies between jobs are defined, then implicitly each job defined for each sub-work above would be run concurrently. However, running all jobs concurrently is not always sensible. For example, the code cannot be built until it is gathered, the code cannot be tested until it is built, and the product cannot be packaged until it is tested.</p>
<p id="p-0051" num="0070">Therefore, in one embodiment, dependencies between jobs can be defined. For example, the input file <b>102</b> (e.g., a JR file) can be constructed to specify one or more dependencies among jobs in the set of jobs defined therein. Furthermore, these dependencies are interpreted by the management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>), and are used to manage the order of execution of the jobs and their constituent executable tasks. A job with a dependency does not execute until all of its dependencies are satisfied. A dependency may be based simply on completion of a dependent job or task, on termination of a dependent job or task, or on a specific termination state of a dependent job or task (e.g., warning state <b>213</b>, error state <b>209</b>, killed state <b>211</b>).</p>
<p id="p-0052" num="0071">In prior approaches to software programming that utilize dependencies between executable files or modules of code, execution of a second job on which a first job is dependent is typically initiated by the first job. Thus, each instance that the first job is encountered during processing of the work triggers execution of the first job's dependents, that is, the second job in this example. In the meantime, the first job is sitting idle waiting for termination of the second job, all the while using system resources.</p>
<p id="p-0053" num="0072">According to an embodiment of the invention, the first job does not trigger execution of the second job, on which the first job is dependent. Significantly, the second job is triggered by the normal operation of the management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>), which sends jobs to the DRM application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) according to the work structure specified in the work request, with respect to both the job aggregation structure and the structure of dependencies between jobs. Upon interpretation of a work request, the management layer <b>104</b> establishes a data observer relationship between the second and second jobs, whereby the second job (as a “publisher”) is directed to announce its termination state to the first job (as an “observer”), and to any other jobs that depend on the second job. Thus, the first job does not become active until the second job notifies it that it has finished executing, that is, that the tasks and sub-works of the second job have finished executing. Consequently, the first job does not initiate and then sit idle, wasting resources of the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>).</p>
<p id="p-0054" num="0073">Additional beneficial consequences derive from the communication between interdependent jobs described above. For example, the embodiment described provides the ability to have a first job be conditionally dependent on a second job or on a third job, via a conditional OR dependency. Consequently, complex and alternative process flows can be defined. In addition, the second and third jobs do not both have to be initiated by the first job, whereby the first job would then wait for one of the second and third jobs to finish in the proper state, thereby unnecessarily using resources, as in prior approaches. Contrarily, in this embodiment, global resources are conserved for the following reasons. First, the first job does not initiate just to initiate the dependent jobs and then to sit idle. In fact, the first job may never initiate, and thus be cancelled, because the second and third jobs may never terminate with the proper state. Second, either one of the second and third jobs, for example the second job, is never run at all because the other job, i.e., the third job, finishes with the proper termination state on which the first job depends, before the second job is ever submitted for execution. The significance of this feature grows with multiple levels of dependencies between jobs and sub-jobs throughout the job aggregation structure.</p>
<p id="p-0055" num="0074">In an embodiment, a dependency between two jobs can be specified to resolution via a logical expression, where the logical expression has as operands the statuses of one or more other jobs. At a further point in the process, the logical expression is resolved using the statuses of the other jobs to determine whether the dependency is met. When the dependency is met, the dependent job is placed in an active state and its sub-works scheduled for execution. In related embodiments, the logical expression is an “OR” operation and is an “AND” operation.</p>
<p id="p-0056" num="0075">According to one embodiment, jobs are not passed to the distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) until all of its dependencies are met. Consequently, the DRM application <b>106</b> queue is reduced and a given job gets dispatched to the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) quicker and more efficiently. That is, the DRM application <b>106</b> is not now, as in the past, sending jobs to the server farm <b>108</b> to “sleep”, where they reside in one or more queues awaiting completion of a job or jobs on which they depend. Furthermore, since resource utilization measurements associated with some DRM applications <b>106</b> are based on the number of processes being managed and processed instead of CPU utilization, utilization of resources associated with operation of the DRM application <b>106</b> are minimized through implementation of this embodiment.</p>
<p id="p-0057" num="0076">Aggregation of jobs facilitates the propagation of workspaces (described below) and variables from parent jobs to their progeny jobs, as well as the propagation of statistics and states (described below) from progeny tasks and jobs to their ancestor jobs. An example of statistics that can propagate through the job aggregation structure includes task runtime statistics such as CPU time, memory usage, DRM queue utilization, disk space used, and disk I/O operations. Such statistics provide valuable information with respect to planning and managing resources associated with a server farm.</p>
<p id="p-0058" num="0077">The state diagram of <figref idref="DRAWINGS">FIG. 2</figref> is applicable to jobs as well as to work, with additional commentary to follow.</p>
<p id="p-0059" num="0078">In one embodiment, all jobs begin in the created state <b>202</b>, which is the same as the standard work created state. A job is moved to the scheduled state <b>204</b> from the created state <b>202</b> when the parent job schedules the job. If the given job is the master (i.e., top-level) job, then it is scheduled by the management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) when the job is submitted to the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) to be run.</p>
<p id="p-0060" num="0079">A job is moved to a pending state <b>206</b> from the scheduled state <b>204</b> when the parent job executes the job. All jobs pass through the pending state <b>206</b> at some point before actually performing work. Furthermore, a job remains in a pending state <b>206</b> until all of its dependencies have been satisfied. A job can move to a pending state <b>206</b> from a suspended state <b>207</b> when a user issues a resume command.</p>
<p id="p-0061" num="0080">A job is moved to an active state <b>208</b> from the pending state <b>206</b> when all of the dependencies of the job are satisfied. In one embodiment, when a job finishes it sends a message to the job or jobs that depend on it. This message indicates whether the job reached the completed state <b>210</b> or some other non-completed, termination state (e.g., warning state <b>213</b>, error state <b>209</b>, killed state <b>211</b>). Once a dependent job receives a message from a job on which it is dependent, the management layer <b>104</b> checks the dependency criteria for all of the jobs on which the dependent job is dependent. If all of the dependency criteria are satisfied, then the dependent job can move into the active state <b>208</b>.</p>
<p id="p-0062" num="0081">When a job is moved to the active state <b>208</b>, all of its sub-works are moved to the scheduled state <b>204</b>. Similarly, sub-works of a given job do not get scheduled, i.e., move to a scheduled state <b>204</b>, until their parent jobs are in the active state <b>208</b>. The management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) will then cause the execution of all of the sub-works of the job, thus moving the sub-works into an active state <b>208</b>. The propagation of state continues, which can be envisioned as continuing out to the leaf nodes of a hierarchical job aggregation tree.</p>
<p id="p-0063" num="0082">A job is moved to a completed state <b>210</b> from an active state <b>208</b> when all of its sub-works have been moved to a completed state <b>210</b>. In one embodiment, when a sub-work finishes executing, it notifies its parent job that it has finished. Then, the parent job checks the status of all of its sub-works to determine whether all of the sub-works are in the completed state <b>210</b>. If all pertinent sub-works are in the completed state <b>210</b>, then and only then, will the parent job also move to the completed state <b>210</b>. After the parent job is moved to the completed state <b>210</b>, it notifies its parent, if any, that it has finished. Hence, not only is state (e.g., the active state <b>208</b>) propagated down the aggregated job structure from parent jobs to progeny jobs (i.e., sub-works), but state (e.g., the completed state <b>210</b>) is also propagated up the aggregated job structure from sub-works to parent jobs (i.e., ancestors).</p>
<p id="p-0064" num="0083">A job is moved to the warning state <b>213</b> or the error state <b>209</b> from the active state <b>208</b> when, and only when, all of its sub-works are in a finished state, such as completed state <b>210</b>, warning state <b>213</b> and error state <b>209</b>, with one or more sub-works being in the warning state <b>213</b> or error state <b>209</b>, respectively. Once a job is set to the warning state <b>213</b> or the error state <b>209</b>, it notifies its parent job, if any, that it has finished, which propagates up the aggregated job structure to the master job.</p>
<p id="p-0065" num="0084">A job transitions from a previous non-finished state to the killed state <b>211</b> upon issuance of a specific kill command. A user can specify any job or task when killing a job. Once a job is moved to the killed state <b>211</b>, it sets the state of all of its sub-works that are not finished to the killed state <b>211</b>. Hence, the killed state <b>211</b> is propagated down the aggregated job structure to the leaf nodes. Furthermore, the killed state <b>211</b> propagates up the aggregated job structure toward the master job, similar to the other finished states (i.e., completed state <b>210</b>, error state <b>209</b> and warning state <b>213</b>). After a job moves its sub-works to the killed state <b>211</b>, it notifies its parent that it has finished. The parent job will only change its own state to the killed state <b>211</b> when all of its children are in a finished state or killed state <b>211</b>.</p>
<p id="p-0066" num="0085">A job transitions from the pending state <b>206</b> or the active state <b>208</b> to the suspended state <b>207</b> upon issuance of a specific suspend command. The suspended job sets the state of all of its sub-works to the suspended state <b>207</b> if they are in the pending state <b>206</b> or active state <b>208</b>. The suspended state <b>207</b> is propagated down the aggregated job structure to the leaf nodes, setting all of the pertinent sub-works to a suspended state <b>207</b>. A specific resume command can be issued to move a job from a suspended state <b>207</b> to a pending state <b>206</b>. Each sub-work of the resumed job is set to the pending state <b>206</b>, not the active state <b>208</b>, if the sub-work was in a suspended state <b>207</b>. The work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) verifies whether, and when, the sub-works can be moved to the active state <b>208</b>.</p>
<p id="p-0067" num="0086"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram graphically illustrating the timing of events with respect to the typical software Build and Release cycle presented above. As depicted in <figref idref="DRAWINGS">FIG. 3</figref>, jobs aggregated or grouped under a given job (for example, 1.3.1.1, 1.3.1.2 and 1.3.1.3 being aggregated under 1.3.1, and 1.3.1, 1.3.2 and 1.3.3 being aggregated under 1.3) are essentially started when their parent job starts, possibly with a slight delay for processing, and are executed concurrently. Furthermore, a job with a dependency on another job (for example, 1.2 BuildProduct is dependent on 1.1 GatherCode, and 1.4 PackageProduct is dependent on 1.3 TestProduct) does not start until its interdependent job finishes. Thus, 1.2 starts after 1.1 finishes, 1.3 starts after 1.2 finishes, and 1.4 starts after 1.3 finishes.</p>
<p id="p-0068" num="0087">In addition to the states depicted in <figref idref="DRAWINGS">FIG. 2</figref>, jobs can also be in a cancelled state. A job is moved to a cancelled state from the pending state <b>206</b> when a dependency condition fails to be met. A dependency condition fails when a respective interdependent job moves to one of the terminal states and does not meet the status, or dependency criteria, associated with the respective dependency and specified in a status condition statement of a work request. For example, a Job A may be dependent on a Job B terminating in a warning state. If Job B terminates in an error state instead of the warning state, the dependency criterion is not met. Hence, Job A is moved to a cancelled state.</p>
<p id="p-0069" num="0088">The functionality of the work control and management layer <b>104</b> provides and enforces structure upon the states and execution of jobs and their constituent tasks. To that end, certain constraints and/or rules are inherent to various embodiments. For example, (1) sub-works do not get scheduled until their respective parent job is in an active state; (2) all jobs pass through a pending state before moving to an active state; (3) a job with a dependency is maintained in the pending state until its dependent jobs reach the completed state; and (4) jobs do not reach the completed state until all of their children jobs (i.e., sub-jobs) are in the completed state.</p>
<heading id="h-0010" level="1">Tasks</heading>
<p id="p-0070" num="0089">A task is an atomic unit of work that is performed on a server farm. That is, a task is an executable command that is executed on one or more processors of a networked multi-processor computing environment. In one implementation, a task is represented as an attribute in a task object. Tasks are grouped together to form jobs, and tasks within a job are run sequentially. The results of a task are maintained in a log file according to a job hierarchy specified in an input file such as input file <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>), and are accessible via a network-based interface, such as an HTML page. Details of the logging function of the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) are described in more detail below. Like a job, a task is a type of work, which has states. Tasks are represented in a job definition, for example, in a JR file, similarly to how jobs are represented.</p>
<p id="p-0071" num="0090">The JR language provides the capability of defining jobs once and passing parameters to the job definitions, which are instantiated as job objects. The parameters are used to create commands that represent tasks that execute on a server farm. The commands that actually execute on the server farm are defined by name, with arguments passed in. Not only are executable task commands declared in a work request, but required directories, configuration management systems, and other environmental information are also specified in the work request. A concept of “workspaces” is used to refer to the specification and establishment of the directories, etc., that a task needs to execute. More details about workspaces are provided below.</p>
<p id="p-0072" num="0091">Tasks constituent to a given job are inherently run in a sequential order, as a default order of execution. On the other hand, jobs are inherently run in parallel. In one embodiment, a task of a given job does not start executing until all previous sub-works of the given job are completed. In this context, “previous” refers to a sub-work occurring in an input file sequentially before another sub-work. If a previous sub-work is a task, then the given task will not start executing until the previous task finishes. If a previous sub-work is a job, then the given task will not start executing until all previous jobs of the given job are finished.</p>
<p id="p-0073" num="0092">A user can group a number of tasks together in a job by defining the tasks sequentially in a work request, i.e., a JR or other input file <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Tasks grouped together in a job are inherently run in a sequential order, but are submitted to a distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) as a single job. Therefore, processing overhead associated with preparation and submission of a job to the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) by the distributed resource management application <b>106</b> is reduced in comparison with submitting each grouped task independently. Hence, resource usage of server farm <b>108</b> is optimized and the work is performed faster.</p>
<p id="p-0074" num="0093">The state diagram of <figref idref="DRAWINGS">FIG. 2</figref> is applicable to tasks as well as to jobs and work. The states of tasks are equivalent to the states described in reference to jobs, unless otherwise indicated in additional commentary below.</p>
<p id="p-0075" num="0094">A task is moved to the scheduled state <b>204</b> from the created state <b>202</b> when its parent job reaches the active state <b>208</b>. Only jobs in the scheduled state <b>204</b> can move to the pending state <b>206</b>. A task is moved to the pending state <b>206</b> from the scheduled state <b>204</b> when the task is submitted to a distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>). The task remains in the pending state <b>206</b> until the task actually starts executing on the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). The longer a task spends in the pending state <b>206</b>, the longer it remains in a queue of the distributed resource management application <b>104</b>, waiting to be distributed to a host machine of server farm <b>108</b>. If queue time is longer than desired, the queue definition can be adjusted and/or additional resources can be allocated.</p>
<p id="p-0076" num="0095">As stated, a task transitions to the active state <b>208</b> from the pending state <b>206</b> when the task actually starts executing on a host machine of server farm <b>108</b>. At this point in the process, an associated task object has additional information stored in its properties to identify the host machine on which it is running and to identify an associated distributed resource manager.</p>
<p id="p-0077" num="0096">A task transitions to the completed state <b>210</b> from the active state <b>208</b> when the corresponding task command finishes executing and exits with a successful termination status. Once a task is moved to the completed state <b>210</b>, it propagates its state up the job aggregation structure, indicating that it has completed executing. As described, a parent job will only change its own state to the completed state <b>210</b> when all of its children sub-works reach the completed state <b>210</b>.</p>
<p id="p-0078" num="0097">A task transitions to an error state <b>209</b> from the active state <b>208</b> when the corresponding task command finishes executing and exits with a failure. Once a task is moved to the error state <b>209</b>, it propagates its state up the job aggregation structure, indicating that it has finished executing but failed.</p>
<p id="p-0079" num="0098">A task transitions from a previous non-finished state to the killed state <b>211</b> upon issuance of a specific kill command. Once a task is moved to the killed state <b>211</b>, it stops all processes and sub-processes associated with the executing command. The killed state <b>211</b> is propagated down the aggregated job structure and up the aggregated job structure. After a task kills its processes, it notifies its parent that it has finished. The parent job will only change its own state to the killed state <b>211</b> when all of its children are in a finished state or killed state <b>211</b>. In addition, if a task reaches the suspended state <b>207</b>, the management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) suspends all processes for the command corresponding to the task. Furthermore, the management layer <b>104</b> sets a termination or exit status (e.g., completed, warning, or error) of a task when its corresponding task command finishes executing.</p>
<heading id="h-0011" level="1">Workspaces</heading>
<p id="p-0080" num="0099">Tasks are typically executed in some execution or surrounding runtime environment. The environment can include, for example without limitation, variables, configuration parameters, applications, a directory hierarchy, data files in a directory hierarchy, and a working directory.</p>
<p id="p-0081" num="0100">In one aspect of the invention, a user can define the execution environment with a concept referred to as workspace or workspace definition. Workspaces typically include resources and an associated configuration that get initialized prior to runtime. Workspaces that are defined in a work request are inherited throughout the aggregated job structure. In other words, a workspace defined for a given job is also used for the given job's progeny jobs, unless otherwise indicated. However, a different workspace can be defined in the work request and utilized for progeny jobs of a given job.</p>
<p id="p-0082" num="0101">Furthermore, a workspace can be created with no knowledge or dependency on the configuration of the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). This is in contrast with prior approaches to constructing environments in which to execute tasks, whereby, typically, scripts are run to construct the required runtime environment and the scripts are customized to a particular computing system, platform, configuration, etc. That is, prior approaches do not provide a global construct such as the workspace construct described herein, whereby runtime resources are configured and made available to multiple processes and multiple processors in a networked multi-processor computing environment. Also, multiple tasks can execute in a given workspace at the same time.</p>
<p id="p-0083" num="0102">Workspace creation is controlled and monitored by the management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>). For each workspace definition in the work request (e.g., an input file <b>102</b>, such as a JR file), a task is created and associated with the appropriate job for which the workspace is defined. Since workspace creation is a task, it has the attributes and follows the constraints described above for tasks, such as state and aggregation and dependency timing. Furthermore, after execution of the tasks within a given workspace, the resources associated with the given workspace are automatically deconfigured, or purged. That is, the resources are freed up for use by other jobs.</p>
<p id="p-0084" num="0103">A user may want to define a customized workspace if, for example without limitation, any of the following requirements are present: (1) a software application needs to be installed prior to task command execution; (2) multiple jobs consist of or rely on the same pre-execution tasks; (3) a configuration management system that requires unique set-up operations is used; and (4) a complex execution environment is required.</p>
<p id="p-0085" num="0104">Customized workspaces define what actions to take to construct an execution environment, often relative to each of multiple computing platforms. In an embodiment, a workspace definition includes a reference to an object class, which comprises functionality that is invoked to create an associated execution environment on one or more computers. Once instantiated, workspace objects are centrally and persistently stored, such as in the database <b>110</b> (<figref idref="DRAWINGS">FIG. 1</figref>), and made available to all of the server machines within the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Additionally, workspaces can be archived, they can be made to automatically destruct or deconfigure, and they can be accessed through a network interface. For example, a user can access the workspace (and other objects and software servers) through a network such as a LAN.</p>
<p id="p-0086" num="0105">A concept of variables can be utilized to define tokens that can be reused throughout a given job definition or work request, for various jobs. Furthermore, variables are inherited from parent jobs to associated sub-jobs. A workspace is a type of variable. A variable may have the same value throughout execution of the relevant jobs, that is, the values of variables can be passed from a parent job to its progeny. Alternatively, the value can be modified with respect to various sub-jobs. That is, a sub-job can override a variable value that was defined in its parent job.</p>
<heading id="h-0012" level="1">Persistent Distributed Object Architecture</heading>
<p id="p-0087" num="0106">The framework provided by the job request language in conjunction with the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) benefits from a mixed-platform inter-process communication methodology for running multiple jobs on a server farm and reporting the status of jobs to a central location. The status of the processes and jobs running on a server farm needs to be fault tolerant so that complex job definitions can be restarted if hardware fails. Hence, according to one aspect, a persistent distributed object architecture is used to satisfy the need for fault tolerance.</p>
<p id="p-0088" num="0107">The persistent distributed object architecture provides a platform-independent solution which decreases the complexity of an implementation of the system and methods described herein. Since the state of the objects which represent the processes running on a server farm are critical, the state of the objects in this framework are persistent, that is, they are stored in a non-volatile medium. Since process architecture within a server farm can change dependent on the size and type of server farm being employed, the inter-process communication utilized by the persistent distributed object architecture is independent of the process architecture of a given server farm.</p>
<p id="p-0089" num="0108">According to one embodiment, the Perl language is used to implement the persistent distributed object architecture. Since the objects are implemented in a distributed manner, the ability to communicate between objects that are not in the same execution process is provided by CORBA (Common Object Request Broker), according to one embodiment. CORBA essentially provides a software object bus for the inter-communication between objects underlying the system.</p>
<p id="p-0090" num="0109">Furthermore, in one embodiment, each object section is stored separately. That is, attributes, properties, variables and statistics are stored as files that contain a list of name-value pairs. The relationships between objects, such as the job aggregation relationships and the dependency relationships, are stored differently than the foregoing sections. Files are used to describe the relationships for respective objects, which contain a list of strings or EOIDs (Extended Object Identifier) that represent the relationships of a given object with one or more other objects. Each EOID uniquely identifies an object in the database. Thus, the persistent distributed object architecture can return an EOID for any object in memory and, likewise, and can create an object containing all of the object data, given an EOID.</p>
<p id="p-0091" num="0110">The persistent distributed object architecture uses a persistent object locator (POL) to readily locate objects, so that if a link between the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) or a job server <b>804</b> (<figref idref="DRAWINGS">FIG. 8</figref>) and the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) fails, a task can continue to execute on the server farm <b>108</b>. When each job server <b>804</b> or task server <b>806</b> (<figref idref="DRAWINGS">FIG. 8</figref>) initializes, it registers with the POL. Consequently, the POL is aware of every job and of the location of the associated objects. Thus, after a system failure, using the persistent object locator, a task server object such as task server <b>806</b> can read the database <b>110</b> (<figref idref="DRAWINGS">FIG. 1</figref>), reinstantiate pertinent objects (including a job server <b>804</b> object), and continue executing.</p>
<heading id="h-0013" level="1">Processes for Managing Execution of Computing Processes on a Server Farm</heading>
<p id="p-0092" num="0111"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating a first process for managing execution of work.</p>
<p id="p-0093" num="0112">At block <b>402</b>, a work request is received that specifies a first job comprising a first task and a second job comprising a second task. Each task is an executable task command. For example, work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) receives a work request via one or more input files <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>), such as a JR file, and parses it. The management layer <b>104</b> interprets the input file <b>102</b> to determine an order of execution of the jobs constituent to the work request and the associated sets of tasks associated with each of the jobs, in accordance with the foregoing teachings. Conventional parsing can be used.</p>
<p id="p-0094" num="0113">At block <b>404</b>, the work request is processed to automatically determine whether the first and second jobs have any dependencies that have not been satisfied. In response to a determination that the first and second jobs have no dependencies that have not been satisfied, at block <b>406</b> the first and second tasks are caused to be executed in parallel. For example, the tasks are sent to a networked multi-processor computing environment, e.g., a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>), for execution on one or more processors of the computing environment.</p>
<p id="p-0095" num="0114">Significantly, the work request does not explicitly specify that the first and second tasks are to be executed in parallel. Hence the default work execution order is to run jobs in parallel, that is, to run the tasks constituent to jobs, in parallel. Since each job is run in parallel unless otherwise specified in the work request, the respective set of task commands included in each respective job are collectively executed in parallel with each other. For example, tasks <b>1</b>-<b>4</b> of a first job are submitted to a distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) to be executed on a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) in parallel with tasks <b>1</b>-<b>10</b> of a second job. Parallel processing of as much of the work as possible, or feasible, provides for efficient use of computational resources and for faster job processing.</p>
<p id="p-0096" num="0115">Furthermore, the respective task commands of a set of task commands are substantially serially executed on one or more networked processors of the computing environment. That is, the respective task commands of a set of task commands are not run in parallel. For example, tasks <b>1</b>-<b>4</b> of a first job are executed serially. That is, each of tasks <b>1</b>-<b>4</b> is run one after another.</p>
<p id="p-0097" num="0116">If the work request that is received at block <b>402</b> specifies that the first and second jobs are to be serially executed, then they are caused to be serially executed on one or more networked processors of the computing environment. Thus, the set of task commands included in one of the first and second jobs is executed after the set of task commands included in the other of the first and second jobs is executed. For example, tasks <b>1</b>-<b>4</b> of a first job are submitted to a distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) to be executed on a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) after tasks <b>1</b>-<b>10</b> of a second job finish executing.</p>
<p id="p-0098" num="0117">In an embodiment, both the first and second jobs are placed in an active <b>208</b> (<figref idref="DRAWINGS">FIG. 2</figref>) state, and the first and second tasks are caused to be executed after the first and second jobs, respectively, are placed in the active state. In a related embodiment, the first task has a parent-child relationship with the first job and the second task has a parent-child relationship with the second job. That is, the first task is a child of the first job and the second task is a child of the second job, according to a job aggregation schema specified in the work request.</p>
<p id="p-0099" num="0118">In an embodiment, the first job further comprises a third task, which is caused to be executed after execution of the first task. In a related embodiment, the first and third tasks are children of the first job, thus, they are executed in sequence rather than in parallel.</p>
<p id="p-0100" num="0119">In one embodiment, a job can include one or more sub-jobs that include executable task commands. Furthermore, if a job is defined to include two or more sub-jobs, then the two or more sub-jobs are caused to be executed in parallel. As such, respective sets of task commands included in respective sub-jobs of the two or more sub-jobs are executed in parallel. For example, tasks <b>1</b>-<b>4</b> of a first sub-job of a first job are submitted to a distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) to be executed on a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) in parallel with tasks <b>1</b>-<b>10</b> of a second sub-job of the first job. As with jobs, the respective task commands included in a respective sub-job are serially executed on one or more processors of the computing environment.</p>
<p id="p-0101" num="0120">Note that the sub-jobs of a given job are inherently run in parallel, and the given job is also inherently run in parallel with other jobs specified in the work request. Hence, sub-jobs of a first job can run in parallel with a second job as long as the first and second jobs do not depend on each other, where the sub-jobs and the second job are at different levels of the aggregated job structure defined in the work request. Again, advantages are obtained by running as much of the work, be it jobs or sub-jobs, in parallel as possible within the inherent structure of the work, as defined in the work request.</p>
<p id="p-0102" num="0121">In an embodiment, the work request is interpreted and processed and upon termination of execution of the task commands included in the job, the termination state of the job is set based on the interpreted work request. For example, if a user wants to establish that a job that runs for more than thirty seconds should terminate executing with an error state <b>209</b> (<figref idref="DRAWINGS">FIG. 2</figref>), this can be specified in the work request. The work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) will perform accordingly by setting the termination state of a job running over thirty seconds to the specified error state <b>209</b>.</p>
<p id="p-0103" num="0122">One benefit of the preceding feature is that job dependencies that are conditional on the termination state of one or more other jobs can be built into a work request. For example, a user could specify that if job <b>1</b> terminates with a completed status <b>210</b> (<figref idref="DRAWINGS">FIG. 2</figref>), then run job <b>2</b>; but if job <b>1</b> terminates with a warning status <b>213</b>, then run job <b>3</b>. In that scenario, only one of jobs <b>2</b> and <b>3</b> actually executes, and which job executes depends on the termination state of job <b>1</b>. Thus, conditional dependencies provide a mechanism to define alternative process flows to perform the desired work. Furthermore, as previously described, one embodiment provides the ability to have a first job be conditionally dependent on a second job or on a third job, via a conditional OR dependency.</p>
<p id="p-0104" num="0123">In one embodiment in which a work request includes a sequential set of executable task commands that are not explicitly structured as a job, instructions are submitted to a distributed resource management application (e.g., application <b>106</b> of <figref idref="DRAWINGS">FIG. 1</figref>) specifying that the sequential set of commands are to execute as a job. That is, the sequential set of task commands are specified to be serially executed on one or more networked processors of the computing environment. Submitting a group of commands to a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) as a single job, i.e., with a single submission to the server farm <b>108</b>, helps to minimize the queuing, control and management burden associated with job scheduling that is typically associated with the distributed resource management application <b>106</b>. For example, each often tasks may take five seconds to run but twenty seconds to independently process, queue and submit to the server farm <b>108</b>. Thus, submitting the group of ten tasks as a single job, where the job takes fifty seconds to run but still only twenty seconds to process, queue and submit, conserves computational resources and finishes sooner.</p>
<p id="p-0105" num="0124">The foregoing processes represent, generally, a method for managing execution of work. Although process steps are described in a particular order in <figref idref="DRAWINGS">FIG. 4</figref>, embodiments of the invention are not necessarily limited to any particular order of carrying out such steps, nor are embodiments necessarily limited to carrying out every step described. Thus, implementation of the principles, techniques and mechanisms described herein may vary considerably and still fall within the scope of the invention.</p>
<p id="p-0106" num="0125"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart illustrating a second process for managing execution of work.</p>
<p id="p-0107" num="0126">At block <b>502</b>, a work request is received that specifies a first job comprising a first set of one or more sub-works and a second job comprising a second set of one or more sub-works. Further, the work request specifies that the second job has a dependency on the first job meeting a particular condition. For example, the second job may only execute if the first job finishes in a completed state <b>210</b> (<figref idref="DRAWINGS">FIG. 2</figref>). However, the dependency condition could also be that the first job finishes in a state of unsuccessful termination, such as error state <b>209</b> or killed state <b>211</b>.</p>
<p id="p-0108" num="0127">An example portion of a simplified work request embodied in an input file <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>), as described in reference to block <b>502</b>, is as follows:</p>
<p id="p-0109" num="0128">FirstJob($ID)
<ul id="ul0012" list-style="none">
    <li id="ul0012-0001" num="0000">
    <ul id="ul0013" list-style="none">
        <li id="ul0013-0001" num="0129">&amp;SubWork1.1($ID)
        <ul id="ul0014" list-style="none">
            <li id="ul0014-0001" num="0130">!Task1.1.1</li>
            <li id="ul0014-0002" num="0131">!Task1.1.2</li>
        </ul>
        </li>
        <li id="ul0013-0002" num="0132">&amp;SubWork1.2($ID)
        <ul id="ul0015" list-style="none">
            <li id="ul0015-0001" num="0133">!Task1.2.1</li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0110" num="0134">SecondJob($ID):FirstJob($ID)
<ul id="ul0016" list-style="none">
    <li id="ul0016-0001" num="0000">
    <ul id="ul0017" list-style="none">
        <li id="ul0017-0001" num="0135">&amp;SubWork2.1($ID)
        <ul id="ul0018" list-style="none">
            <li id="ul0018-0001" num="0136">!Task2.1.1</li>
        </ul>
        </li>
        <li id="ul0017-0002" num="0137">&amp;SubWork2.2($ID):SubWork2.1($ID)
        <ul id="ul0019" list-style="none">
            <li id="ul0019-0001" num="0138">!Task2.2.1
<br/>
where SecondJob($ID):FirstJob($ID) specifies the dependency of the second job on the first job.
</li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0111" num="0139">At block <b>504</b>, the work request is processed to automatically determine that the second job has the dependency on the first job. For example, the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) parses and interprets the entire input file <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>) to determine the dependency between the first and second jobs. Furthermore, the work request is interpreted and processed to identify all other dependencies between other jobs that are constituent to the work request, in order to generate an execution sequence for the multiple jobs and tasks specified in the work request.</p>
<p id="p-0112" num="0140">At block <b>506</b>, the first job is placed in an active state <b>208</b> (<figref idref="DRAWINGS">FIG. 2</figref>), thus enabling its first set of sub-works to be scheduled for execution. Recall that sub-works of a given job cannot be scheduled for execution until the given job is in the active state <b>208</b>. Hence, computing resources are not unnecessarily allocated to, or used for, sub-works before the sub-works are almost ready to execute. In other words, resources are allocated just in time for when they are actually needed, with respect to the overall execution scheme for the entire work execution process. Furthermore, holding sub-works that are task commands in a pending state <b>206</b> (<figref idref="DRAWINGS">FIG. 2</figref>) wastes job management and computing resources, including clogging DRM <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) queues.</p>
<p id="p-0113" num="0141">In an embodiment, and according to the job states described in reference to <figref idref="DRAWINGS">FIG. 2</figref>, the first job is changed to the completed state <b>210</b> from the active state <b>208</b> upon the first set of sub-works, that is, the sub-works of the first job, finishing executing. Hence, a job is not complete until all of its sub-works are complete. In a related embodiment, prior to changing the first job to the completed state <b>210</b>, an indication is received at the first job, from a first sub-work of the first job, that the first sub-work has finished executing. Therefore, the status of the sub-works of the first job other than the first sub-job are checked to determine whether the all of the sub-works of the first job have finished executing. If they have, then the first job is moved to the completed state <b>210</b>. In another related embodiment, propagation of state is performed by the first job notifying its parent job that it is in the completed state <b>210</b>, which can be propagated further up the aggregation hierarchy to the master job.</p>
<p id="p-0114" num="0142">At block <b>508</b>, the second job is placed in a pending state <b>206</b> (<figref idref="DRAWINGS">FIG. 2</figref>), where it remains until all of its dependencies are met. Note that the second job is not a task command, thus it does not unnecessarily waste job management and computing resources while in the pending state <b>206</b>, as do task commands. At block <b>510</b>, it is determined whether the first job has met the particular condition. In an embodiment, block <b>510</b> includes receiving at the second job, from the first job, an indication that the first job has met the particular condition. This process may be referred to as a data observer model, whereby a first entity registers with a second entity on which it depends, and passively observes or awaits for data from the second entity.</p>
<p id="p-0115" num="0143">At block <b>512</b>, in response to a determination that the first job has met the particular condition, thereby indicating the dependency between the first and second jobs has been met, the second job is now placed into an active state <b>208</b> (<figref idref="DRAWINGS">FIG. 2</figref>). Finally, at block <b>514</b>, the second set of sub-works is now scheduled for execution, since its parent job, i.e., the second job, is in an active state because its dependencies have been met.</p>
<p id="p-0116" num="0144">In an embodiment, the second set of sub-works has a parent-child relationship with the second job such that each sub-work in the second set of sub-works is a child of the second job, wherein, and significantly, the sub-works are not explicitly specified as having any dependency on the first job. In other words, sub-works that are aggregated under a given job inherit the dependencies of the given job, that is, they also depend on the same job on which their parent depends. Note that in the example portion of a work request presented above, SubWork1 of SecondJob does not explicitly specify a dependency on FirstJob, although its execution sequence is such that it does depend on the first job meeting the particular condition.</p>
<p id="p-0117" num="0145">In one embodiment, and as depicted in the example portion of a work request, the second set of sub-works, i.e., the sub-works of SecondJob, includes a first sub-job (SubWork2.1) and a second sub-job (SubWork2.2), wherein the second sub-job includes an executable task command (Task2.2.1) and depends on the first sub-job (SubWork2.2($ID):SubWork2.1($ID)). A process for managing such specified work, similar to a portion of the process illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, comprises determining whether the first sub-job has met its particular dependency condition, and in response to a positive determination thereto, placing the second sub-job into an active state. Next, the task command is caused to be executed.</p>
<p id="p-0118" num="0146">The preceding embodiment illustrates that sub-works that are jobs can also have dependencies. The embodiment further illustrates that once dependencies of a sub-work having executable task commands are met, the task commands can be executed.</p>
<p id="p-0119" num="0147">Another embodiment is illustrated in reference to the following portion of an example work request.</p>
<p id="p-0120" num="0148">SecondJob($ID):FirstJob($ID)
<ul id="ul0020" list-style="none">
    <li id="ul0020-0001" num="0000">
    <ul id="ul0021" list-style="none">
        <li id="ul0021-0001" num="0149">&amp;SubWork2.1($ID)
        <ul id="ul0022" list-style="none">
            <li id="ul0022-0001" num="0150">!Task2.1.1</li>
        </ul>
        </li>
        <li id="ul0021-0002" num="0151">&amp;SubWork2.2($ID)
        <ul id="ul0023" list-style="none">
            <li id="ul0023-0001" num="0152">!Task2.2.1</li>
            <li id="ul0023-0002" num="0153">&amp;SubWork2.2.1($ID):SubWork2.1($ID)</li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0121" num="0154">In this work request, the second set of sub-works, i.e., the sub-works of SecondJob, includes a first sub-job (SubWork2.1) and a second sub-job (SubWork2.2), wherein the second sub-job includes a third sub-job (SubWork2.2.1) that depends on the first sub-job (SubWork2.2.1($ID):SubWork2.1($ID)). A process for managing such specified work, similar to a portion of the process illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, comprises determining whether the first sub-job has met its particular dependency condition, and in response to a positive determination thereto, placing the third sub-job into an active state.</p>
<p id="p-0122" num="0155">The preceding embodiment illustrates that sub-works that are jobs can also have dependencies, and that such dependencies can be either on another sub-works at a different level of the aggregation hierarchy. Furthermore, a sub-work dependency can be on a job that is at a different level of the aggregation hierarchy.</p>
<p id="p-0123" num="0156">In an embodiment, a sub-work from the first set of sub-works that is an executable task command is changed to a pending state <b>206</b> (<figref idref="DRAWINGS">FIG. 2</figref>) from a scheduled state <b>204</b> (<figref idref="DRAWINGS">FIG. 2</figref>) upon submission of the task command to a DRM system, such as DRM application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Furthermore, the task command is maintained in the pending state <b>206</b> until the DRM system causes the command to begin execution by distributing the task, such as a task server <b>806</b> (<figref idref="DRAWINGS">FIG. 8</figref>), to a processor, such as a processor of server farm <b>108</b>. The clocking of a task's state within the work management process, in coordination with the task's interaction with a distributed resource management application, is embodied in this process.</p>
<p id="p-0124" num="0157"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating a third process for managing execution of work.</p>
<p id="p-0125" num="0158">At block <b>602</b>, a work request is received that specifies a first job comprising a first task that is a child of the first job. Further, the work request indicates an association between the first job and a workspace definition that defines a first execution environment. Still further, the work request has no explicit directive to execute the first task using the first execution environment. The concept of workspaces and workspace definitions are described above under the heading “Workspaces”.</p>
<p id="p-0126" num="0159">At block <b>604</b>, the work request is processed to automatically determine that the first task inherits the association with the first workspace definition, as a result of the first task being a child of the first job. Hence, the first task should be executed using the first execution environment.</p>
<p id="p-0127" num="0160">At block <b>606</b>, the process causes the first execution environment to be created on one or more first computers, and at block <b>608</b>, causes the first task to be executed using the first execution environment. In various embodiments, causing creation of the first execution environment can cause software applications to be installed, such as a distributed resource management application; cause directories to be created for storage of information associated with execution of the first task; populate directories with data files; cause sets of data to be stored; and cause configuration parameters to be set, for example, for software or hardware configurations.</p>
<p id="p-0128" num="0161">The set of resources that comprise an execution environment can be configured on a single computer or on multiple computers, for example, on multiple servers of a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Furthermore, in an embodiment, creation of a workspace is implemented using task commands. Thus, workspace task commands function similar to other task commands, as described above under the heading “Tasks”. Therefore, an execution environment is not reliant on its creation on a given computing platform, rather, it can be configured on any computing platform running any number of operating systems (e.g., Windows, Unix, Linux, etc.) and still be utilized by task commands executing on different networked computers. That is, a set of resources associated with an execution environment are configured such that the resources are available and accessible to two or more servers of a server farm, without having to configure duplicate sets of resources on each server.</p>
<p id="p-0129" num="0162">According to an embodiment, at block <b>610</b> the first execution environment is caused to be automatically purged, deleted, or deconfigured from the one or more first computers after execution of the first task is completed. Therefore, computing resources that were being used for the execution environment are made available for other uses.</p>
<p id="p-0130" num="0163">In an embodiment, the workspace definition includes a reference to an object class that includes functionality that can be invoked to create the associated execution environment. In a related embodiment, the object class is persistently stored in a database, such as database <b>110</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Hence, a set of resources configured for the execution environment can be reconfigured after a failure of a computer on which the environment was configured, without again processing the work request, as at block <b>604</b>.</p>
<heading id="h-0014" level="1">Hierarchical Logging</heading>
<p id="p-0131" num="0164">The job aggregation structure defined in a work request, i.e., through one or more JR files, is further utilized for status reporting. In this context, status reporting refers to presenting job log information. The structure of the job log information mirrors the job aggregation structure defined in a given work request. The presentation of job log information according to the job aggregation structure is referred to as hierarchical logging.</p>
<p id="p-0132" num="0165">As part of the persistent object model, hierarchical logging overcomes challenges associated with running multiple jobs in multiple locations or on multiple computing platforms. In contrast to prior approaches to logging job execution information in the context of server farms, which typically interleave or concatenate multiple log files from multiple jobs and store a mass of information in a single file or directory, hierarchical logging stores job log information in multiple hierarchically-related entities, in the database.</p>
<p id="p-0133" num="0166">Since the state of tasks and jobs propagate up the job aggregation hierarchy to the master job, a state associated with any job or task at any level is presented through a user interface. For example, various states can be presented in a color-coded manner. Consequently, a user can quickly and easily determine what branch of the job aggregation structure had a job or jobs that terminated with a particular state of interest, such as an error state.</p>
<p id="p-0134" num="0167">In one embodiment, logging information is presented in a manner that allows a user to traverse any given branch of the job aggregation structure to “drill down” through the structure to a job of interest through the use of hyperlinks. For example, a job <b>5</b> may have terminated in an error state, thus, its ancestor jobs, i.e., parent job <b>4</b>, grandparent job <b>3</b>, and master job <b>1</b>, are all presented in a manner indicative of an error state. A user can view the state of the master job <b>1</b> to determine that there is an error somewhere in master job <b>1</b>. Interacting with the master job <b>1</b> link (e.g., clicking on the link with a pointer such as a mouse) causes the state of master job <b>1</b>'s children to be displayed, which would indicate that job <b>3</b> is in the error state. Continuing to drill down through the levels of the hierarchy by following the hyperlinks from job to job, results in the ability to determine that it is job <b>5</b> which actually terminated in the error state. One can then view the log information associated with job <b>5</b> to aid in debugging the error. Traversing the hierarchical job aggregation structure through the use of hyperlinks provides the ability to quickly and easily identify jobs with particular termination states, without having to parse and manually search through thousands of lines of log information in an attempt to discover the actual job in the particular termination state that triggered the propagation of such state up through the presentation of the hierarchical log.</p>
<p id="p-0135" num="0168">One significant aspect of hierarchical logging is that task log information is stored in its associated job object. Furthermore, each job object has its own directory structure, which is typically a hierarchical structure. Thus, data can be concurrently streamed into and read from a given object. Consequently, a user can drill down to a given job from the master job, and can view the log information in real-time, essentially as it is being transmitted to the job object. Hence, the progress of a job can be monitored in real-time, errors can be recognized quickly and potentially fixed and the job restarted, without having to wait for the entire master job to finish. Another benefit of storing and presenting log information hierarchically and in real-time is that a “percentage complete” can be displayed at various levels of an aggregated job process.</p>
<p id="p-0136" num="0169">Hierarchical logging is provided by establishing a file directory, by the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>), based on the job aggregation structure defined in a work request. Operationally, a task server (see task server <b>806</b> of <figref idref="DRAWINGS">FIG. 8</figref>) inquires of its associated job server (see job server <b>804</b> of <figref idref="DRAWINGS">FIG. 8</figref>) as to where to store log information for its executable task command that is being executed on the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Each executable task command has an associated log file to which it stores its respective log information. The log files are organized and related based on the file directory interpreted from the work request. Hence, hierarchical logging benefits from a pre-processed organized storage structure, therefore not requiring post-processing to organize the log information into the hierarchical structure. An additional benefit provided by this feature is that reclamation of resources is made simpler. For example, it is simple to delete a branch or the entire tree of the log structure to free up resources, due to the nature of the hierarchical log structure.</p>
<p id="p-0137" num="0170"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating a process for processing a work request.</p>
<p id="p-0138" num="0171">At block <b>702</b>, a work request is received that specifies a job comprising a first task. At block <b>704</b>, the work request is interpreted and processed to automatically establish a job data structure for the job. For example, an object tree is created which represents a job data structure for a given job, with each object representing a sub-job or task associated with the given job. Further, in an embodiment, a hierarchical directory is established which represents the job aggregation structure specified for the job in the work request. At block <b>706</b>, the work request is interpreted to automatically establish a first data storage structure for the first task. For example, an object within the object tree or a file or folder within the hierarchical job directory is established in association with a given task.</p>
<p id="p-0139" num="0172">As previously described, the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) is capable of processing input files <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>), such as JR language files, to interpret the relationships between jobs and tasks that make up the work, which are inherently specified within the work request input files <b>102</b>. As such, and according to embodiments, the work request does not include an executable command to establish the job data structure or the data storage structure.</p>
<p id="p-0140" num="0173">At block <b>708</b>, the work request is further processed to interpret and automatically establish a parent-child relationship between the job data structure and the first data storage structure. The parent-child relationship, in this context, is sometimes referred to as an ownership relationship, in which the job data structure owns the first data storage structure. Ownership entails a relationship which functions such that if and when the job data structure is deleted, the first data storage structure is resultantly deleted. Thus, in an embodiment, upon receiving a request to delete the job data structure, both the job data structure and the first data storage structure are deleted.</p>
<p id="p-0141" num="0174">At block <b>710</b>, the first task is caused to be executed. For example, a task server <b>806</b> (<figref idref="DRAWINGS">FIG. 8</figref>) is passed to a distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) for distribution to one or more servers of server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). At block <b>712</b>, log information pertaining to execution of the first task is caused to be stored in the first data storage structure. However, in an embodiment, the work request does not include an executable command to store the log information in the first data storage structure. Again, the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>) is capable of processing input files <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>), such as JR language files, to interpret the relationships between jobs and tasks that make up the work, which are inherently specified within the work request input files <b>102</b>. The structure of a work request, when interpreted and processed by an application layer with the capabilities of a work control and management layer <b>104</b>, implicitly indicates that log information associated with particular tasks are stored in respective associated data storage structures. Further, according to an embodiment, the first data storage structure does not include log information pertaining to any task other than the first task.</p>
<p id="p-0142" num="0175">In an embodiment, upon receiving a request to view log information pertaining to execution of the first task, the first data storage structure is accessed and the log information stored therein is rendered. Furthermore, the log information can be rendered while the log information stored in the first data storage structure is being updated, i.e., changing.</p>
<p id="p-0143" num="0176">According to an embodiment, a job representation of the relationship between the job data structure and the first data storage structure is rendered. For example, a user interface at workstation <b>101</b> (<figref idref="DRAWINGS">FIG. 1</figref>) displays information identifying the job associated with the job data structure, and displays information identifying the task associated with the first data storage structure, in such a way as to portray their parent-child relationship. For example, jobs, sub-jobs and tasks for a given unit of work are displayed in an indented or other outline format, thus representing the hierarchical relationships therebetween. Furthermore, the representation includes a hyperlink or similar linking mechanism from the job representation to a task representation associated with the first data storage. Implementations include rendering all levels of the hierarchy on a single view, within the constraints of the workstation screen size, etc., and rendering only two levels of the hierarchy at a time.</p>
<p id="p-0144" num="0177">In response to receiving a request to view the log information pertaining to the first task, which request was submitted via the hyperlink, the first data storage structure is accessed the log information stored therein is rendered as the task representation. As described above, job and task representations can be color coded to indicate termination status, for example, whether a task completed successfully or with an error, warning, etc. Furthermore, the completion status is propagated up the hierarchy to the master job. Significantly, a user can “drill down” through the work and job aggregation hierarchy, as represented and rendered on the display, using a pointing device to enact the hyperlinks. Hence, the user can quickly and easily find and view the log information for a task that finished executing in a certain state (see <figref idref="DRAWINGS">FIG. 2</figref>).</p>
<p id="p-0145" num="0178">As described above, a job can have multiple sub-jobs and multiple tasks. Hence, a different data storage structure is established for each sub-job and task, which are associated with the parent job or sub-job data structure. Log information pertaining to execution of respective tasks, and only the respective task, is stored in respective data storage structures. Furthermore, in response to a request to delete a job data structure, all of the progeny sub-jobs and tasks of that job are deleted.</p>
<p id="p-0146" num="0179">In an embodiment, a work request specifies a job with at least two constituent tasks, each with a distinct data storage structure with a respective status. In order to derive a status for the job, the respective statuses for the respective tasks are processed. As such, the statuses of tasks are propagated up the job aggregation hierarchy, as described above.</p>
<heading id="h-0015" level="1">Work Control and Management Layer</heading>
<p id="p-0147" num="0180"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram illustrating an operating configuration of the work control and management layer <b>104</b> (<figref idref="DRAWINGS">FIG. 1</figref>). A client-side application at client <b>801</b> is used to submit jobs to the work control and management layer <b>104</b>. More specifically, jobs are submitted to the management layer <b>104</b> via a job control server <b>802</b>, depicted as process <b>850</b>. For example, jobs may be submitted through a work request embodied in one or more input files <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>), such as a JR file. Multiple work requests can concurrently be submitted to job control server <b>802</b>.</p>
<p id="p-0148" num="0181">The management layer <b>104</b> includes, at certain times during processing of the work defined in a work request, a job server <b>804</b> and a plurality of task servers <b>806</b>. Servers <b>802</b>, <b>804</b>, <b>806</b> are software applications or processes executing on one or more machines. When a work request is received at job control server <b>802</b>, the job control server <b>802</b> initiates a job server <b>804</b>, depicted as process <b>852</b>.</p>
<p id="p-0149" num="0182">A job server <b>804</b> is essentially a process initiated for each separate work request received by job control server <b>802</b>. Once a job server <b>804</b> is instantiated for a work request, the job server <b>802</b> passes a job ID back to the client <b>801</b> for reference, depicted as process <b>853</b>.</p>
<p id="p-0150" num="0183">In one embodiment, the job ID has a hierarchical configuration resembling a pathname, wherein each level of the job ID corresponds to a level of a hierarchy. The hierarchy embodied in the job ID mirrors the job aggregation hierarchy specified in the work request. For example, a job ID can be configured as: group.usernamejobnumber.sub-job. Thus, components of the job ID reference a process specified in a corresponding work request. Furthermore, successive runs of a job are incrementally identified. Incrementally identifying successive runs of a job facilitates statistical analysis of successive corresponding job runs. The job ID structure also drives the structure, described above, of the log report information presented to a user.</p>
<p id="p-0151" num="0184">Job server <b>804</b> is responsible for parsing the work request submitted by client <b>801</b> and creating a corresponding object tree that embodies the process flow between objects representing, for example without limitation, jobs, tasks, workspace definitions, utilities and the like. Furthermore, the objects are made to be persistent, whereby their state is maintained at all times during their processing, typically in a database such as database <b>110</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Objects are also made to be distributable so that they are accessible to different processes within the work execution flow. Implementation of a conventional distributed object model architecture, such as CORBA, is sufficient for the latter function.</p>
<p id="p-0152" num="0185">When the job server <b>804</b> encounters an executable task command in an input file <b>102</b> (<figref idref="DRAWINGS">FIG. 1</figref>) embodying a work request, the job server <b>804</b> passes a command to a distributed resource management application <b>106</b>, essentially requesting the application <b>106</b> find a processor on a server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) on which to execute the task command, as depicted as process <b>856</b>. The command passed to the management application <b>106</b> requests submission of a task server <b>806</b>, which represents one or multiple grouped tasks, to the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Each task server <b>806</b> consists of the same _exectasks command, along with a job ID.</p>
<p id="p-0153" num="0186">The management application <b>106</b> serves a dispatching function by submitting a task server <b>806</b> to a processor on the server farm <b>108</b>, depicted as process <b>858</b>. Submission of the task server <b>806</b> causes communication back to the job server <b>804</b> via the task server <b>806</b>, depicted as process <b>860</b>. The task server <b>806</b> includes a pointer back to a proxy at the job server <b>804</b>, which points to the real object on the job server <b>804</b>. Thus, process <b>860</b> essentially asks the job server <b>804</b> what to do to execute the task commands associated with the job ID submitted with the _exectasks command, i.e., task server <b>806</b>. Task server <b>806</b> objects are instantiated during the process <b>860</b> when the _exectasks command begins to run, by establishing a connection to the job server <b>804</b>, i.e., the job object identified by the job ID.</p>
<p id="p-0154" num="0187">Process <b>862</b> essentially extracts the information that the server farm <b>108</b> needs to perform a portion of work embodied in one or more tasks from the job server <b>804</b>. For example, process <b>862</b> extracts the actual executable command or commands associated with the task and the workspace configuration commands. In turn, according to one embodiment, a task server <b>806</b> can propagate statistics that are maintained by the task server <b>806</b>, back to the associated job server <b>804</b> to be propagated through the job aggregation structure, ultimately to the master job. Process <b>862</b> is generally in response to the request process <b>860</b>. Once the server farm <b>108</b> has the task server information that it needs, it executes the task commands on one or more processors of the server farm.</p>
<p id="p-0155" num="0188">According to one embodiment, in which a work request includes a sequential set of executable task commands, process <b>856</b> passes the sequential set of task commands to the distributed resource management application <b>106</b> (<figref idref="DRAWINGS">FIG. 1</figref>) as a single job. Hence, as previously described, the sequential tasks are run in sequence, but the overhead associated with submission of the job by the application <b>106</b> to the server farm <b>108</b> (<figref idref="DRAWINGS">FIG. 1</figref>) is reduced in comparison with submission of the tasks separately.</p>
<p id="p-0156" num="0189">In one aspect, the work control and management layer <b>104</b> comprises an automatic optimization feature, through which the management layer <b>104</b> generates a proposed JR file that embodies a work request that was previously encountered and run. Based on statistics generated from a previous work run, the management layer <b>104</b> restructures the work definition, that is, the aggregation of jobs and dependencies between jobs, into a proposed work request. The proposed work request can then be presented to the user for review and implementation, if desired.</p>
<heading id="h-0016" level="1">Implementation Mechanism-Hardware Overview</heading>
<p id="p-0157" num="0190"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram that illustrates a computer system <b>900</b> upon which embodiments of the invention may be implemented. Computer system <b>900</b> includes a bus <b>902</b> or other communication mechanism for communicating information, and a processor <b>904</b> coupled with bus <b>902</b> for processing information. Computer system <b>900</b> also includes a main memory <b>906</b>, such as a random access memory (RAM) or other dynamic storage device, coupled to bus <b>902</b> for storing information and instructions to be executed by processor <b>904</b>. Main memory <b>906</b> also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor <b>904</b>. Computer system <b>900</b> further includes a read only memory (ROM) <b>908</b> or other static storage device coupled to bus <b>902</b> for storing static information and instructions for processor <b>904</b>. A storage device <b>910</b>, such as a magnetic disk or optical disk, is provided and coupled to bus <b>902</b> for storing information and instructions.</p>
<p id="p-0158" num="0191">Computer system <b>900</b> may be coupled via bus <b>902</b> to a display <b>912</b>, such as a cathode ray tube (CRT), for displaying information to a computer user. An input device <b>914</b>, including alphanumeric and other keys, is coupled to bus <b>902</b> for communicating information and command selections to processor <b>904</b>. Another type of user input device is cursor control <b>916</b>, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor <b>904</b> and for controlling cursor movement on display <b>912</b>. This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.</p>
<p id="p-0159" num="0192">The invention is related to the use of computer system <b>900</b> for managing execution of work processes. According to one embodiment of the invention, management and control of processes in a networked multi-processor computing environment is provided by computer system <b>900</b> in response to processor <b>904</b> executing one or more sequences of one or more instructions contained in main memory <b>906</b>. Such instructions may be read into main memory <b>906</b> from another computer-readable medium, such as storage device <b>910</b>. Execution of the sequences of instructions contained in main memory <b>906</b> causes processor <b>904</b> to perform the process steps described herein. One or more processors in a multi-processing arrangement may also be employed to execute the sequences of instructions contained in main memory <b>906</b>. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.</p>
<p id="p-0160" num="0193">The term “computer-readable medium” as used herein refers to any medium that participates in providing instructions to processor <b>904</b> for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device <b>910</b>. Volatile media includes dynamic memory, such as main memory <b>906</b>. Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus <b>902</b>. Transmission media can also take the form of acoustic or light waves, such as those generated during radio wave and infrared data communications.</p>
<p id="p-0161" num="0194">Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punch cards, paper tape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.</p>
<p id="p-0162" num="0195">Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor <b>904</b> for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system <b>900</b> can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal. An infrared detector coupled to bus <b>902</b> can receive the data carried in the infrared signal and place the data on bus <b>902</b>. Bus <b>902</b> carries the data to main memory <b>906</b>, from which processor <b>904</b> retrieves and executes the instructions. The instructions received by main memory <b>906</b> may optionally be stored on storage device <b>910</b> either before or after execution by processor <b>904</b>.</p>
<p id="p-0163" num="0196">Computer system <b>900</b> also includes a communication interface <b>918</b> coupled to bus <b>902</b>. Communication interface <b>918</b> provides a two-way data communication coupling to a network link <b>920</b> that is connected to a local network <b>922</b>. For example, communication interface <b>918</b> may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface <b>918</b> may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface <b>918</b> sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.</p>
<p id="p-0164" num="0197">Network link <b>920</b> typically provides data communication through one or more networks to other data devices. For example, network link <b>920</b> may provide a connection through local network <b>922</b> to a host computer <b>924</b> or to data equipment operated by an Internet Service Provider (ISP) <b>926</b>. ISP <b>926</b> in turn provides data communication services through the worldwide packet data communication network now commonly referred to as the “Internet” <b>928</b>. Local network <b>922</b> and Internet <b>928</b> both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link <b>920</b> and through communication interface <b>918</b>, which carry the digital data to and from computer system <b>900</b>, are exemplary forms of carrier waves transporting the information.</p>
<p id="p-0165" num="0198">Computer system <b>900</b> can send messages and receive data, including program code, through the network(s), network link <b>920</b> and communication interface <b>918</b>. In the Internet example, a server <b>930</b> might transmit a requested code for an application program through Internet <b>928</b>, ISP <b>926</b>, local network <b>922</b> and communication interface <b>918</b>. In accordance with the invention, one such downloaded application provides for management and control of processes in a networked multi-processor computing environment, as described herein.</p>
<p id="p-0166" num="0199">The received code may be executed by processor <b>904</b> as it is received, and/or stored in storage device <b>910</b>, or other non-volatile storage for later execution. In this manner, computer system <b>900</b> may obtain application code in the form of a carrier wave.</p>
<heading id="h-0017" level="1">Extensions and Alternatives</heading>
<p id="p-0167" num="0200">Alternative embodiments of the invention are described throughout the foregoing description, and in locations that best facilitate understanding the context of the embodiments. Furthermore, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. Therefore, the specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.</p>
<p id="p-0168" num="0201">In addition, in this description certain process steps are set forth in a particular order, and alphabetic and alphanumeric labels may be used to identify certain steps. Unless specifically stated in the description, embodiments of the invention are not necessarily limited to any particular order of carrying out such steps. In particular, the labels are used merely for convenient identification of steps, and are not intended to specify or require a particular order of carrying out such steps.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer implemented method for managing execution of work in a networked multi-processor computing environment in which work is distributed between multiple processors, comprising:
<claim-text>a work management layer receiving a work request, said work request specifying a first job, said first job comprising a first task, wherein said first task has a parent-child relationship with said first job such that said first task is a child of said first job, said work request further indicating an association between said first job and a first workspace definition, wherein said first workspace definition defines a first execution environment for use in executing said first job, said first execution environment comprising a working directory in which information generated by executing said first job may be stored, said work request comprising no explicit directive to execute said first task using said first execution environment;</claim-text>
<claim-text>wherein said first job comprises an aggregation of executable commands and wherein said first task comprises at least one of said executable commands;</claim-text>
<claim-text>wherein relationships among jobs and tasks are specified in a corresponding work request by a job aggregation hierarchy;</claim-text>
<claim-text>wherein said first execution environment comprises runtime resources available for use by a plurality of processors independent of a respective operating system controlling each respective processor of said plurality of processors;</claim-text>
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said first task and said first job being hierarchically related in said job aggregation hierarchy specified in said work request, that said first task, as a result of being a child of said first job, inherits said association with said first workspace definition and should be executed using said first execution environment;</claim-text>
<claim-text>said work management layer causing said first execution environment to be created on one or more first computers; and</claim-text>
<claim-text>said work management layer causing a distributed resource management application to cause execution of said first task using said first execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>after execution of said first task is completed, causing said first execution environment to be automatically purged from the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said first workspace definition comprises a reference to an object class, and wherein said object class comprises functionality that can be invoked to create said first execution environment on a computer.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:
<claim-text>persistently storing said object class in a database so that a set of resources configured for said first execution environment can be reconfigured after a failure of a computer of said one or more first computers without again interpreting said work request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein causing said first execution environment to be created comprises:
<claim-text>causing one or more software applications to be installed on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein causing said first execution environment to be created comprises:
<claim-text>causing a distributed resource management application to be configured on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein causing said first execution environment to be created comprises:
<claim-text>causing one or more directories to be created on the first computer for storage of information associated with execution of the first task.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:
<claim-text>populating the one or more directories with one or more files.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein causing said first execution environment to be created comprises:
<claim-text>causing one or more sets of data to be stored on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein causing said first execution environment to be created comprises:
<claim-text>causing one or more configuration parameters to be set on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein causing said first execution environment to be created comprises:
<claim-text>automatically configuring said first execution environment on said one or more first computers of a group of networked computers;</claim-text>
<claim-text>wherein the first execution environment is not reliant on creation on a given computer from the group of networked computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein causing said first execution environment to be created comprises:
<claim-text>configuring a set of resources of said first execution environment such that said set of resources is accessible by two or more computers of a group of networked computers without configuring duplicate sets of said resources on each of said two or more computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said first job further comprises a first sub-job, said first sub-job comprising a second task, wherein said first sub-job has a parent-child relationship with said first job such that said first sub-job is a child of said first job, and wherein said second task has a parent-child relationship with said first sub-job such that said second task is a child of said first sub-job, said work request comprising no explicit directive to execute said second task using said first execution environment, and wherein said method further comprises:
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said second task and said first sub-job and said first job being hierarchically related in said job aggregation hierarchy specified in said work request, that said second task, as a result of being a child of said first sub-job which is a child of said first job, inherits said association with said first workspace definition and should be executed using said first execution environment;</claim-text>
<claim-text>said work management layer causing said first execution environment to be created on a second one or more computers if not already created; and</claim-text>
<claim-text>said work management layer causing said second task to be executed on the second one or more computers using said first execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein said first one or more computers and said second one or more computers are the same one or more computers.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein said first one or more computers and said second one or more computers are different one or more computers.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said first job further comprises a first sub-job, said first sub-job comprising a second task, wherein said first sub-job has a parent-child relationship with said first job such that said first sub-job is a child of said first job, and wherein said second task has a parent-child relationship with said first sub-job such that said second task is a child of said first sub-job, said work request further indicating an association between said first sub-job and a second workspace definition, wherein said second workspace definition defines a second execution environment, said work request comprising no explicit directive to execute said second task using said second execution environment, and wherein said method further comprises:
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said second task and said first sub-job and said first job being hierarchically related in said job aggregation hierarchy specified in said work request, that said second task, as a result of being a child of said first sub-job, inherits said association with said second workspace definition and should be executed using said second execution environment;</claim-text>
<claim-text>said work management layer causing said second execution environment to be created on a second one or more computers; and</claim-text>
<claim-text>said work management layer causing said second task to be executed on the second one or more computers using said second execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said first one or more computers and said second one or more computers are the same one or more computers.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said first one or more computers and said second one or more computers are different one or more computers.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said work request further specifies a second job, said second job comprising a second task, wherein said second task has a parent-child relationship with said second job such that said second task is a child of said second job, said work request further indicating an association between said second job and a second workspace definition, wherein said second workspace definition defines a second execution environment, said work request comprising no explicit directive to execute said second task using said second execution environment, and wherein said method further comprises:
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said second task and said second job being hierarchically related in said job aggregation hierarchy specified in said work request, that said second task, as a result of being a child of said second job, inherits said association with said second workspace definition and should be executed using said second execution environment;</claim-text>
<claim-text>said work management layer causing said second execution environment to be created on a second one or more computers; and</claim-text>
<claim-text>said work management layer causing said second task to be executed on the second computer using said second execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein said first one or more computers and said second one or more computers are the same computer.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein said first one or more computers and said second one or more computers are different computers.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A computer-readable storage medium carrying one or more sequences of instructions for managing execution of work in a networked multi-processor computing environment in which work is distributed between multiple processors, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of:
<claim-text>a work management layer receiving a work request, said work request specifying a first job, said first job comprising a first task, wherein said first task has a parent-child relationship with said first job such that said first task is a child of said first job, said work request further indicating an association between said first job and a first workspace definition, wherein said first workspace definition defines a first execution environment for use in executing said first job, said first execution environment comprising a working directory in which information generated by executing said first job may be stored, said work request comprising no explicit directive to execute said first task using said first execution environment;</claim-text>
<claim-text>wherein said first job comprises an aggregation of executable commands and wherein said first task comprises at least one of said executable commands;</claim-text>
<claim-text>wherein relationships among jobs and tasks are specified in a corresponding work request by a job aggregation hierarchy;</claim-text>
<claim-text>wherein said first execution environment comprises runtime resources available for use by a plurality of processors independent of a respective operating system controlling each respective processor of said plurality of processors;</claim-text>
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said first task and said first job being hierarchically related in said job aggregation hierarchy specified in said work request, that said first task, as a result of being a child of said first job, inherits said association with said first workspace definition and should be executed using said first execution environment;</claim-text>
<claim-text>said work management layer causing said first execution environment to be created on one or more first computers; and</claim-text>
<claim-text>said work management layer causing a distributed resource management application to cause execution of said first task using said first execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of:
<claim-text>after execution of said first task is completed, causing said first execution environment to be automatically purged from the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein said first workspace definition comprises a reference to an object class, and wherein said object class comprises functionality that can be invoked to create said first execution environment on a computer.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The computer-readable storage medium of <claim-ref idref="CLM-00024">claim 24</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of:
<claim-text>persistently storing said object class in a database so that a set of resources configured for said first execution environment can be reconfigured after a failure of a computer of said one or more first computers without again interpreting said work request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of causing said first execution environment to be created by performing the step of:
<claim-text>causing one or more software applications to be installed on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of causing said first execution environment to be created by performing the step of:
<claim-text>causing a distributed resource management application to be configured on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of causing said first execution environment to be created by performing the step of:
<claim-text>causing one or more directories to be created on the first computer for storage of information associated with execution of the first task.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The computer-readable storage medium of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of:
<claim-text>populating the one or more directories with one or more files.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of causing said first execution environment to be created by performing the step of:
<claim-text>causing one or more sets of data to be stored on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of causing said first execution environment to be created by performing the step of:
<claim-text>causing one or more configuration parameters to be set on the one or more first computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of causing said first execution environment to be created by performing the steps of:
<claim-text>automatically configuring said first execution environment on said one or more first computers of a group of networked computers;</claim-text>
<claim-text>wherein the first execution environment is not reliant on creation on a given computer from the group of networked computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00033" num="00033">
<claim-text>33. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the step of causing said first execution environment to be created by performing the step of:
<claim-text>configuring a set of resources of said first execution environment such that said set of resources is accessible by two or more computers of a group of networked computers without configuring duplicate sets of said resources on each of said two or more computers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00034" num="00034">
<claim-text>34. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein said first job further comprises a first sub-job, said first sub-job comprising a second task, wherein said first sub-job has a parent-child relationship with said first job such that said first sub-job is a child of said first job, and wherein said second task has a parent-child relationship with said first sub-job such that said second task is a child of said first sub-job, said work request comprising no explicit directive to execute said second task using said first execution environment, and wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of:
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said second task and said first sub-job and said first job being hierarchically related in said job aggregation hierarchy specified in said work request, that said second task, as a result of being a child of said first sub-job which is a child of said first job, inherits said association with said first workspace definition and should be executed using said first execution environment;</claim-text>
<claim-text>said work management layer causing said first execution environment to be created on a second one or more computers if not already created; and</claim-text>
<claim-text>said work management layer causing said second task to be executed on the second one or more computers using said first execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00035" num="00035">
<claim-text>35. The computer-readable storage medium of <claim-ref idref="CLM-00034">claim 34</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of causing said first and said second execution environments to be created by causing creation of said first and said second execution environments on said first one or more computers and said second one or more computers that are the same one or more computers.</claim-text>
</claim>
<claim id="CLM-00036" num="00036">
<claim-text>36. The computer-readable storage medium of <claim-ref idref="CLM-00034">claim 34</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of causing said first and said second execution environments to be created by causing creation of said first and said second execution environments on said first one or more computers and said second one or more computers that are different one or more computers.</claim-text>
</claim>
<claim id="CLM-00037" num="00037">
<claim-text>37. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein said first job further comprises a first sub-job, said first sub-job comprising a second task, wherein said first sub-job has a parent-child relationship with said first job such that said first sub-job is a child of said first job, and wherein said second task has a parent-child relationship with said first sub-job such that said second task is a child of said first sub-job, said work request further indicating an association between said first sub-job and a second workspace definition, wherein said second workspace definition defines a second execution environment, said work request comprising no explicit directive to execute said second task using said second execution environment, and wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of:
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said second task and said first sub-job and said first job being hierarchically related in said job aggregation hierarchy specified in said work request, that said second task, as a result of being a child of said first sub-job, inherits said association with said second workspace definition and should be executed using said second execution environment;</claim-text>
<claim-text>said work management layer causing said second execution environment to be created on a second one or more computers; and</claim-text>
<claim-text>said work management layer causing said second task to be executed on the second one or more computers using said second execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00038" num="00038">
<claim-text>38. The computer-readable storage medium of <claim-ref idref="CLM-00037">claim 37</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of causing said first and said second execution environments to be created by causing creation of said first and said second execution environments on said first one or more computers and said second one or more computers that are the same one or more computers.</claim-text>
</claim>
<claim id="CLM-00039" num="00039">
<claim-text>39. The computer-readable storage medium of <claim-ref idref="CLM-00037">claim 37</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of causing said first and said second execution environments to be created by causing creation of said first and said second execution environments on said first one or more computers and said second one or more computers that are different one or more computers.</claim-text>
</claim>
<claim id="CLM-00040" num="00040">
<claim-text>40. The computer-readable storage medium of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein said work request further specifies a second job, said second job comprising a second task, wherein said second task has a parent-child relationship with said second job such that said second task is a child of said second job, said work request further indicating an association between said second job and a second workspace definition, wherein said second workspace definition defines a second execution environment, said work request comprising no explicit directive to execute said second task using said second execution environment, and wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of:
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said second task and said second job being hierarchically related in said job aggregation hierarchy specified in said work request, that said second task, as a result of being a child of said second job, inherits said association with said second workspace definition and should be executed using said second execution environment;</claim-text>
<claim-text>said work management layer causing said second execution environment to be created on a second one or more computers; and</claim-text>
<claim-text>said work management layer causing said second task to be executed on the second computer using said second execution environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00041" num="00041">
<claim-text>41. The computer-readable storage medium of <claim-ref idref="CLM-00040">claim 40</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of causing said first and said second execution environments to be created by causing creation of said first and said second execution environments on said first one or more computers and said second one or more computers that are the same one or more computers.</claim-text>
</claim>
<claim id="CLM-00042" num="00042">
<claim-text>42. The computer-readable storage medium of <claim-ref idref="CLM-00040">claim 40</claim-ref>, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of causing said first and said second execution environments to be created by causing creation of said first and said second execution environments on said first one or more computers and said second one or more computers that are different one or more computers.</claim-text>
</claim>
<claim id="CLM-00043" num="00043">
<claim-text>43. A network device that can manage execution of work in a networked multi-processor computing environment in which work is distributed between multiple processors, the network device comprising:
<claim-text>a network interface;</claim-text>
<claim-text>a processor coupled to the network interface and receiving network messages from the network through the network interface;</claim-text>
<claim-text>a computer-readable medium comprising one or more stored sequences of instructions which, when executed by the processor, cause the processor to carry out the steps of:
<claim-text>a work management layer receiving a work request, said work request specifying a first job, said first job comprising a first task, wherein said first task has a parent-child relationship with said first job such that said first task is a child of said first job, said work request further indicating an association between said first job and a first workspace definition, wherein said first workspace definition defines a first execution environment for use in executing said first job, said first execution environment comprising a working directory in which information generated by executing said first job may be stored, said work request comprising no explicit directive to execute said first task using said first execution environment;</claim-text>
<claim-text>wherein said first job comprises an aggregation of executable commands and wherein said first task comprises at least one of said executable commands;</claim-text>
<claim-text>wherein relationships among jobs and tasks are specified in a corresponding work request by a job aggregation hierarchy;</claim-text>
<claim-text>wherein said first execution environment comprises runtime resources available for use by a plurality of processors independent of a respective operating system controlling each respective processor of said plurality of processors;</claim-text>
<claim-text>said work management layer interpreting said work request to automatically determine, based at least in part on said first task and said first job being hierarchically related in said job aggregation hierarchy specified in said work request, that said first task, as a result of being a child of said first job, inherits said association with said first workspace definition and should be executed using said first execution environment;</claim-text>
<claim-text>said work management layer causing said first execution environment to be created on one or more first computers; and</claim-text>
<claim-text>said work management layer causing a distributed resource management application to cause execution of said first task using said first execution environment.</claim-text>
</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
