<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299383-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299383</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10416564</doc-number>
<date>20011113</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>FR</country>
<doc-number>00 14555</doc-number>
<date>20001113</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>1065</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714 51</main-classification>
<further-classification>714 39</further-classification>
</classification-national>
<invention-title id="d0e71">Security method making deterministic real time execution of multitask applications of control and command type with error confinement</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4589093</doc-number>
<kind>A</kind>
<name>Ippolito et al.</name>
<date>19860500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718102</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6338072</doc-number>
<kind>B1</kind>
<name>Durand et al.</name>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707205</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>FR</country>
<doc-number>2 771 828</doc-number>
<kind>A</kind>
<date>19990600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>FR</country>
<doc-number>2771828</doc-number>
<kind>A</kind>
<date>19990600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00005">
<othercit>David, V., et al.: “Safety properties ensured by the OASIS model for safety critical real-time systems,” Computer Safety, Reliability and Security. 17<sup>th </sup>International Conference, SAFECOMP'98. Proceedings, Proceedings of 17<sup>th </sup>International Conference on Computer Safety, Reliability and Security, Heidelberg, Germany, Oct. 5-7, 1998, pp. 45-59.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00006">
<othercit>Aussagues, C., et al: “Vérification de propriétés de sûreté dans le modèle OASIS pour les applications temps réel critiques,” RTS '97 Salon Des Solutions Pour Les Systemes Temps Reel Et Les Applications Enfouies (RTS '97: Real Time Systems And Embedded Applications), 1997 pp. 145-164, Toulouse, France, Teknea, France.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>Aussagues, C., et al.: “Guaranteeing timeliness in safety critical real-time systems,” Distributed Computer Control Systems 1998 (DCCS'98) Proceedings Volume from the 15<sup>th </sup>IFAC Workshop, Proceedings of the 15<sup>th </sup>IFAC Workshop on Distributed Computer Control Systems 1998, Como, Italy, Sep. 9-11, 1998, pp. 83-89, Kidlington, UK, Elsevier Science, UK.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>Aspelund, J., et al.: “A fault tolerant multimicroprocessor operating system modeled with locality Petri nets,” Implementing Functions: Microprocessors and Firmware. Seventh Euromicro Symposium on Microprocessing and Microprogramming, Paris, France, Sep. 8-10, 1981, pp. 63-70, Amsterdam, Netherlands, North-Holland, Netherlands.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>13</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714 51</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 39</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718102</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707205</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>6</number-of-drawing-sheets>
<number-of-figures>14</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040078547</doc-number>
<kind>A1</kind>
<date>20040422</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>David</last-name>
<first-name>Vincent</first-name>
<address>
<city>Versailles</city>
<country>FR</country>
</address>
</addressbook>
<nationality>
<country>FR</country>
</nationality>
<residence>
<country>FR</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Delcoigne</last-name>
<first-name>Jean</first-name>
<address>
<city>Maurepas</city>
<country>FR</country>
</address>
</addressbook>
<nationality>
<country>FR</country>
</nationality>
<residence>
<country>FR</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Weingarten, Schurgin, Gagnebin &amp; Lebovici LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Commissariat a l'Energie Atomique</orgname>
<role>03</role>
<address>
<city>Paris</city>
<country>FR</country>
</address>
</addressbook>
</assignee>
<assignee>
<addressbook>
<orgname>Areva Np</orgname>
<role>03</role>
<address>
<city>Courbevoie</city>
<country>FR</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Lateef</last-name>
<first-name>Marvin</first-name>
<department>2109</department>
</primary-examiner>
<assistant-examiner>
<last-name>Arcos</last-name>
<first-name>Jeison</first-name>
</assistant-examiner>
</examiners>
<pct-or-regional-filing-data>
<document-id>
<country>WO</country>
<doc-number>PCT/FR01/03532</doc-number>
<kind>00</kind>
<date>20011113</date>
</document-id>
<us-371c124-date>
<date>20030623</date>
</us-371c124-date>
</pct-or-regional-filing-data>
<pct-or-regional-publishing-data>
<document-id>
<country>WO</country>
<doc-number>WO02/39277</doc-number>
<kind>A </kind>
<date>20020516</date>
</document-id>
</pct-or-regional-publishing-data>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The method is implemented with a management system of the time-triggered architecture type in association with a processor of a central processor unit that possesses a privileged execution mode to which access is protected by an instruction of the “call to system layer” type. The only system layer call that is authorized from an application task under consideration to the system layer consists in reporting a change of node in the control graph of the task in question. When the system layer has verified that the call is legal relative to the execution paths of the control graph as described in the constant tables of the application, all of the operations to be performed on the node in question by the system layer are predetermined by the constant tables of the application associated with the system layer. Prior to real-time execution, pre-ordering of the lists of tasks of an application under consideration is performed in a micro-kernel, which subsequently ensures, when called by the system layer during real-time execution, that task lists are updated in ordered manner depending on the new time characteristics of the tasks, specifically their earliest start times d(i) and their latest finish times f(i) as calculated by the system layer.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="100.92mm" wi="154.94mm" file="US07299383-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="229.19mm" wi="166.03mm" file="US07299383-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="235.71mm" wi="171.96mm" file="US07299383-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="238.17mm" wi="169.25mm" file="US07299383-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="190.84mm" wi="106.34mm" orientation="landscape" file="US07299383-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="185.59mm" wi="164.51mm" file="US07299383-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="216.83mm" wi="164.68mm" file="US07299383-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<p id="p-0002" num="0001">The present invention relates to a security method for making deterministic the real time execution of multitask applications of the control and command type in a control system having at least a first clock which issues an interrupt signal whenever an adjustable quantity of time has elapsed, a central processor unit with at least one processor capable of receiving at least said clock interrupt signal, a main memory, and a set of peripheral controllers for managing the inputs/outputs of the control system.</p>
<p id="p-0003" num="0002">In a system for multitask management of various processes (inputs/outputs, computations, . . . ) having different time scales and liable to exchange data, with all of the processes being synchronized and coordinated in real time, it is desirable to be capable of executing processes in real time in deterministic manner, i.e. with the overall behavior of all of the tasks that interact with one another and with the environment being unique and invariant. It is also desirable for the execution of real time processes to be made secure, i.e. for it to include detecting and confining anomalies in such a manner as to ensure that the various tasks are independent relative to failures, while nevertheless remaining as deterministic as possible in the presence of operating anomalies.</p>
<p id="p-0004" num="0003">Numerous multitask management systems are already known. However, most of those management systems are asynchronous and therefore non-deterministic. In addition, such systems are of a design that does not prevent certain failure modes from propagating.</p>
<p id="p-0005" num="0004">More particularly, document FR-A-2 771 828 discloses a security method for a multitask computer fitted with a failure detection system by time or space partitioning which, at all times, identifies the task that is executing legally.</p>
<p id="p-0006" num="0005">According to that document, which relates to a system of the cyclical ordering type, partitioning is used to limit the propagation of failures, but there is then no longer any communication between partitions, i.e. there is no longer multitask management at an overall level. Furthermore, there is still a possibility of failures propagating within a partition, which means that maximum security is not available.</p>
<p id="p-0007" num="0006">Document FR-A-2 771 828 thus shows that obtaining deterministic behavior appears to be contradictory with multitask management.</p>
<p id="p-0008" num="0007">The present invention seeks to remedy the drawbacks of the prior art and makes it possible to obtain control systems that are more integrated, that provide better performance, and that are safer.</p>
<p id="p-0009" num="0008">More particularly, the present invention seeks to make it possible to obtain secure multitask execution in real time and in deterministic manner by means of a computer, both with error confinement and with fault tolerance.</p>
<p id="p-0010" num="0009">The invention thus seeks to make it possible to provide security that guarantees highly deterministic execution in real time of multitask applications, both for tasks that are cyclical and for tasks that are not cyclical, with communications that are explicit (time-stamped messages) and implicit (streams of time-stamped data).</p>
<p id="p-0011" num="0010">These objects are achieved by a security method making real time execution of multitask applications of the control and command type in a control system deterministic, the method comprising:</p>
<p id="p-0012" num="0011">at least a first clock that issues an interrupt signal sh whenever an adjustable quantity of time has elapsed;</p>
<p id="p-0013" num="0012">a central processor unit (CPU) having at least one processor capable of receiving at least said clock interrupt signal sh;</p>
<p id="p-0014" num="0013">a main memory; and</p>
<p id="p-0015" num="0014">a set of controllers for controlling peripherals for managing inputs/outputs of the control system,</p>
<p id="p-0016" num="0015">the method being characterized in that it comprises the following steps:</p>
<p id="p-0017" num="0016">a) for each of the tasks of a given application, storing all of the chaining that is authorized from each time synchronization point of the task that requires a call to a system layer, said chaining being represented by a control graph for monitoring the execution of system layer calls made by the task in question, each control graph comprising a set of nodes each corresponding to a call to the system layer of the control system;</p>
<p id="p-0018" num="0017">b) for each node of the control graph of each task, storing the nature of the call to the system layer and its call parameters, including time parameters enabling “earliest start” times d(i) and “latest finish” times f(i) to be updated;</p>
<p id="p-0019" num="0018">c) for each task, storing an initial node in the associated graph;</p>
<p id="p-0020" num="0019">d) for the given application and prior to starting real time execution in a time-triggered mode, initializing, for each task, the initial node and the initial instant representing the initial state of the task in question;</p>
<p id="p-0021" num="0020">e) for the given application and prior to starting real time execution in a time-triggered mode, initializing the starting order of each of the tasks by pre-ordering lists of tasks in an atomic micro-kernel;</p>
<p id="p-0022" num="0021">f) setting the first clock to issue a clock interrupt signal sh constituting a call to the micro-kernel, on the first instant of the application for starting execution of said application in time-triggered mode;</p>
<p id="p-0023" num="0022">g) during normal operation after the first clock has been set, causing the first clock to be reset by the micro-kernel on each call to the micro-kernel; during a call to the micro-kernel by the system layer or by processing the interrupt signal sh, causing the micro-kernel to go to the step of updating the lists of tasks in ordered manner depending on the time characteristics of the tasks, namely their earliest start times d(i) and their latest finish times f(i); and after updating the list, causing the micro-kernel to calculate the nearest future instant on which a task needs to be woken up and causing the first clock to be set by the micro-kernel on the basis of said nearest future instant to wake up said task and leave the micro-kernel; and</p>
<p id="p-0024" num="0023">h) while executing a task, making a call to the system layer only when a node of the control graph of said task is reached, and passing as an argument the number of the node; proceeding on entry into the system layer with a check to verify whether, according to the control graph of the task being executed, the chaining from the node corresponding to the preceding system layer call is authorized, in order to launch anomaly processing in the system layer if said chaining is not authorized or to continue with execution if said chaining is authorized, updating the time parameters of the task being executed comprising the earliest start time d(i) and the latest finish time f(i) using calls to the micro-kernel from the system layer, and continuing normal execution of the current task until said task again reaches a node of its control graph.</p>
<p id="p-0025" num="0024">More particularly, the security method of the invention is applied to a control system further comprising a memory protection unit for controlling addressing access rights, which memory protection unit responds to a requested address ad supplied by the CPU and to the rights of the execution context of the processor to access the addressable memory space, by producing in exclusive manner either a validated address av giving access, or else issuing an exception signal se to the CPU indicative of authorized addressing, and in that it further comprises the following steps:</p>
<p id="p-0026" num="0025">i) during a preparatory stage, for a given application, storing the access rights to each of the memory segments for the micro-kernel and for each application task and for the extension of each task in the system layer so as to constitute first and second execution contexts depending on whether the instructions are in the code specific to the application constituting the task or the instructions are located in generic code of the system layer constituting the extension of the task in the system layer;</p>
<p id="p-0027" num="0026">j) for a given application and prior to starting real time execution in a time-triggered operating mode, initializing the micro-kernel context and the first and second execution context for each task and for its extension in the system layer; and
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0027">k) during execution of a task, making a call to the system layer using an instruction for passing into a privileged mode of execution which makes it possible to pass from the execution context of the task to the execution context of its extension in the system layer, and after verifying that chaining from the node corresponding to the preceding system call is authorized, and after updating the time parameters of the task using calls to the micro-kernel from the system layer, returning to the code of the task by means of an instruction for returning into the non-privileged mode enabling execution to pass from the execution context of the extension in the system layer to the execution context of the task.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0028" num="0028">Preferably, the execution contexts of each application task are disjoint in pairs.</p>
<p id="p-0029" num="0029">According to a particular characteristic of the method of the invention, the extensions of the execution contexts of the application tasks into the system layer are not write accessible to the execution contexts of the tasks in the application code.</p>
<p id="p-0030" num="0030">The coding of the control graph of a task prevents any failure of common cause occurring both in the mechanism for controlling execution of any task of the application and in the execution of said task itself.</p>
<p id="p-0031" num="0031">The method of the invention may further comprise the following steps:</p>
<p id="p-0032" num="0032">l) during a preparatory stage, for each given application, and for all of the authorized chainings in said task, storing a time quota constituting a supremum for the maximum execution time needed for going from one node to the other in the control graph of the task, each of these time quotas covering both the time passed in executing the instructions specific to the task, and also the time passed in executing the generic code of the system layer in the extension of the task; and</p>
<p id="p-0033" num="0033">m) during normal operation, after the first clock has been set, in the event of a call to the micro-kernel triggered by the time interrupt signal sh and causing the first clock to be reset, checking to verify whether the time interrupt signal sh triggering the call to the micro-kernel is associated with an attempt at violating a time quota, and if so, causing the micro-kernel to run anomaly processing, else if the time interrupt signal sh is not associated with an attempt to violate a time quota, causing the micro-kernel to update the task lists, and after updating the task lists, to calculate both the nearest future instants at which a task needs to be woken up and the future instants at which the quota of time allocated to the task that will be executing on exiting the micro-kernel will have expired, which time is determined while updating the lists, and causing the micro-kernel to set the first clock to the nearer of said future instants so that either the task is woken up or else an attempt at violating time quota due to anomalous operation is detected, and leaving the micro-kernel after setting the first clock.</p>
<p id="p-0034" num="0034">When a second clock is implemented in the control system, and according to a particular characteristic of the invention, the micro-kernel is caused to access the second clock in order to monitor the flow of time as triggered by the first clock by comparing the time signals.</p>
<p id="p-0035" num="0035">The security method of the invention adapted to make deterministic the real time execution of communicating multitask applications of the control and command type may further comprise the following steps:</p>
<p id="p-0036" num="0036">n) during a preparatory stage, for each of the tasks of a given application storing all of the authorized chainings of its points for time synchronization and for communication with the other tasks of the application requiring a call to the system layer, these authorized chaining being represented by a control graph for the execution of system layer calls made by the task in question, each graph comprising a set of nodes, each corresponding to a call to the system layer;</p>
<p id="p-0037" num="0037">o) storing each buffer zone needed for exchanging data between tasks, specifying its size, the size of the elements that it contains, its location or base address, and also the relationships between the buffer zones enabling the information transfers needed for communications to be confirmed;</p>
<p id="p-0038" num="0038">p) storing, for each buffer zone, the initial values of its elements;</p>
<p id="p-0039" num="0039">q) for the given application and prior to starting real time execution in a time-triggering operating mode, initializing the values of the elements of the buffer zone with values previously stored in memory; and</p>
<p id="p-0040" num="0040">r) during execution of a task, while making a system layer call when a node of the task control graph is reached and after verifying that according to the control graph of the task currently being executed the chaining from the node corresponding to the preceding system layer call is authorized, causing buffer zones to be updated in succession as a function of the nature of the previously-stored call and performing incremental updates as necessary of the time parameters of the task being executed, comprising its earliest start time d(i) and its latest finish time f(i).</p>
<p id="p-0041" num="0041">According to a particular characteristic of the invention, in the system layer, only the buffer zones are allowed to be shared by the extensions of the execution contexts of the tasks of an application, a given buffer zone for dynamic communications corresponding to sending messages being sharable only by two task execution context extensions, while a given buffer zone for static communications corresponding to a stream of time-stamped data can be shared by more than two task execution context extensions, but can be modified only by the task owning the context extension in the system layer.</p>
<p id="p-0042" num="0042">The security method of the invention is applicable to control and command applications which are highly critical concerning safety.</p>
<p id="p-0043" num="0043">In particular, the method of the invention may be applied to a control and command system of safety class level 1E, for a nuclear reactor.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<p id="p-0044" num="0044">Other characteristics and advantages of the invention appear from the following description of particular embodiments, given as examples with reference to the accompanying drawings, in which:</p>
<p id="p-0045" num="0045"><figref idref="DRAWINGS">FIG. 1</figref> is a simplified diagram of the architecture of a control system to which the safety method of the invention is applicable;</p>
<p id="p-0046" num="0046"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram showing how code is distributed in depth relative to a system layer and to a micro-kernel in the method in accordance with the invention;</p>
<p id="p-0047" num="0047"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart corresponding to processing an example of a real time task in the security method in accordance with the invention;</p>
<p id="p-0048" num="0048"><figref idref="DRAWINGS">FIG. 4</figref> is a control graph corresponding to the flow chart of <figref idref="DRAWINGS">FIG. 3</figref>;</p>
<p id="p-0049" num="0049"><figref idref="DRAWINGS">FIG. 5</figref> is an example of a timing chart and of associated time values while processing the example of <figref idref="DRAWINGS">FIGS. 3 and 4</figref> of a real time task using the safety method in accordance with the invention;</p>
<p id="p-0050" num="0050"><figref idref="DRAWINGS">FIG. 6</figref> is a table of the nodes of the <figref idref="DRAWINGS">FIG. 4</figref> control graph, including a description of the operations to be performed on the earliest start times d(i) and the latest finish times f(i);</p>
<p id="p-0051" num="0051"><figref idref="DRAWINGS">FIG. 7</figref> is a flow chart corresponding to processing an example of a first real time task for communicating with a second task using the security method in accordance with the invention;</p>
<p id="p-0052" num="0052"><figref idref="DRAWINGS">FIG. 8</figref> is a control graph corresponding to the flow chart of <figref idref="DRAWINGS">FIG. 7</figref>;</p>
<p id="p-0053" num="0053"><figref idref="DRAWINGS">FIG. 9</figref> is a flow chart corresponding to processing an example of a second real time task for communicating with the first real time task shown in the flow chart of <figref idref="DRAWINGS">FIG. 7</figref>;</p>
<p id="p-0054" num="0054"><figref idref="DRAWINGS">FIG. 10</figref> is a control graph corresponding to the flow chart of <figref idref="DRAWINGS">FIG. 9</figref>;</p>
<p id="p-0055" num="0055"><figref idref="DRAWINGS">FIG. 11</figref> is an example of a timing chart and of associated time values while processing the example of intercommunicating real time tasks shown in <figref idref="DRAWINGS">FIGS. 7 to 10</figref> using the security method in accordance with the invention;</p>
<p id="p-0056" num="0056"><figref idref="DRAWINGS">FIGS. 12 and 13</figref> are tables of the nodes of the control graphs of <figref idref="DRAWINGS">FIGS. 8 and 10</figref> including descriptions of the operations to be performed on the messages at the earliest start times d(i) and the latest finish times f(i); and</p>
<p id="p-0057" num="0057"><figref idref="DRAWINGS">FIG. 14</figref> is a detailed table showing the processor's access rights to memory segments in an example of the method of the invention and depending on whether it is executing a task, the system layer, or the micro-kernel.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0058" num="0058">The description begins with reference to <figref idref="DRAWINGS">FIG. 1</figref> which shows an example of architecture of simplified type for a control system to which the security method of the invention is applicable.</p>
<p id="p-0059" num="0059">The control system comprises at least a first clock <b>14</b> which transmits an interrupt signal sh over a line <b>22</b> whenever a programmable quantity of time has elapsed. A central processor unit (CPU) <b>10</b> has at least one processor capable of receiving data over a line <b>21</b> and the interrupt signal sh over the line <b>22</b>.</p>
<p id="p-0060" num="0060">The CPU <b>10</b> serves to send out address signals over lines <b>23</b>, <b>24</b> to a main memory comprising both read-only memory (ROM) <b>12</b> and random access memory (RAM) <b>13</b>.</p>
<p id="p-0061" num="0061">The ROM <b>12</b> contains at least information (A) comprising the programs of the application concerned and information (B) comprising the constant tables and data of the application.</p>
<p id="p-0062" num="0062">The RAM <b>13</b> contains the working variable data of the application programs.</p>
<p id="p-0063" num="0063">Controllers <b>1</b><sub>1 </sub>to <b>1</b><sub>N </sub>of peripherals <b>1</b> to N serve to provide real time management of inputs and outputs of the control system.</p>
<p id="p-0064" num="0064">A second clock <b>15</b> may be implemented to provide additional monitoring of proper operation of the clock <b>14</b>.</p>
<p id="p-0065" num="0065">The control system may further comprise a memory protection unit <b>16</b> for enforcing addressing access rights.</p>
<p id="p-0066" num="0066">Starting from a requested address ad supplied by the CPU <b>10</b> to the memory protection unit <b>16</b> over the line <b>23</b> and from the rights (D) of the various execution contexts of the processor to access the addressable memory space, as supplied by a line <b>26</b> connecting the ROM <b>12</b> to the memory protection unit <b>16</b>, said memory protection unit <b>16</b> produces in exclusive manner either a validated address av giving access over the line <b>14</b> connected to the memories <b>12</b> and <b>13</b>, to the peripheral controllers <b>1</b><sub>1 </sub>to <b>1</b><sub>N</sub>, and to the clocks <b>14</b> and <b>15</b>, or else an exception signal sc over a line <b>25</b> to the CPU <b>10</b> indicating that the addressing is not authorized.</p>
<p id="p-0067" num="0067">The memory protection unit <b>16</b> may be constituted by a mechanism present in a standard memory management unit (MMU), which MMU can itself be incorporated in the processor of the CPU <b>10</b>.</p>
<p id="p-0068" num="0068">The processor of the CPU <b>10</b>, which is capable of receiving at least one clock interrupt signal sh and an exception signal se flagging non-authorized addressing, possesses a privileged mode of execution to which access is protected by an instruction of the “call to system layer” type, which may be constituted, for example, by a branch instruction or “trap”.</p>
<p id="p-0069" num="0069">In general, the invention relates to a management system of the type having time-triggered architecture (TTA) for secure deterministic multitasking in real time with explicit communication (time-stamped messages) and implicit communication (streams of time-stamped data), the tasks themselves being either cyclical or non-cyclical.</p>
<p id="p-0070" num="0070">More particularly, in the security method in accordance with the invention, calls to the system layer of the control system (by means of a call to privileged mode execution) are managed in specific manner, which makes it possible to detect and to find errors and to guarantee that behavior is deterministic and predictable.</p>
<p id="p-0071" num="0071">In the invention, calls to the system layer are managed as follows:</p>
<p id="p-0072" num="0072">i/ the only system layer calls that are authorized from an application task in question to the system layer are calls that consist in reporting a change of node in the control graph of the task in question;</p>
<p id="p-0073" num="0073">ii/ the system layer then verifies that each call is legal when compared with the execution path of the control graph which is described in the constant tables of the application; and</p>
<p id="p-0074" num="0074">iii/ when the call is legal, all of the operations to be performed on the node in question by the system layer are predetermined by the constant tables of the associated application of the system layer.</p>
<p id="p-0075" num="0075">Lists of tasks of an application in question are preordered prior to real time execution on an atomic micro-kernel which, when subsequently called by the system layer during real time execution, serves to update the lists of tasks in ordered manner in application of the new time characteristics of the tasks, specifically their earliest start times d(i) and their latest finish time f(i) as calculated by the system layer.</p>
<p id="p-0076" num="0076">The basic security method of the invention essentially comprises the following steps:</p>
<p id="p-0077" num="0077">a) for each of the tasks of a given application, storing all of the chaining that is authorized from each time synchronization point of the task that requires a call to a system layer, said chaining being represented by a control graph for monitoring the execution of calls to the system layer from the task in question, each control graph comprising a set of nodes each corresponding to a call to the system layer of the control system;</p>
<p id="p-0078" num="0078">b) for each node of the control graph of each task, storing the nature of the call to the system layer and its call parameters, including time parameters enabling “earliest start” times d(i) and “latest finish” times f(i) to be updated;</p>
<p id="p-0079" num="0079">c) for each task, storing an initial node (Node <b>0</b>) in the associated graph;</p>
<p id="p-0080" num="0080">d) for the given application and prior to starting real time execution in a time-triggered mode, initializing, for each task, the initial node (Node <b>0</b>) and the initial instant representing the initial state of the task in question;</p>
<p id="p-0081" num="0081">e) for the given application and prior to starting real time execution in a time-triggered mode, initializing the starting order of each of the tasks by pre-ordering lists of tasks in an atomic micro-kernel;</p>
<p id="p-0082" num="0082">f) setting the first clock <b>14</b> to issue a clock interrupt signal sh constituting a call to the micro-kernel, on the first instant of the application for starting execution of said application in time-triggered mode;</p>
<p id="p-0083" num="0083">g) during normal operation after the first clock <b>14</b> has been set, causing the first clock <b>14</b> to be reset by the micro-kernel on each call to the micro-kernel; during a call to the micro-kernel by the system layer or by processing the interrupt signal sh, causing the micro-kernel to go to the step of updating the lists of tasks in ordered manner depending on the time characteristics of the tasks, namely their earliest start times d(i) and their latest finish times f(i); and after updating the list, causing the micro-kernel to calculate the nearest future instant on which a task needs to be woken up and causing the first clock <b>14</b> to be set by the micro-kernel on the basis of said nearest future instant to wake up said task and leave the micro-kernel; and</p>
<p id="p-0084" num="0084">h) while executing a task, making a call to the system layer only when a node of the control graph of said task is reached, and passing as an argument the number of the node; proceeding on entry into the system layer with a check to verify whether, according to the control graph of the task being executed, the chaining from the node corresponding to the preceding system layer call is authorized, in order to launch anomaly processing in the system layer if said chaining is not authorized or to continue with execution if said chaining is authorized, updating the time parameters of the task being executed comprising the earliest start time d(i) and the latest finish time f(i) using calls to the micro-kernel from the system layer, and continuing normal execution of the current task until said task again reaches a node of its control graph.</p>
<p id="p-0085" num="0085">As mentioned above, the control system to which the security method of the invention is applied may include a memory protection unit and tables of the rights of each context to access each of the segments, which access rights are predetermined and may, where appropriate, be stored in ROM. For each execution context, the description of the table defining the rights of the context is initialized only once, during the stage of initializing the entire system, and after this system initialization stage, none of the processes executed on the CPU has those tables in its execution context.</p>
<p id="p-0086" num="0086">The security method of the invention can then further comprise the following steps which take place amongst the steps defined above:</p>
<p id="p-0087" num="0087">i) during a preparatory stage, for a given application, storing the access rights to each of the memory segments for the micro-kernel and for each application task and for the extension of each task in the system layer so as to constitute first and second execution contexts depending on whether the instructions are in the code specific to the application constituting the task or the instructions are located in generic code of the system layer constituting the extension of the task in the system layer;</p>
<p id="p-0088" num="0088">j) for a given application and prior to starting real time execution in a time-triggered operating mode, initializing the micro-kernel context and the first and second execution context for each task and for its extension in the system layer; and</p>
<p id="p-0089" num="0089">k) during execution of a task, making a call to the system layer using an instruction for passing into a privileged mode of execution which makes it possible to pass from the execution context of the task to the execution context of its extension in the system layer, and after verifying that chaining from the node corresponding to the preceding system call is authorized, and after updating the time parameters of the task using calls to the micro-kernel from the system layer, returning to the code of the task by means of an instruction for returning into the non-privileged mode enabling execution to pass from the execution context of the extension in the system layer to the execution context of the task.</p>
<p id="p-0090" num="0090">The security method of the invention may also refer to time quotas and can then further include the following steps which take place amongst the above-defined steps of the basic method and of the basic method as modified to take account of the existence of privileged modes of execution that make it possible to go to an execution context of the extension of a task in the system layer:</p>
<p id="p-0091" num="0091">l) during a preparatory stage, for each given application, and for all of the authorized chainings in said task, storing a time quota constituting a supremum for the maximum execution time needed for going from one node to the other in the control graph of the task, each of these time quotas covering both the time passed in executing the instructions specific to the task, and also the time passed in executing the generic code of the system layer in the extension of the task; and</p>
<p id="p-0092" num="0092">m) during normal operation, after the first clock <b>14</b> has been set, in the event of a call to the micro-kernel triggered by the time interrupt signal sh and causing the first clock <b>14</b> to be reset, checking to verify whether the time interrupt signal sh triggering the call to the micro-kernel is associated with an attempt at violating a time quota, and if so, causing the micro-kernel to run anomaly processing, else if the time interrupt signal sh is not associated with an attempt to violate a time quota, causing the micro-kernel to update the task lists, and after updating the task lists, to calculate both the nearest future instants at which a task needs to be woken up and the future instants at which the quota of time allocated to the task that will be executing on exiting the micro-kernel will have expired, which time is determined while updating the lists, and causing the micro-kernel to set the first clock <b>14</b> to the nearer of said future instants so that either the task is woken up or else an attempt at violating time quota due to anomalous operation is detected, and leaving the micro-kernel after setting the first clock <b>14</b>.</p>
<p id="p-0093" num="0093">The procedure for updating the task lists of the application in the micro-kernel can be made more explicit in the manner specified below, which takes account of a preferred implementation in which reference is made to a time quota allocated to the task being processed, but can also be applied to a simplified basic implementation if reference to a time quota is omitted.</p>
<p id="p-0094" num="0094">For each call to the micro-kernel during execution, whatever the system layer extension of the execution context of the task in question, two parameters are involved in updating the task lists: the earliest start time d(i) and the latest finish time f(i). Two task lists are managed: the list of eligible tasks ready for execution, i.e. having earliest start times d(i) in the past, and the list of non-eligible tasks, that are not ready for execution or that are waiting to be woken up, i.e. tasks having earliest start times d(i) in the future. The list of eligible tasks is ordered in order of increasing latest finish times; the list of non-eligible tasks is ordered in order of increasing earliest start times d(i). Every waiting task is guaranteed to go to the “ready” state once its earliest start time is reached.</p>
<p id="p-0095" num="0095">α) If, during a call to the micro-kernel, the earliest start time d(i) of a task is in the future, the task is not eligible and it is therefore transferred to the ordered list of non-eligible tasks. This time makes it possible to calculate the future instant at which the task ought to be woken up on the basis of the order of earliest start times: the nearest future earliest start time gives the future instant at which the next task in question will become eligible (to be woken up).</p>
<p id="p-0096" num="0096">β) If, on the contrary, during a call to the micro-kernel, the earliest start time d(i) of the task in question is in the past, then the task is eligible and it is transferred to the ordered list of eligible tasks. The micro-kernel then gives control to the eligible task having the nearest future latest finish time in the ordered list of latest finish times, and it calculates the future instant from which the time quota allocated to the elected task will expire (where the quota is the difference between the nearest future latest finish time and the present instant).</p>
<p id="p-0097" num="0097">γ) Nevertheless, if the call to the micro-kernel is caused by the clock <b>14</b> in the event of being set for the time quota allocated to the task currently being processed, then the micro-kernel begins by executing the anomaly processing action specified by the application, after which it performs actions α) and β).</p>
<p id="p-0098" num="0098">On the basis of these two instants (the nearest future time for waking up a task and the future time at which the quota of time allocated to the elected task expires), the micro-kernel then sets the clock <b>14</b> in such a manner that it is activated at the nearest of those two instants (either to wake up a task at the proper time, or else to detect an attempt at violating time quota, i.e. anomalous operation). With the clock <b>14</b> set, the micro-kernel is excited, possibly with switching.</p>
<p id="p-0099" num="0099">Thus, during execution, the active task is changed either by a time interrupt, or following a change of node in the active task.</p>
<p id="p-0100" num="0100">The origin of a time interrupt may either be the fact that a waiting task has become ready (given the time triggering), or else that the active task has used up the quota of time allocated to it, in which case a safety check is performed.</p>
<p id="p-0101" num="0101">When the active task changes node in its control graph, either its latest finish time is pushed back, or else its earliest start time is pushed back. In the first case, some other task can become active, taking its place. In the second case, the active task is put into the set of waiting tasks if its new earliest start time is in the future.</p>
<p id="p-0102" num="0102">The number of preemptions is finite and bounded and it is possible analytically to calculate the maximum bound of the number of preemptions.</p>
<p id="p-0103" num="0103">Furthermore, insofar as time quotas are updated and monitored on each change of node, it is possible to detect anomalies in time in order to confine the task immediately.</p>
<p id="p-0104" num="0104">Insofar as only legal displacements through the control graph are accepted, it is impossible for a task to present behavior in time that leads to it consuming more resources (e.g. memory resource for communications) than that which has been statistically evaluated using the same graph.</p>
<p id="p-0105" num="0105">An implementation of the security method of the invention is described below with reference to <figref idref="DRAWINGS">FIGS. 3 to 6</figref> for a particular real time task.</p>
<p id="p-0106" num="0106">In this example, the function of the real time task is to issue an alarm if a measured value is such that v exceeds a threshold s<sub>1 </sub>over a duration t(v) which itself exceeds a threshold s<sub>2</sub>.</p>
<p id="p-0107" num="0107"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart showing the processing of the task corresponding to the above example.</p>
<p id="p-0108" num="0108">Reference <b>101</b> designates an initial node or Node <b>0</b>, at which a call is made to the system layer.</p>
<p id="p-0109" num="0109">Reference <b>102</b> corresponds to a first step of acquiring the measured value v.</p>
<p id="p-0110" num="0110">Reference <b>103</b> corresponds to making a test, after which the process returns to the initial node <b>101</b> followed by the step <b>102</b> if v&lt;s<sub>1</sub>, or else moves on to Node <b>1</b>, referenced <b>104</b>, followed by step <b>105</b> if v≧s<sub>1</sub>.</p>
<p id="p-0111" num="0111">At node <b>104</b>, a call is made to the system layer, and at step <b>105</b>, the duration t(v) is calculated.</p>
<p id="p-0112" num="0112">After step <b>105</b>, a test <b>106</b> serves to return to the initial node <b>101</b> if t(v)&lt;s<sub>2</sub>, and to move on to Node <b>2</b>, referenced <b>107</b>, if t(v)≧s<sub>2</sub>.</p>
<p id="p-0113" num="0113">After the second node <b>107</b>, where a call is made to the system layer, the process moves on to step <b>108</b> of issuing an alarm, after which it returns to the initial node <b>101</b>.</p>
<p id="p-0114" num="0114"><figref idref="DRAWINGS">FIG. 4</figref> is the control graph having nodes <b>101</b>, <b>104</b>, and <b>107</b> together with the associated arcs that correspond to the flowchart of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0115" num="0115">In this example, the time allocated for performing the operations for “acquiring v” (step <b>102</b>), for “calculating t(v)” (step <b>105</b>), and for “issuing an alarm” (step <b>108</b>), are as follows:</p>
<p id="p-0116" num="0116">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>acquisition step 102:</entry>
<entry>1 time unit</entry>
</row>
<row>
<entry/>
<entry>calculation step 105:</entry>
<entry>2 additional time units</entry>
</row>
<row>
<entry/>
<entry>alarm issuing step 108:</entry>
<entry>1 time unit</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0117" num="0117">For each of nodes <b>101</b>, <b>104</b>, and <b>107</b>, the services provided by the system layer and the operations performed on the earliest start times d(i) and the latest finish times f(i) are given in the table below, it being understood that during initialization, an earliest start time d(0) is given such that d(0)=0, and a latest finish time f(0) is given such that f(0)=1 time unit.</p>
<p id="p-0118" num="0118">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56pt" align="center"/>
<colspec colname="2" colwidth="77pt" align="left"/>
<colspec colname="3" colwidth="84pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Services provided by</entry>
<entry>Operations performed on</entry>
</row>
<row>
<entry>Node</entry>
<entry>the system layer</entry>
<entry>d (i) and f (i)</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>1/ Node 0</entry>
<entry>i) wait for the end of</entry>
<entry>f (i + 1) = f (i) + 1</entry>
</row>
<row>
<entry/>
<entry>the previously fixed</entry>
<entry>d (i + 1) = f (i)</entry>
</row>
<row>
<entry/>
<entry>time</entry>
</row>
<row>
<entry/>
<entry>ii) then adjust the</entry>
</row>
<row>
<entry/>
<entry>new time</entry>
</row>
<row>
<entry>2/ Node 1</entry>
<entry>adjust the new time</entry>
<entry>f (i + 1) = f (i) + 2</entry>
</row>
<row>
<entry/>
<entry/>
<entry>d (i + 1) = d (i)</entry>
</row>
<row>
<entry>3/ Node 2</entry>
<entry>i) wait for the end of</entry>
<entry>f (i + 1) = f (i) + 1</entry>
</row>
<row>
<entry/>
<entry>the previously fixed</entry>
<entry>d (i + 1) = f (i)</entry>
</row>
<row>
<entry/>
<entry>time</entry>
</row>
<row>
<entry/>
<entry>ii) then adjust the</entry>
</row>
<row>
<entry/>
<entry>new time</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0119" num="0119"><figref idref="DRAWINGS">FIG. 6</figref> summarizes a table of Nodes <b>0</b>, <b>1</b>, and <b>2</b> and includes descriptions of the operations to be performed on the earliest start time d(i) and the latest finish time f(i).</p>
<p id="p-0120" num="0120">Furthermore, the task control graph shown in <figref idref="DRAWINGS">FIG. 4</figref> can be encoded in matrix form, in which case it is presented as follows for the above-specified example:</p>
<p id="p-0121" num="0121">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mi>M</mi>
        <mo>=</mo>
        <mrow>
          <mtable>
            <mtr>
              <mtd>
                <mi>Node</mi>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
          </mtable>
          <mo>⁢</mo>
          <mtable>
            <mtr>
              <mtd>
                <mrow>
                  <mn>0</mn>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="1.1em" height="1.1ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mn>1</mn>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="1.7em" height="1.7ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mn>2</mn>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mrow>
                  <mo>(</mo>
                  <mtable>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                    </mtr>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                    </mtr>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                    </mtr>
                  </mtable>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mi>I</mi>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
where:
</p>
<p id="p-0122" num="0122">m<sub>ij</sub>=A if the move from Node i to Node j is authorized;</p>
<p id="p-0123" num="0123">m<sub>ij</sub>=I if the move from Node i to Node j is inhibited.</p>
<p id="p-0124" num="0124"><figref idref="DRAWINGS">FIG. 5</figref> is a timing chart showing an implementation of the above-described real time task, showing the associated time values. Numbers 1 to 10 designate real time in numbers of time units since the start of operation in time-triggered mode.</p>
<p id="p-0125" num="0125">The security method of the invention is also adapted to ensure that the real time execution of multitasking applications communicating with one another by messages is made deterministic.</p>
<p id="p-0126" num="0126">Under such circumstances, the method includes the following particular steps which take place amongst the steps described above for a basic method with multitasking applications without communication between tasks being indicated:</p>
<p id="p-0127" num="0127">n) during a preparatory stage, for each of the tasks of a given application storing all of the authorized chainings of its points for time synchronization and for communication with the other tasks of the application requiring a call to the system layer, these authorized chaining being represented by a control graph for the execution of system layer calls made by the task in question, each graph comprising a set of nodes, each corresponding to a call to the system layer;</p>
<p id="p-0128" num="0128">o) storing each buffer zone needed for exchanging data between tasks, specifying its size, the size of the elements that it contains, its location or base address, and also the relationships between the buffer zones enabling the information transfers needed for communications to be confirmed;</p>
<p id="p-0129" num="0129">p) storing, for each buffer zone, the initial values of its elements;</p>
<p id="p-0130" num="0130">q) for the given application and prior to starting real time execution in a time-triggering operating mode, initializing the values of the elements of the buffer zone with values previously stored in memory; and</p>
<p id="p-0131" num="0131">r) during execution of a task, while making a system layer call when a node of the task control graph is reached and after verifying that according to the control graph of the task currently being executed the chaining from the node corresponding to the preceding system layer call is authorized, causing buffer zones to be updated in succession as a function of the nature of the previously-stored call and performing incremental updates as necessary of the time parameters of the task being executed, comprising its earliest start time d(i) and its latest finish time f(i).</p>
<p id="p-0132" num="0132">When the first and second execution contexts are defined for each task of the application and for its extension into the system layer, the following particular features also apply:</p>
<p id="p-0133" num="0133">In the system layer, only the buffer zones are allowed to be shared by the extensions of the execution contexts of the tasks of an application, a given buffer zone for dynamic communications corresponding to sending messages being sharable only by two task execution context extensions, while a given buffer zone for static communications corresponding to a stream of time-stamped data can be shared by more than two task execution context extensions but can be written to or modified by a single context only.</p>
<p id="p-0134" num="0134">An implementation of the security method of the invention involving two real time tasks that communicate by means of messages is described below with reference to <figref idref="DRAWINGS">FIGS. 7 to 13</figref>.</p>
<p id="p-0135" num="0135">In this simple example, the function performed consists in switching on an alarm lamp if a measured value v is such that v exceeds a threshold s<sub>1</sub>, and if the duration t(v) that the threshold s<sub>1 </sub>has been exceeded by the measured value v, itself exceeds a threshold s<sub>2</sub>.</p>
<p id="p-0136" num="0136">One processing task thus acquires v and, if necessary, sends a message to an alarm task which switches ON the specified lamp.</p>
<p id="p-0137" num="0137"><figref idref="DRAWINGS">FIG. 7</figref> is a flow chart corresponding to executing the processing task in this example.</p>
<p id="p-0138" num="0138">Reference <b>111</b> designates the initial node or Node <b>0</b> at which a call is made to the system layer.</p>
<p id="p-0139" num="0139">The first step <b>112</b> is a step of acquiring the measured value v and it is associated with a test <b>113</b> which compares the value v with the threshold s<sub>1</sub>.</p>
<p id="p-0140" num="0140">If v&lt;s<sub>1</sub>, then the task returns to the initial mode <b>111</b>, else if v≧s<sub>1</sub>, the task moves on to Node <b>1</b>, given reference <b>114</b>, and giving rise to a call to the system layer.</p>
<p id="p-0141" num="0141">The second step <b>115</b>, following node <b>114</b>, corresponds to calculating the duration t(v).</p>
<p id="p-0142" num="0142">The test <b>116</b> associated with step <b>115</b> compares the duration t(v) with the threshold s<sub>2</sub>.</p>
<p id="p-0143" num="0143">If t(v)&lt;s<sub>2</sub>, then the task returns to the initial node <b>111</b>, else if t(v)≧s<sub>2</sub>, then the task moves on to Node <b>2</b>, which is referenced <b>117</b>, and gives rise to a call to the system layer.</p>
<p id="p-0144" num="0144">After node <b>117</b>, the task moves on to Node <b>3</b> referenced <b>118</b> where a call is made to the system layer, and a third step is performed which consists in sending an alarm message, prior to returning to the initial node <b>111</b>.</p>
<p id="p-0145" num="0145"><figref idref="DRAWINGS">FIG. 8</figref> shows the control graph corresponding to the flow chart of <figref idref="DRAWINGS">FIG. 7</figref>, with the nodes and the authorized arcs.</p>
<p id="p-0146" num="0146"><figref idref="DRAWINGS">FIG. 9</figref> shows the flow chart corresponding to executing the alarm task in this example.</p>
<p id="p-0147" num="0147">Reference <b>121</b> designates the initial node or Node <b>0</b> at which a call is made to the system layer.</p>
<p id="p-0148" num="0148">A test <b>122</b> examines whether a message has been received.</p>
<p id="p-0149" num="0149">If no message is present, then the task moves on to step <b>123</b> of switching OFF the alarm lamp, after which it returns to the initial node <b>121</b>.</p>
<p id="p-0150" num="0150">If one or more messages are present, then the task goes to Node <b>1</b>, referenced <b>124</b>, with a call to the system layer and then passes on to a step <b>125</b> of switching ON the alarm lamp, prior to returning to the initial node <b>121</b>.</p>
<p id="p-0151" num="0151"><figref idref="DRAWINGS">FIG. 10</figref> shows the control graph corresponding to the flow chart of <figref idref="DRAWINGS">FIG. 9</figref>, with its nodes and its authorized arcs.</p>
<p id="p-0152" num="0152">In this example, the times allowed for performing the operations: “acquire v”; “calculate t(v)”; “send message”; “switch OFF”; “switch ON”; corresponding respectively to steps <b>112</b>, <b>115</b>, <b>118</b>, <b>123</b>, and <b>125</b> are as follows:</p>
<p id="p-0153" num="0153">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>“acquire <u style="single">v</u>”:</entry>
<entry>1 time unit</entry>
</row>
<row>
<entry/>
<entry>“calculate t (v)”:</entry>
<entry>2 additional time units</entry>
</row>
<row>
<entry/>
<entry>“send message”:</entry>
<entry>1 time unit, but the message will be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>available in 2 time units</entry>
</row>
<row>
<entry/>
<entry>“switch OFF”:</entry>
<entry>1 time unit</entry>
</row>
<row>
<entry/>
<entry>“switch ON”:</entry>
<entry>1 time unit</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0154" num="0154">The services given by the system layer and the operations performed on the earliest start times d(i) and the latest finish times f(i) (it being understood that d(0)=0 and f(0)=1) together with the time dV at which messages become visible are given below for each node of each of the two tasks.</p>
<p id="p-0155" num="0155">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="77pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry/>
<entry>Operations</entry>
</row>
<row>
<entry/>
<entry>Services rendered</entry>
<entry>performed on d (i),</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<colspec colname="3" colwidth="70pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Node</entry>
<entry>by the system layer</entry>
<entry>f (i), and dV</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(Processing task)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<colspec colname="3" colwidth="70pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Node 0 (111)</entry>
<entry>Wait for the end</entry>
<entry>f (i + 1) = f (i) + 1;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>of the previously</entry>
<entry>d (i + 1) = f (i)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>fixed time</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Then adjust new</entry>
</row>
<row>
<entry/>
<entry/>
<entry>time</entry>
</row>
<row>
<entry/>
<entry>Node 1 (114)</entry>
<entry>Adjust the new</entry>
<entry>f (i + 1) = f (i) + 2;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>time</entry>
<entry>d (i + 1) = d (i)</entry>
</row>
<row>
<entry/>
<entry>Node 2 (117)</entry>
<entry>Wait for the end</entry>
<entry>f (i + 1) = f (i) + 1;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>of the previously</entry>
<entry>d (i + 1) = f (i)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>fixed time</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Then adjust the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>new time</entry>
</row>
<row>
<entry/>
<entry>Node 3 (118)</entry>
<entry>Copy the message</entry>
<entry>f (i + 1) = f (i);</entry>
</row>
<row>
<entry/>
<entry/>
<entry>in the send zone of</entry>
<entry>d (i + 1) = d (i)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the extension of</entry>
<entry>dV = d (i) + 2</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the task context in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the system layer</entry>
</row>
<row>
<entry/>
<entry>(Alarm task)</entry>
</row>
<row>
<entry/>
<entry>Node 0 (121)</entry>
<entry>Wait for the end</entry>
<entry>f (i + 1) = f (i) + 1</entry>
</row>
<row>
<entry/>
<entry/>
<entry>of the previously</entry>
<entry>d (i + 1) = f (i)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>fixed time</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Then adjust new</entry>
</row>
<row>
<entry/>
<entry/>
<entry>time</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Copy visible</entry>
</row>
<row>
<entry/>
<entry/>
<entry>messages from the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>send zone of the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>treatment task into</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the receive zone of</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the extension of</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the task context in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the system layer</entry>
</row>
<row>
<entry/>
<entry>Node 1 (124)</entry>
<entry>Make a note in</entry>
<entry>f (i + 1) = f (i)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the receive zone of</entry>
<entry>d (i + 1) = d (i)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the extension of</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the task context in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the system layer,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>that the first</entry>
</row>
<row>
<entry/>
<entry/>
<entry>message has been</entry>
</row>
<row>
<entry/>
<entry/>
<entry>consumed.</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0156" num="0156"><figref idref="DRAWINGS">FIGS. 12 and 13</figref> relate respectively to the processing task and to the alarm task of this example, and comprise tables of nodes with descriptions of the operations to be performed on the earliest start time d(i), the latest finish time f(i), and the visibility time dV.</p>
<p id="p-0157" num="0157">The control graphs of the processing task and of the alarm task can be encoded in matrix form as follows:</p>
<p id="p-0158" num="0158">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mi>M</mi>
        <mo>=</mo>
        <mrow>
          <mtable>
            <mtr>
              <mtd>
                <mrow>
                  <mi>Node</mi>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>2</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>3</mn>
              </mtd>
            </mtr>
          </mtable>
          <mo>⁢</mo>
          <mtable>
            <mtr>
              <mtd>
                <mrow>
                  <mstyle>
                    <mspace width="1.9em" height="1.9ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mrow>
                    <mn>0</mn>
                    <mo>⁢</mo>
                    <mstyle>
                      <mspace width="1.4em" height="1.4ex"/>
                    </mstyle>
                    <mo>⁢</mo>
                    <mn>1</mn>
                    <mo>⁢</mo>
                    <mstyle>
                      <mspace width="1.4em" height="1.4ex"/>
                    </mstyle>
                    <mo>⁢</mo>
                    <mn>2</mn>
                    <mo>⁢</mo>
                    <mstyle>
                      <mspace width="1.9em" height="1.9ex"/>
                    </mstyle>
                    <mo>⁢</mo>
                    <mn>3</mn>
                  </mrow>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="1.9em" height="1.9ex"/>
                  </mstyle>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mrow>
                  <mo>(</mo>
                  <mtable>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                    </mtr>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                    </mtr>
                    <mtr>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                    </mtr>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                    </mtr>
                  </mtable>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mn>2</mn>
          <mo>)</mo>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.6em" height="0.6ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>processing</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="1.1em" height="1.1ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>task</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mi>M</mi>
        <mo>=</mo>
        <mrow>
          <mtable>
            <mtr>
              <mtd>
                <mi>Node</mi>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
          </mtable>
          <mo>⁢</mo>
          <mtable>
            <mtr>
              <mtd>
                <mrow>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mrow>
                    <mn>0</mn>
                    <mo>⁢</mo>
                    <mstyle>
                      <mspace width="1.4em" height="1.4ex"/>
                    </mstyle>
                    <mo>⁢</mo>
                    <mn>1</mn>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mrow>
                  <mo>(</mo>
                  <mtable>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                    </mtr>
                    <mtr>
                      <mtd>
                        <mi>A</mi>
                      </mtd>
                      <mtd>
                        <mi>I</mi>
                      </mtd>
                    </mtr>
                  </mtable>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mn>3</mn>
          <mo>)</mo>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.8em" height="0.8ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>alarm</mi>
            <mo>⁢</mo>
            <mrow>
              <mstyle>
                <mspace width="0.6em" height="0.6ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.6em" height="0.6ex"/>
              </mstyle>
            </mrow>
            <mo>⁢</mo>
            <mi>task</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
where:
</p>
<p id="p-0159" num="0159">m<sub>ij</sub>=A if the move from Node i to Node j is authorized;</p>
<p id="p-0160" num="0160">m<sub>ij</sub>=I if the move from Node i to Node j is inhibited.</p>
<p id="p-0161" num="0161"><figref idref="DRAWINGS">FIG. 11</figref> is a timing chart showing an implementation of the two above-described communicating tasks, showing the associated time values. Numbers 1 to 10 specify real time in number of time units since the beginning of operation in time-triggered mode.</p>
<p id="p-0162" num="0162">Only one type of message is stored in a given message queue. A message visibility time dV is associated with each message sent. The time dV specifies the future instant from which the destination can consume the message. Messages are consumed in order of visibility time dV, then in order of sender name, and finally in send order, thus making it possible to order messages fully for consumption purposes.</p>
<p id="p-0163" num="0163">For each message queue, there exists a send zone in the context of each sender and a receive zone for the owner of the message queue concerned.</p>
<p id="p-0164" num="0164">Since each producer (sender) has a send zone, there is no problem of conflict between two messages being sent by two different tasks.</p>
<p id="p-0165" num="0165">Furthermore, as mentioned above, segmenting the memory makes it possible for the impact of a failure of a task to be restricted to its own memory space. Failure propagation from one task to other tasks in the application is thus impossible.</p>
<p id="p-0166" num="0166">The use of memory segmentation also makes it possible to obtain the following property: within a time interval of the time triggering (TT) of a task, the execution context of the task is invariant between the beginning of a new instruction and the end of the preceding instruction.</p>
<p id="p-0167" num="0167">Memory segmentation is applied to the system layer itself so as to partition it internally and thus partition the micro-kernel from the remainder of the system layer.</p>
<p id="p-0168" num="0168">The memory protection unit <b>16</b> constitutes the hardware mechanism which makes it possible to enforce memory segmentation from the physical architecture point of view.</p>
<p id="p-0169" num="0169"><figref idref="DRAWINGS">FIG. 2</figref> shows the resulting distribution of code depth going from application level with user execution mode <b>201</b> (i.e. non-privileged mode) up to the micro-kernel <b>203</b>, passing via the system layer <b>202</b>, with privileged execution mode.</p>
<p id="p-0170" num="0170">Access to the system layer <b>202</b> with privileged execution mode is protected by a “trap” type branch instruction, while passage from the system layer <b>202</b> to the micro-kernel <b>203</b> is triggered by a move type instruction.</p>
<p id="p-0171" num="0171">The clock <b>14</b> provides time triggering and issues a clock interrupt signal sh whenever a programmable quantity of time has elapsed.</p>
<p id="p-0172" num="0172"><figref idref="DRAWINGS">FIG. 2</figref> thus shows the code and the data of the various tasks at application level <b>201</b>, whereas in system layer level <b>202</b> there can be found the extensions of task contexts into the system layer and also the code of the system layer. In micro-kernel level <b>213</b>, there can be found the data and the code of the micro-kernel for managing the allocation of the processor to the task, and for managing time.</p>
<p id="p-0173" num="0173">Reference is now made to <figref idref="DRAWINGS">FIG. 14</figref> which is a detailed table showing the rights of the various segments in an implementation of the security method of the invention to segmented memory.</p>
<p id="p-0174" num="0174">As mentioned above, a multitask application comprises specific code, tasks, streams of time variables, message boxes, a system layer for transferring information between tasks, a graph executor which monitors movements of tasks in the application code, and a micro-kernel for managing time and processor sharing.</p>
<p id="p-0175" num="0175">The memory is subdivided into segments having access rights that depend on the execution context of the processor.</p>
<p id="p-0176" num="0176">To understand the table of <figref idref="DRAWINGS">FIG. 14</figref>, the following definitions apply:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0177">.inst: a set of consecutive instructions in memory;</li>
    <li id="ul0003-0002" num="0178">.const: a set of consecutive data items of constant values;</li>
    <li id="ul0003-0003" num="0179">.var: a set of consecutive data items modifiable by instructions:</li>
    <li id="ul0003-0004" num="0180">I: entitled to execute the instructions of the segment;</li>
    <li id="ul0003-0005" num="0181">M: entitled to modify and consult the segment;</li>
    <li id="ul0003-0006" num="0182">C: access rights to the segment restricted to consultation (read-only);</li>
    <li id="ul0003-0007" num="0183">R: access to the segment is refused.</li>
</ul>
</p>
<p id="p-0177" num="0184">The segments are grouped together in zones depending on whether they are application-specific or linked with the model of the invention to the CPU <b>10</b> and its processor.</p>
<p id="p-0178" num="0185">For each task, there are successive application zones CT, FT, BM, ME, VT, and PU. These application zones are described as follows:</p>
<p id="h-0001" num="0000">Task Calculation Zone CT:</p>
<p id="p-0179" num="0000">
<ul id="ul0004" list-style="none">
    <li id="ul0004-0001" num="0186">.const and .var: task data including its stack in non-privileged mode;</li>
    <li id="ul0004-0002" num="0187">.inst: task calculations.
<br/>
Task Operating Zone FT:
</li>
    <li id="ul0004-0003" num="0188">.const: description of the operation of the task (execution graph, node descriptions, due times, time increments as calculated by the CPU, . . . );</li>
    <li id="ul0004-0004" num="0189">.var: zone for passing arguments to the system layer;</li>
    <li id="ul0004-0005" num="0190">.inst: functions requesting a change of node from the system layer.
<br/>
Message Box Zone BM:
</li>
    <li id="ul0004-0006" num="0191">.const: the characteristics of each message box of the task, including connections to the send zones (zones ME);</li>
    <li id="ul0004-0007" num="0192">.var: all of the messages that are accessible to the task at the present instant.
<br/>
Message Storage Zone ME:
</li>
    <li id="ul0004-0008" num="0193">.const: the descriptions of storage zones for messages sent by the task and not visible to destination tasks;</li>
    <li id="ul0004-0009" num="0194">.var: the storage zones themselves.
<br/>
Time Variable Zone VT:
</li>
    <li id="ul0004-0010" num="0195">.const: the descriptions of storage zones for the task, the values of the streams of time variables visible to the task including connections to the zones that produce the values;</li>
    <li id="ul0004-0011" num="0196">.var: storage zones for the task for visible values that have been passed.
<br/>
Zone PU:
</li>
    <li id="ul0004-0012" num="0197">.var: temporary working data needed by the processor, the current context of the task, the privileged mode stack.</li>
</ul>
</p>
<p id="p-0180" num="0198">There is also a global application zone common to all of the tasks, and described as follows:</p>
<p id="h-0002" num="0000">Global Zone G:</p>
<p id="p-0181" num="0000">
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0199">.const: descriptions of the global constants of the application (number of tasks, references of task descriptors, descriptions of clocks, . . . ) and the constants providing an interface with the system layer.</li>
</ul>
</p>
<p id="p-0182" num="0200">The system layer itself comprises a zone CS which is described as follows:</p>
<p id="h-0003" num="0000">System Layer Zone CS:</p>
<p id="p-0183" num="0000">
<ul id="ul0006" list-style="none">
    <li id="ul0006-0001" num="0201">.const: for reference;</li>
    <li id="ul0006-0002" num="0202">.var: empty (the past is stored in the segment var of the zone PU);</li>
    <li id="ul0006-0003" num="0203">.inst: the instructions for the graph executor, for managing the message boxes, for making available the passed values of the streams of time variables, and the instructions for managing the clocks and calculating due times.</li>
</ul>
</p>
<p id="p-0184" num="0204">The transfer zone TR common to the system layer is described as follows:</p>
<p id="h-0004" num="0000">Transfer Time TR:</p>
<p id="p-0185" num="0000">
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0205">.const: for reference;</li>
    <li id="ul0007-0002" num="0206">.var: the identity of the active task;</li>
    <li id="ul0007-0003" num="0207">.inst: instructions for changing the hardware access right to the memory and for branching into the system layer or the micro-kernel.</li>
</ul>
</p>
<p id="p-0186" num="0208">The micro-kernel comprises zones MN and RS which are described as follows:</p>
<p id="h-0005" num="0000">Zone MN:</p>
<p id="p-0187" num="0000">
<ul id="ul0008" list-style="none">
    <li id="ul0008-0001" num="0209">.const: for reference;</li>
    <li id="ul0008-0002" num="0210">.var: the data needed for managing hardware (managing time, managing “trap” instructions, . . . );</li>
    <li id="ul0008-0003" num="0211">.inst: instructions for managing sets of ready or resting tasks as a function of due times, backing up and changing hardware context, managing clock interrupts for exhausted right to use the processor, and implementing the memory protection function available on the CPU.
<br/>
Zone RS:
</li>
    <li id="ul0008-0004" num="0212">.const: for reference;</li>
    <li id="ul0008-0005" num="0213">.var: empty;</li>
    <li id="ul0008-0006" num="0214">.inst: instructions for initializing the CPU and the software which executes without memory protection.</li>
</ul>
</p>
<p id="p-0188" num="0215">At a given instant, the processor executes instructions either on behalf of a task in the application code (in non-privileged mode), or for a task in the system layer (in privileged mode), or in the micro-kernel.</p>
<p id="p-0189" num="0216">The rows of the table of <figref idref="DRAWINGS">FIG. 14</figref> represent, the segments of a task, then those of the system layer, and finally those of the micro-kernel, as defined above. The columns represent access rights to the memory depending on whether the processor is executing instructions of the application code of the task (column <b>301</b>), code of the system layer for the task (column <b>302</b>), code of the system layer for another task (column <b>303</b>), or code of the micro-kernel after initialization of the CPU (column <b>304</b>).</p>
<p id="p-0190" num="0217">In general, the memory can be subdivided into pages, and a page can be write-protected, absent, or available. In this situation, segment sizes are rounded to multiples of one page, .const and .var are merged and write-protected, and pages whose access rights are R are either absent or else removed from the description.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US07299383-20071120-M00001.NB">
<img id="EMI-M00001" he="15.16mm" wi="76.20mm" file="US07299383-20071120-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US07299383-20071120-M00002.NB">
<img id="EMI-M00002" he="31.75mm" wi="76.20mm" file="US07299383-20071120-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A security method making real time execution of multitask applications of the control and command type in a control system deterministic, the method comprising:
<claim-text>at least a first clock that issues an interrupt signal sh whenever an adjustable quantity of time has elapsed;</claim-text>
<claim-text>a CPU having at least one processor capable of receiving at least said clock interrupt signal sh;</claim-text>
<claim-text>a main memory; and</claim-text>
<claim-text>a set of controllers (<b>1</b><sub>1 </sub>to <b>1</b><sub>N</sub>) for controlling peripherals (<b>1</b> to N) for managing inputs/outputs of the control system,</claim-text>
<claim-text>the method being characterized in that it comprises the following steps:</claim-text>
<claim-text>for each of the tasks of a given application, storing all of the chaining that is authorized from each time synchronization point of the task that requires a call to a system layer, said chaining being represented by a control graph for monitoring the execution of system layer calls made by the task in question, each control graph comprising a set of nodes each corresponding to a call to the system layer of the control system;</claim-text>
<claim-text>for each node of the control graph of each task, storing the nature of the call to the system layer and its call parameters, including time parameters enabling “earliest start” times d(i) and “latest finish” times f(i) to be updated;</claim-text>
<claim-text>for each task, storing an initial node (Node <b>0</b>) in the associated graph;</claim-text>
<claim-text>for the given application and prior to starting real time execution in a time-triggered mode, initializing, for each task, the initial node (Node <b>0</b>) and the initial instant representing the initial state of the task in question;</claim-text>
<claim-text>for the given application and prior to starting real time execution in a time-triggered mode, initializing the starting order of each of the tasks by pre-ordering lists of tasks in an atomic micro-kernel;</claim-text>
<claim-text>setting the first clock to issue a clock interrupt signal sh constituting a call to the micro-kernel, on the first instant of the application for starting execution of said application in time-triggered mode;</claim-text>
<claim-text>during normal operation after the first clock has been set, causing the first clock to be reset by the micro-kernel on each call to the micro-kernel; during a call to the micro-kernel by the system layer or by processing the interrupt signal sh, causing the micro-kernel to go to the step of updating the lists of tasks in ordered manner depending on the time characteristics of the tasks, namely their earliest start times d(i) and their latest finish times f(i); and after updating the list, causing the micro-kernel to calculate the nearest future instant on which a task needs to be woken up and causing the first clock to be set by the micro-kernel on the basis of said nearest future instant to wake up said task and leave the micro-kernel; and</claim-text>
<claim-text>while executing a task, making a call to the system layer only when a node of the control graph of said task is reached, and passing as an argument the number of the node; proceeding on entry into the system layer with a check to verify whether, according to the control graph of the task being executed, the chaining from the node corresponding to the preceding system layer call is authorized, in order to launch anomaly processing in the system layer if said chaining is not authorized or to continue with execution if said chaining is authorized, updating the time parameters of the task being executed comprising the earliest start time d(i) and the latest finish time f(i) using calls to the micro-kernel from the system layer, and continuing normal execution of the current task until said task again reaches a node of its control graph.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A control system implementing the security method in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a memory protection unit for controlling addressing access rights, which memory protection unit responds to a requested address ad supplied by the CPU and to the rights (C) of the execution context of the processor to access the addressable memory space, by producing in exclusive manner either a validated address av giving access, or else issuing an exception signal se to the CPU indicative of authorized addressing, and in that it further comprises the following steps:
<claim-text>during a preparatory stage, for a given application, storing the access rights to each of the memory segments for the micro-kernel and for each application task and for the extension of each task in the system layer so as to constitute first and second execution contexts depending on whether the instructions are in the code specific to the application constituting the task or the instructions are located in generic code of the system layer constituting the extension of the task in the system layer;</claim-text>
<claim-text>for a given application and prior to starting real time execution in a time-triggered operating mode, initializing the micro-kernel context and the first and second execution context for each task and for its extension in the system layer; and</claim-text>
<claim-text>during execution of a task, making a call to the system layer using an instruction for passing into a privileged mode of execution which makes it possible to pass from the execution context of the task to the execution context of its extension in the system layer, and after verifying that chaining from the node corresponding to the preceding system call is authorized, and after updating the time parameters of the task using calls to the micro-kernel from the system layer, returning to the code of the task by means of an instruction for returning into the non-privileged mode enabling execution to pass from the execution context of the extension in the system layer to the execution context of the task.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, characterized in that the execution contexts of each application task are disjoint in pairs.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, characterized in that the extensions of the execution contexts of the application tasks into the system layer are not write accessible to the execution contexts of the tasks in the application code.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, characterized in that the coding of the control graph of a task prevents any failure of common cause occurring both in the mechanism for controlling execution of any task of the application and in the execution of said task itself.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, characterized in that it further comprises the following steps:
<claim-text>during a preparatory stage, for each given application, and for all of the authorized chainings in said task, storing a time quota constituting a supremum for the maximum execution time needed for going from one node to the other in the control graph of the task, each of these time quotas covering both the time passed in executing the instructions specific to the task, and also the time passed in executing the generic code of the system layer in the extension of the task; and</claim-text>
<claim-text>during normal operation, after the first clock has been set, in the event of a call to the micro-kernel triggered by the time interrupt signal sh and causing the first clock to be reset, checking to verify whether the time interrupt signal sh triggering the call to the micro-kernel is associated with an attempt at violating a time quota, and if so, causing the micro-kernel to run anomaly processing, else if the time interrupt signal sh is not associated with an attempt to violate a time quota, causing the micro-kernel to update the task lists, and after updating the task lists, to calculate both the nearest future instants at which a task needs to be woken up and the future instants at which the quota of time allocated to the task that will be executing on exiting the micro-kernel will have expired, which time is determined while updating the lists, and causing the micro-kernel to set the first clock to the nearer of said future instants so that either the task is woken up or else an attempt at violating time quota due to anomalous operation is detected, and leaving the micro-kernel after setting the first clock.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, characterized in that a second clock is implemented, and in that the micro-kernel is caused to access the second clock to monitor the flows of time as triggered by the first clock by comparing the time signals.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A security method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, causing the real time execution of communicating multitask applications of the control and command type to be made deterministic, the method being characterized in that it further comprises the following steps:
<claim-text>during a preparatory stage, for each of the tasks of a given application storing all of the authorized chainings of its points for time synchronization and for communication with the other tasks of the application requiring a call to the system layer, these authorized chaining being represented by a control graph for the execution of system layer calls made by the task in question, each graph comprising a set of nodes, each corresponding to a call to the system layer;</claim-text>
<claim-text>storing each buffer zone needed for exchanging data between tasks, specifying its size, the size of the elements that it contains, its location or base address, and also the relationships between the buffer zones enabling the information transfers needed for communications to be confirmed;</claim-text>
<claim-text>storing, for each buffer zone, the initial values of its elements;</claim-text>
<claim-text>for the given application and prior to starting real time execution in a time-triggering operating mode, initializing the values of the elements of the buffer zone with values previously stored in memory; and</claim-text>
<claim-text>during execution of a task, while making a system layer call when a node of the task control graph is reached and after verifying that according to the control graph of the task currently being executed the chaining from the node corresponding to the preceding system layer call is authorized, causing buffer zones to be updated in succession as a function of the nature of the previously-stored call and performing incremental updates as necessary of the time parameters of the task being executed, comprising its earliest start time d(i) and its latest finish time f(i).</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method according to <claim-ref idref="CLM-00002">claim 2</claim-ref> for causing the real time execution of communicating multitask applications of the control and command type to be made deterministic, characterized in that during a preparatory stage, for each of the tasks of a given application storing all of the authorized chainings of its points for time synchronization and for communication with the other tasks of the application requiring a call to the system layer, these authorized chaining being represented by a control graph for the execution of system layer calls made by the task in question, each graph comprising a set of nodes, each corresponding to a call to the system layer;
<claim-text>storing each buffer zone needed for exchanging data between tasks, specifying its size, the size of the elements that it contains, its location or base address, and also the relationships between the buffer zones enabling the information transfers needed for communications to be confirmed;</claim-text>
<claim-text>storing, for each buffer zone, the initial values of its elements;</claim-text>
<claim-text>for the given application and prior to starting real time execution in a time-triggering operating mode, initializing the values of the elements of the buffer zone with values previously stored in memory; and</claim-text>
<claim-text>during execution of a task, while making a system layer call when a node of the task control graph is reached and after verifying that according to the control graph of the task currently being executed the chaining from the node corresponding to the preceding system layer call is authorized, causing buffer zones to be updated in succession as a function of the nature of the previously-stored call and performing incremental updates as necessary of the time parameters of the task being executed, comprising its earliest start time d(i) and its latest finish time f(i); and</claim-text>
<claim-text>further characterized in that in the system layer, only the buffer zones are allowed to be shared by the extensions of the execution contexts of the tasks of an application, a given buffer zone for dynamic communications corresponding to sending messages being sharable only by two task execution context extensions, while a given buffer zone for static communications corresponding to a stream of time-stamped data can be shared by more than two task execution context extensions, but can be written to or modified by a single context only.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A control and command system implementing the security method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further having a safety class level 1E, for a nuclear reactor.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, characterized in that the extensions of the execution contexts of the application tasks into the system layer are not write accessible to the execution contexts of the tasks in the application code.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, characterized in that:
<claim-text>the extensions of the execution contexts of the application tasks into the system layer are not write accessible to the execution contexts of the tasks in the application code;</claim-text>
<claim-text>the coding of the control graph of a task prevents any failure of common cause occurring both in the mechanism for controlling execution of any task of the application and in the execution of said task itself;</claim-text>
<claim-text>it further comprises the following steps:</claim-text>
<claim-text>during a preparatory stage, for each given application, and for all of the authorized chainings in said task, storing a time quota constituting a supremum for the maximum execution time needed for going from one node to the other in the control graph of the task, each of these time quotas covering both the time passed in executing the instructions specific to the task, and also the time passed in executing the generic code of the system layer in the extension of the task; and</claim-text>
<claim-text>during normal operation, after the first clock has been set, in the event of a call to the micro-kernel triggered by the time interrupt signal sh and causing the first clock to be reset, checking to verify whether the time interrupt signal sh triggering the call to the micro-kernel is associated with an attempt at violating a time quota, and if so, causing the micro-kernel to run anomaly processing, else if the time interrupt signal sh is not associated with an attempt to violate a time quota, causing the micro-kernel to update the task lists, and after updating the task lists, to calculate both the nearest future instants at which a task needs to be woken up and the future instants at which the quota of time allocated to the task that will be executing on exiting the micro-kernel will have expired, which time is determined while updating the lists, and causing the micro-kernel to set the first clock to the nearer of said future instants so that either the task is woken up or else an attempt at violating time quota due to anomalous operation is detected, and leaving the micro-kernel after setting the first clock;</claim-text>
<claim-text>a second clock is implemented, and in that the micro-kernel is caused to access the second clock to monitor the flows of time as triggered by the first clock by comparing the time signals.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A security method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, causing the real time execution of communicating multitask applications of the control and command type to be made deterministic, the method being characterized in that it further comprises the following steps:
<claim-text>during a preparatory stage, f or each of the tasks of a given application storing all of the authorized chainings of its points for time synchronization and for communication with the other tasks of the application requiring a call to the system layer, these authorized chaining being represented by a control graph for the execution of system layer calls made by the task in question, each graph comprising a set of nodes, each corresponding to a call to the system layer;</claim-text>
<claim-text>storing each buffer zone needed for exchanging data between tasks, specifying its size, the size of the elements that it contains, its location or base address, and also the relationships between the buffer zones enabling the information transfers needed for communications to be confirmed;</claim-text>
<claim-text>storing, for each buffer zone, the initial values of its elements;</claim-text>
<claim-text>for the given application and prior to starting real time execution in a time-triggering operating mode, initializing the values of the elements of the buffer zone with values previously stored in memory; and</claim-text>
<claim-text>during execution of a task, while making a system layer call when a node of the task control graph is reached and after verifying that according to the control graph of the task currently being executed the chaining from the node corresponding to the preceding system layer call is authorized, causing buffer zones to be updated in succession as a function of the nature of the previously-stored call and performing incremental updates as necessary of the time parameters of the task being executed, comprising its earliest start time d(i) and its latest finish time f(i).</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
