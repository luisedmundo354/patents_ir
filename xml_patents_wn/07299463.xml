<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299463-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299463</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>09967093</doc-number>
<date>20010928</date>
</document-id>
</application-reference>
<us-application-series-code>09</us-application-series-code>
<us-term-of-grant>
<us-term-extension>457</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717169</main-classification>
<further-classification>717131</further-classification>
</classification-national>
<invention-title id="d0e53">Method for atomically updating a plurality of files</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5150473</doc-number>
<kind>A</kind>
<name>Zulch</name>
<date>19920900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5404485</doc-number>
<kind>A</kind>
<name>Ban</name>
<date>19950400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5835761</doc-number>
<kind>A</kind>
<name>Ishii et al.</name>
<date>19981100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5930504</doc-number>
<kind>A</kind>
<name>Gabel</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6167567</doc-number>
<kind>A</kind>
<name>Chiles et al.</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717173</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6260156</doc-number>
<kind>B1</kind>
<name>Garvin et al.</name>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6282709</doc-number>
<kind>B1</kind>
<name>Reha et al.</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717175</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6467087</doc-number>
<kind>B1</kind>
<name>Yang</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717168</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6536038</doc-number>
<kind>B1</kind>
<name>Ewertz et al.</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717168</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6640334</doc-number>
<kind>B1</kind>
<name>Rasmussen</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717171</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6678741</doc-number>
<kind>B1</kind>
<name>Northcutt et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709248</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6718407</doc-number>
<kind>B2</kind>
<name>Martwick</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717168</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6889340</doc-number>
<kind>B1</kind>
<name>Bramley, Jr.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  6</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>EP</country>
<doc-number>0 723 226</doc-number>
<kind>A1</kind>
<date>19960700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>GB</country>
<doc-number>2 354 863</doc-number>
<kind>A</kind>
<date>20010400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>WO</country>
<doc-number>PCT/US 02/30883</doc-number>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>IBM, “A Technical Introduction to PCI-Based RS/6000 Servers”, IBM International Technical Support Organization, Austin Center, pp. i-xxi, 1-194, 1996.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
</references-cited>
<number-of-claims>27</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>717167-178</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717120-122</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717131</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707203</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>710  8</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713  2</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>703203</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>16</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030066062</doc-number>
<kind>A1</kind>
<date>20030403</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Brannock</last-name>
<first-name>Kirk D.</first-name>
<address>
<city>Olympia</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Stevens</last-name>
<first-name>William A.</first-name>
<address>
<city>Folsom</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Blakely, Sokoloff, Taylor &amp; Zafman LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Intel Corporation</orgname>
<role>02</role>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Vo</last-name>
<first-name>Ted</first-name>
<department>2191</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method for updating platform firmware is disclosed. This capability is facilitated by a standard software abstraction for a firmware storage device, known as Firmware Volume (FV) that is managed through a Firmware File System (FFS). The FFS enables firmware files to be created, deleted, and updated individually. The FFS also enables a plurality of firmware files to be updated atomically by managing file state information via state bits stored in a file header of each firmware file, whereby an atomic change to a single state bit simultaneously causes the FFS to use an updated set of firmware files in place of an original set of firmware files.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="127.59mm" wi="187.11mm" file="US07299463-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="183.22mm" wi="181.02mm" file="US07299463-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="252.31mm" wi="197.36mm" file="US07299463-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="259.25mm" wi="150.96mm" file="US07299463-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="267.72mm" wi="189.23mm" file="US07299463-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="271.95mm" wi="202.27mm" file="US07299463-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="259.84mm" wi="190.58mm" file="US07299463-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="189.99mm" wi="151.81mm" file="US07299463-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="223.27mm" wi="174.41mm" file="US07299463-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="223.60mm" wi="183.90mm" file="US07299463-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="239.35mm" wi="194.14mm" file="US07299463-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="236.14mm" wi="196.17mm" file="US07299463-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="179.83mm" wi="178.05mm" file="US07299463-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention concerns computer systems in general, and the management of platform firmware in particular.</p>
<p id="p-0004" num="0003">2. Background Information</p>
<p id="p-0005" num="0004">Computer platform firmware is used during initialization of computer systems to verify system integrity and configuration. It also generally provides the basic low-level interface between hardware and software components of those computer systems, enabling specific hardware functions to be implemented via execution of higher-level software instructions contains in computer programs that run on the computer systems. In computers, a primary portion of this firmware is known as the Basic Input/Output System (BIOS) code of a computer system. The BIOS code comprises a set of permanently recorded (or semi-permanently recorded in the case of systems that use Flash Memory BIOS) software routines that provides the system with its fundamental operational characteristics, including instructions telling the computer how to test itself when it is turned on, and how to determine the configurations for various of built-in components and add-on peripherals.</p>
<p id="p-0006" num="0005">In a typical PC architecture, the BIOS is generally defined as the firmware that runs between the processor reset and the first instruction of the Operating System (OS) loader. As shown in <figref idref="DRAWINGS">FIG. 1</figref>, in a typical PC <b>10</b>, the base portion of the BIOS code is stored in some type of ROM (read only memory) device on the PC's motherboard <b>12</b>, such as a standard PROM <b>14</b> or a Flash Memory <b>16</b>. In some configurations, this base portion may be extended using code stored in ROM BIOS chips <b>18</b> contained on one or more add-on peripheral cards <b>20</b>, such as SCSI controllers and bus-mastering devices. This portion of the BIOS is stored in components that are commonly referred to as “option ROMs.” The BIOS code in peripheral card ROM BIOS chips <b>18</b> typically concerns specific functionality provided by their corresponding peripheral card and is executed during initialization of that peripheral card according to a well-defined (mostly) set of rules. In either of the foregoing configurations, all BIOS firmware is stored locally, either on the motherboard or in option ROMs on the peripheral card(s) added to a system.</p>
<p id="p-0007" num="0006">In many instances, the basic functionality of a computer system platform is defined by the platform's firmware. Accordingly, in order to enhance this functionality, corresponding code needs to be added to or modified in the firmware. In today's PC's, this may be accomplished by either replacing the BIOS chip(s) on the motherboard (and/or peripheral cards), or, if the BIOS code is contained in rewritable chips (e.g., Flash Memory), executing a BIOS update software program that rewrites (overwrites) the BIOS code.</p>
<p id="p-0008" num="0007">Both of these methods may be prone to error. Replacement of a BIOS chip by a novice user may lead to several problems, including improper insertion of the new chip, damage of the new chip, damage of the socket, static electricity damage to the new chip and/or existing chips on the motherboard. Popular methods for updating the BIOS code stored on a flash component also have risks. For instance, a user may try to update the BIOS code with an inappropriate set of new code, or a crash could occur in the middle of the update process. Typically, the BIOS code will be stored as a monolithic chunk of code that gets replaced in its entirety by a new monolithic chunk of code. When the BIOS code is stored on a flash component, the memory blocks corresponding to the portions of memory that are to contain the new BIOS code must first be cleared (i.e., reset to all 1's) prior to rewriting the memory. This clearing process wipes out the existing BIOS code. As a result, if a failure occurs in the middle of a rewrite or update, the BIOS code will be corrupt. Suppose a power system failure occurs that causes the user to have to reboot the computer system. Since the BIOS code is typically needed to complete the boot process, the user may not be able to boot the computer system to fix the problem, or an emergency repair disk (that the user often doesn't have) may be need to enable the problem to be fixed.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0009" num="0008">The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same becomes better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic diagram illustrating how BIOS firmware is stored in a conventional personal computer;</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic diagram illustrating an exemplary firmware volume firmware storage scheme and associated file system under which the invention may be implemented;</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 3</figref> is flowchart for illustrating the logic used by the invention when creating a new file in the firmware volume;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIGS. 4 and 5</figref> are schematic diagrams illustrating the sequential changes in a file header and the memory space of a firmware volume when a new file is created in the firmware volume;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 6</figref> is a schematic diagram illustrating how a file is deleted under the firmware file system in accordance with one embodiment of the present invention;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating the logic used by one embodiment of the invention when updating an existing file in the firmware volume;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. 8 and 9</figref> are schematic diagrams illustrating the sequential changes in a file header and the memory space of a firmware volume when a new file is created in the firmware volume;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart illustrating the logic used by one embodiment of the invention when creating a file through use of a temporary pad file;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating the logic used by one embodiment of the invention when updating a file using a temporary pad file;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating the logic used by the invention when updating a plurality of files;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. 13-15</figref> are schematic diagrams illustrating the sequential changes in a file header and the memory space of a firmware volume when a plurality of files are updated in the firmware volume; and</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 16</figref> is a schematic diagram of a personal computer system suitable for implementing the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0003" level="1">DETAILED DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS</heading>
<p id="p-0022" num="0021">In the following description, numerous specific details are provided to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, etc. In other instances, well-known structures or operations are not shown or described in detail to avoid obscuring aspects of various embodiments of the invention.</p>
<p id="p-0023" num="0022">Reference throughout this specification to “one embodiment” or “an embodiment” means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases “in one embodiment” or “in an embodiment” in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.</p>
<p id="h-0004" num="0000">Extensible Firmware Interface and Firmware Volumes</p>
<p id="p-0024" num="0023">Recently, the Intel Corporation has introduced a new firmware paradigm that enables firmware storage to be extended beyond the traditional monolithic storage schemes found in the prior art. This is enabled, in part, by the Extensible Firmware Interface, or EFI. As its name indicates, the EFI enables firmware to be “extended” through use of a standardized software interface.</p>
<p id="p-0025" num="0024">One means for extending firmware is facilitated by a standard software abstraction for a firmware storage device, known as a Firmware Volume (FV). Since the FV firmware storage abstraction is not tied to any specific type of hardware, it can be used to produce firmware components to the BIOS from almost any type of firmware device. For example, in a given system, one FV may represent a Flash Memory part, while another may represent a disk partition, while yet a third may represent a remote directory on a server. A single computer system may have one or more FV's stored on one or more types of hardware.</p>
<p id="p-0026" num="0025">The portions of the BIOS firmware code that are part of a FV are managed by a Firmware File System (FFS). The FFS enables one to manipulate firmware files that make up a FV. The FFS may be used for retrieving, creating, updating, and deleting firmware files. Generally, a FFS may be stored on any persistent memory device, including flash devices, disk partitions, and remote storage devices accessed via a network.</p>
<p id="p-0027" num="0026">In the following paragraphs and related Figures, various embodiments of the invention are discussed with reference to a FV stored on a flash memory device. Those skilled in the art will understand that the invention may be implemented in other types of persistent storage devices for maintaining firmware code and/or data, and the embodiments of the invention using flash devices discussed below are merely exemplary schemes for practicing the invention.</p>
<p id="p-0028" num="0027">Flash Memory is a non-volatile memory technology that allows manufactures and (with the appropriate hardware/software) end users to electrically program and erase information. Flash Memory is typically erased in units of memory called blocks instead of being erased at the bit level, wherein all bits in a given block are switched to predetermined polarity (i.e., logic level) when the block is erased. In one common type of flash memory, such as flash memory devices manufactured by Intel, blocks of memory are erased electronically by setting all bits in a block to 1's. Data can then be written to the block by flipping individual bits to 0's. In other types of flash devices, the erased logic state is all 0's, and writing data to these devices comprising changing individual bits to 1's. It is noted that in conventional flash devices, individual bits cannot be flipped from a changed (i.e., set) logic level back to the erased logic level; in order to updated data in a block, all of the bits have to be erased first, and then rewritten.</p>
<p id="p-0029" num="0028">An exemplary FV <b>22</b> stored on a flash device that uses 1's for its erased state is shown in <figref idref="DRAWINGS">FIG. 2</figref>. FV <b>22</b> includes a FV header <b>24</b> and a plurality of FFS files <b>25</b>. The start of FV header <b>24</b> is stored at the lowest memory address of the flash device, while each FFS file <b>25</b> begins on the next byte boundary following the end of an immediately preceding file or file header (when applicable). In one embodiment, byte boundaries occur every 8 bytes, and files sizes have 8 byte increments. Included among FFS files <b>25</b> is a deleted file <b>26</b>. As explained in further detail below, deleted file <b>26</b> includes a file header that identifies that the file is considered by the FFS to be deleted, even though the deleted file's data may still exist in the FV in the same state that is was before the file was marked as deleted. In general, FFS files <b>25</b> are written sequentially, wherein free space <b>28</b> represents any remaining available space in the FV, and is located toward the top address portion (i.e., the higher memory addresses) of the flash device.</p>
<p id="p-0030" num="0029">FV header <b>24</b> includes a plurality of data fields, including an attributes field <b>30</b>, a header length field <b>32</b>, a FV length field <b>34</b>, a FileSystemID field <b>36</b>, a checksum field <b>38</b>, and an FVBlockMap field <b>40</b>. Attributes field <b>30</b> includes a plurality of bits that include Read/Write capabilities, power-on state, “sticky” write data, a memory mapped flag, and an erase polarity identifier. Header length field <b>32</b> contains the length of the FV header in bytes. FV length field <b>34</b> contains the length of the entire FV in bytes. FileSystemID field <b>36</b> declares what file system the FV is formatted with. Checksum field <b>38</b> comprises a 16-bit checksum of the entire FV header. FVBlockMap field <b>40</b> comprises an array of run-length-encoded block structure descriptors, including a plurality of tuples {NumBlocks, Blocklength} terminated by a {0, 0} tuple.</p>
<p id="p-0031" num="0030">Each FFS file <b>25</b> includes an FFS header <b>42</b> and file data <b>44</b>. Optionally, file data <b>44</b> may include a tail <b>45</b>, which is used for file integrity checking purposes. FFS header <b>42</b> includes various data fields, including a name field <b>46</b>, an IntegrityCheck field <b>47</b>, a type field <b>48</b>, an attributes field <b>49</b>, a size field <b>50</b>, and a state field <b>51</b>. In one embodiment, name <b>46</b> comprises a GUID (Globally Unique Identifier) that is issued by the firmware file system, and is guaranteed to be unique within the firmware volume. IntegrityCheck field <b>47</b> contains data that is used to verify the integrity of files, as explained in further detail below. Type field <b>48</b> identifies the file type and internal format of the file, such as a DXE driver, PEIM, etc. Size field <b>50</b> contains the length of the file (including the file header) in bytes.</p>
<p id="p-0032" num="0031">Files in the FV are located using a chaining mechanism, wherein the length of a current file is added to the starting address of the file to locate the start of the next file in the chain. In addition, the first file in the FV immediately proceeds the end of FV header <b>24</b>, wherein the address of the first file is determined based by the value in FV length <b>34</b>.</p>
<p id="p-0033" num="0032">As depicted toward the upper right corner of <figref idref="DRAWINGS">FIG. 2</figref>, attributes field <b>49</b> includes six data bits (plus two reserved bits) that define various attributes of the file. These attribute bits include a file tail present bit <b>52</b>, a file recovery bit <b>53</b>, a header extension bit <b>54</b>, and a 3-bit data alignment subfield <b>55</b> comprising bits <b>2</b>, <b>3</b>, and <b>4</b> of attributes field <b>49</b>. Attributes field <b>49</b> also includes two reserved bits <b>56</b> and <b>57</b>.</p>
<p id="p-0034" num="0033">File tail present bit <b>52</b> indicates that a 16-bit file tail <b>45</b> exists at the end of the file. Recovery bit <b>53</b> indicates the file is required to execute a crisis recovery. Header extension bit <b>54</b> is reserved for future extensions. Data alignment subfield <b>55</b> comprises a 3-bit field that indicates how the beginning of the data is to be aligned on a particular boundary relative to the FV base. The three bits in this field provide an enumeration of alignment possibilities, such as an 8-byte alignment.</p>
<p id="p-0035" num="0034">Further details of state field <b>51</b> are shown in the lower right hand portion of <figref idref="DRAWINGS">FIG. 2</figref>. State field <b>51</b> is an eight-bit field that includes six state bits that are used to track the current state of a file operation, which are used during file creation, deletion, and updates. The state bits include an FFS under construction bit <b>58</b> (bit <b>0</b>), a FFS header valid bit <b>59</b> (bit <b>1</b>), a data area valid bit <b>60</b> (bit <b>2</b>), a file marked for update bit <b>61</b> (bit <b>3</b>), a file deleted bit <b>62</b> (bit <b>4</b>), and an FFS header invalid bit <b>65</b> (bit <b>5</b>). In addition to these state bits, bits <b>6</b> and <b>7</b> (not shown) are left in the erased state (i.e., logic level FALSE) throughout all operations. In all state change operations described below, all state bits transitions are atomic operations, i.e., the logic level of only one state bit is changed at a time for a given file state change. In addition, the transition of a given bit to TRUE must be fully complete before any additional writes to the firmware volume are made. Furthermore, except where specifically noted, only the most significant state bit that is set to TRUE has meaning. Accordingly, lower-order state bits are superceded by higher-order state bits.</p>
<p id="h-0005" num="0000">File Creation</p>
<p id="p-0036" num="0035">With reference to the flowchart of <figref idref="DRAWINGS">FIG. 3</figref> and <figref idref="DRAWINGS">FIGS. 4 and 5</figref>, creation of a new file proceeds in the following manner. A new field is created by allocating space from the FV immediately beyond the end of a preceding file (or firmware volume header <b>24</b> if the new file is the first file written to the FV). Suppose FV <b>22</b> initially includes a single file X (<b>68</b>), and a new file Y is to be added. Accordingly, the remaining memory space above the last (highest) address occupied by file X comprises free space <b>28</b>, wherein all of the bits occupying this portion of memory are set to a FALSE logic level corresponding to the erased state of the firmware device. As a result of the foregoing, the memory space to be occupied by the new file Y, including the file's header, initially comprises all 1's, as depicted by a file Y initial state <b>70</b> in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0037" num="0036">The file creation process begins in a block <b>100</b>, in which the file header under construction bit (<b>58</b>) is set to TRUE, which allocates space in the FV for the new file header. This yields a State=11111110b for file Y, which indicates the header construction for file Y has begun, but has yet to be completed. This condition is depicted in <figref idref="DRAWINGS">FIG. 4</figref> as a header under construction state <b>72</b>. This has the effect of “claiming” the FFS header space from FV free space <b>28</b>, which is now occupied by a file Y header <b>74</b>. While in this state, all of the other header fields are initialized in a block <b>102</b>, by writing appropriate data to each field. This includes initializing name field <b>46</b>, IntegrityCheck field <b>47</b>, type field <b>48</b>, attributes field <b>49</b>, and size field <b>50</b>. In one embodiment, name field <b>46</b> comprises a GUID that is issued by the FFS. Typically, the GUID may comprise a 32-bit, 64-bit, or 128-bit GUID, although any bit-length of GUID may be used as long as the GUID will guarantee uniqueness within the FV.</p>
<p id="p-0038" num="0037">IntegrityCheck field <b>47</b> is a 16-bit field that includes three subfields: an IntegrityCheck.Checksum.Header subfield, an IntegrityCheck.Checksum.File subfield, and an IntegrityCheck.TailReference subfield. The IntegrityCheck.Checksum.Header subfield occupies the lower 8 bits of IntegrityCheck field <b>47</b>, and comprises an 8-bit checksum for the file header. The State and IntegrityCheck.Checksum.File fields are assumed to be zero and the checksum is calculated such that the entire header sums to zero. The IntegrityCheck.Checksum.Header is valid anytime file header valid bit <b>59</b> is set to TRUE in state field <b>51</b>.</p>
<p id="p-0039" num="0038">The IntegrityCheck.Checksum.File subfield occupies the higher 8 bits of IntegrityCheck field <b>47</b>, and comprises an 8-bit checksum of the entire file. State field <b>51</b> and file tail <b>45</b> are assumed to be zero and the checksum is calculated such that the entire file sums to zero. The IntegrityCheck.Checksum.File is valid anytime file data valid bit <b>60</b> is set to TRUE in state field <b>51</b>.</p>
<p id="p-0040" num="0039">The IntegrityCheck.TailReference subfield comprises the full 16 bits of IntegrityCheck field <b>47</b>. It is used in calculating the value for file tail <b>45</b> if file tail present bit <b>52</b> is set to TRUE in attributes field <b>49</b>.</p>
<p id="p-0041" num="0040">After the initialization of the FFS header fields is completed, the new file header is marked as complete by setting file header valid bit <b>59</b> to TRUE in a block <b>104</b>. This yields a State=11111100b, as depicted by a header valid state <b>76</b> in <figref idref="DRAWINGS">FIG. 5</figref>, which indicates the header construction is complete, but the file data has not yet been written. This has the effect of “claiming” the full length of the file from FV free space <b>28</b>. Once file header valid bit <b>59</b> is set to TRUE, no further changes to name field <b>46</b>, type field <b>48</b>, attributes field <b>49</b>, size field <b>50</b>, or the IntegrityCheck.Checksum.Header value may be made.</p>
<p id="p-0042" num="0041">While in this state, the file data, the IntegrityCheck.Checksum.File value, and the file tail (if appropriate) are written to FV <b>22</b> in a block <b>106</b>, as depicted by data <b>78</b> and optional file tail <b>79</b>. Whether a file tail is written will be dependent on the state of file tail present bit <b>52</b> in attributes field <b>49</b>—written if the value is TRUE, not written if the value is FALSE. The file tail, which is used for file integrity checking, follows the data and comprises the last two bytes of the file's image in FV<b>22</b>.</p>
<p id="p-0043" num="0042">Once appropriate data has been written in block <b>106</b>, an optional integrity check may be performed in a block <b>108</b>. There are various file or data integrity checks that are well-known in the art that may be used for this purpose. For example, if a source image for the file is available, a bit-by-bit compare or a checksum compare can be performed against the source image and the written image (i.e., the version of the file that has just been written to FV <b>22</b>). In some instances, the source image may not be available, such as in the case that the file data was written from a buffer that has since been flushed. In this case, a file integrity verification may be made by providing some indicia particular to the source  file (e.g., a checksum value) that may be compared against similar indicia contained in the newly-written file.</p>
<p id="p-0044" num="0043">The file creation process in completed in a block <b>110</b>, in which file data valid bit <b>60</b> is set to TRUE, indicating that the file data is valid. This yields a State=11111000b, as depicted by a file data valid state <b>80</b> in <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="h-0006" num="0000">File Deletion</p>
<p id="p-0045" num="0044">In addition to file creation, files may be deleted via an atomic change to state field <b>51</b>. Any file with file header valid bit <b>59</b> set to TRUE and file deleted bit <b>62</b> set to FALSE is a candidate for deletion. To delete a file, file deleted bit <b>62</b> is set to TRUE, as shown in <figref idref="DRAWINGS">FIG. 6</figref>. As before, the transition of this bit to the TRUE state must be atomic and fully complete before any additional writes to FV <b>22</b> are made. This yields a State=1110xx00b, as depicted by a deleted file state <b>82</b>, which indicates the file is marked as deleted. The “x's” in the Figures herein indicate that the value may be 1 or 0, depending on the current state. Even though the file is marked as deleted, its header is still valid, however, in as much as length file size field <b>50</b> is used in locating the start of the next file in FV <b>22</b>.</p>
<p id="h-0007" num="0000">File Update</p>
<p id="p-0046" num="0045">Another feature provided by the firmware file system is the ability to update existing files. A file update is a special case of file creation where the file being added already exists in the firmware volume. In short, the update progress comprises transparently writing a new (updated) version of a file in a free space portion of the firmware volume, performing an atomic change to FV file header data to simultaneously validate the new file and invalidate the original file, and then marking the original file as deleted. As this work is being performed, the state bits in state field <b>51</b> of both of the files are changed, one bit at a time, in a predetermined sequence that enables full recovery in the event of an anomaly during the update, such as a power failure. Accordingly, only one of the files, either the updated file (e.g., file X′) or the original file (e.g., File X), is valid at any given time.</p>
<p id="p-0047" num="0046">With reference to <figref idref="DRAWINGS">FIGS. 7-9</figref>, an embodiment of a file update by the firmware file system in which an original file X, including a file header <b>84</b> and file data <b>86</b>, is updated to a file X′ proceeds as follows. The process begins in a block <b>112</b> of <figref idref="DRAWINGS">FIG. 7</figref>, in which file marked for update bit <b>61</b> is set to TRUE in the file header (<b>84</b>) of the file that is to be updated, original file X. The transition of this bit to the TRUE state must be atomic and fully complete before any addition writes to FV <b>22</b> are made. This yields a State=11110000b, which indicates the file is marked for update, as shown by a file marked for update state <b>88</b> in <figref idref="DRAWINGS">FIG. 8</figref>. A file in this state remains valid as long as there is not another file in the firmware volume with that same name and a State=111110xxb.</p>
<p id="p-0048" num="0047">Next, in a block <b>114</b>, the new updated file, file X′, is created in the same manner discussed above with reference to <figref idref="DRAWINGS">FIGS. 4-5</figref> and process blocks <b>100</b>, <b>102</b>, <b>104</b>, <b>106</b>, <b>108</b> and <b>110</b> of <figref idref="DRAWINGS">FIG. 3</figref>. This includes creating and initializing the fields in a new file header <b>90</b> and writing the file's updated image to a portion of memory comprising file data <b>92</b>. Upon validation of the new file, as indicated by file data valid state <b>80</b>, the original file, which has been marked for update, becomes invalid. As discussed above, this occurs because there is now another file in FV <b>22</b> that has the same name as the original file and a state that does not=111110xxb. The act of writing the file data valid bit in state field <b>51</b> of new file header <b>90</b> has the additional effect of invalidating the original file X. The file update process is completed in a block <b>116</b>, in which file deleted bit <b>62</b> is set to TRUE in the file header for the original file, file header <b>84</b>, as depicted by a file deleted state <b>94</b> in <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="h-0008" num="0000">Pad Files</p>
<p id="p-0049" num="0048">Under the firmware file system, various file types can be used. The type of each file is identified by the value in type field <b>48</b> of the file's header. Included among these different types of files is a Pad file. A pad file gets its name from one of its common uses. It can be used to pad the location of the file that follows it in the storage media. This may be done for a variety of reasons, including fixing the location of a file in a FV, consuming space before a Volume Top File (a file added at the end of the memory space to completely fill the FV), and guaranteeing data alignment for a file to correspond with the alignment criteria specified by the alignments bits set in data alignment subfield <b>55</b> of attributes field <b>49</b>. A pad file may also be used in performing file update operations where multiple files within a firmware volume are updated in lockstep, as described below.</p>
<p id="p-0050" num="0049">The normal state of any valid (not deleted or invalidated) file is that both its header and data are valid. This is indicated by setting the state bits in state field <b>51</b> to State=11111000b. Pad files differ from all other types of files in that any pad file in this state should not have any data written into its data area. It is essentially a file filled with free space. In addition, file tail present bit <b>52</b> of attributes field <b>49</b> must be clear for pad files. This restriction is because if this bit was set, it would not be possible to reclaim the free space from the pad file. Since the data are of the pad file comprises free space, an extended check of the file is simply a check for any non-free data.</p>
<p id="p-0051" num="0050">Since a pad file's data area is not used, it is desirable to reclaim this free space for use, if possible. This is done by using two of the pad file's state bits. Since the data area of a pad file with a State=11111000b is guaranteed to be unperturbed free space, the conventional use of the file marked for update bit <b>61</b> (i.e., as used above) would not make sense. In pad files, the meaning of this bit is overloaded to indicate that the data area is not unperturbed free space, but may have had some data written to it. This is the key to reclaiming the free space contained in a pad file.</p>
<p id="p-0052" num="0051">With reference to <figref idref="DRAWINGS">FIG. 10</figref>, free space contained within a pad file may be reclaimed by performing the following process. The process begins in a block <b>120</b> in which file marked for update bit <b>61</b> is set to TRUE in the pad file's header. As before, the transition of this and any other bit in the pad file header to the TRUE state must be atomic and fully complete before any additional writes to the firmware volume are made. This yields a State=11110000b, which indicates the pad file's data area is not guaranteed to be unperturbed free space.</p>
<p id="p-0053" num="0052">Next, in a block <b>122</b>, a complete new file is created and written to the pad file's data area (i.e., free space). If the new file does not have any special alignment requirement, it is created at the lowest address within the pad file. If there is an alignment requirement, it may be necessary to precede the desired file with another pad file, all written to the original pad file's data area. Regardless, the new file(s) must be written completely, including the file header and data. The state bits of this file is written such that the State=11111000b. Since the header (and therefore the state field) for the new file is really part of the pad file's data area, it is not yet visible as part of the FFS.</p>
<p id="p-0054" num="0053">If the new file created in block <b>122</b> does not completely fill the pad file's data area, another pad file will need to be created to fill this space, as provided by a block <b>124</b>. This file is created in the same manner as block <b>122</b>, except the beginning of the new pad file's header follows the data for the file that was just created.</p>
<p id="p-0055" num="0054">The process is completed in a block <b>126</b>, in which file header invalid bit <b>63</b> in the original pad file is set to TRUE. This yields a State=11010000b, which indicates the pad file's header is invalid. Since the pad file's header is now invalid, the length field in the pad file's header is also no longer valid. The effect of this is that the FFS will skip the pad file's header only and look for another file header in what formerly was the pad file's data area. Since the new file's header exists at this location, it is correctly interpreted as a valid file.</p>
<p id="h-0009" num="0000">File Update Using a Pad File</p>
<p id="p-0056" num="0055">A file update using pad file free space is very similar to the normal file update process discussed above, except that the updated file is written into a pad file's “free” space rather than “normal” free space <b>28</b>. With reference to the flowchart of <figref idref="DRAWINGS">FIG. 11</figref>, performing a file update using a pad file proceeds as follows. The process begins in a block <b>130</b> in which file marked for update bit <b>61</b> is set to TRUE in the pad file's header. This yields a State=11110000b, which indicates the pad file's data area is not guaranteed to be unperturbed free space.</p>
<p id="p-0057" num="0056">Next, in a block <b>132</b>, a complete new file is created in the pad file's data area (free space) at its lowest address (after its header). If the new file has special alignment requirements, this must be handled in the same manner as discussed above with reference to block <b>122</b> of <figref idref="DRAWINGS">FIG. 10</figref>. This new file must be written completely including the file header and data. The state bits of the file header for this new file are written such that a State=11111000b is indicated. Since it's really part of the pad file's data area, it is not yet visible as part of the FFS.</p>
<p id="p-0058" num="0057">If the new file created in block <b>132</b> does not completely fill the pad file's data area, another pad file must be created to fill this space, as provided by a block <b>134</b>. This file is created in the same manner as in block <b>132</b>, except the beginning of the new pad file's header follows the data for the newly created file. File marked for update bit <b>61</b> is then set to TRUE in the original file that is targeted for update in a block <b>136</b>.</p>
<p id="p-0059" num="0058">Next, in a block <b>138</b>, file header invalid bit <b>63</b> is set to TRUE in the original pad file to TRUE. This yields a State=11010000b, which indicates the pad file's header is invalid. Since the pad file's header is now invalid, the length field in the pad file's header is also no longer valid. The effect of this is for the FFS to skip the pad file's header only and look for another file header in what was the pad file's data area. Since the new file's header exists at this location, it is correctly interpreted as a valid file. The process is completed in a block <b>140</b> in which the original file that was targeted for update is deleted.</p>
<p id="h-0010" num="0000">Atomic Update of Multiple Files</p>
<p id="p-0060" num="0059">An important aspect of the invention is its ability to atomically update a plurality of FFS files in a manner that enables a complete recovery in the event of an anomaly during the update process, such as a power failure. For example, during an update process, new data is written to a FV. If a write-failure occurs during this process due to a power system failure or other system failure, the FFS can be left in an inconsistent state. However, through the use of the state bits and IntegrityCheckese field, these types of failures are detected by the FFS, which then attempts to either continue the update process at the point the failure occurred, or revert the firmware files back to their original state prior to beginning the update process.</p>
<p id="p-0061" num="0060">One embodiment of an atomic update of multiple files in a firmware file system is shown in <figref idref="DRAWINGS">FIGS. 12-15</figref>. An atomic update updates multiple files in a FV at the same time, in lock step. If a system failure occurs during the atomic update, then the firmware file system will retain either a complete set of the old firmware files to be updated or a complete set of the new updated firmware files. The atomic update prevents the firmware volume from having the updated files be a mix of old and new versions after a system failure during the firmware files update process. It is appreciated that during an atomic update, not all of the firmware files in a FV must be updated. In general, an atomic update may be executed with two or more files in the same FV. In the following example, if two files are updated atomically, there must by a respective new file replaces each existing file. In general, the number of new files will be equal to or greater than the number of original files are to be atomically updated. In cases in which there are more new files than existing files, the extra new file(s) is simply added to the FV as a new file rather than an updated file.</p>
<p id="p-0062" num="0061">Atomically updating a plurality of files involves a process that is substantially similar to the file update process discussed above with reference to <figref idref="DRAWINGS">FIG. 11</figref>, except in this instance, multiple original files are updated with firmware data written to the pad file's data area instead of a single file. With reference to <figref idref="DRAWINGS">FIG. 13</figref>, suppose an initial configuration of a firmware volume <b>160</b> includes two files, X and Y, which are to be updated to files X′ and Y′, respectively. File X includes a file header <b>162</b> and a data area <b>164</b>, while file Y includes a file header <b>166</b> and a data area <b>168</b>. State field <b>51</b> for each of file headers <b>162</b> and <b>166</b> is set so that the State=11111000b, indicating that each of file X and file Y is valid, as respectively shown by file data valid states <b>80</b>X and <b>80</b>Y.</p>
<p id="p-0063" num="0062">With reference to the flowchart of <figref idref="DRAWINGS">FIG. 12</figref>, the process of atomically updating a plurality of files begins in a block <b>142</b>, in which a pad file is created, at a byte boundary immediately following the end of the FFS file occupying the highest address space (i.e., the lowest address of free space <b>28</b>), in the manner discussed above for creating a file with reference to <figref idref="DRAWINGS">FIGS. 3-5</figref>. After the pad file is created, it will include a pad file header <b>170</b> and a data area <b>172</b>. Ideally, the pad file should be sized so that it can hold the combined size of the updated file images and their corresponding file headers. In this matter, maximum memory utilization is realized. Initially, the state for the pad file will be 11111000x, indicating the pad file data is valid, as depicted by a file data valid state <b>80</b>P in <figref idref="DRAWINGS">FIG. 13</figref>.</p>
<p id="p-0064" num="0063">Next, in a block <b>144</b>, file marked for update bit <b>61</b> is set to TRUE in the pad file's header. This is depicted by a file marked for update state <b>88</b>P in <figref idref="DRAWINGS">FIGS. 13 and 14</figref>. At this point, in a block <b>146</b>, a new file for each of the files to be updated are written to data area <b>172</b> of the pad file, in a sequential manner (i.e., a next file begins immediately following the most recently written file). This includes writing both the header and data for each file. The data for a file will comprise a file image corresponding to the updated portion of firmware that is meant to supercede the original firmware stored in the file being updated. As depicted in <figref idref="DRAWINGS">FIG. 14</figref>, new files X′ and Y′ are written during this operation, wherein file X′ includes a file header <b>174</b> and a data area <b>176</b> in which an image for its updated firmware is written, and file Y′ includes a file header <b>178</b> and a data area <b>180</b> in which an image for its updated firmware is written. In a manner similar to that discussed above, both of these files are “hidden” from the FFS at this point since the pad file is still marked as valid.</p>
<p id="p-0065" num="0064">After the updated files are created, an optional data integrity check may be performed in a block <b>148</b> on one or more of the updated files. As described above, the data integrity check may comprise a bit-by-bit comparison check between the newly written file image and its source, a checksum comparison, or another type of file integrity check that is well-known in the art.</p>
<p id="p-0066" num="0065">The logic next flows to a block <b>150</b> in which file marked for update bit <b>61</b> is set to TRUE in the header for each of the original files that are targeted for update. Each of the states for original files X and Y now=11110000x, as depicted by file marked for update states <b>88</b>X and <b>88</b>Y in <figref idref="DRAWINGS">FIGS. 14 and 15</figref>. Next, in a block <b>152</b>, file header invalid bit <b>63</b> is set to TRUE in the original pad file, which now has a State=11010000x, as shown by file header invalid state <b>182</b> in <figref idref="DRAWINGS">FIG. 15</figref>. This invalidates the pad file header, enabling the newly updated files (e.g., file X′ and Y′) to become visible to the FFS. This visibility is accomplished in the following manner. Although the pad file header is invalid, it is still used to provide the location (via the nominal size of the header, e.g., 6 bytes). Accordingly, when the FFS reads pad file header <b>170</b>, it recognizes that the header is invalid and moves forwards to the beginning of the file header for the first updated file written to the pad file's data area (file X′ in this example). This file header contains information (via its size field <b>50</b>) that is used by the FFS to locate the beginning of the header for the next file in the FV, as well.</p>
<p id="p-0067" num="0066">The atomic update of multiple files is completed in a block <b>154</b>, wherein each of the original files that were targeted for update are deleted by setting their file deleted bit <b>62</b> to TRUE. This changes the state of these files to 11100000x, as shown by file deleted states <b>82</b>X and <b>82</b>Y in <figref idref="DRAWINGS">FIG. 15</figref>.</p>
<p id="p-0068" num="0067">The foregoing process ensures that multiple-file updates are performed in lock-step so as to guarantee that the FFS either uses the original version of the files or the updated version of the files, which no chance for mismatch between the two versions. In the event of a system anomaly, the headers of the various files can be checked to determine which state each of the files were in when the system anomaly occurred. This provides a recovery path that enables the file update process to be resumed where it was left off until the file updates are successfully completed. In contrast to prior art systems, since the FV always contains a valid set of firmware files, computer systems that implement the invention will not be prevented from rebooting in the event of a system anomaly during a firmware update process.</p>
<p id="h-0011" num="0000">Exemplary Computer System for Implementing the Invention</p>
<p id="p-0069" num="0068">With reference to <figref idref="DRAWINGS">FIG. 16</figref>, a generally conventional personal computer <b>200</b> is illustrated, which is suitable for use in connection with practicing the present invention. The system may be implemented using a local platform firmware architecture (e.g., all firmware is stored local to the computer using firmware storage devices such as flash devices and option ROMs, or a distributed platform firmware architecture may also be implemented, as depicted in <figref idref="DRAWINGS">FIG. 16</figref>. The invention may also be implemented on other computer systems as well, including workstations, laptops, and computer servers.</p>
<p id="p-0070" num="0069">Personal computer <b>200</b> includes a processor chassis <b>202</b> in which are mounted a floppy disk drive <b>204</b>, a hard drive <b>206</b>, a motherboard <b>208</b> populated with appropriate integrated circuits including one or more microprocessors and memory modules (both not shown), and a power supply (also not shown), as are generally well known to those of ordinary skill in the art. Motherboard <b>208</b> also includes a local firmware storage device <b>210</b> (e.g., Flash Memory) on which the base portion of the BIOS firmware is stored. To facilitate access to the portion of the BIOS firmware that is retrieved from a remote firmware storage device <b>212</b> via a network <b>214</b>, personal computer <b>200</b> includes a network interface card <b>116</b> or equivalent circuitry built into motherboard <b>208</b>. Network <b>214</b> may comprise a LAN, WAN, and/or the Internet, and may provide a wired or wireless connection between personal computer <b>200</b> and remote firmware storage device <b>212</b>.</p>
<p id="p-0071" num="0070">A monitor <b>218</b> is included for displaying graphics and text generated by software programs that are run by the personal computer and which may generally be displayed during the POST test and other aspect of firmware load/execution. A mouse <b>220</b> (or other pointing device) is connected to a serial port (or to a bus port) on the rear of processor chassis <b>202</b>, and signals from mouse <b>220</b> are conveyed to motherboard <b>208</b> to control a cursor on the display and to select text, menu options, and graphic components displayed on monitor <b>218</b> by software programs executing on the personal computer. In addition, a keyboard <b>222</b> is coupled to the motherboard for user entry of text and commands that affect the running of software programs executing on the personal computer.</p>
<p id="p-0072" num="0071">Personal computer <b>200</b> also optionally includes a compact disk-read only memory (CD-ROM) drive <b>224</b> into which a CD-ROM disk may be inserted so that executable files and data on the disk can be read for transfer into the memory and/or into storage on hard drive <b>206</b> of personal computer <b>200</b>. If the base BIOS firmware is stored on a rewriteable device, such as a Flash Memory, machine instructions for updating the base portion of the BIOS firmware may be stored on a CD-ROM disk or a floppy disk and read and processed by the computer's processor to rewrite the BIOS firmware stored on the Flash Memory. Updateable BIOS firmware may also be loaded via network <b>214</b>.</p>
<p id="p-0073" num="0072">Machines similar to computer <b>200</b> may be used for the various servers in the system. However, it is preferable that machines that are designed specifically for web, file and application server functions be implemented as such.</p>
<p id="p-0074" num="0073">In general, from the viewpoint of hardware and software components running on the computer system, those components will not be able to distinguish that respective portions of the BIOS firmware that are stored on local and remote storage devices. Other than the loading and initial execution of the BIOS firmware for testing system integrity and determining/verifying the system configuration and other pre-OS boot processes, a computer system implementing the invention will function in an identical manner to a conventional computer system that uses the same components and runs the same software.</p>
<p id="p-0075" num="0074">Although the present invention has been described in connection with a preferred form of practicing it and modifications thereto, those of ordinary skill in the art will understand that many other modifications can be made to the invention within the scope of the claims that follow. Accordingly, it is not intended that the scope of the invention in any way be limited by the above description, but instead be determined entirely by reference to the claims that follow.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for updating an existing portion of platform firmware data in persistent firmware memory, comprising:
<claim-text>writing updated firmware data to a pad file in the persistent firmware memory that is different from a memory location of the existing platform firmware data so that the persistent firmware memory comprises both the existing platform firmware data and the updated platform data; and</claim-text>
<claim-text>performing an atomic operation to modify firmware configuration data to indicate whether the existing platform firmware data or the updated platform firmware data is valid and is to be loaded and executed, such that only the existing platform firmware data will be loaded and executed before the atomic operation is performed and only the updated platform firmware data will be loaded and executed after the atomic operation is performed.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising performing an integrity check of the updated platform firmware data to verify that the updated platform firmware data is valid.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the updated platform firmware data is written to the persistent firmware memory in a manner in which the updated platform firmware data is invisible to a firmware management system used to access firmware data stored on the persistent firmware memory until the atomic modification of the firmware configuration data has been performed.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising enabling a full recovery of the existing portion of platform firmware data that is to be updated during an upgrade process in response to a system anomaly that prevents completion of the upgrade process.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising deleting the at least a portion of existing platform firmware data after it has been upgraded.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory comprises a flash memory device.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A method for updating a plurality of existing platform firmware files in persistent firmware memory, which at least a portion of existing platform firmware data comprises header data indicating whether or not the existing platform firmware data is valid and is to be updated, the method comprising:
<claim-text>modifying the header data of the existing platform firmware data to indicate that the existing platform firmware data is valid and is to be updated;</claim-text>
<claim-text>writing updated platform firmware data to a memory location that is different from the memory location of the existing platform firmware data so that the persistent firmware memory comprises both the existing platform firmware data and the updated platform firmware data, which update platform firmware data comprises header data indicating that the updated platform firmware data is not valid and is not to be updated; and</claim-text>
<claim-text>performing an atomic operation to modify the header data of the updated platform firmware data is valid and is not to be updated, thereby indicating that the updated platform firmware data is to be loaded and executed instead of the existing platform firmware data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein each platform firmware file comprises a file header and a data area in which platform firmware data corresponding to that file is written, and wherein each file header includes a plurality of state bits that are used to track a current state of each platform firmware file during the update process.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the temporary file is created by creating a file header that identifies the temporary file includes a data area that is sized to hold all of the updated platform firmware files, said data area being mapped to a memory area on a firmware storage device that is used to store the existing and updated platform firmware files.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising changing a state bit in the temporary file's file header to indicate that the temporary file is invalid after data corresponding to the updated platform firmware files are written to the data area of the temporary file.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein a file system is used to access the platform firmware files and the updated firmware files appear invisible to the file system prior to when the state bit is changed and become visible to the file system after the state bit is changed.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein each existing platform firmware file has a name that is shared by a corresponding updated platform firmware file, further comprising:
<claim-text>changing the state bits in each of the existing platform firmware files to indicate they are to be updated;</claim-text>
<claim-text>setting the state bits in each of the updated platform firmware files to indicate that they are valid,</claim-text>
<claim-text>wherein, upon becoming visible to the file system, the state bits in the file headers of the updated platform files in combination with the state bits in the existing platform firmware files simultaneously inform the file system that the existing platform files are invalid and the updated platform files are valid.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising performing an integrity check of the updated platform firmware files to verify that the updated firmware files are valid prior to atomically modifying the platform firmware file configuration information to indicate that the updated platform firmware files are to be used in place of the existing platform firmware.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising enabling a full recovery of the existing platform firmware files that are to be updated during the upgrade process in response to a system anomaly that prevents completion of the upgrade process.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising setting the state bits in each file header of the existing platform firmware files to indicate the file is deleted after the upgrade process has been complete.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A machine readable media on which a plurality of machine-executable instructions are stored that when executed by a machine updates an existing portion of platform firmware data partitioned into a plurality of sets of firmware code by performing the operation of:
<claim-text>writing updated firmware data to a pad file in the persistent firmware memory that is different from a memory location of the existing platform firmware data so that the persistent firmware memory comprises both the existing platform firmware data and the updated platform data; and</claim-text>
<claim-text>performing an atomic operation to modify firmware configuration data to indicate whether the existing platform firmware data or the updated platform firmware data is valid and is to be loaded and executed, such that only the existing platform firmware data will be loaded and executed before the atomic operation is performed and only the updated platform firmware data will be loaded and executed after the atomic operation is performed.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The machine readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein execution of the plurality of machine instructions further performs the operation of performing an integrity check of the updated firmware data to verify that the updated firmware data is valid.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The machine readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein execution of the plurality of machine instructions further enable the machine to perform a full recovery of the existing portion of firmware data that is to be updated during an upgrade process in response to a machine anomaly that prevents completion of the upgrade process.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A machine readable media on which a plurality of machine-executable instructions are stored that when executed by a machine updates a plurality of existing platform firmware files in persistent firmware memory wherein each of said plurality of existing platform firmware files comprises header data indicating whether or not the existing platform firmware file is valid and is to be updated by performing the operations of:
<claim-text>creating a pad file at a memory location in the persistent firmware memory which is different from the memory location of the existing platform firmware files, the pad file having a data area and a header data indicating that the pad file is valid;</claim-text>
<claim-text>writing data corresponding to a plurality of updated platform firmware files comprising new versions of the plurality of existing platform firmware files to the data area of the pad file so that the persistent firmware memory comprises both the plurality of existing platform firmware files and the plurality of updated platform firmware files, each of the plurality of update platform firmware files comprising header data indicating that the updated platform firmware file is valid and is not to be updated;</claim-text>
<claim-text>modifying the header data of each of the existing platform firmware files to indicate that the existing platform firmware file is valid and is to be updated; and</claim-text>
<claim-text>performing an atomic operation to modify the header data of the pad file to indicate that the pad file is not valid, thereby indicating that the updated platform firmware files written to the data area of the pad file are to be loaded and executed instead of the existing platform firmware files.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The machine readable media of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein each file header includes a plurality of state bits that are used to track a current state of each platform firmware file during the update process.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The machine readable media of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the temporary file is created by creating a file header that identifies the temporary file includes a data area that is sized to hold all of the updated platform firmware files, said data area being mapped to a memory area on a firmware storage device that is used to store the existing and updated platform firmware files.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The machine readable media of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein execution of the plurality of machine instructions further performs the operation of changing a state bit in the file header of the temporary file to indicate that the temporary file is invalid after data corresponding to the updated platform firmware files are written to the data area of the temporary file.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The machine readable media of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein a file system is used to access the platform firmware files and the updated firmware files appear invisible to the file system prior to when the state bit is changed and become visible to the file system after the state bit is changed.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The machine readable media of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein each existing platform firmware file has a name that is shared by a corresponding updated platform firmware file, and wherein execution of the plurality of machine instructions further performs the operations of:
<claim-text>changing the state bits in each of the existing platform firmware files to indicate they are to be updated; and</claim-text>
<claim-text>setting the state bits in each of the updated platform firmware files to indicate that they are valid,</claim-text>
<claim-text>wherein, upon becoming visible to the file system, the state bits in the file headers of the updated platform files in combination with the state bits in the platform firmware files simultaneously inform the file system that the existing platform files are invalid and the updated platform files are valid.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The machine readable media of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein execution of the plurality of machine instructions further performs the operation of performing an integrity check of the updated platform firmware files to verify that the updated firmware files are valid prior to atomically modifying the platform firmware file configuration information to indicate that the updated platform firmware files are to be used in place of the existing platform firmware.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The machine readable media of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein execution of the plurality of machine instructions further performs the operation of enabling a full recovery of the existing platform firmware files that are to be updated during the upgrade process in response to a system anomaly that prevents completion of the upgrade process.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The machine readable media of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein execution of the plurality of machine instructions further performs the operation of setting the state bits in each file header of the existing platform firmware files to indicate the file is deleted after the upgrade process has been complete.</claim-text>
</claim>
</claims>
</us-patent-grant>
