<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299316-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299316</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10956826</doc-number>
<date>20041001</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
<further-classification>711115</further-classification>
<further-classification>711159</further-classification>
<further-classification>711170</further-classification>
</classification-national>
<invention-title id="d0e51">Memory flash card reader employing an indexing scheme</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>2002/0036922</doc-number>
<kind>A1</kind>
<name>Roohparvar</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>36518511</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2003/0093606</doc-number>
<kind>A1</kind>
<name>Mambakkam et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710305</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2003/0177300</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2004/0243749</doc-number>
<kind>A1</kind>
<name>Learmonth</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 73</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2005/0083741</doc-number>
<kind>A1</kind>
<name>Chang et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>365200</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2005/0114587</doc-number>
<kind>A1</kind>
<name>Chou et al.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2005/0144360</doc-number>
<kind>A1</kind>
<name>Bennett et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2005/0182858</doc-number>
<kind>A1</kind>
<name>Lo et al.</name>
<date>20050800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710  1</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2005/0193161</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2005/0193162</doc-number>
<kind>A1</kind>
<name>Chou et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2005/0216624</doc-number>
<kind>A1</kind>
<name>Deng et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 74</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00012">
<othercit>Standard Microsystems Corporation, USB97C242, USB 2.0 Flash Driver Controller Data Sheet, Oct. 2002, pp. 1-22.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
</references-cited>
<number-of-claims>32</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711115</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711159</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711170</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711109</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>710305</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>18</number-of-drawing-sheets>
<number-of-figures>23</number-of-figures>
</figures>
<us-related-documents>
<continuation-in-part>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>10789333</doc-number>
<kind>00</kind>
<date>20040226</date>
</document-id>
<parent-status>ABANDONED</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>10956826</doc-number>
</document-id>
</child-doc>
</relation>
</continuation-in-part>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050193162</doc-number>
<kind>A1</kind>
<date>20050901</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Chou</last-name>
<first-name>Horng-Yee</first-name>
<address>
<city>Palo Alto</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Lee</last-name>
<first-name>Edward W.</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Schein &amp; Cai LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Mackenzie</last-name>
<first-name>Douglas</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="03" rep-type="attorney">
<addressbook>
<last-name>Cai</last-name>
<first-name>James</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Super Talent Electronics, Inc.</orgname>
<role>02</role>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kim</last-name>
<first-name>Hong</first-name>
<department>2185</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A memory flash card reader includes a processor for receiving at least one request from a host system, an index comprising information regarding sectors of the memory flash card wherein the processor may utilize the index to determine sectors of the memory flash card that are available for programming, reprogramming, or reading, and at least one card controller coupled to the processor.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="194.31mm" wi="151.55mm" file="US07299316-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="183.13mm" wi="160.95mm" file="US07299316-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="146.22mm" wi="157.82mm" file="US07299316-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="209.72mm" wi="159.68mm" file="US07299316-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="214.46mm" wi="149.10mm" file="US07299316-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="201.42mm" wi="157.14mm" file="US07299316-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="208.45mm" wi="154.86mm" file="US07299316-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="213.19mm" wi="150.71mm" orientation="landscape" file="US07299316-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="222.33mm" wi="157.14mm" orientation="landscape" file="US07299316-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="211.33mm" wi="163.91mm" file="US07299316-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="194.06mm" wi="164.17mm" file="US07299316-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="218.02mm" wi="122.26mm" file="US07299316-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="223.60mm" wi="124.97mm" file="US07299316-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="223.77mm" wi="122.51mm" file="US07299316-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="224.79mm" wi="160.95mm" file="US07299316-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="217.34mm" wi="156.46mm" file="US07299316-20071120-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="194.65mm" wi="155.19mm" file="US07299316-20071120-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="191.18mm" wi="147.83mm" file="US07299316-20071120-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="222.50mm" wi="154.86mm" file="US07299316-20071120-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">The present application is a continuation in part of application Ser. No. 10/789,333, entitled “System and Method for Controlling Flash Memory”, filed on Feb. 26, 2004, now abandoned, the disclosure of which is herein incorporated by reference in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates generally to memory systems and more particularly to a system and method for providing a USB flash memory card reader capable of reading a plurality of flash memory card formats.</p>
<p id="p-0004" num="0003">As flash memory technology becomes more advanced, flash memory is replacing traditional magnetic hard disks as storage media for mobile systems. Flash memory has significant advantages over magnetic hard disks such as having high-G resistance and low power dissipation. Because of the smaller physical sizes of flash memory, they are also more conducive to mobile systems. Accordingly, the flash memory trend has been growing because of its compatibility with mobile systems and its low-power feature.</p>
<p id="p-0005" num="0004">New generation personal computer (PC) card technologies have been developed that combine flash memory with architecture that is compatible with the Universal Serial Bus (USB) standard. This has further fueled the flash memory trend because the USB standard is easy to implement and is popular with PC users. In addition to replacing hard drives, flash memory is also replacing floppy disks because flash memory provides higher storage capacity and faster access speeds than floppy drives.</p>
<p id="p-0006" num="0005">However, the USB standard has several features that require additional processing resources. These features include fixed-frame times, transaction packets, and enumeration processes. For better optimization, these features have been implemented in application-specific integrated circuits (ASICs).</p>
<p id="p-0007" num="0006">In addition to the limitations introduced by the USB standard, there are inherent limitations with flash memory. First, flash memory sectors that have already been programmed must be erased before being reprogrammed. Also, flash memory sectors have a limited life span; i.e., they can be erased only a limited number of times before failure. Accordingly, flash memory access is slow due to the erase-before-write nature and ongoing erasing will damage the flash memory sectors over time.</p>
<p id="p-0008" num="0007">Hardware and firmware utilize existing small computer systems interface (SCSI) protocols so that flash memory can function as mass-storage devices similar to magnetic hard disks. SCSI protocols have been used in USB-standard mass-storage devices long before flash memory devices have been widely adopted as storage media. Accordingly, the application extensions of the USB standard have incorporated traditional SCSI protocols.</p>
<p id="p-0009" num="0008">A prior art solution provides a driver procedure for flash memory write transactions. This procedure has three different sub-procedures. Generally, the data of a requested flash memory address is first read. If there is data already written to that address, the firmware executes an erase command. Then, if the erase command executes correctly, the firmware executes a write request. However, this driver procedure utilizes protocols that require additional computing resources at the host system. It is also slow.</p>
<p id="p-0010" num="0009">Disadvantages of many of the above-described and other known arrangements include additional host system resources required to process special protocols and the resulting added processing time required for managing flash memory.</p>
<p id="p-0011" num="0010">Accordingly, there is a need for a USB flash memory card reader capable of reading a plurality of flash memory card formats which incorporates an improved system and method for controlling the flash memory card. The USB flash memory card reader preferably complies with the USB standard, is suitable for ASIC hardware implementation, and is fast, simple, cost effective and capable of being easily adapted to existing silicon technology. The present invention addresses such a need.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0012" num="0011">In accordance with one aspect of the invention, a memory flash card reader includes a processor for receiving at least one request from a host system, an index comprising information regarding sectors of the memory flash card wherein the processor may utilize the index to determine sectors of the memory flash card that are available for programming, reprogramming, or reading, and at least one card controller coupled to the processor.</p>
<p id="p-0013" num="0012">In another aspect of the invention, a method of managing a flash memory includes the steps of receiving at least one request from a host system in a processor within a flash memory controller, determining which sectors of the flash memory are available for writing, erasing and reading utilizing the processor and an index coupled to the processor, and writing, erasing and reading to a flash memory card through at least one card controller coupled to the processor.</p>
<p id="p-0014" num="0013">These and other feature, aspects, and advantages of the present invention will become better understood with reference to the following drawings, description, and claims.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic representation showing a memory card coupleable to a host computer in accordance with the invention;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic representation showing a memory card coupleable to a host computer through a card reader box in accordance with the invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic representation showing a logical representation of the configuration of <figref idref="DRAWINGS">FIG. 1</figref> or <b>2</b> in accordance with the invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> is a block diagram of a first portion of a peripheral device in accordance with the invention;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of a second portion of a peripheral device in accordance with the invention;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram of a preferred embodiment of the first portion in accordance with the invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram of a logical/physical block address translation look up table, a physical usage table, and a block copy and recycling FIFO in accordance with the invention;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram of a peripheral flash device array data structure in accordance with the invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 9</figref> is a flow chart of a firmware read/write/erase method in accordance with the invention;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 10A</figref> is a flow chart of a main firmware service method in accordance with the invention;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 10B</figref> is a flow chart of a phase I flash write method in accordance with the invention;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 10C</figref> is a flow chart of a phase II block copy method in accordance with the invention;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 10D</figref> is a flow chart of an erase and recycle method in accordance with the invention;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIGS. 11A through 11F</figref> are tables showing a representative example in accordance with the invention;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 12</figref> is a detailed flow chart of a write sector method in accordance with the invention;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 13</figref> is a detailed flow chart of a phase II background sector copy method in accordance with the invention;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 14</figref> is a flow chart of an erase and recycle method in accordance with the invention; and</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 15</figref> is a flow chart of a read method in accordance with the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0033" num="0032">The following detailed description is of the best mode of carrying out the invention. The description is not to be taken in a limiting sense, but is made merely for the purposes of illustrating the general principles of the invention, since the scope of the invention is best defined by the appended claims.</p>
<p id="p-0034" num="0033">In a first aspect of the invention, and with reference to <figref idref="DRAWINGS">FIG. 1</figref>, there is shown a card reader system generally designated <b>100</b> including a first portion <b>120</b> which may be disposed within a host system <b>110</b> and a second portion <b>130</b> coupleable to the first portion <b>120</b>. First portion <b>120</b> may include a card reader and second portion <b>130</b> may include a flash memory card. Note that the first portion <b>120</b> and the host system <b>110</b> can reside on the same printed circuit board in one specific implementation. In another implementation, they can be separate boards. First portion <b>120</b> may be coupled to the host system <b>110</b> by means of a standard interface that may provide both mechanical and electrical connection between the first portion <b>120</b> and the host system <b>110</b>. The standard interface may include a conventional 3.5 inch slot, a 5.25 inch slot, or a riser card. The electrical interface between the first portion <b>120</b> and the host system <b>110</b> preferably includes the USB interface.</p>
<p id="p-0035" num="0034">The second portion <b>130</b> may be removably coupled to the first portion <b>120</b> by means of second portion connector <b>140</b>. The connection between the second portion <b>130</b> and the first portion <b>120</b> may include a proprietary connection, Multi Media Card (MMC), Secure Digital (SD) Card, Memory Stick (MS), Smart Media (SM), Compact Flash (CF), PCl Express, Serial Advanced Technology Attachment (SATA), Serial Attached Small Computer System Interface (SCSI), and IEEE 1394. The connection may include a MX1 (multiple in one) or a 1×1 (one in one) connection.</p>
<p id="p-0036" num="0035">The second portion connector <b>140</b> generally includes pins that provide connections to ground, voltage supplies, serial/parallel data in and/or out, control lines, select lines, address lines, test pins as well as a signal that acknowledges the presence of the second or daughter portion <b>130</b>. Depending on selective implementations of these pins, many pins or very few pins may be used in the second portion connector <b>140</b> and a first portion second connector <b>300</b> (<figref idref="DRAWINGS">FIG. 3</figref>). In a minimum pin implementation, data, addresses and commands are multiplexed into a serial stream before being passed across the second portion connector <b>140</b>. Once across, the serial stream may be de-multiplexed into its respective components. As an example, this serial stream may be an MMC interface.</p>
<p id="p-0037" num="0036">According to one aspect of the invention, a peripheral device may include flash memory chips and supporting hardware circuits that form a USB controller <b>320</b> (<figref idref="DRAWINGS">FIG. 3</figref>) for controlling the operations of the flash memory and for interfacing to the host system <b>110</b>. The peripheral device can be partitioned such that the USB controller <b>320</b> resides on the first portion <b>120</b> and the flash memory chips reside on the second portion <b>130</b>, such as defined by the XD standard. A more popular partition is to put all of the complexity onto the USB controller <b>320</b>. In this case a controller on the memory card <b>130</b> only has a very simple interface control.</p>
<p id="p-0038" num="0037">In this manner, a cost-effective flash memory system is provided, especially in applications where magnetic floppy disks are to be replaced. In accordance with the invention, second portion <b>130</b> may act essentially like a semiconductor flash memory “floppy disk” and may or may not have a controller on the second portion <b>130</b>. The USB controller <b>320</b> on the first portion <b>120</b> may then serve any number of flash memory “floppy disks”. The cost of each flash memory “floppy disk” is therefore reduced by simplifying or eliminating the controller on the “floppy disk” itself. Another advantage is an increase in system flexibility. A user may add or decrease memory capacity by choosing among second portion <b>130</b> cards with various amounts of installed memory. Also, with each update or upgrade of the USB controller <b>320</b>, only the first portion <b>120</b> needs be replaced, the second portion <b>130</b> card “floppy disk” being fully usable with an updated or upgraded first portion <b>120</b>.</p>
<p id="p-0039" num="0038">In another aspect of the invention and with reference to <figref idref="DRAWINGS">FIG. 2</figref>, first portion <b>120</b> may include a USB flash memory card reader box <b>200</b> which may be coupled to the host system <b>110</b> by means of a USB cable <b>210</b>. Card reader box <b>200</b> may include USB controller <b>320</b>. The second portion <b>130</b> may be removably coupled to the card reader box <b>200</b> by means of second portion connector <b>140</b>.</p>
<p id="p-0040" num="0039">As shown in <figref idref="DRAWINGS">FIG. 3</figref>, a logical representation of the card reader system <b>100</b> may include the second portion <b>130</b> having circuits <b>310</b> disposed therein. Circuits <b>310</b> may include flash memory chips. USB controller <b>320</b> may be disposed in first portion <b>120</b> which may be coupled to a host USB controller <b>330</b> disposed in host system <b>110</b>.</p>
<p id="p-0041" num="0040">First portion <b>120</b> may include a first portion processor <b>400</b> coupled to a bus <b>410</b> as shown in <figref idref="DRAWINGS">FIG. 4</figref>. A random access memory device <b>420</b> and a read only memory device <b>430</b> may be coupled to bus <b>410</b>. A USB serial engine <b>480</b> may be coupled to bus <b>410</b> and include a USB connector <b>490</b>. A pair of card controllers <b>440</b> and <b>460</b> may be coupled to bus <b>410</b> and include connectors <b>300</b><i>a </i>and <b>300</b><i>b </i>respectively. Card controllers <b>440</b> and <b>460</b> may include controllers adapted to interface with flash memory cards having different connections such as a proprietary connection, Multi Media Card (MMC), Secure Digital (SD) Card, Memory Stick (MS), Smart Media (SM), Compact Flash (CF), XD, PCI Express, Serial Advanced Technology Attachment (SATA), Serial Attached Small Computer System Interface (SCSI), and IEEE 1394. Although only two card controllers <b>440</b> and <b>460</b> are shown, those skilled in the art will appreciate that a plurality of card controllers may be coupled to bus <b>410</b>.</p>
<p id="p-0042" num="0041">Second portion <b>130</b> may include a second portion processor <b>500</b> coupled to a bus <b>510</b> as shown in <figref idref="DRAWINGS">FIG. 5</figref>. A random access memory device <b>520</b> and a read only memory device <b>530</b> may be coupled to bus <b>510</b>. A flash memory controller <b>540</b> may be coupled to bus <b>510</b> and to a flash memory array <b>550</b>. A card controller <b>560</b> may be coupled to bus <b>510</b> and to second portion connector <b>140</b>.</p>
<p id="p-0043" num="0042">With reference to <figref idref="DRAWINGS">FIG. 6</figref>, USB controller <b>320</b> may include serial engine <b>480</b> having a transceiver <b>600</b> operable to convert analog signals to digital streams and to provide a phase lock loop circuit for generating precision clocks for internal data latching. For USB 2.0, the phase lock loop functionality can be sensitive and thus useful due to its operating at 480 MHz. Serial engine <b>480</b> may also include a serial interface engine (SIE) <b>610</b> which may provide serial and parallel data conversion, packet decoding/generation, cyclic redundancy code (CRC) generation/checking, non-return-to-zero (NRZI) encoding/decoding, and bit stuffing according to the USB 2.0 standard.</p>
<p id="p-0044" num="0043">A bulk-only transport unit (BOT) <b>615</b> may receive command block wrappers (CBW) and may include a data transfer length register <b>620</b> and a logical block address (LBA) register <b>625</b>.</p>
<p id="p-0045" num="0044">A sector FIFO <b>630</b> may be used for data buffering. A FIFO-not-empty interrupt signal <b>635</b> may trigger an interrupt service routine at an interrupt handler of processor <b>400</b>. The interrupt routine responds to the host system <b>110</b> confirming that a write process has been completed. In the mean time, processor <b>400</b> may execute firmware stored in ROM <b>430</b> to take care of sector data in FIFO <b>630</b> and execute the write process.</p>
<p id="p-0046" num="0045">Microprocessor <b>400</b> may be an 8-bit or a 16-bit processor. Microprocessor <b>400</b> may be operable to respond to host system <b>110</b> requests and communicate with second portion <b>130</b> through card controller <b>440</b>, <b>460</b>. As firmware algorithms become more complicated, tradeoffs between performance and cost may determine the proper microprocessor selected.</p>
<p id="p-0047" num="0046">In order to achieve logical to physical address translation, two look up tables may be used, write look up table <b>640</b> for write access and read look up table <b>645</b> for read access. Write look up table <b>640</b> and read look up table <b>645</b> provide an index or indexing scheme to flash memory array <b>550</b>. A block copy and recycling FIFO <b>650</b> may be used with a write pointer <b>655</b> and two read pointers <b>660</b> and <b>662</b> assigned for block valid sector copy and erase operations. These two functions may share one FIFO mechanism to fulfill this purpose and may run in the background.</p>
<p id="p-0048" num="0047">The physical usage table <b>670</b> may be used for physical sector mapping bookkeeping and may provide a bitmap indicating programmed sectors, that is, sectors to which data has already been written. Card controllers <b>440</b> and <b>460</b> may interface with second portion <b>130</b> to carry out commands from processor <b>400</b>. Card controllers <b>440</b> and <b>460</b> may receive physical block addresses (PBAs) from write and read look up tables <b>640</b> and <b>645</b> respectively to service write and read requests.</p>
<p id="p-0049" num="0048">For optimal ASIC implementation, the write look up table <b>640</b>, the read look up table <b>645</b>, the physical usage table <b>670</b>, and the recycling FIFO <b>650</b> may be implemented with volatile random access memory <b>420</b>.</p>
<p id="p-0050" num="0049">With reference to <figref idref="DRAWINGS">FIG. 7</figref>, logical block addresses (LBAs) <b>700</b> may be used to index the write look up table <b>640</b> and the read look up table <b>645</b>. Block offset bits (bit<b>0</b> to bit<b>5</b>) may not be needed as both the write look up table <b>640</b> and the read look up table <b>645</b> use a block address based search mechanism. PBAx <b>705</b> may be a physical block address of flash memory array <b>550</b> (<figref idref="DRAWINGS">FIG. 5</figref>) and sector valid field <b>710</b> may include a bit which may indicate whether this specific sector data is valid or not. Each entry in the write look up table <b>640</b> and read look up table <b>645</b> may point to a physical block address.</p>
<p id="p-0051" num="0050">Read look up table <b>645</b> may be dedicated to read transactions while write look up table <b>640</b> may be dedicated to write transactions. To maintain block address consistency and achieve write efficiency, the write process may be segregated into two phases. Once the exact addresses are calculated from the write look up table <b>640</b>, new data sectors may be written into flash memory <b>550</b> immediately and control returned to the firmware routine. If a next transaction is a read transaction, a physical block address may be looked up from the read look up table <b>645</b> if the read address is different from the last write address. In the meantime, a valid sector copy from an old block to a new block may be performed in the background to maintain data coherency.</p>
<p id="p-0052" num="0051">Every time a sector-write occurs, usage information may be recorded in the physical usage table <b>670</b>. Bit mapping of the physical usage table <b>670</b> is a recording of all sectors used.</p>
<p id="p-0053" num="0052">Each time a sector-write occurs, an obsolete block may be put in the block copy and recycling FIFO <b>650</b>. The copying process may be started when the write process is complete. The erasing and recycling processes may be started when all necessary copies are completed.</p>
<p id="p-0054" num="0053">A flash memory data structure generally designated <b>800</b> is shown in <figref idref="DRAWINGS">FIG. 8</figref> including a data field <b>810</b> having 512 or 2112 bytes. Spare fields may include ECC <b>820</b>, bad block indicator <b>815</b>, erase count <b>840</b> for each block as a life time mileage indicator, and a logical block address field <b>850</b> for system initialization. A bad block may occur when read/write sector data fails or erase block fails. A last block bookkeeping field <b>830</b> may be easier for the firmware routine to read with setting <b>835</b> as one bit per block. To maintain reliability, four copies of bad block indicators may be saved in a last block of the flash memory <b>550</b>.</p>
<p id="p-0055" num="0054">In accordance with the USB 2.0 protocol, host system <b>110</b> is always the command master which sends out commands through token packets. In the mass storage class, bulk-only transport is the standard which uses Reduced Block Command (RBC) of the SCSI communication protocol to read/write a target flash device. A 31 byte command format describes the read/write direction, logical block address, and transfer sector length as the sector count. The firmware routine processes the command by using the flash memory <b>550</b> as a storage medium.</p>
<p id="p-0056" num="0055">A method of processing a USB command in accordance with the invention generally designated <b>900</b> is shown in <figref idref="DRAWINGS">FIG. 9</figref>. In step <b>905</b> receipt of a USB command/status token packet from the host system <b>110</b> may be determined. If no USB command/status token packet has been received, then in step <b>910</b> the status of the recycling FIFO <b>650</b> may be determined. If the recycling FIFO <b>650</b> is not empty, then in step <b>920</b>, a flash recycling process may be performed as further described herein. If the recycling FIFO <b>650</b> is empty, the processing returns to step <b>905</b>.</p>
<p id="p-0057" num="0056">If a USB command/status token packet has been received, then in step <b>925</b>, the packet may be processed by the serial interface engine <b>610</b> (<figref idref="DRAWINGS">FIG. 6</figref>). Next, in step <b>930</b> the bulk-only transport unit <b>615</b> may receive command block wrappers.</p>
<p id="p-0058" num="0057">In step <b>935</b>, it may be determined if the packet is an IN packet. If the packet is not an IN packet then in step <b>940</b> sector FIFO <b>630</b> is filled and an interrupt is sent to microprocessor <b>400</b>. Once the write data is written to the sector FIFO <b>630</b>, an ACK write status is returned to the host system <b>110</b> in step <b>945</b>. In step <b>950</b> the write flash process may be started by the firmware routine.</p>
<p id="p-0059" num="0058">If the packet is an IN packet then in step <b>955</b> it may be determined if the logical block address matches the LBAs in the sector FIFO <b>603</b>. If the logical block address does not match, then in step <b>960</b> the read process may be started and in step <b>965</b> an ACK read status may be returned to the host system <b>110</b>. If the logical block address matches, then in step <b>970</b> the sector FIFO <b>630</b> may be read and in step <b>975</b> an ACK read status returned to the host system <b>110</b>. Following either of step <b>965</b> or step <b>975</b>, the process may return to step <b>905</b>.</p>
<p id="p-0060" num="0059">A main firmware routine generally designated <b>1000</b> is shown in <figref idref="DRAWINGS">FIG. 10A</figref> and may include a step <b>1002</b> in which the processor <b>400</b> idles while waiting for a CBW read or write request. If a write request is received in a step <b>1004</b> it may be determined if there is enough space in the sector FIFO <b>630</b>. If there is insufficient space, in a step <b>1006</b> a NAK handshake packet may be sent to the host system <b>110</b>. If there is enough space, the write data may be received successfully and written to the sector FIFO <b>630</b> in a step <b>1008</b>. In a step <b>1010</b> an ACK handshake packet may be sent to the host system <b>110</b> to indicate that the write data was received correctly.</p>
<p id="p-0061" num="0060">If a read request is received, the read process may be executed in step <b>1012</b>. In step <b>1014</b> the read data may be returned to the host system <b>110</b> in a data packet. After completion of either step <b>1010</b> or step <b>1014</b> the routine may return to step <b>1002</b>.</p>
<p id="p-0062" num="0061">A sector write process generally designated <b>1020</b> is shown in <figref idref="DRAWINGS">FIG. 10B</figref>. Phase I write process <b>1020</b> may be independent of process <b>1000</b> and may have a lower priority than process <b>1000</b>. In step <b>1022</b> it may be determined if the sector FIFO <b>630</b> is empty. If the sector FIFO <b>630</b> is empty, then process <b>1020</b> returns to step <b>1022</b>. If the sector FIFO <b>630</b> is not empty, then in step <b>1024</b> it may be determined if a request has been received. If a request has been received the process returns to process <b>1000</b> (<figref idref="DRAWINGS">FIG. 10A</figref>). If no request has been received then in a step <b>1026</b> a phase I sector write process may be performed. In step <b>1027</b> it may be determined if a block has been moved. If a block has been moved, then in step <b>1028</b> the block copy and recycling FIFO is updated. Otherwise, nothing needs to be done. Phase I sector write process <b>1020</b> may include writing sector data at the top of the sector FIFO to flash memory <b>550</b>. Process <b>1020</b> then returns to step <b>1022</b>.</p>
<p id="p-0063" num="0062">A block copy process generally designated <b>1030</b> is shown in <figref idref="DRAWINGS">FIG. 10C</figref>. Block copy process <b>1030</b> may be independent of process <b>1000</b> and process <b>1020</b> and may be operable to maintain data coherency. In a step <b>1032</b> it may be determined if the block copy FIFO <b>650</b> is empty. If it is empty, the process <b>1030</b> returns to step <b>1032</b>. If the block copy FIFO <b>650</b> is not empty, then in step <b>1034</b> it is determined if a request has been received. If a request has been received the process returns to process <b>1000</b> (<figref idref="DRAWINGS">FIG. 10A</figref>). If a request has not been received, then in step <b>1036</b> it is determined if the sector FIFO <b>630</b> is empty. If the sector FIFO <b>630</b> is empty then the process <b>1030</b> may return to process <b>1032</b>. If the sector FIFO <b>630</b> is not empty then a phase <b>11</b> block copy process may be performed in step <b>1038</b>. In step <b>1040</b> read pointer <b>662</b> may be incremented.</p>
<p id="p-0064" num="0063">The erase and recycling process generally designated <b>920</b> is shown in <figref idref="DRAWINGS">FIG. 10D</figref>. Erase and recycling process <b>920</b> may be independent of processes <b>1000</b>, <b>1020</b>, and <b>1030</b> and may be operable to make blocks available for writing. In a step <b>1052</b> it may be determined if the recycling FIFO <b>650</b> is empty. If the recycling FIFO <b>650</b> is empty then the process <b>1050</b> returns to step <b>1052</b>. If the recycling FIFO <b>650</b> is not empty then in step <b>1054</b> it is determined if a request has been received. If a request has been received the process returns to process <b>1000</b> (<figref idref="DRAWINGS">FIG. 10A</figref>). If a request has not been received, then in step <b>1056</b> it is determined if the sector FIFO <b>630</b> is empty. If the sector FIFO <b>630</b> is not empty, then the process <b>1050</b> may return to process <b>1020</b> (<figref idref="DRAWINGS">FIG. 10B</figref>). If the sector FIFO <b>630</b> is empty, then in step <b>1058</b> it may be determined if the block copy FIFO <b>650</b> is empty. If the block copy FIFO <b>650</b> is not empty, then the process <b>1050</b> may return to process <b>1030</b> (<figref idref="DRAWINGS">FIG. 10C</figref>). If the block copy FIFO <b>650</b> is empty, then in step <b>1060</b> an erase block and recycle process may be executed and in step <b>1062</b> the read pointer <b>660</b> may be incremented.</p>
<p id="p-0065" num="0064">With reference to <figref idref="DRAWINGS">FIGS. 11A through 11F</figref>, the processes of the invention will be explained with reference to an example. Three write transactions A (<figref idref="DRAWINGS">FIG. 11A</figref>), B (<figref idref="DRAWINGS">FIG. 11B</figref>), and C (<figref idref="DRAWINGS">FIG. 11C</figref>) may be performed and then the written data may be updated as shown in <figref idref="DRAWINGS">FIGS. 11D through 11F</figref>. For purposes of illustration, flash memory <b>550</b> is shown as having four sectors per block. Translation to physical block addresses may have two SRAM for this purpose, one for read access and one for write access. The index to both SRAM may be the logical block address <b>700</b> without offset bits.</p>
<p id="p-0066" num="0065">To improve the speed of the read/write process, the write process may be separated into several processes. In the sector write process <b>1020</b>, write data sector may be written to flash memory <b>550</b>. In the block copy process <b>1030</b>, the line copy is performed in the background to maintain data coherency. After the write process is completed, the write look up table <b>640</b> and the read look up table <b>645</b> may be synchronized. Read look up table <b>645</b> may be dedicated to read access immediately after a write due to the fact that immediately after a write, sector data in the old block may not be available in the new written block.</p>
<p id="p-0067" num="0066">The write process may be separated into two phases. In phase I, after the sector data is written into the new block, the write look up table <b>640</b> is updated. Phase II may be executed in the background to maintain data coherency.</p>
<p id="p-0068" num="0067">With reference to <figref idref="DRAWINGS">FIG. 11A</figref>, write transaction A includes writing to six sectors of flash memory <b>550</b>. Since flash memory is empty before the write transaction, write look up table <b>640</b> may be updated with the first physical block address (0) as it points to this particular memory block. In the meantime, the physical usage table <b>670</b> is updated to indicate which sectors are occupied. The firmware routine uses the physical usage table <b>670</b> to decide which sectors to write to.</p>
<p id="p-0069" num="0068">Write transaction B is shown in <figref idref="DRAWINGS">FIG. 11B</figref>. Only one sector in flash memory <b>550</b> is used. Write transaction C is shown in <figref idref="DRAWINGS">FIG. 11C</figref> and includes writing to two sectors which cross a block boundary. Read look up table <b>645</b> may be copied from write look up table <b>640</b> for read access to synchronize read look up table <b>645</b> with write look up table <b>640</b> after both write phases are completed.</p>
<p id="p-0070" num="0069">With reference to <figref idref="DRAWINGS">FIG. 11D</figref>, data written in write transaction A may be updated to include data written to five sectors. Since rewriting flash memory <b>550</b> requires an erase, a faster way to accomplish the update without waiting for an erase is to find a new block to write the updated data to. By checking the physical usage table <b>670</b>, it may be determined that a next available empty block is physical block <b>3</b>. The updated data may be written to five sectors in blocks <b>3</b> and <b>4</b>. The sector count in this transaction is five and therefore continuous sector write will occur. The write look up table <b>640</b> is updated with the new physical block address <b>3</b>. In physical block address <b>3</b>, no line copy is required because the whole block is written by one transaction. Block <b>0</b> may be put into recycling FIFO <b>650</b> as the first block to be erased. FIFO write pointer <b>655</b> may be incremented to point to a next position.</p>
<p id="p-0071" num="0070">When sector <b>4</b> of transaction A is updated, a block boundary is crossed. A <b>5</b> will not be used anymore. Transactions B and C are now on a same block. To maintain data coherency in the write look up table <b>640</b>, some sectors of physical block <b>1</b> must be copied to physical block <b>4</b>. Physical block <b>1</b> may be put into block copy &amp; recycling FIFO <b>650</b> and write pointer <b>655</b> may be incremented. B and C<b>0</b> may be copied to block <b>4</b>. Write look up table may also be updated to physical block <b>4</b>. From the point of view of flash memory <b>550</b>, there is no indication that A in block <b>1</b> and <b>2</b> is no longer valid. Only the file system knows.</p>
<p id="p-0072" num="0071">With reference to <figref idref="DRAWINGS">FIG. 11E</figref>, transaction B may be updated with two sectors. First, new data b<b>0</b> is written into physical block <b>5</b>. Then, the other sectors of physical block <b>4</b> may be copied to block <b>5</b>. Write look up table <b>645</b> second entry may be updated to <b>5</b> to reflect the new changes. Block <b>4</b> may be put into recycling FIFO <b>650</b> for erasure. After b<b>0</b> is written, b<b>1</b> is written into physical block <b>2</b>. Write pointer <b>655</b> may be incremented to point to the next position.</p>
<p id="p-0073" num="0072">With reference to <figref idref="DRAWINGS">FIG. 11F</figref>, transaction C may be updated with a same number of sectors. By checking the write look up table <b>645</b>, it is known that block <b>5</b> has part of transaction C. Block <b>5</b> may be copied to block <b>6</b> with the updated transaction. Since C<b>1</b> is in block <b>2</b>, block <b>2</b> needs to be in block <b>7</b>. Blocks <b>5</b> and <b>2</b> may be put in recycling FIFO <b>650</b> for erasure. After block <b>0</b> is erased, read pointer <b>662</b> may be incremented. Physical usage table <b>670</b> may be cleared for use.</p>
<p id="p-0074" num="0073">Logical block address (LBA) and sector count may be recorded from command block wrappers (CBW). Whenever sector FIFO <b>630</b> is not empty, an interrupt <b>635</b> may be sent to processor <b>400</b>. Inside the interrupt service routine, write sector process <b>1026</b> may be executed. The algorithm always handles one sector at a time. Sector count is decremented whenever a sector is written into flash. When the sector count equals zero, process <b>1026</b> is complete. To achieve higher performance and maintain data coherency, the flash write process may be divided into two phases. Phase I write sector process generally designated <b>1026</b> is shown in <figref idref="DRAWINGS">FIG. 12</figref>. Phase I write sector process <b>1026</b> may write a received sector data to available flash memory <b>550</b>. To maintain data coherency, valid data sectors in an old physical block may be copied to a new block pointed to by the updated write look up table <b>640</b>.</p>
<p id="p-0075" num="0074">A block copy FIFO may be dedicated for this purpose. Old write look up table <b>640</b> entries may be put into block copy FIFO for background operation. Both write look up table <b>640</b> and read look up table <b>645</b> may be synchronous and identical when phase II write process is complete. Priority is given first to demand write, then to background copy and then to erase and recycling.</p>
<p id="p-0076" num="0075">Phase I write sector process <b>1026</b> may include a step <b>1205</b> in which logical block address and sector count are loaded from the incoming CBW. In a step <b>1210</b> block offset bits may be used as the sector number. LBAx is the block address used as an index to the write look up table <b>640</b> to look through for a corresponding physical block address. As an example, if LBA is 0010,0101 and the number of sectors in a block is <b>16</b>, then 0010 will be the LBAx for the entry pointer of both the write look up table <b>640</b> and the read look up table <b>645</b>. Since at power up all initial SRAM contents are unknown, firmware may search through flash spare LBA field to rebuild both the write look up table <b>640</b> and the read look up table <b>645</b>.</p>
<p id="p-0077" num="0076">In step <b>1211</b>, the LBA may be used to find the corresponding entry in the write look up table <b>640</b>. Then the valid bit for the PBA field may be examined (not shown). If the PBA field is not valid, then in step <b>1212</b> an available free block may be found in physical usage table <b>670</b>. In step <b>1213</b> the physical address of the available free block may be used to update the PBA field of the write look up table <b>640</b> entry.</p>
<p id="p-0078" num="0077">Following step <b>1213</b> or step <b>1211</b> in the case where the PBA field is valid, in step <b>1215</b> a sector valid field in the write look up table <b>640</b> is checked. If the sector valid field bit is set to one, then old data exists in the sector and a new free block must be used and the old block moved to the block copy and recycling FIFO <b>650</b> in step <b>1220</b>. When moving to the block copy and recycling FIFO <b>650</b> the physical block address may be directly copied. The sector bits may require some tweaking. The sector valid bits for all new write sectors may be cleared. All other sector valid bits may remain the same. In step <b>1225</b> an available free block may be found from the physical usage table <b>670</b>. In the case where the sector valid field is set to zero, the sector is free to be used and process <b>1026</b> may proceed to step <b>1230</b>.</p>
<p id="p-0079" num="0078">In step <b>1230</b> sector data may be written into flash memory <b>550</b>. Additionally, the sector valid field bit may be set to one in the write look up table <b>640</b>. In step <b>1235</b> the physical block address sector bit may be set to one in the physical usage table <b>670</b>. In step <b>1240</b> the sector number may be incremented to continue the process <b>1026</b>. During the erase and recycle process <b>920</b>, the block pointed to by read pointer <b>660</b> may be erased and the physical usage table cleared accordingly. This indicates that the block is available to be used again.</p>
<p id="p-0080" num="0079">In step <b>1260</b> the sector count may be decremented and in step <b>1265</b> it may be determined if the sector count is zero. If the sector count is zero the process <b>1026</b> ends. Otherwise, the write data availability may be checked in sector FIFO <b>630</b> in step <b>1270</b>. If no write data is available then it may be determined if the process <b>1026</b> has timed out in step <b>1275</b>. If the process <b>1026</b> has timed out, then an error has occurred and the process <b>1026</b> ends. If the process <b>1026</b> has not timed out, then processing returns to step <b>1270</b>.</p>
<p id="p-0081" num="0080">In step <b>1245</b> the current sector number is checked against a total sector number per block. If they are not equal, meaning that the end of the block has not been reached, then process <b>1026</b> returns to step <b>1230</b> to write a next sector data. If they are equal, meaning that the end of the block has been reached, in step <b>1285</b> the LBAx field may be incremented when a flash block boundary is reached. In step <b>1290</b> the sector number may be cycled back to sector number zero and processing returned to step <b>1211</b>.</p>
<p id="p-0082" num="0081">The phase II block copy process <b>1038</b> is shown in <figref idref="DRAWINGS">FIG. 13</figref> and may be done in the background whenever the block copy FIFO <b>650</b> is not empty. Block copy FIFO <b>650</b> may be determined to be not empty by comparing pointer values of write pointer <b>655</b> and read pointer <b>662</b> in step <b>1310</b>. If the value of write pointer <b>655</b> is not greater than the value of read pointer <b>662</b> then the process <b>1300</b> ends. The sector valid field from FIFO entry pointed to by read pointer <b>662</b> may indicate valid sectors that need to be copied to the new physical block address for data consistency. The sector number may be set to zero in step <b>1311</b>. A determination in step <b>1315</b> may be made whether a current sector must be copied or not. If it must be copied, it may be copied in step <b>1320</b>. A location of this sector in the physical usage table <b>670</b> may be set in step <b>1325</b> for the new physical address entry. The location in the write look up table <b>640</b> may be set in step <b>1330</b> and a sector offset number incremented in step <b>1335</b>. If the current sector must not be copied, then process <b>1300</b> proceeds to step <b>1335</b>.</p>
<p id="p-0083" num="0082">Sector copy may be determined to be complete when the sector number reaches the block boundary in step <b>1340</b>. If sector copy is complete read pointer <b>662</b> may be incremented in step <b>1345</b> and the PBA entry in the read look up table <b>640</b> is updated with the PBA entry in the write look up table <b>645</b> in step <b>1350</b>. Processing then returns to step <b>1310</b>. If sector copy is not complete, processing returns to step <b>1315</b>.</p>
<p id="p-0084" num="0083">The erase block and recycle process <b>1060</b> is shown in <figref idref="DRAWINGS">FIG. 14</figref>. In step <b>1410</b> read pointers <b>660</b> and <b>662</b> may be compared. If they are equal the process <b>1400</b> ends. If they are not equal, a physical block pointed to by read pointer <b>660</b> may be erased. Firmware may read out the physical block address pointed to by read pointer <b>660</b> and the physical block erased in step <b>1420</b>. In step <b>1430</b> a corresponding physical usage table <b>670</b> entry may be cleared to zero to indicate that the physical block is free to be used again. Read pointer <b>660</b> may be incremented for a next background recycling operation in a step <b>1440</b>.</p>
<p id="p-0085" num="0084">A read process generally designated <b>1500</b> is shown in <figref idref="DRAWINGS">FIG. 15</figref>. Read process <b>1500</b> may be performed by firmware once a CBW is received and recognized as a read command. In step <b>1505</b> the logical block address register <b>625</b> and the sector count register may be loaded from the CBW. The write pointer look up table <b>640</b> may be accessed first by using the logical block address as an index. The offset of the logical block address may be used to index into the corresponding entry to see if the sector is available in the physical block or not, in step <b>1510</b>. If the block has already been moved to a new location, the sectors that need to be copied over may not have been copied yet because the copying process may be done in the background, which will take some amount of time.</p>
<p id="p-0086" num="0085">If the sector is available, then in step <b>1515</b> the write look up table <b>640</b> may be used to translate logical block addresses to physical block addresses. If the sector is not available, the physical block address in the write look up table <b>640</b> is a new block and the old data is still in the old block, which is still pointed to by the entry in read look up table <b>645</b>. In this case, read look up table <b>645</b> is used to translate the logical block address to the physical block address in step <b>1520</b>.</p>
<p id="p-0087" num="0086">Read process <b>1500</b> immediately after writing has a higher priority than the phase II block copy process <b>1038</b> in order to have better system performance and read response time.</p>
<p id="p-0088" num="0087">After translation, the resultant physical address may be used to read data from flash memory <b>550</b>, the sector count decremented and the sector number incremented in step <b>1525</b>. In step <b>1530</b> the ECC may be calculated from the read sector data and in step <b>1535</b> the calculated ECC may be compared with a stored ECC. If they are not equal, then further analysis may be performed to determine if the error is correctable in step <b>1540</b>. If not correctable, the process <b>1500</b> fails in step <b>1545</b>. If correctible, then an ECC correction process is executed in step <b>1550</b>.</p>
<p id="p-0089" num="0088">In step <b>1555</b> the current sector data may be ready to be returned to host <b>110</b>. In step <b>1560</b> it may be determined if the sector count is equal to zero. If sector count equals zero then process <b>1500</b> ends. In step <b>1565</b> the block boundary may be checked. If the block boundary has been reached, the logical block address may be incremented in step <b>1570</b> and the offset bits set to zero is step <b>1575</b>. Since CBW only has a starting address, all intermediate addresses will be generated internally.</p>
<p id="p-0090" num="0089">It will be apparent to those skilled in the art that various modifications and variations can be made to the structure of the present invention without departing from the scope or spirit of the invention. In view of the foregoing, it is intended that the present invention cover modifications and variations of this invention provided they fall within the scope of the following claims and their equivalents.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A memory flash card reader for writing to and reading from a memory flash card comprising:
<claim-text>a processor for receiving at least one request from a host system;</claim-text>
<claim-text>an index comprising information regarding sectors of the memory flash card wherein the processor may utilize the index to determine sectors of the memory flash card that are available for writing, erasing and reading, the index further comprising a write look up, table, a read look up table and a physical usage table;</claim-text>
<claim-text>a block copy and recycling first-in-first-out unit (FIFO); and</claim-text>
<claim-text>at least one card controller coupled to the processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one request comprises a logical block address for reading or writing and wherein the index maps the logical block address to a physical block address in the memory flash card.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is operable to recycle obsolete blocks from the FIFO in the background with respect to the host system to free up resources of the host system.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is operable to recycle obsolete blocks from the FIFO after a block sector copy process.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a Universal Serial Bus interface to the host system.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is operable to communicate with the host system using a Bulk Only Transport protocol.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is operable to communicate with the host system using the SCSI transparent command set protocol.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is operable to communicate with the host system using the Reduced Block Command T10 Project 240-D protocol.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory flash card functions as a floppy disk.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory flash card reader can be applied to USB and ExpressCard plug and receptacle systems.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one card controller comprises a USB controller.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one card controller comprises a Secure Digital controller.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one card controller comprises a MultiMediaCard controller.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one card controller comprises a Memory Stick controller.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The memory flash card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one card controller comprises a Compact Flash controller.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The flash memory card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor, index and at least one card controller are housed in a box coupled to the host system by a cable.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The flash memory card reader of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor, index and at least one card controller are housed in the host system.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A method of managing a flash memory comprising the steps of:
<claim-text>receiving at least one request from a host system in a processor within a flash memory controller;</claim-text>
<claim-text>determining which sectors of the flash memory are available for writing, erasing and reading utilizing the processor and an index coupled to the processor, the index comprising a write look up table, a read look up table and a physical usage table;</claim-text>
<claim-text>recycling obsolete blocks copy and recycling first-in-first-out unit (FIFO) after a block sector copy process; and</claim-text>
<claim-text>writing, erasing and reading to a flash memory card through at least one card controller coupled to the processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein determining which sectors of the flash memory are available for writing, erasing and reading comprises mapping a logical block address provided in the at least one request from the host system to a physical block address in the flash memory card utilizing the index.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the recycling of obsolete blocks occurs in the background with respect to the host system to free up resources of the host system.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the recycling of obsolete blocks occurs after a block sector copy of valid data from sectors of a first block to sectors of a second block, the first block becoming an obsolete block, and wherein the sectors of the first block are erased.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the flash memory controller is coupled to the host system by a Universal Serial Bus interface.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the processor is operable to communicate with the host system using a Bulk Only Transport protocol.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the processor is operable to communicate with the host system using the SCSI transparent command set protocol.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the processor is operable to communicate with the host system using the Reduced Block Command T10 Project 240-D protocol.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the memory flash card functions as a floppy disk.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the memory flash card reader can be applied to USB and ExpressCard plug and receptacle systems.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the at least one card controller comprises a USB controller.</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the at least one card controller comprises a Secure Digital controller.</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the at least one card controller comprises a MultiMediaCard controller.</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the at least one card controller comprises a Memory Stick controller.</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The method of managing a flash memory of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the at least one card controller comprises a Compact Flash controller.</claim-text>
</claim>
</claims>
</us-patent-grant>
