<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298297-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298297</doc-number>
<kind>B1</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11207131</doc-number>
<date>20050818</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>146</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>03</class>
<subclass>M</subclass>
<main-group>7</main-group>
<subgroup>40</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>341 65</main-classification>
<further-classification>341 50</further-classification>
<further-classification>341 51</further-classification>
</classification-national>
<invention-title id="d0e53">Hardware-implemented Huffman decoder</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5784631</doc-number>
<kind>A</kind>
<name>Wise</name>
<date>19980700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>382246</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5881301</doc-number>
<kind>A</kind>
<name>Robbins</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  1</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5965741</doc-number>
<kind>A</kind>
<name>Breault et al.</name>
<date>19991000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>548252</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6435737</doc-number>
<kind>B1</kind>
<name>Wise et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712200</main-classification></classification-national>
</citation>
</references-cited>
<number-of-claims>19</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>341 50</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>341512</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>341 65</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>17</number-of-drawing-sheets>
<number-of-figures>27</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60522116</doc-number>
<kind>00</kind>
<date>20040818</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60522128</doc-number>
<kind>00</kind>
<date>20040818</date>
</document-id>
</us-provisional-application>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Li</last-name>
<first-name>Shao-Lun</first-name>
<address>
<city>Kaohsiung</city>
<country>TW</country>
</address>
</addressbook>
<nationality>
<country>TW</country>
</nationality>
<residence>
<country>TW</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Thomas, Kayden, Horstemeyer &amp; Risley</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Mediatek Inc.</orgname>
<role>03</role>
<address>
<city>Hsin-Chu</city>
<country>TW</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Jeanglaude</last-name>
<first-name>Jean Bruner</first-name>
<department>2819</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A hardware-implemented Huffman decoder converting Huffman-encoded data to raw data using logic gates to implement logic states. The logic states include IDLE, COEFF_READ, COEFF_WRITE, HUFF_ADDR_LOG, HUFF_ADDR_PHY, AMP_CAL, and EOB_RUN<sub>13 </sub>GEN. IDLE state transfers to COEFF_READ or AMP_CAL states according to eob_run, ac_first_scan, and ss signals, COEFF_READ state transfers to HUFF_ADDR_LOG or AMP_CAL states according to ac_first_scan, ac_refine_scan, eob_run, new_ac_nonzero_coeff, and dc_refine_scan signals. COEFF_WRITE state transfers to AMP_CAL or COEFF_READ states according to ac_first_scan, coeff_index, zero_run, and eob_run signals. HUFF_ADDR_LOG state transfers to HUFF_ADDR_PHY state and HUFF_ADDR_PHY state transfers to AMP_CAL or EOB_RUN_GEN states according to ac_first_scan and ac_refine_scan signals. AMP_CAL state transfers to AMP_CAL, COEFF_WRITE, or HUFF_ADDR_LOG states according to dc_first_scan, dc_refine_scan, ac_first_scan, ac_refine_scan, coeff_index, zero_run, eob_run, new_ac_nonzero_coeff, se, and progr_coeff<b>0</b>_pool signals. EOB_RUN_GEN state transfer to AMP_CAL state.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="168.06mm" wi="146.05mm" file="US07298297-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="192.19mm" wi="151.98mm" file="US07298297-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="201.68mm" wi="143.51mm" file="US07298297-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="198.80mm" wi="119.30mm" orientation="landscape" file="US07298297-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="202.61mm" wi="122.09mm" orientation="landscape" file="US07298297-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="204.05mm" wi="135.30mm" orientation="landscape" file="US07298297-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="208.87mm" wi="135.97mm" orientation="landscape" file="US07298297-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="199.39mm" wi="129.79mm" file="US07298297-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="206.08mm" wi="123.44mm" file="US07298297-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="204.39mm" wi="130.22mm" file="US07298297-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="195.24mm" wi="144.02mm" file="US07298297-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="215.48mm" wi="134.62mm" file="US07298297-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="127.76mm" wi="132.42mm" file="US07298297-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="195.50mm" wi="138.68mm" file="US07298297-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="169.08mm" wi="141.73mm" file="US07298297-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="148.42mm" wi="143.68mm" file="US07298297-20071120-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="206.33mm" wi="148.76mm" file="US07298297-20071120-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="216.83mm" wi="163.83mm" file="US07298297-20071120-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE APPLICATION</heading>
<p id="p-0002" num="0001">This application claims priority from U.S. Provisional Patent Application Ser. No. 60/522,116 No. and U.S. Provisional Patent Application Ser. No. 60/522,128 filed both on Aug. 18, 2004. Both the '116 and '128 applications are incorporated herein in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">The invention relates to image decoding, and in particular to methods and systems for decoding images conforming to JPEG format.</p>
<p id="p-0004" num="0003">JPEG (Joint Photographic Experts Group) format is a popular static image compression technology. Currently, more than 90% of static image files conform to JPEG format.</p>
<p id="p-0005" num="0004">JPEG format is commonly used as a file transfer format for multimedia communications. Generally, photos or images captured by digital cameras are pre-stored and then displayed or transmitted to computers for further editing process. Thus, a standard format, such as the JPEG format, which simultaneously compatible with the digital cameras and computers is required. Another reason for using the JPEG format is that JPEG image compression/encoding reduces huge storage requirement of image files. The memory-reduction feature is especially advantageous for specific application devices, such as mobile phones, digital cameras, or personal digital assistants (PDAs).</p>
<p id="p-0006" num="0005">Two scan modes may be employed to JPEG images, baseline and progressive modes. An image can be divided into frames for encoding/decoding. While being scanned in baseline scan mode, an image frame is completely scanned at one time and all image information, such as hue values, is obtained from the onetime scan. While being scanned in progressive mode, the image frame is scanned repeatedly in each scan.</p>
<p id="p-0007" num="0006">The baseline mode scan produces a simpler file structure that makes the corresponding JPEG decoder easier to implement. While presently JPEG decoders focus on baseline scan mode, JPEG decoders in progressive scan mode are however desirable in the future. Since the progressive mode produces a much more complex file structure, it raises a problem that the decoding speed by the traditional decoder becomes intolerably slow.</p>
<p id="p-0008" num="0007">It is an important issue to have a better JPEG decoder for decoding JPEG images in either the baseline or progressive modes.</p>
<p id="p-0009" num="0008">Huffman coding is an entropy encoding algorithm used for lossless data compression. The term “entropy encoding” refers to the use of a variable-length code table for encoding a source symbol where the variable-length code table has been derived based on the estimated probability of each possibly value of the source symbol. Huffman coding is currently used as compression method for multimedia coding, such as JEPG or MP3.</p>
<p id="p-0010" num="0009">A JPEG image frame in progressive mode can be scanned by DC first scan, DC refine scan, AC first scan, or AC refine scan. If an image frame is scanned in DC scan, the scan contains only DCT (Discrete Cosine Transform) coefficient <b>0</b>. If an image frame is scanned in AC scan, the scan contains no DCT coefficient <b>0</b>. Additionally, a first scan means that a scan contains MSBs (most significant bits) of DCT coefficients and a refine scan means that a scan contains no MSBs of DCT coefficients. For progressive JPEG images, DC coefficients can be completely retrieved according to each DC first scan and DC refine scan. Similarly, AC coefficients can be fully regained according to each AC first scan and AC refine scan.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0011" num="0010">An exemplary embodiment of a Huffman decoder uses logic gates to implement logic states. The logic states comprise IDLE, COEFF_READ, COEFF_WRITE, HUFF_ADDR_LOG, HUFF_PHY, AMP_CAL, and EOB_RUN_GEN states. IDLE state transfers to COEFF_READ or AMP_CAL state according to eob_run, ac_first_scan, and ss signals. COEFF_READ state transfer to HUFF_ADDR_LOG or AMP_CAL state according to ac_first_scan, ac_refine_scan, eob_run, new_ac_nonzero_coeff, and dc_refine_scan signals. COEFF_WRITE state transfers to AMP_CAL or COEFF_READ state according to ac_first_scan, coeff_index, zero_run, and eob_run signals. HUFF_ADDR_LOG state transfers to HUFF_ADDR_PHY state. HUFF_ADDR_PHY state transfers to AMP_CAL or EOB_RUN_GEN state according to ac_first_scan and ac_refine_scan signals. AMP_CAL state transfers to AMP_CAL, COEFF_WRITE, or HUFF_ADDR_LOG logic state according to dc_first_scan, dc_refine_scan, ac_first_scan, ac_refine_scan, coeff_index, zero_run, eob_run, new_ac_nonzero_coeff, se, and progr_coeff0_pool signals. EOB_RUN_GEN state transfers to AMP_CAL state.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011">The invention can be more fully understood by reading the subsequent detailed description and examples with references made to the accompanying drawings, wherein:</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram of an embodiment of a JPEG decoder in hardware.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref><i>a </i>is a diagram of an exemplary embodiment of a DC coefficient.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 2</figref><i>b </i>is a diagram of an exemplary embodiment of an AC coefficient.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 3</figref><i>a </i>is a diagram of an exemplary embodiment of a state machine diagram of a DC first scan.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref><i>b </i>is a diagram of an exemplary embodiment of a state machine diagram of a DC refine scan.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref><i>c </i>is a diagram of an exemplary embodiment of a state machine diagram of an AC first scan.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 3</figref><i>d </i>is a diagram of an exemplary embodiment of a state machine diagram of an AC refine scan.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. 4</figref><i>a</i>-<b>4</b><i>g </i>are diagrams of exemplary embodiments of detailed hardware states for state machine diagrams.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an exemplary embodiment of a state diagram of IDLE state.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIGS. 6</figref><i>a</i>-<b>6</b><i>d </i>are diagrams of exemplary embodiments of detailed state diagrams.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram of an exemplary embodiment of a state diagram of COEFF_WRITE state.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIGS. 8</figref><i>a</i>-<b>8</b><i>c </i>are diagrams of exemplary embodiments of detailed state diagrams.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram of a JPEG image divided into several consecutive portions in the multi-run algorithm.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram of a hardware-implemented multi-run algorithm controller in a Huffman decoder.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 11</figref> is a diagram of a graphical interpretation about the problem with AC refine scan in multi-run algorithm.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 12</figref> is a diagram of the trick for AC refine scan in multi-run algorithm.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DESCRIPTION</heading>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram of an embodiment of a JPEG decoder in hardware. The JPEG decoder comprises a DMA (Direct Memory Access) buffer <b>100</b>, a barrel shift register <b>102</b>, an APB interface <b>104</b>, a market parser <b>106</b>, a JPEG decoder controller <b>108</b>, a progressive address generator <b>110</b>, and a Huffman decoder <b>112</b>.</p>
<p id="p-0030" num="0029">The DMA buffer <b>100</b> is a direct memory access channel. The DMA buffer <b>100</b> receives an image frame in JPEG format, comprising a frame header and scan section, from a memory device through memory interface. The received data is then transmitted to the barrel shift register <b>102</b>. The barrel shift register <b>102</b> provides data for the marker parser <b>106</b>, the JPEG decoder controller <b>108</b>, and the Huffman decoder <b>112</b>.</p>
<p id="p-0031" num="0030">The JPEG decoder controller <b>108</b> handles handshakes information between the marker parser <b>106</b> and the Huffman decoder <b>112</b>. The marker parser <b>106</b> parses the header information from the frame header and scan header. The Huffman decoder <b>112</b> decodes information bits from the parsed data according to the address provided by the progressive address generator <b>110</b>.</p>
<p id="p-0032" num="0031">The marker Parser <b>106</b> also parses information from different headers, such as SOS (Start of Scan) headers, DHT (Define Huffman Table) headers, DQT (Define Quantization Table) headers, and DRI (Define Restart Interval) headers. Concretely, the marker parser <b>106</b> may activate one suitable header parser for header parse. In one embodiment, Huffman decoding-related tables, such as four quantization tables, four DC Huffman tables, and four AC Huffman tables, can be pre-stored in internal or external hardware devices coupled to the marker parser <b>106</b> for image decoding. The Huffman decoding-related tables could be generated by Huffman encoder. A Huffman decoder decodes data by referring to the stored tables.</p>
<p id="p-0033" num="0032">If an image frame is scanned in progressive scan mode, each scan may include one to three data components and each component may include several 8×8 data units. The SOS header parser obtains data information, such as the number of data components contained in the current scan or data units of each data component in a minimum coding unit (MCU). The MCU comprises data components to express hue values of an image frame.</p>
<p id="p-0034" num="0033">The Huffman decoder <b>112</b> converts Huffman-encoded data stream to raw data for Inverse Discrete Cosine Transform (IDCT) unit <b>114</b> to perform inverse discrete cosine transform. APB interface <b>104</b> is an interface of software programs transmitting decoding information. The Huffman decoder <b>112</b> may contain memory buffer <b>114</b> storing data for Huffman-encoded data decoding. When the Huffman decoder <b>112</b> or the marker parser <b>106</b> executes data decoding or data parsing, some decoding information may obtained from the APB interface <b>104</b>. For example, some variables used for data decoding are calculated by software programs of the APB interface <b>104</b>.</p>
<p id="p-0035" num="0034">Due to the nature of progressive JPEG compression, the memory buffer <b>114</b> functions as a temporary buffer for storing the whole JPEG image, which is necessary for decoding a progressive JPEG image. Generally, the memory buffer <b>114</b> stores the intermediate, partially decoded coefficients. All coefficients must remain in the memory buffer <b>114</b> until all scans are processed.</p>
<p id="p-0036" num="0035">The size of the memory buffer <b>114</b> is determined by the decoding image size. If the image size is W×H, the size of the memory buffer <b>114</b> will be W×E×N<sub>1</sub>×N<sub>2</sub>, where N<sub>1 </sub>represents the number of the components in the decoding image and N<sub>2 </sub>represents the number of bits in each coefficient of each component. For example, assuming there are totally 3 components and each coefficient of a component is 11 bits, for a VGA size, the size of the memory buffer <b>114</b> should be about 1.2 Mbytes (Megabytes) (640×480×3×11).</p>
<p id="p-0037" num="0036">For portable devices like cellular phones, it is unreasonable to allocate 1.2 Mbytes memory for progressive JPEG image decoding. In some embodiments, the Huffman decoder <b>112</b> of the present invention applies a multi-run algorithm for reducing the memory usage.</p>
<p id="p-0038" num="0037">In the multi-run algorithm, the JPEG image is divided into several consecutive portions as shown in <figref idref="DRAWINGS">FIG. 9</figref>. In each run, only one portion is processed by the Huffman decoder <b>112</b>. Since only one portion is processed, the memory buffer <b>114</b> only needs to contain the progressive coefficients in that portion and therefore the buffer size in the memory buffer <b>114</b> can be greatly reduced. In some embodiments, the size of each portion is set in the unit of MCU (Minimum Coding Unit) by software programs of the APB interface <b>104</b>. That is, the smallest portion is one MCU. In JPEG specifications, the maximum MCU is composed of ten 8×8 data units and each coefficient takes 2 bytes to store. Therefore, the maximum size of a MCU is 10(data units(×8(width)×8(height)×2(bytes)=1280 Bytes, which is the minimum coefficient buffer size of the memory buffer <b>114</b> for the progressive JPEG decoder to decode progressive JPEG images.</p>
<p id="p-0039" num="0038">Besides storing the coefficients, the memory buffer <b>114</b> also needs to store Huffman/quantization tables. Up to 4 DC Huffman tables, 4 AC Huffman tables and 4 quantization tables are possibly seen in a JPEG file. Since each quantization table is 64 bytes and each pair of DC/AC Huffman table is less than 256 bytes, by the portion dividing multi-run algorithm, the memory buffer <b>114</b> only needs 4×(64+256)=1280 bytes to store all these tables.</p>
<p id="p-0040" num="0039">In other words, the required size of the memory buffer <b>114</b> for progressive coefficients and Huffman/quantization table storage in the progressive JPEG decoder is only 2560 Bytes.</p>
<p id="p-0041" num="0040">In the multi-run algorithm of the present invention, the process the certain portion of a progressive JPEG image file and bypass the rest, it needs some indexes to identify the starting point and end point of the certain portion. Since the portion is measured in the unit of MCU, in the following embodiment, the starting point and end point will be specified in MCU numbers.</p>
<p id="p-0042" num="0041">As a scan in progressive JPEG image file may contain all 3 components or only one of the three components, 4 sets of indexes, including intlv_first_mcu and intlv_last_mcu, comp0_first_data_unit and comp0_last_data_unit, comp1_first_mcu and comp1_last_mcu, and comp2_first_mcu and comp2_last_mcu, are defined and programmed by software.</p>
<p id="p-0043" num="0042">Two kinds of scan orders may be used in decoding data units, interleaved scan and non-interleaved scan. The non-interleaved scan means an image frame is scanned in line by line. That is, the scan moves to the next line only when the scan of the previous line is finished. Conversely. The interleaved scan means an image frame may be scanned from the previous line to next line while the scan of the previous line is not finished. Here, the index of intlv_first_mcu defines the first MCU number to process in an interleaved scan. The index of intlv_last_mcu defines the last MCU number to process in an interleaved scan. The index of comp0_first_data_unt defines the first data unit number to proves in a non-interleaved scan containing component 0 only. The index of comp0_last_data_unit defines the last data unit number to process in a non-interleaved scan containing component 0 only. The index of comp1_first_mcu defines the first dat unit number to process in a non-interleaved scan containing component <b>1</b> only. The index of comp1_last_mcu defines the last data unit number to process in a non-interleaved scan containing component <b>1</b> only. The index of comp2_first_mcu defines the first data unit number to process in a non-interleaved scan containing component <b>2</b> only. The index of comp2_last_mcu defines the last data unit number to process in a non-interleaved scan containing component <b>2</b> only. Given the se indexes, the decoder will skip and not process the data stream before the starting indexes (intlv_first_mcu, comp0_first_data_unit, comp1_first_data_unit, comp2_first_data_unit) and after the end indexes (intlv_last_mcu, comp0_last_data_unit, comp1_last_data_unit, comp2_last_data_unit).</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 10</figref> shows a hardware-implemented multi-run algorithm controller in a Huffman decoder. As shown in <figref idref="DRAWINGS">FIG. 10</figref>, a signal data_skip is generated and input to a Fli-flop device. When the data_skip stays high, the controller will make the Huffman decoder skip the data processing of the current data and not write back the decoded coefficients into the memory buffer <b>114</b>. If data_skip is low, the Huffman decoder will process data as normal. Data_skip is configured by data_skip_set and data_skip_reset.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 10</figref> lists the condition for data_skip_set and data_skip_reset to hold true. After the header parsing is done (SOS marker is over), if the starting index if not 0, data_skip_set must go high to skip the first several MCUs until the index counter reaches the starting index. Also, when the index counter reaches the ending index and the current MCU is done, data_skip_set must go active as well to skip the remaining unnecessary data. Similarly, data_skip_reset goes active when the index counter equals to the starting index minus 1 and the current MCU ends, which means the MCU right before the first valid MCU is over. The data_skip_reset signal doesn't have to act when the starting index is set to 0 because the default value of data_skip is 0 upon hardware reset. A starting index of 0 indicates hardware to process the data from the very first MCU in the JPEG image file.</p>
<p id="p-0046" num="0045">The data_skip controlling scheme is good enough for DC first scan, DC refine scan and AC first scan since in these 3 scan, the Huffman decoding of any DC/AC coefficient doesn't need the amplitude information from coefficients generated in previous scans. However, the AC refine scans, the decoding of AC coefficients relies on the amplitude of AC coefficients generated in previous AC first scans. Due to limited memory usage, some AC coefficients are skipped and the amplitude information will not be available in memory anymore. Without the AC coefficient amplitude information from previous AC first scan, an AC refine scan can't decode the bit stream correctly and therefore the MCU index counter can't count properly.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 11</figref> gives a graphical interpretation about the problem with AC refine scan in multi-run algorithm. For the 1<sup>st </sup>run, there is no issue at all because the AC coefficients of MCU 0˜K in AC first scan are stored in memory and AC refine scan can use them to decode AC coefficients correctly. For the 2<sup>nd </sup>run, the decoder won't know how many data bits are consumed by AC coefficients of MCU 0˜K in AC refine scan because no AC coefficients of MCU 0˜K in AC first scan are available. Therefore, the decoder does not know where and when to start decoding MCU K.</p>
<p id="p-0048" num="0047">To solve this problem, the present invention make AC refine scan proceed without AC coefficient amplitude information from previous scans by storing enough hardware control signals and status information into memory at the end of the AC refine scan in the previous run and then reloading these information at the same AC refine scan in the current run. <figref idref="DRAWINGS">FIG. 12</figref> shows how the reloading works. The hardware control signals and status information stored at the end of each AC refine scan may include the following items:</p>
<p id="p-0049" num="0048">1. The location in the JPEG decoding image where the current portion of AC refine scan ends.</p>
<p id="p-0050" num="0049">2. EOB run length after the current portion of AC refine scan is done.</p>
<p id="p-0051" num="0050">3. Values of miscellaneous hardware control signals.</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. 2</figref><i>a </i>is a diagram of an exemplary embodiment of a DC coefficient. As shown in <figref idref="DRAWINGS">FIG. 2</figref><i>a</i>, if a DC coefficient is 11 bits in length, bit <b>0</b> to bit (m−1) may be contributed by DC refine scan and bit m to bit <b>10</b> by DC first scan. <figref idref="DRAWINGS">FIG. 2</figref><i>b </i>is a diagram of an exemplary embodiment of an AC coefficient. As shown in <figref idref="DRAWINGS">FIG. 2</figref><i>b</i>, if an AC coefficient is 11 bits, bit <b>0</b> to bit (n−1) may be contributed by AC refine scan and bit n to bit <b>10</b> by AC first scan. Here, MSBs and LSBs (least significant bits) of DC/AC coefficients may be located in different positions in different scans. The variables m and n can be different for Y, U, and V components of an image frame. Scanning, such as a DC first scan, DC refine scan, AC first scan or AC refine scan, may generate one, two, or three components. A Huffman decoder is required to decode Huffman-encoded data all types of scanning data.</p>
<p id="p-0053" num="0052">For brevity, the following state diagrams illustrate functions of the Huffman decoder of the present invention for decoding DC/AC coefficients, which is not a limitation to the present invention. As shown in those state diagrams, there are totally several states in the Huffman decoder state machine to support both Huffman decoding algorithm and multi-run algorithm, including IDLE state, COEFF_READ state, COEFF_WRITE state, HOFF_ADDR_LOG state, HUFF_ADDR_PHY state, and AMP_CAL state.</p>
<p id="p-0054" num="0053">The IDLE state is the initial state. In the COEFF_READ state, the progressive coefficient is read back from memory for update. In HUFF_ADDR_LOG state, after figuring out logical and physical address of the codeword which Huffman code refers to, it moves to HUFF_ADDR_PHY state to read back the codeword. In HUFF_DEC_PHY state, a memory read is performed to read back the codeword that Huffman code refers to.</p>
<p id="p-0055" num="0054">In EOB_RUN_GEN state, the main task is to determine eob_run and zero_run. Note that if the run/size is representing an EOB run length, the value of eob_run is to append some raw data bits from the barrel shifter to a single bit ‘<b>1</b>’. The number of the appending raw data bits is “run”. If the run/size is a zero-run length, just make zero_run equal to “run”. The AMP_CAL state is to calculate the non-zero coefficient amplitude based on “size” and the raw data bits from barrel shift register (return_data[15:0]). In COEFF_WRITE state, the refined coefficients are written back into memory buffer.</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 3</figref><i>a </i>is a diagram of an exemplary embodiment of a state machine diagram of a DC first scan. In the DC first scan decoding process. DC coefficients are sent to memory storage for further DC refine scans. Here, because a data access length in a JPEG decoder is generally 32 bits, which contain two 11-bit coefficients, although no decoded coefficient of a DC first scan is required to be read for updating, the state machine may revert from the IDLE state <b>300</b> to COEFF_READ state <b>302</b>.</p>
<p id="p-0057" num="0056">Thereafter, the state machine transfers directly to the Huffman decoding states, i.e. HUFF_ADDR_LOG <b>304</b> and HUFF_ADDR_PHY <b>306</b>.</p>
<p id="p-0058" num="0057">Due to the marker parser storing Huffman tables in different memory addresses allocated by software, the HUFF_ADDR_LOG state <b>304</b> generates logical addresses of data encoded in Huffman code. Physical addresses are calculated in HUFF_ADDR_PHY state <b>306</b>. The state machine may further trigger a read to memory based on the calculated physical address. The logic states transfer to AMP_CAL state <b>308</b> to compute DC coefficients after the run/length is obtained. The DC coefficients are stored to memory storage based on the physical address provided by a progressive address generator in COEFF_WRITE STATE <b>310</b>. The stored DC coefficients are used for further DC refine scans.</p>
<p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. 3</figref><i>b </i>is a diagram of an exemplary embodiment of a state diagram of a DC refine scan. A DC refine scan is easily processed because only raw data bits are contained therein. Each DC refine scan updates one bit according to the previous decoded DC coefficients. The state machine transfers from IDLE state <b>310</b> to COEFF_READ state <b>312</b> to read the DC decoded coefficients produced by previous DC first scans or DC refine scans. Because the DC refine scan includes only raw data, Huffman decoding is not required. The state machine transfers to AMP_CAL state <b>314</b> to extract the raw data bits to update the current DC coefficients. The DC coefficients are stored to memory storage as the read address in COEFF_WRITE state <b>316</b> after updating.</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 3</figref><i>c </i>is a diagram of an exemplary embodiment of a state diagram of an AC first scan. An AC first scan is similar to DC first scan except that an AC first scan may include zero run and EOB (End of Block) run. Zero run is generated by zero run length coding indicating the number of zeros before the next non-zero coefficient in a current 8×8 data block. Consequently, the zero run can be treated as length of zeros. Similarly, EOB run is the length of EOB. An EOB in an AC first scan means all AC coefficients in the current 8×8 data block are zero. If EOB runs is three, the next three 8×8 data blocks do not generate non-zero AC coefficients.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 3</figref><i>c </i>is a diagram of an exemplary embodiment of a state machine diagram of an AC first scan. The state machine transfers from IDLE state <b>320</b> to COEFF_READ state <b>322</b>. The COEFF_READ state <b>322</b> disrupts the previously decoded coefficients. Zero run and EOB run are checked to determine the next state, i.e. HUFF_ADDR_LOG state <b>324</b> or AMP_CAL state <b>330</b>. If zero run or EOB run carries a positive value, next non-zero AC coefficient is recognized as unreached. Thus, the next state is AMP_CAL state <b>330</b>.</p>
<p id="p-0062" num="0061">Otherwise, if both zero run and EOB run are zeros, the current AC coefficient is non-zero and the value is to be determined. The state transition goes through HUFF_ADDR_LOG <b>324</b> and HUFF_ADDR_PHY <b>326</b> states to acquire run/length information bits from AC Huffman tables in memory storage. if the run/length indicates that the EOB run is not zero, the hardware stores this EOB run length and sets AC coefficients in following several blocks as zeros. The state machine transfers the AMP_CAL state <b>330</b> for setting the AC coefficient to a zero or non-zero value whatever the EOB run is zero or not.</p>
<p id="p-0063" num="0062">In AMP_CAL state <b>330</b>, the state machine may transfer to three possible states. Each memory access, that is, data read/write, of progressive coefficient buffer affects two coefficients. The first is even-indexed as coefficient <b>2</b><i>k </i>and the second is odd-indexed as coefficient (2<i>k+</i>1).</p>
<p id="p-0064" num="0063">If coefficient <b>2</b><i>k </i>is processed and the zero run or EOB run is recognized as non-zero, the state stays in AMP_CAL state <b>330</b>. If coefficient (2<i>k+</i>1) is processed and the zero run or EOB run is recognized as non-zero, the state transfers to COEFF_WRITE state <b>332</b> to write coefficients <b>2</b><i>k </i>and (2<i>k+</i>1) back into a progressive coefficient buffer.</p>
<p id="p-0065" num="0064">If coefficient (2<i>k+</i>1) is processed and both zero run and EOB run are recognized as zeros, the state also transfers to COEFF_WRITE state <b>332</b> to write coefficients <b>2</b><i>k </i>and (2<i>k+</i>1). If coefficient <b>2</b><i>k </i>is processed and both zero run and EOB are recognized as zeros, the state transfers to HUFF_ADDR_LOG state <b>324</b> to obtain next run/length information bits to determine the value of coefficient (2<i>k+</i>1).</p>
<p id="p-0066" num="0065">In COEFF_WRITE state <b>332</b>, if the zero run or EOB run is still not zero and the current data unit is still processing, the state transfers back to AMP_CAL state <b>330</b> since the next AC coefficient is definitely zero. If the current data unit processing is finished, the state transfers to IDLE state <b>320</b> for next data unit processing. If both zero run and EOB run are zeros and the current data unit processing is not finished, the state proceeds to COEFF_READ state <b>322</b>.</p>
<p id="p-0067" num="0066">If state transfers to IDLE state <b>320</b>, EOB run is checked if it is zero. If EOB run is not zero, no Huffman decoding is necessary and the state transfers to AMP_CAL state <b>330</b> directly. Otherwise, the state transfers to COEFF_READ state <b>322</b> for Huffman decoding.</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 3</figref><i>d </i>is a diagram of an exemplary embodiment of a state diagram of an AC refine scan. The state machine transition in AC refine scan is similar to AC first scan. The difference is that the state does not transfer to AMP_CAL state <b>330</b> from COEFF_WRITE state <b>332</b> because AC refine scan checks every AC coefficient even when the zero run or EOB run is not zero.</p>
<p id="p-0069" num="0068">Based on the disclosed scan framework, hardware-implemented Huffman decoders using logic gates to implement logic states are provided. The logic states include IDLE, COEFF_READ, COEFF_WRITE, HUFF_ADDR_LOG, HUFF_ADDR_PHY, AM_CAL, and EOB_RUN_GEN.</p>
<p id="p-0070" num="0069"><figref idref="DRAWINGS">FIGS. 4</figref><i>a</i>-<b>4</b><i>g </i>are diagrams of exemplary embodiments of detailed hardware states for state machine diagrams. IDLE state <b>400</b> transfers to COEFF_READ state <b>402</b> or AMP_CAL state <b>404</b> according to eob_run, ac_first_scan, and ss signals as shown in <figref idref="DRAWINGS">FIG. 4</figref><i>a</i>. COEFF_READ state <b>402</b> transfers to HUFF_ADDR_LOG state <b>406</b> or AMP_CAL state <b>404</b> according to ac_first_scan, ac_refine_scan, eob_run, new_ac_nonzero_coeff, and dc_refine_scan signals as shown in <figref idref="DRAWINGS">FIG. 4</figref><i>b</i>. COEFF_WRITE state <b>408</b> transfers to AMP_CAL state <b>402</b> or COEFF_READ state <b>404</b> according to ac_first_scan, coeff_index, zero_run, and eob_run signals as shown in <figref idref="DRAWINGS">FIG. 4</figref><i>c. </i></p>
<p id="p-0071" num="0070">HUFF_ADDR_LOG state <b>406</b> transfers to HUFF_ADDR_PHY state <b>410</b> as shown in <figref idref="DRAWINGS">FIG. 4</figref><i>d</i>. HUFF_ADDR_PHY state transfer to AMP_CAL state <b>404</b> or EOB_RUN_GEN state <b>412</b> according to ac_first_scan and ac_refine_scan signals as shown in <figref idref="DRAWINGS">FIG. 4</figref><i>e</i>. AMP_CAL state <b>412</b> transfer to AMP_CAL state <b>404</b>, COEFF_WRITE state <b>408</b>, or HUFF_ADDR_LOG state <b>406</b> according to dc_first_scan, dc_refine_scan, ac_first_scan, ac_refine_scan, coeff_index, zero_run, eob_run, new_ac_nonzero_coeff, se, and progr_coeff0_pool signals as shown in <figref idref="DRAWINGS">FIG. 4</figref><i>f</i>. EOB_RUN_GEN state <b>412</b> transfers to AMP_CAL state <b>404</b> as shown in <figref idref="DRAWINGS">FIG. 4</figref><i>g. </i></p>
<p id="p-0072" num="0071">Here, the ss and se signals indicate start and end coefficients in the current scan and are generated by a maker parser coupled to the Huffman decoder. The ac_first_scan, ac_refine_scan, dc_first_scan, and dc_refine_scan signals identifying the current scan as an AC first scan, an AC refine scan, a DC first scan, or a DC refine scan, are generated by a JPEG decoder controller coupled to the Huffman decoder. The coeff_index signal, indicating an index of coefficients of the current scan, is also generated by the JPEG decoder controller. The eob_run, zero_run, new_ac_nonzero_coeff, and the progr_coeffe0_pool signals indicating EOB run length, zero run length, non-zero EOB run length, and a current coefficient with even index, are generated by the Huffman decoder.</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an exemplary embodiment of state diagram of IDLE state. Referring to <figref idref="DRAWINGS">FIG. 5</figref> along with <figref idref="DRAWINGS">FIG. 4</figref><i>a</i>, the IDLE state <b>400</b> further transfers to RELOAD_SCAN_START_ADDR state <b>500</b> according to the ac_refine_scan and a data_skip signals. The data_skip signal indicates whether the logic state transfers from the IDLE state to the RELOAD_SCAN_START_ADDR state.</p>
<p id="p-0074" num="0073">The RELOAD_SCAN_START_ADDR state transfers to RELOAD_EOB_RUN state <b>502</b> as shown in <figref idref="DRAWINGS">FIG. 6</figref><i>a</i>. The RELOAD_EOB_RUN state <b>502</b> transfers to BYPASS_DATA state <b>504</b> as shown in <figref idref="DRAWINGS">FIG. 6</figref><i>b</i>. The BYPASS_DATA state <b>504</b> transfers to RELOAD_CTRL state <b>506</b> as shown in <figref idref="DRAWINGS">FIG. 6</figref><i>c</i>. The RELOAD_CTRL state <b>506</b> transfer to the COEFF_READ state <b>402</b>.</p>
<p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram of an exemplary embodiment of state diagram of COEFF_WRITE state. Referring to <figref idref="DRAWINGS">FIG. 7</figref> along with <figref idref="DRAWINGS">FIG. 4</figref><i>c</i>, the COEFF_WRITE state <b>408</b> further transfers to SAVE_SCAN_START_ADDR state <b>510</b> according to the ac_refine_scan, a scan_done, and a mcu_skip_set signals. Here, the scan_done and the mcu_skip_set signals indicate the termination of a current scan and disregarding of a MCU.</p>
<p id="p-0076" num="0075">The SAVE_SCAN_START_ADDR state <b>510</b> transfers to SAVE_EOB_RUN state <b>512</b> as shown in <figref idref="DRAWINGS">FIG. 8</figref><i>a</i>. The SAVE_EOB_RUN state <b>512</b> transfers to SAVE_CTRL state <b>514</b> as shown in <figref idref="DRAWINGS">FIG. 8</figref><i>b</i>. The SAVE_CTRL state <b>514</b> transfers to the IDLE state <b>400</b>.</p>
<p id="p-0077" num="0076">As disclosed, a hardware-implemented Huffman decoder increases decoding speed. Furthermore, the hardware-implemented Huffman decoder reduces switching between software and hardware for image decoding.</p>
<p id="p-0078" num="0077">While the invention has been described by way of example and in terms of preferred embodiment, it is to be understood that the invention is not limited thereto. Those who are skilled in this technology can still make various alterations and modifications without departing from the scope and spirit of this invention. Therefore, the scope of the present invention shall be defined and protected by the following claims and their equivalents.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A JPEG decoder, comprising:
<claim-text>a barrel shift register receiving and transmitting one portion of a JPEF file comprising at least one of frame header or/and image data to a marker parser or a Huffman decoder;</claim-text>
<claim-text>the marker parser receiving the portion of the JPEG file to decode a header information thereof;</claim-text>
<claim-text>a JPEG decoder controller receiving a control signal from the marker parser to enable the Huffman decoder;</claim-text>
<claim-text>a memory buffer storing progressive coefficients;</claim-text>
<claim-text>the Huffman decoder receiving and converting the progressive coefficients to logic addresses, decoding the portion of the JPEG file which does not comprises the header information;</claim-text>
<claim-text>a progressive address generator receiving and converting the logic addresses to physical addresses; and</claim-text>
<claim-text>an inverse discrete cosine transform unit performing an inverse discrete cosine transform on received row data to output a JPEG picture.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a dma buffer storing and transmitting the portions of JPEG file to the barrel shift register.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising an APB interface storing variables used for data decoding.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The decoder as claimed in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the variables comprises an start address and an end address of each portion of the JPEG file.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory buffer further stores Huffman/quantization tables.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the Huffman decoder further converts the decoded portion of the JPEG file which does not comprise the header information into the row data.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the JPEG file comprises three layers, and the Huffman decoder performs one first scan and two refine scan respectively on the three layers.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The decoder as claimed in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein values of pixels of the JPEG picture is determined based on the processing results of the first scan and the refine scan.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the size of the memory buffer is 2560 bytes.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the size of each portion of the JPEF file 1280 bytes.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The decoder as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein when the Huffman decoder detects that the image data is 0, the Huffman decoder skips processing and transmitting a stop signal to stop the operating of the inverse discrete cosine transform unit.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The decoder as claimed in <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein when the Huffman decoder detects that the image data is not 0, the Huffman decoder begins processing and transmitting a start signal to enable the operating of the inverse discrete cosine transform unit.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A JPEG decoding method, comprising:
<claim-text>transmitting a portion of a JPEG file to marker parser to decode a header information thereof;</claim-text>
<claim-text>transmitting the portion of the JPEG file to a Huffman decoder to decode an image data thereof when the decoding of the header information is finished;</claim-text>
<claim-text>receiving and converting progressive coefficients to logic addresses by the Huffman decoder;</claim-text>
<claim-text>receiving and converting the to physical addresses by a progressive address generator; and</claim-text>
<claim-text>performing an inverse discrete cosine transform on the decoded data from the Huffman decoder to output a JPEG picture.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising when the Huffman decoder detects that the image data is 0, the Huffman decoder skips processing and transmitting a stop signal to stop the operating of the inverse discrete cosine transform unit.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising when the Huffman decoder detects that the image data is not 0, the Huffman decoder begins processing and transmitting a start signal to enable the operating of the inverse discrete cosine transform unit.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising providing a memory buffer storing the progressive coefficients and Huffman/quantization tables.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method as claimed in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the size of the memory buffer is 2560 bytes.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the size of each portion of the JPEF file 1280 bytes.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising converting the decoded portion of the JPEG file which does not comprise the header information into the row data by the Huffman decoder.</claim-text>
</claim>
</claims>
</us-patent-grant>
