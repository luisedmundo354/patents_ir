<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299280-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299280</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10272646</doc-number>
<date>20021016</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>779</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>173</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>16</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
<further-classification>709230</further-classification>
<further-classification>709235</further-classification>
</classification-national>
<invention-title id="d0e53">Method and apparatus for TCP with faster recovery</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5132964</doc-number>
<kind>A</kind>
<name>Esaki</name>
<date>19920700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370418</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5872920</doc-number>
<kind>A</kind>
<name>Hausman et al.</name>
<date>19990200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709250</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6262990</doc-number>
<kind>B1</kind>
<name>Ejiri</name>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370412</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6421348</doc-number>
<kind>B1</kind>
<name>Gaudet et al.</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370401</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6480498</doc-number>
<kind>B1</kind>
<name>Gaudet et al.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370402</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6643259</doc-number>
<kind>B1</kind>
<name>Borella et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370231</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6757255</doc-number>
<kind>B1</kind>
<name>Aoki et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370252</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6765878</doc-number>
<kind>B1</kind>
<name>Carlson</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370252</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6772375</doc-number>
<kind>B1</kind>
<name>Banga</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 47</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6779043</doc-number>
<kind>B1</kind>
<name>Crinion</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709249</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6952424</doc-number>
<kind>B1</kind>
<name>Bass et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370412</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6954430</doc-number>
<kind>B2</kind>
<name>Haglund</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370232</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6990070</doc-number>
<kind>B1</kind>
<name>Aweya et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370230</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>7092355</doc-number>
<kind>B1</kind>
<name>Duong-Van</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370230</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>7099273</doc-number>
<kind>B2</kind>
<name>Ha et al.</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370229</main-classification></classification-national>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>7130268</doc-number>
<kind>B2</kind>
<name>Mascolo</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370232</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00017">
<othercit>Moldeklev et al., “How a Large ATM MTU Causes Deadlocks in TCP Data Transfers”, IEEE Transactions on Networking, vol. 3, No. 4, Aug. 1995.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>Mascolo, Saverio, et al., “An ABR Congestion Control Algorithm Feeding Back Available Bandwidth and Queue Level,” ATM Workshop Proceedings, Fairfax, VA., 1998 IEEE, May 26, 1998, pp. 91-96.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>Almesberger, Werner, et al., “SRP: A Scalable Resource Reservation Protocol for the Internet,” Quality of Service 1998, Sixth International Workshop on Napa, CA, May 18-20, 1998, pp. 107-116.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00020">
<othercit>Mascolo, S., et al., “TCP Westwood: Congestion Control With Faster Recovery,” UCLA CSD Technical Report, Jul. 2000, pp. 1-14.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>19</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709230</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709235</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60330364</doc-number>
<kind>00</kind>
<date>20011017</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030149785</doc-number>
<kind>A1</kind>
<date>20030807</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Gerla</last-name>
<first-name>Mario</first-name>
<address>
<city>Santa Monica</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Sanadidi</last-name>
<first-name>M. Yahya</first-name>
<address>
<city>Santa Monica</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Casetti</last-name>
<first-name>Claudio E.</first-name>
<address>
<city>Turin</city>
<country>IT</country>
</address>
</addressbook>
<nationality>
<country>IT</country>
</nationality>
<residence>
<country>IT</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Mascolo</last-name>
<first-name>Saverio</first-name>
<address>
<city>Irsina</city>
<country>IT</country>
</address>
</addressbook>
<nationality>
<country>IT</country>
</nationality>
<residence>
<country>IT</country>
</residence>
</applicant>
<applicant sequence="005" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Lee</last-name>
<first-name>Scott</first-name>
<address>
<city>Whittier</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Christie, Parker &amp; Hale, LLP.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>The Regents of University of California</orgname>
<role>02</role>
<address>
<city>Los Angeles</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Etienne</last-name>
<first-name>Ario</first-name>
<department>2157</department>
</primary-examiner>
<assistant-examiner>
<last-name>El-chanti</last-name>
<first-name>Hussein A</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and apparatus for congestion control of a Transmission Control Protocol (TCP) connection. A TCP source monitors received acknowledgments (ACKs) and uses header information associated with the ACKs to determine an amount of data delivered at a TCP receiver. The amount of delivered data, divided by the time requited to deliver the data, gives a measure of instant data rate. The instant data rate is input to a filtering and averaging process to generate an estimate of the end-to-end bandwidth share or data rate of the connection. For the entire duration of the connection, the TCP source updates its estimate of the end-to-end bandwidth share every time an ACK is received. The estimate of the end-to-end bandwidth share is used the reset a congestion window and a slow start threshold whenever packet loss is indicated such as whenever a timeout expires or whenever three (3) duplicate ACKs are received.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="112.78mm" wi="164.51mm" file="US07299280-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="113.88mm" wi="169.08mm" file="US07299280-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="192.70mm" wi="170.26mm" file="US07299280-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="218.36mm" wi="174.24mm" orientation="landscape" file="US07299280-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION</heading>
<p id="p-0002" num="0001">The present application claims priority to U.S. Provisional Patent Application No. 60/330,364, filed Oct. 17, 2001 which is hereby incorporated by reference as if set forth in full herein.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?GOVINT description="Government Interest" end="lead"?>
<heading id="h-0002" level="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</heading>
<p id="p-0003" num="0002">The U.S. Government has certain rights in this invention pursuant to grants ANI-9983138 and ANI-9805436 awarded by the National Science Foundation and grant NAG2-1249 awarded by the National Aeronautics and Space Administration.</p>
<?GOVINT description="Government Interest" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">Transmission Control Protocol (TCP) is a transport protocol widely used in the Internet. It is a protocol between two hosts, such as a TCP source and a TCP receiver, providing (1) error recovery, and (2) congestion control. The error recovery is provided by an acknowledgment scheme. Acknowledgments (ACKs) are sent by the TCP receiver to the TCP source, and confirm the arrival of a packet at the TCP receiver. Congestion control is provided via a window scheme. In essence, the TCP source is allowed to send a number of packets equal to the “congestion window” size (called “cwin” in the TCP standard). The TCP source then stops and waits for ACKs before resuming transmission. When the value of cwin is high, the TCP source manages to transmit several packets before feedback from the TCP receiver. When cwin is low, the opposite is true. Thus, cwin can be used for congestion control. The TCP source keeps increasing the TCP source's cwin value and thus, the TCP source's sending rate, as long as the TCP source perceives that the network is not congested. The TCP source reduces cwin, on the other hand, when the TCP source senses that network congestion is building up.</p>
<p id="p-0005" num="0004">Congestion is detected from packet loss. In the current standard TCP, two indications of packet loss are taken into consideration: (1) The reception of 3 duplicate ACKs, and (2) The expiration of a time interval (Timeout) after a packet transmission, without receiving any feedback from the TCP receiver. The first indication is considered “soft loss” since the path from TCP source to TCP receiver appears to be still in operation, even after packet loss. The second indication is considered more serious since the TCP source has no indication that anything has been delivered to the TCP receiver after packet loss. The current design for TCP congestion control assumes that every packet loss is because of congestion in the network. This assumption is justified in a network with optical fiber links where losses on the link because of link errors are extremely rare. However, when some of the links are not optical, and particularly when some links are wireless, error rates are significant, and packets can be lost because of congestion or because of error on transmission links.</p>
<p id="p-0006" num="0005">After three (3) duplicate ACKs are received at the TCP source, in one TCP protocol (named New Reno) cwin is reset to half its current value. If the Timeout expires, cwin is reset to 1. That is the TCP source can only send one packet and then has to wait for a feedback from the TCP receiver.</p>
<p id="p-0007" num="0006">In addition to cwin, another congestion control parameter in TCP is the so-called Slow Start Threshold, or ssthresh. This parameter is also used in setting the sending rate of the TCP source. In particular, ssthresh controls the rate of increase of the sending rate when feedback from the TCP receiver is positive. Ssthresh does have significant impact on network congestion control. If the threshold indicates that the rate of increase of cwin should be high, a TCP source can increase its sending rate at a high rate possibly inducing congestion. Thus setting ssthresh properly is desired for proper congestion avoidance.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0008" num="0007">In one aspect of the invention, a method for estimating the bandwidth share of a TCP connection is provided. A TCP source monitors received ACKs. The TCP source uses header information associated with the ACKs to determine an amount of data delivered at the TCP source. The amount of delivered data is then input to a filtering and averaging process. The output of the filtering/averaging process is an estimated bandwidth share or the data rate of the connection. For the entire duration of the connection, the TCP source updates its estimate of the bandwidth share every time an ACK is received. The estimate is used whenever packet loss is indicated; that is, whenever a timeout expires or whenever three (3) duplicate ACKs are received.</p>
<p id="p-0009" num="0008">In another aspect of the invention, a method is provided for use of an estimated bandwidth share of a connection between a TCP source and a TCP receiver to provide a congestion control mechanism. Whenever the TCP source perceives a potential packet loss, the estimated bandwidth share is used to determine congestion control parameters as follows: (1) a congestion window size is generated using the estimated bandwidth share of the connection and an estimated round trip propagation time from the TCP source to the TCP receiver, and (2) a slow start threshold is generated using the estimated bandwidth share of the connection and the estimated round trip propagation time from the TCP source to the TCP receiver.</p>
<p id="p-0010" num="0009">In one embodiment of the invention, a method of setting a parameter for a transport protocol used by a source to transmit data to a receiver across a connection through a computer network is provided. The method includes generating an estimate of end-to-end bandwidth share available to the connection through the computer network and setting the parameter using the estimated end-to-end bandwidth share for the connection if congestion is detected on the computer network.</p>
<p id="p-0011" num="0010">In another embodiment of the invention, the estimated end-to-end bandwidth share is generated by generating a sample bandwidth share and filtering the sample bandwidth share to generate the estimated end-to-end bandwidth share.</p>
<p id="p-0012" num="0011">In another embodiment of the invention, generating the sample bandwidth share further includes determining a quantity of data transmitted by the source to the receiver over the connection and an elapsed time for transmission of the quantity of data. The quantity of data transmitted and the elapsed time are then used to generate the sample bandwidth share.</p>
<p id="p-0013" num="0012">In another embodiment of the invention, determining the elapsed time is accomplished by receiving by the source from the receiver a first acknowledgment at a first time and a second acknowledgment at a second time and determining the elapsed time using the difference between the first time and the second time.</p>
<p id="p-0014" num="0013">In another embodiment of the invention, determining the quantity of data is accomplished by receiving duplicate acknowledgments by the source and determining the quantity of data using an average of segment sizes of data packets transmitted by the source to the receiver.</p>
<p id="p-0015" num="0014">In another embodiment of the invention, the sample bandwidth share is filtered using an exponential filter.</p>
<p id="p-0016" num="0015">In another embodiment of the invention, the sample bandwidth share is filtered using a discrete time filter.</p>
<p id="p-0017" num="0016">In another embodiment of the invention, the modified parameters are a slow start threshold and optionally a congestion window used in a transmission control protocol.</p>
<p id="p-0018" num="0017">In another embodiment of the invention, an apparatus for setting a parameter for a transmission control protocol used by a source to transmit data to a receiver across a connection through a computer network is provided. The apparatus has a processor and a memory coupled to the processor. Store in the memory are processor executable program instructions. While executing the program instructions, the processor receives a first acknowledgment at a first time and a second acknowledgment at a second time. The processor then determines an elapsed time using the difference between the first time and the second time and determines a quantity of data transmitted by the source to the receiver using the first acknowledgment and the second acknowledgment. The processor then generates a sample bandwidth share using the quantity of data transmitted and the elapsed time. The process then generates an estimated end-to-end bandwidth share available to the connection by filtering the sample bandwidth share. When the processor detects that the computer network is becoming congested, the processor generates a congestion window and a slow start threshold using the estimated end-to-end bandwidth share.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0019" num="0018">These and other features, aspects, and advantages of the present invention will become better understood with regard to the following description, accompanying drawings, and attached appendices where:</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 1</figref> is a process flow diagram of a TCP process in accordance with an exemplary embodiment of the present invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 2</figref> is a formula for calculating a sample bandwidth by an embodiment of a TCP control process in accordance with the present invention;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 3</figref> is a formula for a discrete time filter as used by an embodiment of a TCP control process in accordance with the present invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 4</figref> is a formula for a discrete time filter with constant coefficients as used by an embodiment of a TCP control process in accordance with the present invention; and</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of a computing device suitable for hosting a TCP process in accordance with an exemplary embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0025" num="0024">Resetting cwin to half its value by a TCP source when three (3) duplicate ACKs are received has been proven to be useful when no other information is available about network conditions. However, a TCP version in accordance with an exemplary embodiment of the present invention, herein termed “TCP Westwood”, utilizes available information about the network and about a path from the TCP source to a TCP receiver. In particular, the TCP source may monitor the flow of ACKs, thus estimating the rate at which data is delivered to the TCP receiver. By exploiting such information, the TCP source can more intelligently set the cwin value, and the ssthresh value when packet loss is sensed. This intelligence has a stronger positive impact on the efficiency of the system when the dominant cause of packet loss is link errors as opposed to congestion.</p>
<p id="p-0026" num="0025">The resulting congestion control scheme better utilizes available network capacity since it sets the congestion control parameters more intelligently as indicated above. The result is that more connections may be supported on the same path in the network, and transfer of data may be completed significantly faster under certain conditions.</p>
<p id="p-0027" num="0026">A design philosophy of the standard Internet TCP congestion control algorithm is that it is performed end-to-end. A network is considered as a “black box” meaning a TCP source cannot receive any explicit congestion feedback from the network. Therefore the TCP source, to determine the rate at which it can transmit, probes the path by progressively increasing the input load (through the slow start and congestion avoidance phases) until implicit feedback, such as timeouts or duplicate acknowledgments, signals that the network capacity has been reached. The end-to-end principle guarantees the delivery of data over any kind of heterogeneous network. An aspect of TCP Westwood is to exploit TCP acknowledgment packets to derive network measurements.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 1</figref> is a process flow diagram of a TCP process in accordance with an exemplary embodiment of the present invention. A TCP source employing TCP Westwood <b>102</b> uses returning acknowledgments (ACKs) <b>104</b> to generate (<b>106</b>) a measurement of a sample bandwidth share (or data rate) <b>108</b> along a TCP connection path by measuring and averaging the rate of the ACKs. The samples of bandwidth share are filtered (<b>110</b>) to generate an estimate of end-to-end bandwidth share (or data rate) <b>114</b> for the connection path between the TCP source and a TCP receiver. When the TCP source detects a congestion episode (for example, the TCP source receives three duplicate ACKs or a timeout) the TCP source uses the end-to-end estimate of end-to-end bandwidth share to generate (<b>118</b>) a new congestion window (cwin) and a new slow start threshold (ssthresh) <b>120</b>, starting a procedure herein termed “faster recovery”.</p>
<p id="p-0029" num="0028">In slightly more detail, a TCP source monitors received ACKs, and processes header information to determine an amount of data delivered at a TCP receiver. The amount of delivered data divided by the time required by the TCP source to deliver the data to the TCP receiver gives a measure of instant data rate. The instant data rate is then input to a filter. The output of the filter is an estimated end-to-end bandwidth share or data rate of the connection between the TCP source and a TCP receiver. For the entire duration of the connection, the TCP source updates its estimate of the end-to-end bandwidth share every time an ACK is received. The estimate is used whenever packet loss is indicated; that is, whenever a timeout expires or whenever three (3) duplicate ACKs are received.</p>
<p id="p-0030" num="0029">In one embodiment of a TCP process in accordance with the present invention, the filter is a discrete time filter. In another TCP process in accordance with the present invention, the filter is an exponential averaging process.</p>
<p id="p-0031" num="0030">Whenever the TCP source perceives a potential packet loss, the estimated end-to-end bandwidth share is used to set the congestion control parameters as follows: (1) the slow start threshold is set using the estimated end-to-end bandwidth share of the connection and the estimated round trip propagation time from the TCP source to the TCP receiver, and (2) if the size of the congestion window is greater than the slow start threshold, then congestion window is set to the size of the slow start threshold.</p>
<p id="p-0032" num="0031">When an ACK is received by the TCP source, the ACK conveys the information that an amount of data corresponding to a specific transmitted packet was delivered to the TCP receiver. If the transmission process is not affected by losses, averaging the delivered data count over time yields an estimate of the bandwidth share, or source data rate, currently used by the TCP source.</p>
<p id="p-0033" num="0032">The present invention provides a method to estimate the data rate of the connection even in the present of duplicate acknowledgments. When duplicate acknowledgments (DUPACKs) (indicating an out-of-sequence reception) reach the TCP source, the DUPACKs are counted toward the bandwidth estimate, and a new estimate is computed right after the reception of DUPACKs.</p>
<p id="p-0034" num="0033">However, the TCP source may not be able to tell for sure which segment triggered the DUPACK transmission, and it may thus be unable to update the data count by the exact size of that segment. An average of the segment sizes sent thus far in the ongoing connection is therefore used, allowing for corrections when the next cumulative ACK is received. All TCP segments are assumed to be of the same size. Following this assumption, all sequence numbers are incremented by one per segment sent, although an actual TCP implementation keeps track of the number of bytes instead: the two notations are interchangeable if all segments have the same size.</p>
<p id="p-0035" num="0034">Immediately after a congestion episode, followed either by a timeout or, in general, n duplicate ACKs, the bottleneck is at saturation and a connection delivery rate is equal to the share of the best-effort bandwidth (i.e., saturation bandwidth) available to that connection. At steady state, under proper conditions this is herein termed the “fair share”. The saturation condition may be confirmed by the fact that packets have been dropped, an indication that one or more intermediate buffers are full. Before a congestion episode, the used bandwidth is less than or equal to the available bandwidth because the TCP source is still increasing its window to probe the network capacity. As a result, TCP Westwood adjusts its input by taking into account the network capacity that is available to it at the time of congestion.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 2</figref> is a formula for generating a sample of an end-to-end bandwidth in accordance with an exemplary embodiment of the present invention. In the formula, b<sub>k </sub>is the sample bandwidth at time t<sub>k </sub>when an ACK is received at the TCP source, t<sub>k</sub>−1 is the time a previous ACK was received at the TCP source, and d<sub>k </sub>is the amount of data reported to be delivered to the TCP receiver by the TCP source in the time interval between the two ACKs.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 3</figref> is a formula for a discrete time filter as used by an embodiment of a TCP control process in accordance with the present invention. Since congestion occurs whenever low-frequency input traffic rate exceeds link capacity, a low-pass filter may be employed to average sampled measurements and to obtain low-frequency components of the available bandwidth. Averaging also filters out noise caused by delayed acknowledgments. The discrete time filter is a discrete form of a continuous low-pass filter using the Tustin Approximation where {circumflex over (b)}<sub>k </sub>is a filtered estimate of the end-to-end bandwidth at time t=t<sub>k</sub>, and 1/τ is the cut-off frequency of the filter.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 4</figref> is a formula of a constant coefficient filter form of the discrete time filter of <figref idref="DRAWINGS">FIG. 3</figref>. To understand how the discrete time filter works it is useful to consider a constant interarrival time t<sub>k</sub>−t<sub>k−1</sub>=Δ<sub>k</sub>=τ/10. Then, the discrete time filter becomes a filter with constant coefficients as shown in <figref idref="DRAWINGS">FIG. 4</figref>. The constant coefficient filter form shows that the new value {circumflex over (b)}<sub>k </sub>is made by the 90% of the previous value {circumflex over (b)}<sub>k−1 </sub>plus the 10% of the arithmetic average of the last two samples {circumflex over (b)}<sub>k </sub>and {circumflex over (b)}<sub>k−1</sub>. Even though the constant coefficients filter is useful to explain how the average is computed, it is not used because in packet-switched networks the interarrival time between ACKs is not constant. To counteract the effect of time-varying interarrival time, the coefficients of the discrete time filter depend on t<sub>k</sub>−t<sub>k−1</sub>. When the interarrival time increases, the last value {circumflex over (b)}<sub>k−1 </sub>has less significance, since it represents an older value, whereas the significance of recent samples is higher. This is exactly what happens with the discrete time filter of <figref idref="DRAWINGS">FIG. 3</figref>: the “a” coefficient decreases when the interarrival time increases meaning that the previous value b<sub>k−1</sub>, has less significance with respect to the last two recent samples which are multiplied by (1−a).</p>
<p id="p-0039" num="0038">Finally, the discrete time filter has a cut-off frequency equal to 1/τ. This means that all frequency components above 1/τ are filtered out. According to the Nyquist sampling theorem, in order to sample a signal with bandwidth 1/τ a sampling interval less than or equal to τ/2 is necessary. But, since the ACK stream may be irregular(for instance, no ACKs are returned when the TCP source is idle), the sampling frequency constraint cannot be guaranteed. To guarantee the Nyquist constraint and thus preserve the low pass filter effect, if a time τ/m (m≧2) has elapsed since the last received ACK without receiving any new ACK, then the filter assumes the reception of a virtual sample b<sub>k</sub>=0. As such, the value of {circumflex over (b)}<sub>k </sub>exponentially goes to zero in the absence of ACKs the estimated bandwidth.</p>
<p id="p-0040" num="0039">As previously stated, DUPACKs should count toward the bandwidth estimation, since their arrival indicates a successfully received segment, albeit in the wrong order. As a consequence, a cumulative ACK should only count as one segment's worth of data since duplicate ACKs ought to have already been taken into account. However, the matter is further complicated by the issue of delayed ACKs. A standard TCP implementation provides for the possibility of an ACK being sent back once every other in-sequence segment received, or if a 200-ms timeout expires after the reception of a single segment. The combination of delayed and cumulative ACKs can potentially disrupt the bandwidth estimation process. This results in two aspects of the bandwidth estimation process:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0040">a. The TCP source keeps track of the number of DUPACKs it has received before new data is acknowledged;</li>
        <li id="ul0002-0002" num="0041">b. The TCP source detects delayed ACKs and acts accordingly.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0041" num="0042">An approach to take care of these two issues can be found in the AckedCount procedure, detailed below, showing the set of actions to be undertaken upon the reception of an ACK, for a correct determination of the number of packets (or equivalently data bytes) that should be accounted for by the bandwidth estimation procedure, indicated by the variable acked in the pseudocode. The key variable is accounted, which keeps track of the received DUPACKs. When an ACK is received, the number of segments it acknowledges is first determined (cumul_ack). If cumul_ack is equal to 0, then the received ACK is clearly a DUPACK and counts as 1 segment towards the end-to-end bandwidth estimate (BWE); the DUPACK count is also updated. If cumul_ack is larger than 1, the received ACK is either a delayed ACK or a cumulative ACK following a retransmission event; in that case, the number of ACKed segments is to be checked against the number of segments already accounted for (accounted_for). If the received ACK acknowledges fewer or the same number of segments than expected, it means that the “missing” segments were already accounted for when DUPACKs were received, and they should not be counted twice. If the received ACK acknowledges more segments than expected, it means that although part of them were already accounted for by way of DUPACKs, the rest are cumulatively acknowledged by the current ACK; therefore, the current ACK should only count as the cumulatively acknowledged segments. It should be noted that the last condition correctly estimates the delayed ACKs (cumul_ack=2 and accounted_for=0).</p>
<p id="p-0042" num="0043">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>PROCEDURE AckedCount</entry>
</row>
<row>
<entry/>
<entry>cumul_ack = current_ack_seqno − last_ack_seqno;</entry>
</row>
<row>
<entry/>
<entry>if (cumul_ack = 0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>accounted_for=accounted_for+1;</entry>
</row>
<row>
<entry/>
<entry>cumul_ack=1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>endif</entry>
</row>
<row>
<entry/>
<entry>if (cumul_ack &gt; 1)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>if (accounted_for &gt;= cumul_ack)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>accounted_for = accounted_for − cumul_ack;</entry>
</row>
<row>
<entry/>
<entry>cumul ack = 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else if (accounted_for &lt; cumul_ack)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>cumul_ack=cumul_ack − accounted_for;</entry>
</row>
<row>
<entry/>
<entry>accounted_for = 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>endif</entry>
</row>
<row>
<entry/>
<entry>last_ack_seqno=current_ack_seqno;</entry>
</row>
<row>
<entry/>
<entry>acked=cumul_ack;</entry>
</row>
<row>
<entry/>
<entry>return (acked);</entry>
</row>
<row>
<entry/>
<entry>END PROCEDURE</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0043" num="0044">The end-to-end bandwidth estimation can be used by a congestion control algorithm executed at the TCP source side of a TCP connection. As will be explained, the congestion window dynamics during slow start and congestion avoidance are unchanged, that is they increase exponentially and linearly, respectively, as in current TCP Reno. The end-to-end bandwidth estimate (BWE), or eligible data rate, is used to set the congestion window (cwin) and the slow start threshold (ssthresh) after a congestion episode. The process can be understood by describing the general algorithm behavior after n duplicate ACKs and after coarse timeout expiration.</p>
<p id="p-0044" num="0045">The pseudocode for the n duplicate ACKs portion of the algorithm is the following:</p>
<p id="p-0045" num="0046">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>if (n DUPACKs are received)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ssthresh = (BWE*RTTmin)/seg_size;</entry>
</row>
<row>
<entry/>
<entry>if (cwin&gt;ssthresh) /* congestion avoid.*/</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>cwin = ssthresh;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>endif</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="left" id="FOO-00001">Note that seg_size identifies the length of a TCP segment in bits.</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0046" num="0047">During the congestion avoidance phase, the TCP source probes for extra available bandwidth. Therefore, when n DUPACKs are received, it means that the TCP source has hit the network capacity (or that, in the case of wireless links, one or more segments were dropped due to sporadic losses). Thus, the slow start threshold is set equal to the available pipe size (which is based on the estimated connection data rate or bandwidth estimate (BWE), when the bottleneck buffer is empty, namely BWE*RTTmin. The congestion window is set equal to the ssthresh and the congestion avoidance phase is entered again to gently probe for new available bandwidth. The value RTTmin is set as the smallest Round Trip Time (RTT) sample observed over the duration of a connection. This setting allows the queue to be drained after a congestion episode. During the slow-start phase, the TCP source is still probing for the available bandwidth. Therefore the BWE we obtain after n duplicate ACKs is used to set the slow start threshold. After ssthresh has been set, the congestion window is set equal to the slow start threshold only if cwin&gt;ssthresh. In other words, during slow start, cwin still features an exponential increase as in current implementations of TCP Reno.</p>
<p id="p-0047" num="0048">The pseudocode of an after timeout expiration algorithm is:</p>
<p id="p-0048" num="0049">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>if (timeout expires)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ssthresh = (BWE*RTTmin)/seg_size;</entry>
</row>
<row>
<entry/>
<entry>if (ssthresh &lt; 2)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ssthresh = 2;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>endif;</entry>
</row>
<row>
<entry/>
<entry>cwin = 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>endif</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
After a timeout cwin and ssthresh are set equal to 1 and BWE, respectively, so that the basic Reno behavior is still captured, while a speedy recovery is granted by the ssthresh being set to the bandwidth estimation at the time of timeout expiration.
</p>
<p id="p-0049" num="0050">In another embodiment of a TCP control process in accordance with the present invention employing the use of bandwidth estimation, faster recovery after a coarse timeout is achieved. To overcome the lack of information on the actual available bandwidth while a congestion window is still growing, available bandwidth is estimated by looking at the reception rate of acknowledgments. Several cases arise. In one case the TCP connection has a heavy backlog and it suddenly experiences congestion at a bottleneck. In such conditions, it likely that a timeout expires or three duplicate acknowledgments are received. In the meantime, the TCP source has been transmitting at a rate greater than the available bandwidth. In that case, the rate of acknowledgments is proportional to the rate of data delivered to the TCP receiver, providing a good estimate of the (reduced) available bandwidth.</p>
<p id="p-0050" num="0051">If a sporadic or random loss has occurred, the rate of received acknowledgments is only marginally affected, and the bandwidth estimation will show little change. The TCP control process uses the estimate of available bandwidth to set the slow start threshold and to compute the congestion window. The rate of acknowledgment is estimated through an exponential averaging process. The averaging process is run upon the reception of an ACK, including duplicate ACKs (since they signal the reception of data, although out of sequence). The process is detailed by the following pseudo-code:</p>
<p id="p-0051" num="0052">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>if (ACK is received) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>sample_BWE = pkt_size*8/(now − lastacktime) ;</entry>
</row>
<row>
<entry/>
<entry>BWE = BWE*alpha + sample_BWE*(1 − alpha) ;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
where pkt size indicates the segment size in bytes, now indicates the current time, and lastacktime the time the previous ACK was received. Alpha determines the smoothing operated by the exponential filtering. It should be noted that since the segment size is usually not fixed, the value pkt size can set as the average size of the last n received segments. A similar problem arises with duplicate ACKs, since they do not carry information on the size of the received segment. In this case, the average size computed before the reception of the duplicate ACK is used, and the average size is updated only when new data are acknowledged.
</p>
<p id="p-0052" num="0053">A Faster Recovery TCP algorithm (FR-TCP) behaves like TCP Reno as far as the sequence of actions following a triple duplicate ACK or a coarse timeout expiration are concerned; however, the estimated bandwidth (BWE) is used to set the congestion window (CWIN) and the ssthresh as follows:</p>
<p id="p-0053" num="0054">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>triple duplicate ACKS:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ssthresh = (BWE * RTTmin ) /a</entry>
</row>
<row>
<entry/>
<entry>if (CWIN &gt; ssthresh)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="77pt" align="left"/>
<colspec colname="1" colwidth="140pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>CWIN = sstrhesh;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end if</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>timeout expiration:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ssthresh = (BWE * RTTmin ) /a</entry>
</row>
<row>
<entry/>
<entry>CWIN =1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
where RTT min is the smallest Round Trip Time (RTT) recorded by TCP for that specific connection and a is a reduction factor. Assuming the minimum RTT excludes queueing delays, the process converges to a situation where the transmission rate is equal to the actual available bandwidth between a TCP source and a TCP receiver.
</p>
<p id="p-0054" num="0055">The rationale of this strategy is as follows. The estimate of the available bandwidth is used to set the ssthresh equal to a fraction 1/a of BWE*RTT min. In the presence of one or few TCP connections, a good choice for a is 1, whereas in the presence of many TCP connections a better choice is a=2 or greater. Increasing a may mitigate the degradation of TCP performance known as “many-flows effect”.</p>
<p id="p-0055" num="0056">In another TCP control process in accordance with an exemplary embodiment of the present invention, the TCP source recognizes when the output rate can be safely. This TCP control process is herein termed Gradual Faster Recovery TCP (GFR-TCP). As described above, in the slow start phase, a TCP source may grab bandwidth quickly. In contrast, in the congestion avoidance phase, it takes a relatively long time for the TCP source to reach maximum available bandwidth. If the TCP source experiences consecutive segment losses, the slow start threshold becomes very small, and this leads to congestion avoidance with very small congestion window. Subsequently, even though the available bandwidth might have drastically increased, the TCP control process, unaware of the bandwidth increase, widens the congestion window linearly (for example rather slowly). Thus, while there is a need for a bandwidth-aware window-decreasing algorithm(as in FR-TCP), a way to recognize when the output rate can be safely increased is also useful. GFR-TCP handles the latter case. The following is the pseudo-code for the GFR-TCP algorithm:</p>
<p id="p-0056" num="0057">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>If (CWIN &gt; ssthresh) AND (CWIN &lt; BWE*RTT_min) then</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ssthresh = ssthresh + (BWE*RTT_min-ssthresh) /2;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
where CWIN is the TCP congestion window in segments, BWE is the bandwidth estimation in segments/sec, RTT is the round-trip time that TCP keeps monitoring, and ssthresh is the TCP slow start threshold.
</p>
<p id="p-0057" num="0058">Thus, the process monitors the available bandwidth share in the congestion avoidance phase and periodically increase the slow start threshold if the conditions allow it. To apply the process periodically, the TCP slow timer is used. In one embodiment of a TCP control process in accordance with the present invention, the standard TCP value of 500 ms is used.</p>
<p id="p-0058" num="0059">GFR-TCP employs the same mechanisms as FR-TCP to set the congestion window and the slow start threshold on segment losses, but periodically checks the condition described above. Whenever the condition is met, the process recomputes the slow start threshold which forces TCP to reenter the slow start phase. Repeatedly carrying out the process, TCP can reach the available bandwidth much more rapidly than if it remained in congestion avoidance all this time.</p>
<p id="p-0059" num="0060"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of a computing device suitable for hosting a transport protocol control process in accordance with an exemplary embodiment of the present invention. A host <b>500</b> includes a processor <b>502</b> coupled via a bus <b>504</b> to a memory device <b>506</b>, a storage device controller <b>508</b>, and a network device controller <b>510</b>. The processor uses the network device controller to control the operations of a network device <b>512</b> which is adapted for communications using a transport protocol to transmit data to a receiver <b>514</b> across a connection <b>516</b> through a computer network <b>518</b>.</p>
<p id="p-0060" num="0061">The storage controller is coupled to a storage device <b>520</b> having a computer readable storage medium for storage of program instructions <b>522</b> executable by the processor. The program instructions are stored in the storage device until the processor retrieves the program instructions and stores them in the memory. The processor then executes the program instructions stored in memory to implement the transport protocol control process as previously described.</p>
<p id="p-0061" num="0062">Although this invention has been described in certain specific embodiments, many additional modifications and variations would be apparent to those skilled in the art. It is therefore to be understood that this invention may be practiced otherwise than as specifically described. Thus, the present embodiments of the invention should be considered in all respects as illustrative and not restrictive, the scope of the invention to be determined by claims supported by this application and the claims' equivalents rather than the foregoing description.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for setting a congestion control window for transmitting data between a plurality of computing devices across a connection through a computer network, comprising:
<claim-text>generating under control of a first one of the computing devices an estimate of end-to-end bandwidth share currently achieved by the connection of the first one of the computing devices through the computer network, wherein the estimated end-to-end bandwidth share currently achieved by the connection is generated from monitoring a time interval associated with one or more acknowledgement packets received by the first one of the computing devices;</claim-text>
<claim-text>detecting under control of the first one of the computing devices a congestion indicator configured to indicate congestion on the computer network; and</claim-text>
<claim-text>if the congestion indicator is detected, performing the steps comprising:</claim-text>
<claim-text>adjusting under control of the first one of the computing devices the congestion control window and a slow start threshold using the estimated end-to-end bandwidth; and</claim-text>
<claim-text>setting the congestion window to the size of the slow start threshold if the size of the congestion window is greater than the slow start threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the time interval is time elapsed between receipt of a prior acknowledgment packet and a current acknowledgment packet, and generating the estimated end-to-end bandwidth share currently achieved by the connection includes:
<claim-text>generating a sample bandwidth share by determining an amount of data acknowledged by the current acknowledgment packet and dividing the amount of data by the time interval; and</claim-text>
<claim-text>filtering the sample bandwidth share to generate the estimated end-to-end bandwidth share currently achieved by the connection.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref> further comprising:
<claim-text>updating the estimated end-to-end bandwidth share achieved for the connection for each received acknowledgment packet.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the amount of acknowledged data is included as header information in the current acknowledgment packet.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the sample bandwidth share is filtered using a discrete time filter.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the congestion indicator is a duplicate acknowledgement packet transmitted by one of the computing devices.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the congestion indicator is loss of a data packet.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the time interval is time elapsed between receipt of a prior acknowledgment packet and a current acknowledgment packet, and generating the estimated end-to-end bandwidth share currently achieved by the connection includes:
<claim-text>determining an amount of data acknowledged by the current acknowledgment packet; and</claim-text>
<claim-text>dividing the amount of data by the time interval.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the amount of acknowledged data is included as header information in the current acknowledgment packet.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. An apparatus for setting a congestion control window for transmitting data between a plurality of computing devices across a connection through a computer network, comprising:
<claim-text>a processor; and</claim-text>
<claim-text>a memory coupled to the processor, the memory having processor executable program instructions stored therein, the program instructions when executed by the processor perform the steps including:</claim-text>
<claim-text>generating under control of a first one of the computing devices an estimate of end-to-end bandwidth share currently achieved by the connection of the first one of the computing devices through the computer network, wherein the estimated end-to-end bandwidth share currently achieved by the connection is generated from monitoring a time interval associated with one or more acknowledgement packets received by the first one of the computing devices;</claim-text>
<claim-text>detecting under control of the first one of the computing devices a congestion indicator configured to indicate congestion on the computer network; and</claim-text>
<claim-text>if the congestion indicator is detected, performing the steps comprising:</claim-text>
<claim-text>adjusting under control of first one of the computing devices the congestion control window and a slow start threshold using the estimated end-to-end bandwidth; and</claim-text>
<claim-text>setting the congestion window to the size of the slow start threshold if the size of the congestion window is greater than the slow start threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The apparatus of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the time interval is time elapsed between receipt of a prior acknowledgment packet and a current acknowledgment packet, and the program instructions for generating the estimated end-to-end bandwidth share currently achieved by the connection further include:
<claim-text>generating a sample bandwidth share by determining an amount of data acknowledged by the current acknowledgment packet and dividing the amount of data by the time interval; and</claim-text>
<claim-text>filtering the sample bandwidth share to generate the estimated end-to-end bandwidth share currently achieved by the connection.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The apparatus of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein amount of acknowledged data is included as header information in the current acknowledgment packet.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The apparatus of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the sample bandwidth share is filtered using an exponential filter.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The apparatus of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the sample bandwidth share is filtered using a discrete time filter.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A computer-readable medium storing program instructions for setting a congestion control window for transmitting data between a plurality of computing devices across a connection through a computer network, the program instructions when executed perform the steps comprising:
<claim-text>generating under control of a first one of the computing devices an estimate of end-to-end bandwidth share currently achieved by the connection of the first one of the computing devices through the computer network, wherein the estimated end-to-end bandwidth share currently achieved by the connection is generated from monitoring a time interval associated with one or more acknowledgement packets received by the first one of the computing devices;</claim-text>
<claim-text>detecting under control of the first one of the computing devices a congestion indicator configured to indicate congestion on the computer network; and</claim-text>
<claim-text>if the congestion indicator is detected, performing the steps comprising:</claim-text>
<claim-text>adjusting under control of the first one of the computing devices the congestion control window and a slow start threshold using the estimated end-to-end bandwidth; and</claim-text>
<claim-text>setting the congestion window to the size of the slow start threshold if the size of the congestion window is greater than the slow start threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the time interval is time elapsed between receipt of a prior acknowledgment packet and a current acknowledgment packet, and the program instructions for generating the estimated end-to-end bandwidth share comprise:
<claim-text>generating a sample bandwidth share by determining an amount of data acknowledged by the current acknowledgment packet and dividing the amount of data by the time interval; and</claim-text>
<claim-text>filtering the sample bandwidth share to generate the estimated end-to-end bandwidth share currently achieved by the connection.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer-readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein amount of acknowledged data is included as header information in the current acknowledgment packet.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer-readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the sample bandwidth share is filtered using an exponential filter.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer-readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the sample bandwidth share is filtered using a discrete time filter.</claim-text>
</claim>
</claims>
</us-patent-grant>
