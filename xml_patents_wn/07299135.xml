<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299135-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299135</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11271316</doc-number>
<date>20051110</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>63</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>01</class>
<subclass>N</subclass>
<main-group>33</main-group>
<subgroup>48</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>01</class>
<subclass>N</subclass>
<main-group>33</main-group>
<subgroup>50</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>702 21</main-classification>
</classification-national>
<invention-title id="d0e53">Methods for identifying discrete populations (e.g., clusters) of data within a flow cytometer multi-dimensional data set</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5380663</doc-number>
<kind>A</kind>
<name>Schwartz et al.</name>
<date>19950100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>436 10</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5451525</doc-number>
<kind>A</kind>
<name>Shenkin et al.</name>
<date>19950900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>436 63</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5627037</doc-number>
<kind>A</kind>
<name>Ward et al.</name>
<date>19970500</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>435  721</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6524960</doc-number>
<kind>B2</kind>
<name>Wensel</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>438690</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6618143</doc-number>
<kind>B2</kind>
<name>Roche et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>356339</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6784981</doc-number>
<kind>B1</kind>
<name>Roche et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>356 39</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7043500</doc-number>
<kind>B2</kind>
<name>Leary</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>7071041</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7218764</doc-number>
<kind>B2</kind>
<name>Vaisberg et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>382129</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2001/0049689</doc-number>
<kind>A1</kind>
<name>Mentzer</name>
<date>20011200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>7071041</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2005/0112541</doc-number>
<kind>A1</kind>
<name>Durack et al.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>435  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2006/0190195</doc-number>
<kind>A1</kind>
<name>Watanabe et al.</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>702 32</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>EP</country>
<doc-number>0553951</doc-number>
<date>19930800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>EP</country>
<doc-number>1686494</doc-number>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>WO</country>
<doc-number>WO 0185914</doc-number>
<date>20011100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>WO</country>
<doc-number>WO 2005008254</doc-number>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>WO</country>
<doc-number>WO 2005085842</doc-number>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>Thayer et al., “Detection of Protein Coding Sequences Using a Mixture Model for Local Protein Amino Acid Sequence”, Journal of Computational Biology, vol. 7 Nos. 1/2, pp. 317-327 (2000).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>Gelman et al., “Bayesian Data Analysis”, Second Edition , Chapman &amp; Hall/CRC, pp. 1-29, 73-95 117-152, 463-494 (2003).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>Rocke et al., “Sampling and Subsampling for Cluster Analysis in Data Mining: With Applications to Sky Survey Data”, Data Mining and Knowledge Discovery No. 7, pp. 215-232 (2003).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00020">
<othercit>Dempster et al., “Maximum Likelihood from Incomplete Data Via the <i>EM </i>Algorithm”, Journal of Royal Statistical Society, pp. 1-39 (1977).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00021">
<othercit>Jordan et al., “Hierarchical Mixtures of Experts and the EM Algorithm”, Neural Computation, No. 6, pp. 181-214 (1994).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00022">
<othercit>Bishop, “Neural Networks for Pattern Recognition”, Oxford: Oxford University Press pp. 58-65 (1995).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00023">
<othercit>Shu-jen Yeh et al., “Algorithm for the Discovery of Clusters in WBC Data”, Progress in Biomedical Optics, Proceedings of Optical Diagnostics of Living Cells and Biofluids, SPIE vol. 2678, pp. 254-266 (1996).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00024">
<othercit>McLachlan et al., “Finite Mixture Models”, John Wiley &amp; Sons, Inc., pp. 1-11 (2000).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00025">
<othercit>Fu, L. et al., “A hybrid system approach to multivariate analysis of flow cytometry data”, Proceedings of the Annual Symposium on Computer Based Medical Systems, IEEE.D, vol. Symp. 5, pp. 315-324 (Jun. 14, 1992).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00026">
<othercit>Extended European Search Report in EP Application No. 06255789.7, dated Apr. 23, 2007.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>29</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>702 21</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20070118297</doc-number>
<kind>A1</kind>
<date>20070524</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Thayer</last-name>
<first-name>Edward</first-name>
<address>
<city>Freeport</city>
<state>ME</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>McDonnell Boehnen Hulbert &amp; Berghoff LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>IDEXX Laboratories, Inc.</orgname>
<role>02</role>
<address>
<city>Westbrook</city>
<state>ME</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Nghiem</last-name>
<first-name>Michael</first-name>
<department>2863</department>
</primary-examiner>
<assistant-examiner>
<last-name>Khuu</last-name>
<first-name>Cindy D.</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Systems and methods for identifying populations of events in a multi-dimensional data set are described. The populations may, for example, be sets or clusters of data representing different white blood cell components in sample processed by a flow cytometer. The methods use a library consisting of one or more one finite mixture models, each model representing multi-dimensional Gaussian probability distributions with a density function for each population of events expected in the data set. The methods further use an expert knowledge set including one or more data transformations and one or more logical statements. The transformations and logical statements encode a priori expectations as to the populations of events in the data set. The methods further use program code by which a computer may operate on the data, a finite mixture model selected from the library, and the expert knowledge set to thereby identify populations of events in the data set.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="83.31mm" wi="146.39mm" file="US07299135-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="230.89mm" wi="163.41mm" file="US07299135-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="205.15mm" wi="106.26mm" file="US07299135-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="243.42mm" wi="153.08mm" orientation="landscape" file="US07299135-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="222.33mm" wi="146.22mm" orientation="landscape" file="US07299135-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="169.16mm" wi="138.35mm" orientation="landscape" file="US07299135-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="225.21mm" wi="142.24mm" orientation="landscape" file="US07299135-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="230.89mm" wi="148.00mm" orientation="landscape" file="US07299135-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="228.43mm" wi="159.51mm" orientation="landscape" file="US07299135-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="250.78mm" wi="165.86mm" orientation="landscape" file="US07299135-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="221.23mm" wi="152.23mm" orientation="landscape" file="US07299135-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">NOTICE REGARDING COPYRIGHT</heading>
<p id="p-0002" num="0001">A portion of this disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">A. Field of the Invention</p>
<p id="p-0004" num="0003">This invention relates to the field of methods of analysis of multi-dimensional data and more particularly to methods for identifying and classifying discrete populations or clusters within such data. This invention has applications in a variety of disciplines, including the fields of biology, drug discovery and medicine, such as analysis of blood. One specific application described herein is analysis of multi-dimensional data obtained from a flow cytometer in order to identify and classify the data into discrete populations of different types of white blood cells.</p>
<p id="p-0005" num="0004">B. Related Art</p>
<p id="p-0006" num="0005">Mammalian peripheral blood usually contains three major classifications of blood cells—red blood cells (“RBCs”), white blood cells (“WBCs”), and platelets (“PLTs”). These cells are suspended in a solution referred to as plasma, which contains many different proteins, enzymes, and ions. The functions of the plasma components include blood coagulation, osmolality maintenance, immune surveillance, and a multitude of other functions.</p>
<p id="p-0007" num="0006">Mammals usually have anywhere from 2-10×10<sup>12 </sup>RBCs per liter. RBCs are responsible for oxygen and carbon dioxide transport within the circulatory system. In many mammals, including humans, normal mature red cells have a bi-concave cross-sectional shape and lack nuclei. RBCs can range in diameter between 4 and 9 microns, depending on the species, and have a thickness that is generally less than 2 microns. The RBCs contain high concentrations of hemoglobin, a heme-containing protein which performs the dual roles of oxygen and carbon dioxide transport. Hemoglobin is responsible for the overall red color of blood, due to the presence of iron in the heme molecule. In the present application, the terms “erythrocytes”, “red blood cells”, “red cells”, and “RBCs” are used interchangeably to refer to the hemoglobin-containing blood cells present in the circulation as described above.</p>
<p id="p-0008" num="0007">In addition to mature RBCs, immature forms of red blood cells can often be found in peripheral blood samples. A slightly immature RBC is referred to as a reticulocyte, and the very immature forms of RBCs are broadly classified as nucleated red blood cells (NRBCs). Higher level non-mammalian animals, such as birds, reptiles, and amphibians, have exclusively nucleated RBCs in their blood.</p>
<p id="p-0009" num="0008">Reticulocytes are red blood cell precursors that have completed most of the normal red cell development stages in bone marrow, and have expelled their nuclei. The last portion remaining to leave the reticulocyte before it becomes a truly mature RBC is transfer RNA. Detection of reticulocytes is important in clinical evaluation of a patient's ability to produce new red blood cells. The reticulocyte count also can be used to distinguish among different types of anemia. In anemia, red cell production may be diminished to the point where it can no longer keep up with red cell removal, and as a result the overall red blood cell count and hematocrit are low. The presence of an increased number of reticulocytes in anemic patients provides evidence that their bone marrow is functioning, and attempting to make up for the red blood cell deficit. If few or no reticulocytes are detectable in these patients, the bone marrow is not adequately responding to the red blood cell deficit.</p>
<p id="p-0010" num="0009">White blood cells (also called “leukocytes”) are the blood-borne immune system cells that destroy foreign agents, such as bacteria, viruses, and other pathogens that cause infection. WBCs exist in peripheral blood in very low concentrations as compared to red blood cells. Normal concentrations of these cells range from 5-15×10<sup>9 </sup>per liter, which is about three orders of magnitude less than red blood cells. These cells are generally larger than RBCs, having diameters between 6 to 13 microns, depending on the type of white cell and the species. Unlike RBCs, there are a variety of white blood cell types that perform different functions within the body. In this application, the terms “white blood cells”, “white cells”, “leukocytes”, and “WBCs” are used interchangeably to refer to the non-hemoglobin-containing nucleated blood cells present in the circulation as described above.</p>
<p id="p-0011" num="0010">Measurements of the numbers of white cells in blood is important in the detection and monitoring of a variety of physiological disorders. For example, elevated numbers of abnormal white blood cells may indicate leukemia, which is an uncontrolled proliferation of a myelogenous or a lymphogenous cell. Neutrophilia, or an abnormally high concentration of neutrophils, is an indication of inflammation or tissue destruction in the body, by whatever cause.</p>
<p id="p-0012" num="0011">White blood cells may be broadly classified as either granular or agranular. Granular cells, or granulocytes, are further subdivided into neutrophils, eosinophils, and basophils. Agranular white cells are sometimes referred to as mononuclear cells, and are further sub-classified as either lymphocytes or monocytes. Measurements of the percentages in the blood of the two major WBC classifications (granulocytes and mononuclear cells) comprise a two-part WBC differential count (or two-part differential). Measurements of the components of these subclassifications (neutrophils, eosinophils, basophils, lymphocytes, and monocytes), produce a five-part WBC differential count (or five-part differential).</p>
<p id="p-0013" num="0012">Neutrophils are the most prevalent of the granulocytes and of the five major subclasses of white cells, usually making up a little over half of the total number of white blood cells. Neutrophils are so named because they contain granules within their cytoplasm which can be stained at a neutral pH. These cells have a relatively short life span, on the order of a day or less. Neutrophils attack and destroy invading bacteria and other foreign agents in the tissues or circulating blood as part of the body's immune response mechanisms.</p>
<p id="p-0014" num="0013">Eosinophils are the second most prevalent of the granulocytes, behind the neutrophils, but generally account for less than five percent of the total number of white blood cells. Eosinophils also contain granules within their cytoplasm which can be stained with an eosin stain. Like neutrophils, these cells are short-lived in the peripheral blood. Eosinophils play a part in the body's immune response mechanisms that are usually associated with allergies or parasitic infections.</p>
<p id="p-0015" num="0014">Basophils are the least common of the granulocytes, and the least common of all the five classifications of WBCs. As they are granulocytes, they contain granules within their cytoplasm which can be stained, in this case using a basic (high pH) stain. These cells also are known to play a role in the body's immune response mechanisms, but the specifics are not certain.</p>
<p id="p-0016" num="0015">Lymphocytes are the most prevalent of the mononuclear cell types, and generally make up between 20 and 30 percent of the total number of white blood cells. Lymphocytes specifically recognize foreign antigens and in response divide and differentiate to form effector cells. The effector cells may be B lymphocytes or T lymphocytes. B lymphocytes secrete large amounts of antibodies in response to foreign antigens. T lymphocytes exist in two main forms—cytotoxic T cells, which destroy host cells infected by infectious agents, such as viruses, and helper T cells, which stimulate antibody synthesis and macrophage activation by releasing cytokines. Lymphocytes have no granules in their cytoplasm, and their nucleus occupies a large majority of the cell volume. The thin area of cytoplasm outside the nucleus of lymphocytes can be stained with a nucleic acid stain, since it contains RNA. Many lymphocytes differentiate into memory B or T cells, which are relatively long-lived and respond more quickly to foreign antigen than naive B or T cells.</p>
<p id="p-0017" num="0016">Monocytes are immature forms of macrophages that, in themselves, have little ability to fight infectious agents in the circulating blood. However, when there is an infection in the tissues surrounding a blood vessel, these cells leave the circulating blood and enter the surrounding tissues. The monocytes then undergo a dramatic morphological transformation to form macrophages, increasing their diameter as much as fivefold and developing large numbers of mitochondria and lysosomes in their cytoplasm. The macrophages then attack the invading foreign objects by phagocytosis and activation of other immune system cells, such as T cells. Increased numbers of macrophages are a signal that inflammation is occurring in the body.</p>
<p id="p-0018" num="0017">Platelets are found in all mammalian species, and are involved in blood clotting. Normal animals will generally have between 1-5×10<sup>11 </sup>platelets per liter. These cellular particles are usually much smaller than RBCs, having a diameter between 1 and 3 μm. Platelets are formed as buds from the surfaces of megakarocytes, which are very large cells found in the bone marrow. The megakaryocytes do not themselves leave the marrow to enter the blood circulation; rather, buds form on the surface, pinch off and enter the circulation as platelets. Like RBCs, platelets lack nuclei and thus cannot reproduce. Functionally, platelets aggregate so as to plug or repair small holes in blood vessels. In the case of larger holes, platelet aggregation acts as an early step in clot formation. As a result, platelet count and function are clinically very important. For example, abnormally low platelet counts may be the cause of a clotting disorder.</p>
<p id="p-0019" num="0018">Collectively, the counting and sizing of RBCs, the counting of WBCs, and the counting of platelets is referred to as a complete blood count (“CBC”). The separation of white blood cells into the five major classifications (i.e., neutrophils, eosinophils, basophils, lymphocytes, and monocytes) and their quantification on a percent basis is referred to as a five-part differential. The separation of white blood cells into two major classifications, granular and agranular leukocytes, and their quantification on a percent basis is referred to as a two-part differential. The categorizing of red blood cells into two classifications, mature red blood cells and reticulated red blood cells, on a percent basis is referred to as a reticulocyte count.</p>
<p id="p-0020" num="0019">The determination of a CBC, with a five-part differential and a reticulocyte count, is a common diagnostic procedure performed to diagnose, track and treat an abundance of ailments. These tests make up the great majority of hematology analyses that are performed in medical and veterinary clinical laboratories around the world. These three tests have for many years been performed using a microscope, centrifuge, counting chamber, slide, and appropriate reagents. However, the skills necessary to perform these test manually are rare and require years of training. Furthermore, the time required to perform each of these tests manually is very high. As a result, significant automation via instrumentation has been pursued in this field since the early 1950's.</p>
<p id="p-0021" num="0020">Flow cytometry is a powerful method of analysis that is able to determine the cellular content of various types of samples, and in particular samples that contain living cells. In clinical applications, flow cytometers are useful for lymphocyte counting and classification, for immunological characterization of leukemias and lymphomas, and for cross-matching tissues for transplants. In most flow cytometry techniques, cells in a fluid solution are caused to flow individually through a light beam, usually produced by a laser light source. As light strikes each cell, the light is scattered and the resulting scattered light is analyzed to determine the type of cell. Different types of cells produce different types of scattered light. The type of scattered light produced may depend on the degree of granularity, the size of the cell, etc. Cells in a fluid solution may also be labeled with a marker linked to a fluorescent molecule, which fluoresces when light strikes it and thereby reveals the presence of the marker on the cell. In this fashion, information about the surface components of the cell can be obtained. Examples of such fluorescent molecules include FITC (fluorescein isothiocyanate), TRITC (tetramethyl rhodamine isothiocyanate), Cy3, Texas Red (sulforhodamine 101), and PE (phycoerythrin). In addition, intracellular components of the cell, such as nucleic acids, may be stained by fluorescent compounds, and subsequently detected by fluorescence. Examples of such compounds include ethidium bromide, propidium iodide, YOYO-1, YOYO-3, TOTO-1, TOTO-3, BO-PRO-1, YO-PRO-1, and TO-PRO-1. Cells may also be stained with dyes that label particular cellular components, and the absorbance of the dye bound to the cells measured.</p>
<p id="p-0022" num="0021">Blood cell measurements made using flow cytometry often require two separate measurements—one to measure the RBCs and platelets, and the other to measure WBCs. The reason for separate measurements is that the RBCs are present in the blood at a much higher concentration than other blood cell types, and thus detection of other cell types in the presence of RBCs requires that the RBCs either be removed or large volumes of sample be measured. Alternatively, these cells may be distinguished on the basis of immunochemical staining of particular cell surface antigens and/or differential cell type staining.</p>
<p id="p-0023" num="0022">Light scattering measurements are widely used in flow cytometry to measure cell sizes and to distinguish among several different types of cells. It is known that incident light is scattered by cells at small angles (approximately 0.5-20 degrees) from the line traveled by the incident light that interrogates the cells, and that the intensity of the scattered light is proportional to the cell volume. The light scattered at small angles is referred to forward scattered light. Forward scattered light (also called forward light scatter, or small-angle scatter for angles of scatter between 0.5-2.0.degree.) is useful in determining cell size. The ability to measure cell size depends on the wavelength employed and the precise range of angles over which light is collected. For example, material within cells having a strong absorption at the illuminating wavelength may interfere with size determination because cells containing this material produce smaller forward scatter signals than would otherwise be expected, leading to an underestimate of cell size. In addition, differences in refractive index between the cells and the surrounding medium may also influence the small-angle scatter measurements.</p>
<p id="p-0024" num="0023">In addition to forward scattered light, cells having a high degree of granularity, such as granulocytes, scatter incident light at high angles to a much greater degree than cells with low granularity, such as lymphocytes. Different cell types may be distinguished on the basis of the amount of orthogonal light scatter (also referred to herein as right angle side scatter) they produce. As a result, forward and right angle side scatter measurements are commonly used to distinguish among different types of blood cells, such as red blood cells, lymphocytes, monocytes, and granulocytes.</p>
<p id="p-0025" num="0024">Additionally, eosinophils may be distinguished from other granulocytes and lymphocytes on the basis of polarization measurements of right angle side scatter. Normally, incident polarized light is scattered orthogonally and remains polarized. However, eosinophils cause incident polarized light scattered orthogonally to become depolarized to a greater degree than other cells. This higher degree of depolarization permits the specific identification of eosinophil populations in blood samples.</p>
<p id="p-0026" num="0025">Flow cytometers have been commercialized and are known in the art. IDEXX Laboratories, the assignee of this invention, has developed a commercial flow cytometer for analysis of blood which is marketed under the trademark LASERCYTE. Flow cytometers are also described in the patent literature, see for example U.S. Pat. Nos. 6,784,981 and 6,618,143, both assigned to IDEXX Laboratories, the contents of which are incorporated by reference herein. Other patents of interest include U.S. Pat. Nos. 5,380,663; 5,451,525; and 5,627,037.</p>
<p id="p-0027" num="0026">In conventional hematology instruments, the hemoglobin concentration is generally measured in an otherwise clear solution, and is referenced to a clear fluid. Lysis of red cells allow the hemoglobin to be measured in the same fluidic channel as the white blood cells. Alternatively, on some systems, the hemoglobin content may be measured in a separate channel.</p>
<p id="p-0028" num="0027">To obtain meaningful information about the numbers and types of cells in a biological sample, or of the concentration of markers on cell surfaces, the samples must be standardized with respect to the amount of light scatter, fluorescence or impedance associated with standardized populations of the cells. In addition, the flow cytometry instrument itself must be calibrated to ensure proper performance. Calibration of the instrument is typically accomplished by passing standard particles through the instrument, and measuring the resulting scatter, fluorescence, or impedance. Flow cytometers may be calibrated with either synthetic standard materials (e.g., polystyrene latex beads) or with cells or other biological material (e.g., pollen, fixed cells, or stained nuclei). These standardization materials are desirably extremely uniform in size, and contain precise amounts of fluorescent molecules to serve in calibrating the photomultiplier tubes used in detection of fluorescent probes. However, the calibration procedures are lengthy and complicated, and require extensive training to perform properly. Consequently, these calibration procedures are typically performed only once at the beginning of the analysis. Changes in the instrument or in the sample may alter the performance of the instrument.</p>
<p id="p-0029" num="0028">Flow cytometry techniques that took advantage of the light scattering characteristics of cells were applied beginning in the early 1970's to perform white cell differential analysis, in combination with CBC determination. Automated reticulocyte analysis was developed in the 1980's. However, these early systems did not perform a CBC or white blood cell differential. Eventually, manufacturers like Technicon (Bayer), Coulter (Beckman-Coulter) and Abbott incorporated reticulocyte counting with their automated CBC/white cell differential systems, in such high-end hematology systems as the Technicon (Bayer) H*3, Bayer Advia 120™, Coulter STKS™, Coulter GenS™., and Abbott CellDyn 3500 and CellDyn 4000. These high-end instrument systems are capable of measuring all of the parameters for a complete hematology analysis that are clinically important for patient assessment, namely, CBC, five-part WBC differential and reticulocyte count.</p>
<p id="p-0030" num="0029">The WBC data generated by passing a single blood sample through a flow cytometer consists of N data points, each point captured in a separate channel. Each “channel” is associated with a discrete detector built into the instrument, or, alternatively, an integration of a detector signal over some time period. Thus, the flow cytometer produces N data points in M channels for a data set totalling N×M data points, where M may be 2, 3, 4 or other integer and is equal to the number of detectors in the instrument and whether integration or other processing is used to create more channels than detectors. In the LaserCyte instrument, the instrument captures N seven dimensional data points (M=7). The dimensions are Extinction (EXT), Extinction Integrated (EXT_Int), Right Angle Scatter (RAS), Right Angle Scatter Integrated (RAS_Int), Forward Scatter Low (FSL), Forward Scatter High (FSH), and Time of Flight (TOF). See U.S. Pat. Nos. 6,784,981 and 6,618,143 for details on the geometry of these data collectors and their meanings. The terms “dimensions” and “channels” are used interchangeably in this document. A single seven-dimensional data point is referred to as an “event”.</p>
<p id="p-0031" num="0030">The physical properties of the different white blood cells cause light passing through them to scatter differently. For example, larger cells generally have greater EXT and EXT_Int values due to their greater light occlusion, while cells with greater internal complexity tend to produce greater light scatter and this is observed at the FSH detector.</p>
<p id="p-0032" num="0031">The human eye can distinguish data clumps or clusters (“populations”) amongst some two-dimensional projections of the seven-dimensional event data, e.g., a conventional 2D plotting of the N event data with the EXT value being in positive Y axis and the RAS value plotted the positive X axis. Moreover, it has been shown that on clean, well-handled samples, the percentage of observed events within each cluster typically corresponds to the relative percentages of the five different white blood cell types (neutrophils, monocytes, lymphocytes, eosinophils, and basophils). However, there is a need for quantifying such populations with some precision, preferably in an automated manner, as quantitative measurements provide a more meaningful way to measure and compare the populations and therefore use them for diagnostic or other analytical purposes.</p>
<p id="p-0033" num="0032">The solution provided by this disclosure is a method and apparatus for finding and classifying, in an automated fashion, event data in the midst of noise and to give estimates, in quantitative terms, on the relative frequencies of populations in a multidimensional data set, such as for example, frequencies of WBC type in a given sample of human or animal blood. This is no small feat. The sample-to-sample and machine-to-machine variability, combined with varying degrees of noise resulting from unknown cellular events, greatly complicate this classification problem. The art has lacked a robust analysis method that offers the ability to combine expert knowledge with stable unsupervised classifying and classifying algorithms for identifying discrete populations (clusters) of data within a large multidimensional data set, e.g., as obtained by a flow cytometer.</p>
<p id="p-0034" num="0033">The foregoing examples of the related art and limitations related therewith are intended to be illustrative and not exclusive. Other limitations of the related art will become apparent to those of skill in the art upon a reading of the specification and a study of the drawings.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0035" num="0034">The following embodiments and aspects thereof are described and illustrated in conjunction with systems, tools and methods which are meant to be exemplary and illustrative, not limiting in scope. In various embodiments one or more of the above-described problems have been reduced or eliminated, while other embodiments are directed to other improvements.</p>
<p id="p-0036" num="0035">In a first aspect, an improvement is provided to a computing system used for identifying populations of events in a multi-dimensional data set obtained from a flow cytometer. The improvement comprises one or more machine readable storage media for use with the computing system, the machine readable storage media storing:</p>
<p id="p-0037" num="0036">a) data representing a finite mixture model, the model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set;</p>
<p id="p-0038" num="0037">b) an expert knowledge set, comprising one or more data transformations for operation on the multi-dimensional data set and one or more logical statements (“expert rules” herein), the transformations and logical statements encoding a priori expectations as to the populations of events in the data set; and</p>
<p id="p-0039" num="0038">c) program code for the computing system comprising instructions for operating on the multi-dimensional data, the finite mixture model, and the expert knowledge set, to thereby identify populations of events in the multi-dimensional data set.</p>
<p id="p-0040" num="0039">The identification of populations in the multi-dimensional data set can be converted to quantitative or qualitative data presented in a human-perceptible form, such as a graph or plot of the data with color coding to identify discrete populations in the data set, or as an output in terms of numbers or percentages of data points in the data set which are associated with the populations. As another example, the identified populations can be represented as one or more files in electronic from which can be stored in memory in the computer system, or transferred over a network to a computer workstation for further analysis or display to an operator (e.g., hematologist, veterinarian, or primary care physician).</p>
<p id="p-0041" num="0040">The use of the expert knowledge set in combination with the finite mixture model allows for more robust and accurate methods of automatically classifying data into one or more populations. In the context of flow cytometry and blood samples, an expert hematologist approaches a given flow cytometry data set expecting to find evidence of the five WBC types and has, as a result of previous information derived from blood manipulation studies, a good idea where they fall in one or more two-dimensional projections of the seven-dimensional data. There are no necessary bounds on what might comprise an expert's a priori knowledge set, but examples can include cluster position (e.g., in a two-dimensional projection or plot of a subset of the data), geometric shape of a cluster within some two-dimensional projections, and cluster position relative to other clusters. Such relationships often correspond to, and encode, known differences between the cell types, e.g. neutrophils are larger than most lymphocytes, and eosinophils contain more dense organelles than monocytes, etc. but could also arise from instrument specific knowledge. The present inventive methods provide an automated classification system and methods that rely on similar types of information, and, importantly, code such knowledge into an expert knowledge set of data transformations and logical statements or operations, and uses such knowledge set on a data set or data derived from the data set (“hidden data” herein) to more accurately classify the data set into populations.</p>
<p id="p-0042" num="0041">In one specific embodiment, the multi-dimensional data set comprises a data set obtained from a flow cytometer for one blood sample. The multi-dimensional data could of course be obtained from another analytical instrument or combination of instruments. In one further specific embodiment, the populations in the data set are associated with blood components, e.g., white blood cell components, in a sample of human or animal blood.</p>
<p id="p-0043" num="0042">In one specific embodiment, the expert knowledge set includes at least one geometric transformation for transforming the multidimensional data set or subset thereof. The expert knowledge may also include one or more probability transformations.</p>
<p id="p-0044" num="0043">The program code using the finite mixture model and the expert knowledge set can take a variety of forms and no specific structure or sequence to the programming operations is believed to be essential or critical. In one specific embodiment, the program instructions include a number of processing modules. In the specific embodiment, these modules include a pre-optimization module, an optimization module and a classification module.</p>
<p id="p-0045" num="0044">The pre-optimization module performs a scaling of the multi-dimensional data set. Such scaling can be performed to adjust the data for machine to machine variability given the most likely finite mixture model's parameters. The pre-optimization model may also make a selection of a finite mixture model from the library of finite mixture models, for example in the case where there are multiple models in the library and one is particularly suitable for use with the given sample.</p>
<p id="p-0046" num="0045">The optimization module seeks to adjust the parameters of the finite mixture model so as to best accommodate (model) the data being classified. To do so, it iteratively performs three operations: (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density functions of the selected finite mixture model.</p>
<p id="p-0047" num="0046">The expectation operation (1) computes an array of numbers (the array being an J×K matrix where J is equal to the number of events and K is the number of finite mixture model components) that is referred to herein as “hidden data”, and referred to as such in the Expectation/Maximization algorithm literature. Such data is related to the probability that an event arose from each of the different density functions in the finite mixture model, and we will denote an entry in this array by Pr(C<sub>i</sub>|x<sub>j</sub>,Ω). This hidden data is important to both the expectation and maximization operations and to the application of the expert knowledge set. In particular, the rules in the expert knowledge set adjusts these values preferentially based on expert knowledge about the interdependencies between the expected populations in the multi-dimensional data.</p>
<p id="p-0048" num="0047">The maximization operation updates each density function's parameters and the mixing coefficients based on the hidden data. From a simple perspective, if the hidden data were binary, which is to say one knew precisely which event class ought to be assigned to any event, updating the parameters would be easy since one would only include those events known to belong to a cluster and standard maximum likelihood estimate methods would suggest parameter updates. As one can observe from the maximization step description that follows, the hidden data simply serves as a weighting mechanism in the simple estimate formulas. The parameter update rules result from an algebraic solution to a gradient ascent optimization problem, in a manner known in the finite mixture model literature.</p>
<p id="p-0049" num="0048">The classification module is responsive to the output of the maximization operation for classifying the multi-dimensional data set into one or more populations. In one specific embodiment, the event classification step uses Bayes rule together with the parameter estimates returned from the model optimization (maximization) process. By Bayes rule, an event is then assigned to the class with the greatest class-specific posterior probability (Pr(C<sub>i</sub>|x<sub>j</sub>,Ω)). These quantities incorporate changes made to each class's density function parameters during model optimization (expectation and maximization updates plus the use of expert rules from the expert knowledge set) and a final expectation step.</p>
<p id="p-0050" num="0049">In one specific embodiment, a post-classification module is provided which modifies the classification of the multi-dimensional data set using one or more expert rules from the expert knowledge set.</p>
<p id="p-0051" num="0050">In another aspect, a method is disclosed of identifying populations of events in a multi-dimensional data set. The method includes the steps of:</p>
<p id="p-0052" num="0051">(a) processing a sample with an analytical instrument, e.g., a flow cytometer, to thereby obtain a multi-dimensional data set;</p>
<p id="p-0053" num="0052">(b) storing the data set in a machine-readable memory;</p>
<p id="p-0054" num="0053">(c) selecting a finite mixture model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set; and</p>
<p id="p-0055" num="0054">(d) operating on the multi-dimensional data and the finite mixture model with the aid of an expert knowledge set to thereby identify populations of events in the multi-dimensional data set, wherein the expert knowledge set comprises one or more data transformations for operation on the multi-dimensional data set and one or more logical statements or operations, the transformations and logical statements encoding a priori expectations as to the populations of events in the data set.</p>
<p id="p-0056" num="0055">In one specific embodiment, the operations of step (d) include a pre-optimization step performing scaling of the multi-dimensional data set. The operations of step (d) further includes an optimization step which involves iteratively performing (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density function of the selected finite mixture model. The operations further include a classification step responsive to the output of the maximization operation for classifying the multidimensional data set into one or more populations. Optionally, post-classification steps are performed using one or more expert rules in the expert knowledge set.</p>
<p id="p-0057" num="0056">In still another aspect, a flow cytometry system is disclosed which comprises a flow cytometer and a data processing unit for processing data obtained from the flow cytometer. The system further includes a memory storing a finite mixture model, an expert knowledge set comprising logical operations and data transformations, and program code for execution by the processing unit for using the expert knowledge set and the finite mixture model to identify populations of events in the data obtained from the flow cytometer.</p>
<p id="p-0058" num="0057">In addition to the exemplary aspects and embodiments described above, further aspects and embodiments will become apparent by reference to the drawings and by study of the following detailed descriptions.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0059" num="0058">Exemplary embodiments are illustrated in referenced figures of the drawings. It is intended that the embodiments and figures disclosed herein are to be considered illustrative rather than restrictive.</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic representation of an analytical instrument and associated data processing unit in the form of a general purpose computer configured with a memory containing a library of finite mixture models, expert knowledge set and program code for implementing the methods disclosed herein for identifying populations within a multidimensional data set. In the example of <figref idref="DRAWINGS">FIG. 1</figref>, the data set is generated by an instrument in the form of a flow cytometer processing a human or animal blood sample.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 2</figref> is a simplified block diagram of the data processing unit of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart showing the major processing steps embodied in the program code to identify populations in the data set of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. 4</figref> is an illustration showing conceptually the operations performed by the modules in the flow chart of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. 5</figref> is an illustration of an input multi-dimensional data set and a library of finite mixture models for use in processing the input data in the method of shown in the flow chart of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 6</figref> is an illustration of a rescaling operation performed by the pre-optimization processing step of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. 7</figref> is an illustration of a first aspect of an expectation step in the optimization module of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 8</figref> is an illustration of a second aspect of an expectation step in the optimization module of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 9</figref> is an illustration of a first aspect of the application of elements of the expert knowledge set, including transformation operations and logical statements, in the optimization module of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. 10</figref> is an illustration of a second aspect of the application of elements of the expert knowledge set, including transformation operations and logical statements, in the optimization module of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. 11</figref> is an illustration of a maximization step in the optimization module of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
<p id="p-0071" num="0070">Overview</p>
<p id="p-0072" num="0071">As noted above, when a blood sample is passed through a flow cytometry system, the system generates N data points in multiple dimensions. In the present example, the flow cytometer obtains data in seven dimensions. The dimensions are referred to herein as “channels” and are abbreviated EXT, EXT_Int, RAS, RAS_Int, FSL, FSH, and TOF, and have been defined previously. The physical properties of the different white blood cells cause light passing through them to scatter differently. For example, larger cells generally have greater EXT and EXT_Int values due to their greater light occlusion, while cells with greater internal complexity tend to produce greater light scatter and this is observed at the FSH detector. In a flow cytometry application of this invention, the goal of the methods described herein is to find, i.e., identify and classify, these populations in the midst of noise and to give quantitative or qualitative estimates on the relative frequencies of each white blood cell type. Obviously, in other applications of this invention the populations will correspond to other quantities and so the application in the field of flow cytometry is offered by way of example and not limitation.</p>
<p id="p-0073" num="0072">The sample-to-sample and machine-to-machine variability combined with varying degrees of noise resulting from unknown cellular events greatly complicate this classification problem and call for a robust analysis method that offers the ability to combine expert knowledge with stable unsupervised classifying algorithms. This disclosure provides such a robust analysis method.</p>
<p id="p-0074" num="0073">The present disclosure provides for a method and system for identifying populations in a multi-dimensional data set. The system contains two primary elements. Firstly, a library of finite mixture models is provided, components of which are probability density functions characterizing each population of events expected in the data set. One model is selected from the library for use in the processing described herein. The second element is an expert knowledge set encoding a priori “expert” experience with the multi-dimensional data, expressed in the form of data transformations and logical statements or operations (“rules” herein) concerning the expected populations.</p>
<p id="p-0075" num="0074">In a flow cytometry example, the expert knowledge set takes advantage of how an expert hematologist would approach the problem of finding population distributions in a data set (e.g., expected locations of the five WBC types). In particular, an expert has, as a result of previous information derived from blood manipulation studies, a good idea where population distributions fall in one or more two-dimensional projections of the seven-dimensional data. There are no necessary bounds on what might comprise an expert's a priori knowledge set, but examples include cluster position, geometric shape within some two-dimensional projections, and cluster position relative to other clusters. Such relationships often correspond to, and encode, known differences between the cell types, e.g. neutrophils are larger than most lymphocytes, and eosinophils contain more dense organelles than monocytes, etc. but could also arise from instrument specific knowledge. The present inventive methods provide an automated classification system and methods that rely on similar types of information, and, importantly, code such knowledge into an expert knowledge set of data transformations and logical statements or operations, and uses such knowledge set to more accurately classify the data set into populations.</p>
<p id="p-0076" num="0075">In a practical implementation of the method, the finite mixture models and the expert rules are stored in computer memory and used by a data processing unit, e.g. computer workstation, to automatically identify populations in the data set. The memory further stores program code for the computing system comprising instructions for operating on the multi-dimensional data, selecting a finite mixture model from the library of finite mixture models, and incorporating an expert knowledge set, to thereby identify populations of events in the multi-dimensional data set, as will be explained in detail below.</p>
<p id="p-0077" num="0076">The identification of populations in the multi-dimensional data set can be converted to quantitative or qualitative data presented in a human-perceptible form, such as a graph or plot of the data with color coding to identify discrete populations in the data set or as an output in terms of numbers or percentages of data points in the data set which are associated with the populations. As another example, the identified populations can be represented as one or more files in electronic from which can be stored in memory in the computer system, or transferred over a network to a computer workstation for further analysis or display to an operator (e.g., hematologist, veterinarian, or primary care physician).</p>
<p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic representation of one exemplary environment in the form of a flow cytometry system <b>10</b> that implements this invention. The system <b>10</b> includes a flow cytometer <b>12</b> having a flow cell <b>14</b> through which a sample <b>16</b>, in this case human or animal blood, is passed. The flow cell <b>14</b> includes a laser light source <b>18</b> and a plurality of detectors <b>20</b>, including one measuring the extinction of the light from the laser (EXT channel), a detector measuring Right Angle Scatter (RAS channel), a forward angle scatter detector (FSH channel), and possibly other detectors. Additionally, signal from one or more channels may be integrated over a time period to form an additional integration channel, e.g., RAS_Int channel. There as a total of seven channels in the illustrated embodiment. Thus, for each event (e.g. each cell passing through the flow cell <b>14</b>) data is collected in seven channels. Such data is converted into digital form and supplied over a cable <b>22</b> to a data processing instrument <b>24</b>, which may take the form of a general purpose computer workstation. The workstation includes a display <b>26</b> for presentation of the channel data, e.g., in the form of scatter plots, or presentation of textual reports indicating the relative frequencies of populations in the data collected by the flow cell <b>14</b>. The workstation <b>24</b> may also include attached peripheral devices, e.g., printers, and may also include a connection to a local or wide area network so as to allow flow cytometry data to be shared with other computing resources or transmitted to a remote location such as a lab, primary care physician, hospital, etc. The data processing unit <b>24</b> may also be incorporated into the flow cytometer <b>12</b> itself.</p>
<p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of the data processing unit <b>24</b> of <figref idref="DRAWINGS">FIG. 1</figref>. The data processing unit <b>24</b> includes input and output circuitry for connecting the unit <b>24</b> to the analytical instrument and to any attached computer networks, a central processing unit <b>28</b>, user interface devices <b>26</b>, attached peripheral devices <b>32</b>, and one or memory devices <b>34</b>. The memory <b>34</b> may take the form of a hard disk memory. Such memory stores data sets and program code used in the methods described herein. The memory includes data representing a library of finite mixture models <b>40</b>, an expert knowledge set <b>42</b> consisting of expert rules <b>44</b> in the form of code representing logical operations and statements, and geometrical and probability transformations <b>46</b> in the form of code. The memory <b>34</b> further stores the multi-dimensional flow cell data <b>52</b>. The memory further stores executable program code and data structures <b>50</b> which operate on the flow cell data <b>52</b>, one or more finite mixture models <b>40</b> in the library of models and the expert knowledge set <b>42</b>. The memory further stores data representing scaling factors <b>54</b> which are used in a pre-optimization step to scale the data to account for machine to machine variability as will be explain in further detail later on.</p>
<p id="p-0080" num="0079">Finite Mixture Model Usage in Event Classification <b>40</b></p>
<p id="p-0081" num="0080">A finite mixture model is a finite weighted sum of probability density functions, one per population (or class). Specifically, a finite mixture model containing G probability density functions takes the form</p>
<p id="p-0082" num="0081">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <mi>Pr</mi>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <msub>
            <mi>x</mi>
            <mi>j</mi>
          </msub>
          <mo>|</mo>
          <mi>Ω</mi>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mrow>
          <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mrow>
            <mi>…</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.6em" height="0.6ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>G</mi>
          </mrow>
        </mrow>
      </munder>
      <mo>⁢</mo>
      <mrow>
        <msub>
          <mi>π</mi>
          <mi>i</mi>
        </msub>
        <mo>⁢</mo>
        <mrow>
          <msub>
            <mi>f</mi>
            <mi>i</mi>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>x</mi>
                <mi>j</mi>
              </msub>
              <mo>|</mo>
              <mi>Ω</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
  <mrow>
    <mrow>
      <mi>with</mi>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.8em" height="0.8ex"/>
      </mstyle>
      <mo>⁢</mo>
      <mrow>
        <munder>
          <mo>∑</mo>
          <mrow>
            <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <mi>…</mi>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.6em" height="0.6ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mi>G</mi>
            </mrow>
          </mrow>
        </munder>
        <mo>⁢</mo>
        <msub>
          <mi>π</mi>
          <mi>i</mi>
        </msub>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
and where Ω is a vector of parameters including both the class weights π<sub>i </sub>and the individual density function parameters. G corresponds to the number of expected populations in the classification problem. Finite mixture models have attracted a great deal of attention from the Bayesian pattern recognition community where they consider each density function f<sub>i </sub>as a conditional probability of a data point arising from a density function characteristic of a given classifier C<sub>i </sub>or outcome type. To emphasize this, the following notation for a finite mixture model is used:
</p>
<p id="p-0083" num="0082">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <mi>Pr</mi>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <msub>
            <mi>x</mi>
            <mi>j</mi>
          </msub>
          <mo>|</mo>
          <mi>Ω</mi>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mrow>
          <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mrow>
            <mi>…</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.6em" height="0.6ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>G</mi>
          </mrow>
        </mrow>
      </munder>
      <mo>⁢</mo>
      <mrow>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>C</mi>
                <mi>i</mi>
              </msub>
              <mo>|</mo>
              <mi>Ω</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mrow>
                <msub>
                  <mi>x</mi>
                  <mi>j</mi>
                </msub>
                <mo>|</mo>
                <msub>
                  <mi>C</mi>
                  <mi>i</mi>
                </msub>
              </mrow>
              <mo>,</mo>
              <mi>Ω</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
  <mrow>
    <mrow>
      <mi>with</mi>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.8em" height="0.8ex"/>
      </mstyle>
      <mo>⁢</mo>
      <mrow>
        <munder>
          <mo>∑</mo>
          <mrow>
            <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <mi>…</mi>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.6em" height="0.6ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mi>G</mi>
            </mrow>
          </mrow>
        </munder>
        <mo>⁢</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>C</mi>
                <mi>i</mi>
              </msub>
              <mo>|</mo>
              <mi>Ω</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
where the conditional nature of the density function is noted explicitly, and the weighting value π<sub>i </sub>have been replaced by Pr(C<sub>i</sub>|Ω), (considered an a priori estimate of the probability of an observed data point x<sub>j </sub>having been generated from the outcome type C<sub>i</sub>). Because the weighting values are not conditioned on the observed data point x<sub>j</sub>, they correspond to the relative frequency of events from each class (C<sub>i</sub>).
</p>
<p id="p-0084" num="0083">Given an optimized finite mixture model, it is common to classify data points <b>108</b> using the following classification schema
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Class(<i>x</i><sub>j</sub>)=arg max{<i>Pr</i>(<i>C</i><sub>i</sub><i>|x</i><sub>j</sub>,Ω)|<i>i=</i>1, 2<i>, . . . , G},</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
where, according to Bayes' rule,
</p>
<p id="p-0085" num="0084">
<maths id="MATH-US-00003" num="00003">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>Pr</mi>
    <mo>⁡</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mrow>
          <msub>
            <mi>C</mi>
            <mi>i</mi>
          </msub>
          <mo>|</mo>
          <msub>
            <mi>x</mi>
            <mi>j</mi>
          </msub>
        </mrow>
        <mo>,</mo>
        <mi>Ω</mi>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mfrac>
      <mrow>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>C</mi>
                <mi>i</mi>
              </msub>
              <mo>|</mo>
              <mi>Ω</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mrow>
                <msub>
                  <mi>x</mi>
                  <mi>j</mi>
                </msub>
                <mo>|</mo>
                <msub>
                  <mi>C</mi>
                  <mi>i</mi>
                </msub>
              </mrow>
              <mo>,</mo>
              <mi>Ω</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
      <mrow>
        <mi>Pr</mi>
        <mo>⁡</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mi>x</mi>
              <mi>j</mi>
            </msub>
            <mo>|</mo>
            <mi>Ω</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
Hence, given an optimized finite mixture model there is a natural way to classify points. The art in the use of a finite mixture model for classification lies in the optimization process itself.
</p>
<p id="p-0086" num="0085">A variety of methods for deriving an optimized (or trained) finite mixture model exist in the literature. A novel optimization method is described next, which incorporates multiple levels of expert knowledge from the classification problem domain.</p>
<p id="p-0087" num="0086">Finite Mixture Model Library and Initial Model Selection</p>
<p id="p-0088" num="0087">As it happens, different patient samples demonstrate the presence of different types of cellular populations. One of the most notable population differences can be observed in the neutrophil populations of canine cancer patients, where several veterinarians have noted a “left-shift” population. The “left-shift” neutrophil population has a significantly lower RAS position than in a normal patient (on the same instrument), but it also demonstrates a marked shape change in the RAS_Peak by EXT_Peak projection (as opposed to having no significant shape differences in the FSH_Peak by TOF projection). In order to accommodate these different types of populations, the classifying algorithm allows for a library of possible populations, which amounts to a list of different Gaussian density functions for each expected event population. Hence, in the “left-shift” classification problem, such a library would contain two distinct Gaussians for the neutrophil populations. And ideally, given a “left-shift” sample, the algorithm would recognize this sample condition and elect to start the finite mixture model optimization process with the appropriate neutrophil density function.</p>
<p id="p-0089" num="0088">Note that a grouping formed of a choice of one density function for each cell type (or expected data class) from the library, with a weighting assigned to each density function, constitutes a finite mixture model. For example, a library that contained two neutrophil, three monocyte, and four lymphocyte densities would effectively define 2*3*4=24 possible finite mixture models. Each combination of density parameters determines a different finite mixture model and is denoted by Ω<sub>k</sub>. Since model optimization tries to find the most appropriate parameters for the classification problem (given the observed data), starting with an Ω<sub>k </sub>closest to the eventual solution saves computational time and increases the odds of finding the right classification. This leads us to a finite mixture model selection problem, which from a Bayesian perspective is solved by choosing the parameters Ω<sub>k </sub>that yield the greatest</p>
<p id="p-0090" num="0089">
<maths id="MATH-US-00004" num="00004">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>Pr</mi>
    <mo>⁡</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <msub>
          <mi>Ω</mi>
          <mi>k</mi>
        </msub>
        <mo>|</mo>
        <mi>X</mi>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mfrac>
      <mrow>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <msub>
              <mi>Ω</mi>
              <mi>k</mi>
            </msub>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>X</mi>
              <mo>|</mo>
              <msub>
                <mi>Ω</mi>
                <mi>k</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
      <mrow>
        <mi>Pr</mi>
        <mo>⁡</mo>
        <mrow>
          <mo>(</mo>
          <mi>X</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
And while Pr(X) is unknown, it is constant for a given data set X. Also, assuming statistical independence between the observations in X, we can expand
</p>
<p id="p-0091" num="0090">
<maths id="MATH-US-00005" num="00005">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>Pr</mi>
    <mo>⁡</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mi>X</mi>
        <mo>|</mo>
        <msub>
          <mi>Ω</mi>
          <mi>k</mi>
        </msub>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <munder>
      <mo>∏</mo>
      <mrow>
        <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mrow>
          <mi>…</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.6em" height="0.6ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mi>N</mi>
        </mrow>
      </mrow>
    </munder>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mrow>
          <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mrow>
            <mi>…</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.6em" height="0.6ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>G</mi>
          </mrow>
        </mrow>
      </munder>
      <mo>⁢</mo>
      <mrow>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>C</mi>
                <mi>i</mi>
              </msub>
              <mo>|</mo>
              <msub>
                <mi>Ω</mi>
                <mi>k</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mrow>
          <mrow>
            <mi>Pr</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mrow>
                  <msub>
                    <mi>x</mi>
                    <mi>j</mi>
                  </msub>
                  <mo>|</mo>
                  <msub>
                    <mi>C</mi>
                    <mi>i</mi>
                  </msub>
                </mrow>
                <mo>,</mo>
                <msub>
                  <mi>Ω</mi>
                  <mi>k</mi>
                </msub>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>.</mo>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
Hence, given some expectations on the frequencies of each possible finite mixture model described by a finite mixture model library, one can identify the best candidate for an initial FMM by finding
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Ω=arg max{<i>Pr</i>(Ω<sub>k</sub>)<i>Pr</i>(<i>X|Ω</i><sub>k</sub>)|<i>k=</i>1, 2<i>, . . . , K}.</i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0092" num="0091">Data generated by different instruments within a fixed classification problem can also complicate the discrimination task. These differences can often be traced back to the manufacturing process for sensor standardization, and generally alter the locations and shapes of the populations being sought. Additionally, changes in the power output of the laser have the effect of moving populations in the seven-dimensional input space. While finite mixture model libraries could be constructed to accommodate these differences, and thereby allow one library specification for all machines, additional inventions are described herein that take advantage of the finite mixture model approach.</p>
<p id="p-0093" num="0092">Given any finite mixture model (and in practice one is probably best off choosing the most frequently used model from the library), one can assess how well the model fits that data set using</p>
<p id="p-0094" num="0093">
<maths id="MATH-US-00006" num="00006">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <mi>Pr</mi>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>X</mi>
          <mo>|</mo>
          <msub>
            <mi>Ω</mi>
            <mi>k</mi>
          </msub>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <munder>
        <mo>∏</mo>
        <mrow>
          <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mrow>
            <mi>…</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.6em" height="0.6ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>N</mi>
          </mrow>
        </mrow>
      </munder>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
      <mo>⁢</mo>
      <mrow>
        <munder>
          <mo>∑</mo>
          <mrow>
            <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mo>,</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <mi>…</mi>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.6em" height="0.6ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mi>G</mi>
            </mrow>
          </mrow>
        </munder>
        <mo>⁢</mo>
        <mrow>
          <mrow>
            <mi>Pr</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <msub>
                  <mi>C</mi>
                  <mi>i</mi>
                </msub>
                <mo>|</mo>
                <msub>
                  <mi>Ω</mi>
                  <mi>k</mi>
                </msub>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>⁢</mo>
          <mrow>
            <mi>Pr</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mrow>
                  <msub>
                    <mi>x</mi>
                    <mi>j</mi>
                  </msub>
                  <mo>|</mo>
                  <msub>
                    <mi>C</mi>
                    <mi>i</mi>
                  </msub>
                </mrow>
                <mo>,</mo>
                <msub>
                  <mi>Ω</mi>
                  <mi>k</mi>
                </msub>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
(or the negative log of this quantity). Fixing the finite mixture model Ω<sub>k </sub>we have found it advantageous to maximize
</p>
<p id="p-0095" num="0094">
<maths id="MATH-US-00007" num="00007">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>Pr</mi>
    <mo>⁡</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mrow>
          <mi>X</mi>
          <mo>⊗</mo>
          <mi>s</mi>
        </mrow>
        <mo>|</mo>
        <msub>
          <mi>Ω</mi>
          <mi>k</mi>
        </msub>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <munder>
      <mo>∏</mo>
      <mrow>
        <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mrow>
          <mi>…</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.6em" height="0.6ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mi>N</mi>
        </mrow>
      </mrow>
    </munder>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mrow>
          <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mrow>
            <mi>…</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.6em" height="0.6ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>G</mi>
          </mrow>
        </mrow>
      </munder>
      <mo>⁢</mo>
      <mrow>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>C</mi>
                <mi>i</mi>
              </msub>
              <mo>|</mo>
              <msub>
                <mi>Ω</mi>
                <mi>k</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mrow>
                <mrow>
                  <msub>
                    <mi>x</mi>
                    <mi>j</mi>
                  </msub>
                  <mo>⁢</mo>
                  <mi>s</mi>
                </mrow>
                <mo>|</mo>
                <msub>
                  <mi>C</mi>
                  <mi>i</mi>
                </msub>
              </mrow>
              <mo>,</mo>
              <msub>
                <mi>Ω</mi>
                <mi>k</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
with respect to the M×1 real-valued vector s (M=number of input channels). This maximization is referred to herein as the scaling factor search process <b>104</b> in the pre-optimization step (<figref idref="DRAWINGS">FIG. 3</figref>, <b>104</b>) since the resulting vector s<sup>t</sup>=(s<sub>1</sub>, s<sub>2</sub>, . . . , s<sub>M</sub>) expands or contracts the i<sup>th </sup>input coordinate by s<sub>i</sub>. Many different search algorithms could be employed to find the desired scaling factor, and in the presently preferred implementation, once found, the finite mixture model selection criteria described above has been employed. This added pre-optimization step greatly reduces the required library's complexity and additionally reduces the classification algorithm's execution time.
</p>
<p id="p-0096" num="0095">Expert Knowledge Set <b>42</b></p>
<p id="p-0097" num="0096">As noted above, the systems and methods of this disclosure use what is referred to herein as an expert knowledge set. This set consists of two sub elements: a collection of expert data transforms, and a collection of expert rules which may take the form of logical statements or logical operations. As the name implies, expert data transforms are mathematical functions that alter data in some fashion. From the mathematical perspective, the data collected by the analytical instrument can be thought of as a list of length N of seven dimensional vectors, where N is the number of digitized events. But one could just as well consider this data set as seven N-dimensional vectors, one vector for each input channel. The expert transformations act on these N-dimensional vectors, and output any number of similar vectors. The outputs can be thought of as derived coordinates since each observation has a value in each output. Such expert transforms come in several varieties, including geometrical, and probabilistic transforms, as will be explained below.</p>
<p id="p-0098" num="0097">A presently preferred implementation allows expert transform outputs to serve as inputs to any other transform. Moreover, once created, transform output vectors can be referenced by name and may be combined into other transforms (as inputs) or rule constructions (described below) without regard to their originating transform. This flexibility thereby allows any combination of hierarchies of inputs and data transformations to be used.</p>
<p id="p-0099" num="0098">On first glance the ability to transform the data does not appear to be a very powerful tool. In fact it would appear that these manipulations only serve to complicate the problem by adding any number of new coordinates above and beyond the original seven collection channels. While this is true, they benefit us by allowing an expert to modify the “presentation” of the data to the classification algorithm, thereby emphasizing known aspects of the populations sought.</p>
<p id="p-0100" num="0099">A domain expert's knowledge is encoded in what is referred to herein as “expert rules” (<figref idref="DRAWINGS">FIG. 2</figref>, item <b>44</b>). Each rule contains two essential elements: a logical statement on the transform output vectors, and a list of population effects. The logical statement takes the form of a list of transform outputs together with an inequality for each (e.g. &lt;=0 or &gt;0). Such a list defines a subset of data points (possibly empty) that satisfies all inequalities on the list. We'll call this subset the rule's “true domain,” and its complement (points on which at least one of the logical statements is false), the rule's “false domain.”</p>
<p id="p-0101" num="0100">A rule's population effects consist of a list of population names (classes) and a weighting or posterior probability adjustment scalar for each. A rule is “applied” by multiplying those rows of the hidden data (Pr(C<sub>i</sub>|x<sub>j</sub>,Ω)) corresponding to data points in the rule's true domain and those columns defined by the populations in the rule's list of effected populations by the adjustment scalar.</p>
<p id="p-0102" num="0101">Hence, for example, a rule that combines three expert data transforms to define a region in which neutrophils are expected to be plentiful would probably increase the odds of finding neutrophils in the True domain while decreasing the odds of finding a non-neutrophil event. And in the complementary region it would reduce the odds of finding neutrophils. Because the hidden data (Pr(C<sub>i</sub>|x<sub>j</sub>,Ω)) plays a critical role in the model optimization mathematics, the expert rules are able to guide the classifying algorithm towards a preferred classification using simple logical statements, typically defined relative to the algorithm's best current estimate of population locations.</p>
<p id="p-0103" num="0102">Identification Method/Program Code <b>50</b></p>
<p id="p-0104" num="0103">Now that the finite mixture model and expert rules concepts have been described in more detail, this disclosure will proceed to describe a process or method by which these elements are combined and used in conjunction with a multi-dimensional data set to generate an event classification (i.e. identify populations). The process described subsequently is preferably coded in software and run on the analytical instrument or the data processing unit of <figref idref="DRAWINGS">FIG. 1</figref>. Pseudo-code for a main processing loop and main subroutines is set forth later, as are data structures that are used by the code.</p>
<p id="p-0105" num="0104">The computational process described below is fundamentally a maximization process. In particular, the process seeks the assignment of events in the multi-dimensional data to each Gaussian density in such a way as to yield the highest overall probability that the semi-parametric finite mixture model generated the data. As is common with these types of computations, they can find sub optimal solutions (local minima) and get struck there. The machine learning literature contains many heuristics that address this problem. The present solution avoids such problems by using an unsupervised clustering algorithm modified to include input in the form of expert knowledge, coded as expert transformations and rules, as will be explained now in detail.</p>
<p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart showing, in conceptual form, the major processing steps embodied in the program code to identify populations in the a multidimensional data set <b>52</b> obtained from an analytical instrument, e.g., flow cytometer of <figref idref="DRAWINGS">FIG. 1</figref>. The code operates on a data set obtained by processing a sample in the instrument and collecting, digitizing and storing the multidimensional data, indicated at <b>102</b>. The program code <b>100</b> includes a pre-optimization module <b>104</b>. This module does two operations: 1) applies a linear scaling factor to the data collected at step <b>102</b> and 2) selects a finite mixture model from the library in the manner described above. The model optimization module <b>106</b> iteratively <b>106</b>D performs three operations: (1) an expectation operation on at least a subset of the multi-dimensional data set (commonly referred to as the Expectation step in the Expectation-Maximization Algorithm literature) <b>106</b>A, (2) an application of the expert knowledge set to data resulting from the expectation operation <b>106</b>B, and (3) a maximization operation updating parameters associated with the density function of the selected finite mixture model <b>106</b>C.</p>
<p id="p-0107" num="0106">Still referring to <figref idref="DRAWINGS">FIG. 3</figref>, the event classification module <b>108</b> of <figref idref="DRAWINGS">FIG. 3</figref> is responsive to the output of the optimization module (i.e., a final expectation operation) and performs a classifying of the multi-dimensional data set into one or more populations. This module codes the operation:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Class(<i>x</i><sub>j</sub>)=arg max{<i>Pr</i>(<i>C</i><sub>i</sub><i>|x</i><sub>j</sub>,Ω)|<i>i=</i>1, 2<i>, . . . , G</i>} discussed above.<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0108" num="0107">The program code optionally includes a post-classification module <b>110</b> which modifies the classification of the multidimensional data set using one or more expert rules from the expert knowledge set. The program code further includes a module <b>112</b> returning results to the operator, e.g., by displaying the data on a monitor with color coding to indicate how the data was classified, providing quantitative results as to the classification, or other output method, such as storing the classification data in a file and making it available either locally or remotely to an operator or customer.</p>
<p id="p-0109" num="0108"><figref idref="DRAWINGS">FIG. 4</figref> is an illustration showing, in simplified form, the operations performed by the modules in the flow chart of <figref idref="DRAWINGS">FIG. 3</figref>. The input data set <b>52</b> consists of multi-dimensional data, which can be represented as projections in two dimensions by plotting data values in a coordinate system with the X and Y axes being two channels selected in the seven available channels. Such data exists in raw form. The pre-optimization module <b>104</b> takes the data points and multiplies their values by a scalar in seven dimensions to thereby calculate a scaled data set <b>52</b>′. Following completion of the scale factor search, a finite mixture model <b>40</b> is selected from the library of models. The model <b>40</b> consists of a set of weighted probability density functions, each of which are shown by the ellipses <b>40</b>. Each ellipse (probability density function) is associated with an expected population in the data set, e.g., the ellipse with the letter N represents the neutrophils probability density function, the ellipse with the letter E represents the eosinophil probability density function, M represents monocytes, etc. Such probability density functions are defined on all seven dimensional vectors, so the ellipses shown in <figref idref="DRAWINGS">FIG. 4</figref> should only be interpreted as two dimensional representations of these higher dimensional density functions (perhaps suggestive of the density function's ninetieth percentile in the chosen two dimensional projection).</p>
<p id="p-0110" num="0109">As mentioned previously, the model optimization module <b>106</b> consists of three separate sub-steps: expectation <b>106</b>A, application of expert rules <b>106</b>B, and maximization <b>106</b>C, performed in an iterative manner indicated by the arrow <b>106</b>D. The expectation step <b>106</b>A computes the “hidden data”, which estimates the posterior probability of each event given the current estimates for each class density function. The expert knowledge set module <b>106</b>B transforms the data set and uses logical statements to identify interesting subsets of the data set on which adjustments are made to the probability values assigned in the expectation step <b>106</b>A. The maximization step <b>106</b>C modifies the parameters in the finite mixture model (the mean vector and covariance matrix defining the probability density function), essentially changing the shape of the model using the hidden data and the results from the application of the expert knowledge set in step <b>106</b>B. The process loops back and modules <b>106</b>A, <b>106</b>B and <b>106</b>C repeat if necessary until a maximization criteria (fit between the finite mixture model and scaled data set) is met. At step <b>108</b>, the classification module executes and the individual events in the data set are classified as being a member of a single population, e.g., eosinophil, monocyte, basophil, neutrophil, etc. Post-classification adjustments, if necessary, are performed at this stage. <figref idref="DRAWINGS">FIG. 4</figref> also shows the effects of the output results module <b>112</b>, e.g., the data is presented as a two-dimensional plot with the data points color coded to show their membership in discrete populations <b>109</b>. The output results module may also give absolute numbers or percentages, such as the percent of the events being in each population, the total number of events in each population, the concentration of a population, e.g., number of neutrophils per liter of blood, or in any other appropriate form.</p>
<p id="p-0111" num="0110">The modules <b>104</b>, <b>106</b> and <b>108</b> of <figref idref="DRAWINGS">FIGS. 3 and 4</figref> will now be described in further detail.</p>
<p id="p-0112" num="0111">A. Pre-Optimization <b>104</b> (<figref idref="DRAWINGS">FIGS. 3</figref>, <b>4</b>, <b>5</b>, <b>6</b>)</p>
<p id="p-0113" num="0112">The pre-optimization module <b>104</b> starts by accessing the multi-dimensional data <b>52</b> and a library of finite mixture models <b>40</b>, shown in <figref idref="DRAWINGS">FIG. 5</figref>. The data <b>52</b> is represented schematically as a two dimensional plot as is customary in this art. The library of finite mixture models <b>40</b> includes seven dimensional weighted Gaussian probability density functions, one for each expected population in the data set <b>52</b>. More than one probability density function may exist for each population. The library in this example consists of two lymphocyte density functions <b>40</b>A and <b>40</b>B, two monocytes density functions <b>40</b>C and <b>40</b>D, one eosinophils density function <b>40</b>E, and three neutrophil density functions <b>40</b>F, <b>40</b>G and <b>40</b>H.</p>
<p id="p-0114" num="0113">The pre-optimization module <b>104</b> step has several functions: A first function is to find scalars s<b>1</b>, . . . s<b>7</b> such that s<b>1</b>*X<b>1</b>, s<b>2</b>*X<b>2</b>, . . . s<b>7</b>*X<b>7</b> has the highest probability of being generated from at least one FMM combination from the library. X<b>1</b>, . . . , X<b>7</b> are a N×1 vector of the multi-dimensional data, where N is the number of events and 1 . . . 7 index the seven channels. The second pre-optimization function is to record the finite mixture model (set of individual density functions <b>40</b>) that yield the highest total probability. This finite mixture model serves as an initial guess for the optimized model's parameters, and will be used in the subsequent processing. Both of these functions were described previously in the discussion concerning the selection of an initial finite mixture model from the library. A third pre-optimization function is to remove data associated with control particles in the sample from the data set so as to avoid assigning a control particle to one of the expected populations in the data set, and to reduce calculation time.</p>
<p id="p-0115" num="0114">The result of the operation of the pre-optimization module is scaled data and initial finite mixture model parameters. This is shown in <figref idref="DRAWINGS">FIG. 6</figref>. Comparing <figref idref="DRAWINGS">FIG. 6</figref> with <figref idref="DRAWINGS">FIG. 5</figref>, it can be seen that the data set is extended out away from the origin (as a result of application of the scaling operation), and a subset of all the probability density functions in the library has been elected—one density function for lymphocytes <b>40</b>B, one <b>40</b>D for monocytes, one <b>40</b>E for eosinophils, and one <b>40</b>G for neutrophil, collectively forming a finite mixture model. The point cloud <b>53</b> represents non-white blood cells and there is no probability density function used for this population. The point cloud <b>55</b> represents control particles and this data is removed from the data set, as indicated by the X.</p>
<p id="p-0116" num="0115">The rationale for the pre-processing step is that one needs to find reasonable starting conditions (parameters) for the finite mixture model, and remove the control particles from the data passed to the later steps. Machine-to-machine standardization differences complicate the general classification problem (this is primarily the result of historical standardization practices and the fact that previous classifying algorithms used a reduced dataset). The primary source of machine-to-machine standardization differences can be traced back to the channel gains used during the digitized data collection process. These gains are set during the manufacturing process and have been observed to vary over the product manufacturing cycle. Generally speaking, the manufacturing standardization process adjusts the gains so as to position the control particle's centroid position at a specific location in a subset of the seven collection channels, while placing loose specifications for those not used by the current white blood cell classification algorithm. These adjustments are judged acceptable by a human observer who has access to the scatter plots and the classifying algorithm's performance. This disclosure replaces this human observer with a mathematical function, one that assesses algorithm performance (or potential performance). Instead of altering the electronic gains (as the manufacturing technician would), the algorithm uses seven scalar multipliers (one for each input channel) to move the data in space so as to maximize the likelihood the data arose from a specified model in the library of all possible finite mixture model combinations.</p>
<p id="p-0117" num="0116">Since the flow cytometer (e.g. the LASERCYTE) generates seven-dimensional datasets, there will be seven scaling factors. These factors are generally expected to be around 1.0, but have been seen to vary from 0.5 to 2.0 for some machines.</p>
<p id="p-0118" num="0117">B. Model Optimization <b>106</b> (<b>106</b>A, <b>106</b>B and <b>106</b>C, <figref idref="DRAWINGS">FIGS. 3</figref>, <b>4</b>, <b>7</b>-<b>11</b>)</p>
<p id="p-0119" num="0118">The model optimization module <b>106</b>, and specifically sub-steps <b>106</b>A, <b>106</b>B and <b>106</b>C of <figref idref="DRAWINGS">FIGS. 3 and 4</figref> will now be discussed in conjunction with <figref idref="DRAWINGS">FIGS. 7-11</figref>.</p>
<p id="p-0120" num="0119">Conceptually, the model optimization module <b>106</b> seeks to adjust the parameters of the initial finite mixture model (<figref idref="DRAWINGS">FIG. 6</figref>, probability density functions <b>40</b>B, <b>40</b>D, <b>40</b>E, <b>40</b>G) so as to best accommodate (model) the data being classified. This step consists of three steps performed iteratively. These are an expectation step <b>106</b>A (<figref idref="DRAWINGS">FIGS. 7</figref> and <b>8</b>), an expert knowledge set application step <b>106</b>B (transformations and logical operations) (<figref idref="DRAWINGS">FIGS. 9 and 10</figref>), and a maximization step <b>106</b>C (<figref idref="DRAWINGS">FIG. 11</figref>). Because we adjust (or bias) the hidden data in this optimization process, it differs from those found in the general Expectation-Maximization algorithm (Dempster et al., 1967). Before going through each of these individually, a few general comments are offered initially.</p>
<p id="p-0121" num="0120">Because the goal at this stage of the computation is to estimate the best parameters for the finite mixture model (given the initial model parameters, the scaling adjustments, and any applied Expert Rules), it is possible to operate on a subset of the entire collected data set (see SubsetSize parameter in MVN_Collection definition described below). Hence the developer has the option of specifying an optimization dataset size and the algorithm will randomly select (uniformly distributed across all events) a subset on which to optimize. Some of the advantages of sub-sampling for optimization include: reduced influence of rare noise in convergence, and speed. However, the first advantage also plays against us because rare populations may not be sufficiently well represented in order for the model to find them.</p>
<p id="p-0122" num="0121">One way to increase the chances of finding rare populations, and one that is uniquely available because of the use of a finite mixture model, is to add pseudo rare population events to the dataset based on the density function selected in the initial model search process. This is enabled via a list of populations from which to simulate data and simulation parameters that determine the number of pseudo-events to create and any modifications to the densities themselves, e.g. shrunken covariance (see MVNEMSimulateEvents parameters in the MVN_Collection definition). These events are appended to the random subset of events used for optimization, and are removed before the final event classification step in which all events (not just the optimization subset) are classified.</p>
<p id="p-0123" num="0122">Step 1. Expectation (E) (<b>106</b>A, <figref idref="DRAWINGS">FIGS. 7 and 8</figref>)</p>
<p id="p-0124" num="0123">The (s+1)<sup>st </sup>iteration of the Expectation step <b>106</b> in the optimization module <b>106</b> computes an array of numbers (numEvents×numModelComponents) that the literature often refers to as the hidden data. Specifically, this data is related to the probability that an event arose from each of the different density functions in the finite mixture model. We will denote an entry in this array by Pr(C<sub>i</sub>|x<sub>j</sub>,Ω<sup>(s+1)</sup>) (or z<sub>ij</sub><sup>(s+1) </sup>as is common in the literature) where</p>
<p id="p-0125" num="0124">
<maths id="MATH-US-00008" num="00008">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msubsup>
          <mi>z</mi>
          <mi>ij</mi>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>s</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
            <mo>)</mo>
          </mrow>
        </msubsup>
        <mo>=</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mrow>
                <msub>
                  <mi>C</mi>
                  <mi>i</mi>
                </msub>
                <mo>|</mo>
                <msub>
                  <mi>x</mi>
                  <mi>j</mi>
                </msub>
              </mrow>
              <mo>,</mo>
              <msup>
                <mi>Ω</mi>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>s</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </msup>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <mrow>
              <mi>Pr</mi>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <msub>
                    <mi>C</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>|</mo>
                  <msup>
                    <mi>Ω</mi>
                    <mrow>
                      <mo>(</mo>
                      <mi>s</mi>
                      <mo>)</mo>
                    </mrow>
                  </msup>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>⁢</mo>
            <mrow>
              <mi>Pr</mi>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>x</mi>
                      <mi>j</mi>
                    </msub>
                    <mo>|</mo>
                    <msub>
                      <mi>C</mi>
                      <mi>i</mi>
                    </msub>
                  </mrow>
                  <mo>,</mo>
                  <msup>
                    <mi>Ω</mi>
                    <mrow>
                      <mo>(</mo>
                      <mi>s</mi>
                      <mo>)</mo>
                    </mrow>
                  </msup>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
          <mrow>
            <mi>Pr</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>x</mi>
                <mo>|</mo>
                <msup>
                  <mi>Ω</mi>
                  <mrow>
                    <mo>(</mo>
                    <mi>s</mi>
                    <mo>)</mo>
                  </mrow>
                </msup>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mo>=</mo>
          <mfrac>
            <mrow>
              <mrow>
                <mi>Pr</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <msub>
                      <mi>C</mi>
                      <mi>i</mi>
                    </msub>
                    <mo>|</mo>
                    <msup>
                      <mi>Ω</mi>
                      <mrow>
                        <mo>(</mo>
                        <mi>s</mi>
                        <mo>)</mo>
                      </mrow>
                    </msup>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>⁢</mo>
              <mrow>
                <mi>Pr</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mrow>
                      <msub>
                        <mi>x</mi>
                        <mi>j</mi>
                      </msub>
                      <mo>|</mo>
                      <msub>
                        <mi>C</mi>
                        <mi>i</mi>
                      </msub>
                    </mrow>
                    <mo>,</mo>
                    <msup>
                      <mi>Ω</mi>
                      <mrow>
                        <mo>(</mo>
                        <mi>s</mi>
                        <mo>)</mo>
                      </mrow>
                    </msup>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mrow>
              <munder>
                <mo>∑</mo>
                <mrow>
                  <mrow>
                    <mi>m</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mo>,</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mi>…</mi>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.6em" height="0.6ex"/>
                  </mstyle>
                  <mo>,</mo>
                  <mi>G</mi>
                </mrow>
              </munder>
              <mo>⁢</mo>
              <mrow>
                <mrow>
                  <mi>Pr</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <msub>
                        <mi>C</mi>
                        <mi>m</mi>
                      </msub>
                      <mo>|</mo>
                      <msup>
                        <mi>Ω</mi>
                        <mrow>
                          <mo>(</mo>
                          <mi>s</mi>
                          <mo>)</mo>
                        </mrow>
                      </msup>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>⁢</mo>
                <mrow>
                  <mi>Pr</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mrow>
                        <msub>
                          <mi>x</mi>
                          <mi>j</mi>
                        </msub>
                        <mo>|</mo>
                        <msub>
                          <mi>C</mi>
                          <mi>m</mi>
                        </msub>
                      </mrow>
                      <mo>,</mo>
                      <msup>
                        <mi>Ω</mi>
                        <mrow>
                          <mo>(</mo>
                          <mi>s</mi>
                          <mo>)</mo>
                        </mrow>
                      </msup>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mfrac>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
is computed based on the previous iteration's values for the mixing coefficients Pr(C<sub>i</sub>|Ω<sup>(s)</sup>), and the density function's parameters Ω<sup>(s)</sup>. This hidden data is core to both the EM algorithm (see algorithm details below) and the Expert Rules (which adjusts these values preferentially based on expert knowledge about the interdependencies between the sought after event populations).
</p>
<p id="p-0126" num="0125">The expectation step is conceptually illustrated in <figref idref="DRAWINGS">FIGS. 7 and 8</figref>. <figref idref="DRAWINGS">FIG. 7</figref> shows the scaled data set <b>52</b>′ and points <b>53</b>A-<b>53</b>E each representing an event in the multi-dimensional data. For each point in the multi-dimensional data, the module <b>106</b>A computes a probability, based on the values of event data and the parameters of the probability density functions in the mixture model, that that event is a member of each of the classes represented by the Gaussian probability density functions <b>40</b>B, <b>40</b>D, <b>40</b>E and <b>40</b>G forming the finite mixture model. Such probability values (array of numbers) are the “hidden data” and is stored in the memory of the processing unit.</p>
<p id="p-0127" num="0126"><figref idref="DRAWINGS">FIG. 8</figref> shows in graphic form the so-called hidden data as a probability assignment indicated by square on a probability axis. Each event data point <b>53</b>A-E is shown as having a probability axis <b>60</b>, and the position of the square <b>62</b> on the axis <b>60</b> indicates relative probability (a value between 0 and 1). In the left half of <figref idref="DRAWINGS">FIG. 8</figref>, the location of the square <b>60</b> on the probability axis <b>62</b> indicates the probability that the given data point is a member of the neutrophil (“N”) class <b>40</b>G Point <b>53</b>A is located close to the center of the ellipse <b>40</b>G, so it has a high probability, as indicated by the position of the square <b>62</b> close to the left hand edge of the axis towards a probability of “1”. Conversely, point <b>53</b>E is farther from the center of the neutrophil probability distribution <b>40</b>G, and hence has a probability value closer to 0 on the probability axis <b>60</b>. The right hand side of this figure shows the same assignment of probability, but this time for the monocyte probability density <b>40</b>D. Point <b>53</b>D is relatively close to the center of the monocytes probability density <b>40</b>D and so has a square <b>62</b> positioned close to the “1” end of the probability axis <b>60</b>, indicating that a high probability is assigned to this event.</p>
<p id="p-0128" num="0127">Such assignments as shown in <figref idref="DRAWINGS">FIG. 8</figref> are made for all events (or a subset of events in an alternative embodiment), and for all probability distributions in the finite mixture model.</p>
<p id="p-0129" num="0128">Step 2. Application of Expert Knowledge Set (<b>106</b>B, <figref idref="DRAWINGS">FIGS. 4</figref>, <b>9</b> and <b>10</b>)</p>
<p id="p-0130" num="0129">The module <b>106</b>B (<figref idref="DRAWINGS">FIG. 4</figref>) of the optimization module provides for the application of the expert knowledge set to the hidden data and specifically provides for transformation operations and application of logical statements (“expert rules”) on the hidden data resulting from the expectation process. The expert transformation operations can consist of geometrical operations (e.g. polar angle and radial distance transformations) or probability operations such as a Mahalanbois Distance transformation based on specific populations (classes) in the finite mixture model.</p>
<p id="p-0131" num="0130">An example of a geometrical transformation will be described first. Select two channels from the original seven channels, say RAS_Peak and EXT_Peak, and suppose for this example that there are 10,000 events in a given sample. Since each of the 10,000 data points has a RAS_Peak and EXT_Peak coordinate, we can compute the polar coordinates (relative to RAS_Peak and EXT_Peak) and output both the angle made between each point and the RAS_Peak axis (for example) and the distance of that point from the origin. In the language of the expert data transform, the input vectors here are the RAS_Peak vector and the EXT_Peak vector, each of length 10,000, while the outputs would be two new vectors, say RAS_Peak×EXT_Peak PolarAngle and RAS_Peak×EXT_Peak RadialDistance, each also of length 10,000—one pair for each event in the digitized dataset. While this example has two input and two output vectors there is no limit to the number of inputs or outputs, nor any constraint that there be an equal number of inputs and outputs. In fact many transforms have multiple inputs and only one output vector.</p>
<p id="p-0132" num="0131">In addition to transforming data a transform must select a special point in each of its the output vectors, namely the zero point. These zero points define logical conditionals on the event data set, specifically, an event is either greater than or equal to zero or it is less than zero. Formally, if there are M*&gt;M possible transform outputs, the choice of a zero point in any one output corresponds to an (M*−1)-dimensional hyper plane in M* dimensional space. The choice of a zero point corresponds to an affine codimension one hyper plane and a test for &lt;=0 or &gt;0 selects one side of each hyper plane.</p>
<p id="p-0133" num="0132">The following example of <figref idref="DRAWINGS">FIGS. 9 and 10</figref> is offered to illustrate conceptually this process for one such expert rule. Each bold line <b>70</b>A and <b>70</b>B in <figref idref="DRAWINGS">FIGS. 9 and 10</figref> corresponds to the zero hyper plane for one transform. In this case, both level sets <b>70</b>A and <b>70</b>B represent polar angle transforms where the difference between these two sets lies in the choice of specific zeros (angles). Zero hyper plane <b>70</b>A is chosen to separate the neutrophils <b>40</b>G and eosinophils <b>40</b>E from the monocytes <b>40</b>D, while <b>70</b>B places its zero so as to separate monocytes <b>40</b>D and eosinophils <b>40</b>E from the neutrophils <b>40</b>G.</p>
<p id="p-0134" num="0133">Alternative transforms may move the zero point in the collected data channels to the expected location of the neutrophil centroid <b>40</b>G. Or, one may prefer to center the data at a point two standard deviations from the neutrophil centroid in RAS_Peak channel so that an event greater than zero has less than a 95% chance of being a neutrophil. For either of these outputs, we can assign a logical true/false value to each event in the input dataset according to whether it is above or below zero. In this fashion, an output vector implies a logical statement about each event in the dataset.</p>
<p id="p-0135" num="0134">The Expert Rule application operates on the hidden data values estimated during the previous E-step, taking into account the zero point transformations just performed. Recall that each rule is constructed by the conjunction of a finite list of logical statements on the events (in this case those events selected for model optimization) that defines a True and False domain for that rule together with a list of population classes and associated weighting factors for each domain. The True and False domains correspond to two subsets of rows in the hidden data array, those rows associated with events falling into the True domain and its complimentary set of rows respectively. The population lists associated with these domains identify columns in the hidden data array, and the expert provided weights tell us how to modify (by multiplication) the hidden data for each column and subset of rows.</p>
<p id="p-0136" num="0135">Formally, each expert rule is defined as a pairing (L,E) where L=((l<sub>s</sub>,b<sub>s</sub>):s=1, . . . , S) is a collection of pairs of (M*−1) dimensional hyper planes l<sub>s </sub>within the space of the input channels and the expert transform outputs (dimension=M*) and sidedness indicators b<sub>s</sub>, and E=(e<sub>t</sub>=(P<sub>t</sub>, w<sub>t</sub>):t=1, . . . , T) is a collection of pairs of expected population identifiers P<sub>t </sub>(e.g. class names or finite mixture model component indices) and scalar values w<sub>t</sub>. Note that a (M*−1) dimensional hyper plane is defined by one of the transform outputs where the sidedness indicator takes the form of a simple inequality. Hence there is a one-to-one correspondence between each (l<sub>s</sub>, b<sub>s</sub>) pairing and a specific transform output and designated zero point in that output coordinate. For lack of a better notation, the rule can be stated as follows:</p>
<p id="p-0137" num="0136">
<maths id="MATH-US-00009" num="00009">
<math overflow="scroll">
<mrow>
  <mrow>
    <msub>
      <mi>l</mi>
      <mi>s</mi>
    </msub>
    <mo>⁡</mo>
    <mrow>
      <mo>(</mo>
      <msub>
        <mi>x</mi>
        <mi>j</mi>
      </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mo>{</mo>
    <mtable>
      <mtr>
        <mtd>
          <mrow>
            <mi>true</mi>
            <mo>,</mo>
          </mrow>
        </mtd>
        <mtd>
          <mrow>
            <mrow>
              <mi>if</mi>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.8em" height="0.8ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mrow>
                <msub>
                  <mi>l</mi>
                  <mi>s</mi>
                </msub>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>x</mi>
                    <mi>j</mi>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>≤</mo>
            <msub>
              <mi>b</mi>
              <mi>s</mi>
            </msub>
          </mrow>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mrow>
            <mi>false</mi>
            <mo>,</mo>
          </mrow>
        </mtd>
        <mtd>
          <mi>otherwise</mi>
        </mtd>
      </mtr>
    </mtable>
  </mrow>
</mrow>
</math>
</maths>
<br/>
To apply this rule, first define R(X) to be the set of data points lying on the designated side of all hyper planes in L as follows
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i>(<i>X</i>)={<i>x</i><sub>j</sub><i>|l</i><sub>s</sub>(<i>x</i><sub>j</sub>)=true, <i>s=</i>1<i>, . . . , S},</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
which is a subset of the data set X and corresponds to what we've called the rule R's true domain. And given this notation, rule R's effects on the hidden data is Pr(C<sub>i</sub>|x<sub>j</sub>,Ω)=w<sub>i</sub>*Pr(C<sub>i</sub>|x<sub>j</sub>,Ω) for any x<sub>j </sub>in R(X) and each i in {P<sub>l</sub>: t=1, . . . , T}. The factors w<sub>i </sub>are probability weighting factors.
</p>
<p id="p-0138" num="0137">The right hand side of <figref idref="DRAWINGS">FIG. 9</figref> depicts conceptually the effects of the weighting factors w<sub>i </sub>on the neutrophil column of the hidden data. The “true domain” is determined as those points (events) having a value that is above the zero vector <b>70</b>A the neutrophil expert rule AND below the zero vector <b>70</b>B. Point <b>53</b>A satisfies this criteria, and so its probability value (location of square <b>62</b> on the probability axis <b>60</b>), is increased, as can be seen by a comparison between the left hand side of <figref idref="DRAWINGS">FIG. 9</figref> with the right hand side of <figref idref="DRAWINGS">FIG. 9</figref> for this point. All of the other data points <b>53</b> shown in <figref idref="DRAWINGS">FIG. 9</figref> do not satisfy this criteria, and so their probability assignments (represented by the position of the squares <b>62</b> on the probability axes <b>60</b>) are lowered, as indicated by the movement of the squares towards the zero end of the probability axes <b>60</b> (compare left side of <figref idref="DRAWINGS">FIG. 9</figref> to right side of <figref idref="DRAWINGS">FIG. 9</figref>).</p>
<p id="p-0139" num="0138">These expert rules <b>44</b> are shown in <figref idref="DRAWINGS">FIG. 9</figref> has having two separate components: a rules component comprising logical statements <b>44</b>A and actions <b>44</b>B operating on the probability values assigned to the events in the hidden data, namely one action increasing the probability of an event being a neutrophil if the rules <b>44</b>A are satisfied and decreasing the probability of an event belonging to the neutrophil population if the rules are not satisfied. Three logical statements <b>44</b>A are shown, the first two of which define the zero point hyper planes shown as vectors <b>70</b>A and <b>70</b>B and a third statement (&gt;R<b>7</b>+3TOF SD) defining a third hyper plane, the two dimensional projection of which is not shown in order to avoid cluttering <figref idref="DRAWINGS">FIG. 9</figref>. The third vector (not shown) could be considered as defining the third side of the triangle <b>74</b> representing a region in seven dimensional space defined by the rules <b>44</b>A. In the nomenclature of the rules <b>44</b>A of <figref idref="DRAWINGS">FIG. 9</figref>, SD represents “standard deviation”, and the three rules define the three zero point planes described above and, by implication, the true and false domains depending on where a given event lies relative to the union or intersection of such planes.</p>
<p id="p-0140" num="0139"><figref idref="DRAWINGS">FIG. 9</figref> shows the application of the expert transformations and rules for one population Gaussian density distribution, namely density <b>40</b>G. <figref idref="DRAWINGS">FIG. 10</figref> shows that the operation described above can be applied for more than one probability density (or class) in the mixture model. In particular, <figref idref="DRAWINGS">FIG. 10</figref> shows that each point (event) <b>53</b> has two probability values assigned to it, again represented by the position of a square <b>62</b> on a probability axis <b>60</b>. The second probability axis in <figref idref="DRAWINGS">FIG. 10</figref> is the probability that the event is associated with the monocytes class <b>40</b>D in the mixture model. Take for example point <b>53</b>D. Axis <b>60</b>A represents the probability axis for the event <b>53</b>D belonging to the neutrophil population. Axis <b>60</b>B represents the probability that the event <b>53</b>E belongs to the monocyte population. Comparing the left hand side of <figref idref="DRAWINGS">FIG. 10</figref> with the right hand side of <figref idref="DRAWINGS">FIG. 10</figref>, the square <b>62</b>B is moved closer to the “1” end of the probability axis <b>60</b>B due to the position of the event <b>53</b> relative to the zero hyper planes <b>70</b>A and <b>70</b>B—above vector <b>70</b>B but below vector <b>70</b>A (i.e., in the false domain for the neutrophil expert rule). Similarly, the square <b>62</b>B for point <b>53</b>E is moved towards the “1” end of the probability axis <b>60</b>B due to its position relative to the zero hyper planes. These actions are represented by the actions aspect <b>44</b>B of the expert rules. Specifically, these actions modify probability assignments represented by the hidden data matrix.</p>
<p id="p-0141" num="0140">These operations are performed for all points in the event data set and for all components of the mixture model. Moreover, the program code may specify any number of these rules and transforms as needed for the classification problem at hand.</p>
<p id="p-0142" num="0141">Step 3. Maximization (M) (<b>106</b>C, <figref idref="DRAWINGS">FIGS. 4</figref>, <b>11</b>)</p>
<p id="p-0143" num="0142">The Maximization step of the EM algorithm updates each density function's parameters and the mixing coefficients based on the hidden data, as modified by the application of the expert rules module <b>106</b>C. This operation is represented schematically in <figref idref="DRAWINGS">FIG. 11</figref> by moving, and changing the shapes, of each of the probability density functions <b>40</b>B, <b>40</b>D, <b>40</b>E, <b>40</b>G forming the finite mixture model as indicated at <b>40</b>B′, <b>40</b>D′, <b>40</b>E′, <b>40</b>G′.</p>
<p id="p-0144" num="0143">From a simplified perspective, if the hidden data were binary, which is to say we knew precisely which event class ought to be assigned to any event, updating the parameters would be easy since one would only include those events known to belong to a cluster and then one would use standard maximum likelihood estimate methods, for example, the maximum likelihood estimate for a populations mean is the mean vector of all events belonging to that population. As one can observe from the M-step formulas (below), the hidden data simply serves as a weighting mechanism in the simplified estimate formulas. While this satisfies the casual observer, it must be noted that the parameter update rules actually result from an algebraic solution to a gradient ascent optimization problem (see standard references on finite mixture model optimization).</p>
<p id="p-0145" num="0144">Because the disclosed methods use an unconstrained update method in the implementation of the M-step, several problems can arise. Most notably, when an expected population is poorly represented in a data file, the maximum likelihood estimate for its covariance matrix may collapse. Additionally, but more from the perspective of the specific application, some populations must always be present in a white cell count. Both of these situations are controlled using two modifications to the standard M-step. First, a minimum prior threshold is placed on each density function in the finite mixture model. Second, the code allows the expert to include some representation from the initial finite mixture model's mean and covariance matrices. Regarding the prior threshold, once a component's prior drops below its threshold, the component is removed from the continuing calculations while its parameters are frozen at their current values. If a deactivated classifier corresponds to an expected population that is required in the final report, their finite mixture model components will be reactivated prior to event classification and the component's initial parameter values will be used.</p>
<p id="p-0146" num="0145">The other way in which the implementation differs from a standard version of the maximization step in the EM algorithm is the use of priors placed on each population's parameters. Specifically, the mean and covariance parameters for each component in the finite mixture model can be biased (in a Bayesian manner as is commonly used in an Monte Carlo Markov Chain optimization approach) toward the initial density function's parameters. Implementation specific parameters determine how much biasing is used in the M-step formulas.</p>
<p id="p-0147" num="0146">Note that extreme biasing (strongly defined population parameter priors) can potentially cause a population to remain fixed at its initial settings. A finite mixture model component of this nature can be considered so stable as to never need updating. It is common to use this technique for the density function associated with a control particle, which tends to be easy to find in most files and whose density function is therefore very generic (large covariance eigenvalues).</p>
<p id="p-0148" num="0147">Formally, the (s+1)<sup>st </sup>iteration of the maximization step uses the following formulas for updating the parameters to each component's density function. Specific parameters that are updated are the mixing coefficients</p>
<p id="p-0149" num="0148">
<maths id="MATH-US-00010" num="00010">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <mi>Pr</mi>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <msub>
            <mi>C</mi>
            <mi>i</mi>
          </msub>
          <mo>|</mo>
          <msup>
            <mi>Ω</mi>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>s</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <mo>)</mo>
            </mrow>
          </msup>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <munderover>
        <mo>∑</mo>
        <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mi>n</mi>
      </munderover>
      <mo>⁢</mo>
      <mfrac>
        <msubsup>
          <mi>z</mi>
          <mi>ij</mi>
          <mrow>
            <mo>(</mo>
            <mi>s</mi>
            <mo>)</mo>
          </mrow>
        </msubsup>
        <mi>n</mi>
      </mfrac>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
the mean estimate for each class's Gaussian density function
</p>
<p id="p-0150" num="0149">
<maths id="MATH-US-00011" num="00011">
<math overflow="scroll">
<mrow>
  <mrow>
    <msubsup>
      <mi>μ</mi>
      <mi>i</mi>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>s</mi>
          <mo>+</mo>
          <mn>1</mn>
        </mrow>
        <mo>)</mo>
      </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <munderover>
            <mo>∑</mo>
            <mrow>
              <mi>j</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mi>n</mi>
          </munderover>
          <mo>⁢</mo>
          <mrow>
            <msubsup>
              <mi>z</mi>
              <mi>ij</mi>
              <mrow>
                <mo>(</mo>
                <mi>s</mi>
                <mo>)</mo>
              </mrow>
            </msubsup>
            <mo>⁢</mo>
            <msub>
              <mi>y</mi>
              <mi>j</mi>
            </msub>
          </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
          <msub>
            <mi>κ</mi>
            <mi>i</mi>
          </msub>
          <mo>⁢</mo>
          <msubsup>
            <mi>μ</mi>
            <mi>i</mi>
            <mrow>
              <mo>(</mo>
              <mn>0</mn>
              <mo>)</mo>
            </mrow>
          </msubsup>
        </mrow>
      </mrow>
      <mrow>
        <mrow>
          <munderover>
            <mo>∑</mo>
            <mrow>
              <mi>j</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mi>n</mi>
          </munderover>
          <mo>⁢</mo>
          <msubsup>
            <mi>z</mi>
            <mi>ij</mi>
            <mrow>
              <mo>(</mo>
              <mi>s</mi>
              <mo>)</mo>
            </mrow>
          </msubsup>
        </mrow>
        <mo>+</mo>
        <msub>
          <mi>κ</mi>
          <mi>i</mi>
        </msub>
      </mrow>
    </mfrac>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
where κ<sub>i </sub>is a real number that weighs in some amount of the initial mean vector, and the covariance matrix for each class's Gaussian density function
</p>
<p id="p-0151" num="0150">
<maths id="MATH-US-00012" num="00012">
<math overflow="scroll">
  <mrow>
    <mstyle>
      <mspace width="1.1em" height="1.1ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <mrow>
        <msubsup>
          <mi>V</mi>
          <mi>i</mi>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>s</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
            <mo>)</mo>
          </mrow>
        </msubsup>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <munderover>
              <mo>∑</mo>
              <mrow>
                <mi>j</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>n</mi>
            </munderover>
            <mo>⁢</mo>
            <mrow>
              <mrow>
                <msubsup>
                  <mi>z</mi>
                  <mi>ij</mi>
                  <mrow>
                    <mo>(</mo>
                    <mi>s</mi>
                    <mo>)</mo>
                  </mrow>
                </msubsup>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <msub>
                      <mi>y</mi>
                      <mi>j</mi>
                    </msub>
                    <mo>-</mo>
                    <msubsup>
                      <mi>μ</mi>
                      <mi>i</mi>
                      <mrow>
                        <mo>(</mo>
                        <mrow>
                          <mi>s</mi>
                          <mo>+</mo>
                          <mn>1</mn>
                        </mrow>
                        <mo>)</mo>
                      </mrow>
                    </msubsup>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>⁢</mo>
              <msup>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <msub>
                      <mi>y</mi>
                      <mi>j</mi>
                    </msub>
                    <mo>-</mo>
                    <msubsup>
                      <mi>μ</mi>
                      <mi>i</mi>
                      <mrow>
                        <mo>(</mo>
                        <mrow>
                          <mi>s</mi>
                          <mo>+</mo>
                          <mn>1</mn>
                        </mrow>
                        <mo>)</mo>
                      </mrow>
                    </msubsup>
                  </mrow>
                  <mo>)</mo>
                </mrow>
                <mi>t</mi>
              </msup>
            </mrow>
          </mrow>
          <mrow>
            <munderover>
              <mo>∑</mo>
              <mrow>
                <mi>j</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>n</mi>
            </munderover>
            <mo>⁢</mo>
            <msubsup>
              <mi>z</mi>
              <mi>ij</mi>
              <mrow>
                <mo>(</mo>
                <mi>s</mi>
                <mo>)</mo>
              </mrow>
            </msubsup>
          </mrow>
        </mfrac>
      </mrow>
      <mo>,</mo>
      <mstyle>
        <mtext>
</mtext>
      </mstyle>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="1.1em" height="1.1ex"/>
      </mstyle>
      <mo>⁢</mo>
      <mi>and</mi>
    </mrow>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00012-2" num="00012.2">
<math overflow="scroll">
  <mrow>
    <mrow>
      <msubsup>
        <mi>Σ</mi>
        <mi>i</mi>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>s</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
          <mo>)</mo>
        </mrow>
      </msubsup>
      <mo>=</mo>
      <mrow>
        <msup>
          <mrow>
            <mo>(</mo>
            <msubsup>
              <mi>Σ</mi>
              <mi>i</mi>
              <mrow>
                <mo>(</mo>
                <mn>0</mn>
                <mo>)</mo>
              </mrow>
            </msubsup>
            <mo>)</mo>
          </mrow>
          <mrow>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
        </msup>
        <mo>+</mo>
        <mrow>
          <msubsup>
            <mi>V</mi>
            <mi>i</mi>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>r</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <mo>)</mo>
            </mrow>
          </msubsup>
          <mo>⁢</mo>
          <mrow>
            <munderover>
              <mo>∑</mo>
              <mrow>
                <mi>j</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>n</mi>
            </munderover>
            <mo>⁢</mo>
            <msubsup>
              <mi>z</mi>
              <mi>ij</mi>
              <mrow>
                <mo>(</mo>
                <mi>s</mi>
                <mo>)</mo>
              </mrow>
            </msubsup>
          </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
          <mfrac>
            <mrow>
              <msub>
                <mi>ρ</mi>
                <mi>i</mi>
              </msub>
              <mo>⁢</mo>
              <mrow>
                <munderover>
                  <mo>∑</mo>
                  <mrow>
                    <mi>j</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>n</mi>
                </munderover>
                <mo>⁢</mo>
                <msubsup>
                  <mi>z</mi>
                  <mi>ij</mi>
                  <mrow>
                    <mo>(</mo>
                    <mi>s</mi>
                    <mo>)</mo>
                  </mrow>
                </msubsup>
              </mrow>
            </mrow>
            <mrow>
              <msub>
                <mi>ρ</mi>
                <mi>i</mi>
              </msub>
              <mo>+</mo>
              <mrow>
                <munderover>
                  <mo>∑</mo>
                  <mrow>
                    <mi>j</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>n</mi>
                </munderover>
                <mo>⁢</mo>
                <msubsup>
                  <mi>z</mi>
                  <mi>ij</mi>
                  <mrow>
                    <mo>(</mo>
                    <mi>s</mi>
                    <mo>)</mo>
                  </mrow>
                </msubsup>
              </mrow>
            </mrow>
          </mfrac>
          <mo>⁢</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msubsup>
                <mi>μ</mi>
                <mi>i</mi>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>r</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </msubsup>
              <mo>-</mo>
              <msubsup>
                <mi>μ</mi>
                <mi>i</mi>
                <mrow>
                  <mo>(</mo>
                  <mn>0</mn>
                  <mo>)</mo>
                </mrow>
              </msubsup>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>⁢</mo>
          <msup>
            <mrow>
              <mo>(</mo>
              <mrow>
                <msubsup>
                  <mi>μ</mi>
                  <mi>i</mi>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mi>r</mi>
                      <mo>+</mo>
                      <mn>1</mn>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </msubsup>
                <mo>-</mo>
                <msubsup>
                  <mi>μ</mi>
                  <mi>i</mi>
                  <mrow>
                    <mo>(</mo>
                    <mn>0</mn>
                    <mo>)</mo>
                  </mrow>
                </msubsup>
              </mrow>
              <mo>)</mo>
            </mrow>
            <mi>t</mi>
          </msup>
        </mrow>
      </mrow>
    </mrow>
    <mo>,</mo>
  </mrow>
</math>
</maths>
<br/>
where z<sub>ij</sub><sup>(s)</sup>=Pr(C<sub>i</sub>|x<sub>j</sub>,Ω<sup>(s)</sup>) is the hidden data values from the recently completed Expectation step, and ρ<sub>i </sub>biases a population's covariance matrix towards the initial matrix Σ<sub>i</sub><sup>(0)</sup>. These update formulas are specific to the use of Gaussian density functions, but are founded on standard Bayesian priors.
</p>
<p id="p-0152" num="0151">After the maximization process completes and new parameters for the finite mixture model density distributions are assigned, the process loops back to the expectation step <b>106</b>A and the process of <b>106</b>A, <b>106</b>B and <b>106</b>C described above repeats until a close fit between the model and the data set is achieved. The closeness required to cease execution of the iterations is a configurable parameter in the algorithm. After the final maximization iteration, a final application of the expectation step <b>106</b>A is then performed and then the classification process <b>108</b> executes.</p>
<p id="p-0153" num="0152">C. Classification (<b>108</b>, <figref idref="DRAWINGS">FIG. 3</figref>, <b>4</b>, <b>11</b>)</p>
<p id="p-0154" num="0153">The event classification step uses Bayes rule together with the parameter estimates returned from the model optimization process (<b>106</b>C) to assign events in the multidimensional data to one of the expected populations. Prior to this, we must extend the hidden data calculations returned from the model optimization (potentially computed on a random subset of the collected events), re-activate any components of the finite mixture model that may have been silenced during optimization (including the control particle component if these events were hidden during the model optimization), and drop any simulated pseudo-events. Once the hidden data is computed for the entire dataset, the developer has the option of applying expert rules for an optional post classification step (discussed below).</p>
<p id="h-0006" num="0000">By Bayes rule, an event is then assigned to the class with the greatest class-specific posterior probability (Pr(C<sub>i</sub>|x<sub>j</sub>,Ω)), and in particular:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Class(<i>x</i><sub>j</sub>)=arg max{<i>Pr</i>(<i>C</i><sub>i</sub><i>|x</i><sub>j</sub>,Ω)|<i>i=</i>1, 2<i>, . . . , G}.</i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0155" num="0154">These quantities incorporate changes made to each class's density function parameters during model optimization (EM updates plus Expert Rules) and a final E-step.</p>
<p id="p-0156" num="0155">D. Optional Post-Classification Processing <b>110</b> (<figref idref="DRAWINGS">FIG. 3</figref>)</p>
<p id="p-0157" num="0156">The post-classification process serves as a “clean-up” step because it allows the expert rules to examine the final classification resulting from step <b>108</b> and, depending on an event's classification, where it falls relative to a rule's True or False domain and the relative class frequency, it may be reclassified. Post-classification rules differ from optimization rules in that they have minimum requirements for being applied. These “triggers” are meant to control the application of these rules. Also, as post-classification rules, they are no longer able to modify/influence the hidden data information, and therefore have different “effects”. Specifically, all post-classification rules have two common elements: a FromPopulation list, and a ToPopulation specification, which determine which events are available to be changed and what population they will be changed to (provided they fall into the rule's True domain). There are no consequences for events that fall into a post-classification rule's False domain—the classification into a population remains intact. In one embodiment, there are two types of post-classification expert rules: Misclassification, and MissingRequiredPopulation, and each are triggered by different conditions.</p>
<p id="p-0158" num="0157">After post-classification <b>110</b> has been performed, results of the process are then presented to a user as indicated in module <b>112</b> of <figref idref="DRAWINGS">FIG. 3</figref>, e.g., on the display of populations on a graphical user interface of a workstation, in the form of a printout containing quantitative results, or in some other form.</p>
<p id="p-0159" num="0158">Further Exemplary Implementation Details</p>
<p id="p-0160" num="0159">The program code to identify populations or clusters from an input data set operates an input dataset retrieved from memory. The input data set consists of multi-dimensional data observations obtained from the analytical instrument (e.g., flow cytometer) and a parameter file including the finite mixture model library and the expert knowledge set. This section is devoted to describing one possible embodiment of the input file contents and structure.</p>
<p id="p-0161" num="0160">As we have above, we denote the observed event vectors (multidimensional input data set) as X={x<sub>j</sub>} where x<sub>j </sub>is one observation vector, and in the illustrative embodiment is seven-dimensional, for seven input data channels.</p>
<p id="p-0162" num="0161">The parameter input file determines the specifics of the classifying process and primarily contains the finite mixture model library, and the expert knowledge set consisting of expert transforms, and expert rules (logical statements or operations). The parameter file is generally associated with the sample's species. Accordingly, it would be expected that an expert in the problem domain using the disclosed classifying methodology would construct a specific parameter file suitable for the problem domain in question.</p>
<p id="p-0163" num="0162">Formally, the parameter file Ω is an ordered set (M,F,T,R), where
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0163">1. M contains a finite mixture model library and some general switches and process control parameters (see MVN_Collection Structure section below),</li>
    <li id="ul0001-0002" num="0164">2. F is a FIFO of recent scaling vectors (see Scaling Factor FIFO section below),</li>
    <li id="ul0001-0003" num="0165">3. T contains the Expert Transforms to be used (see Expert Transform Definition section below), and</li>
    <li id="ul0001-0004" num="0166">4. R contains the Expert Rules structure (see Expert Rule Definition section below).</li>
</ul>
</p>
<p id="p-0164" num="0167">Algorithm Pseudo Code</p>
<p id="p-0165" num="0168">The following section describes the main program loop and subroutines of the program code in accordance with one possible embodiment.</p>
<p id="p-0166" num="0169">© IDEXX Laboratories, Inc. 2005. See notice regarding copyright at the beginning of this document.</p>
<p id="p-0167" num="0170">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>function Main (inputDataFilename)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* get inputs */</entry>
</row>
<row>
<entry/>
<entry>X = read observations from inputDataFilename</entry>
</row>
<row>
<entry/>
<entry>species = get sample species from inputDataFilename</entry>
</row>
<row>
<entry/>
<entry>inputModelFilename = pick Model Inputs using sample species</entry>
</row>
<row>
<entry/>
<entry>scalingFactorFIFO = read ScaleFactorFIFO associated with sample</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>species</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>MVN_Collection = read Algorithm Input Parameters from</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>inputModelFilename</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* removed control particle events from input data */</entry>
</row>
<row>
<entry/>
<entry>if (MVN_Collection.CallFindLatex)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>prunedX = remove control particles from input X</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>prunedX = X</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* scale input data &amp; find initial FMM parameters */</entry>
</row>
<row>
<entry/>
<entry>if (MVN_Collection.SearchForScalingFactors)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>[MVN, scaledX, scaledPrunedX] = searchForScalingFactor(X,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="119pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>prunedX, MVN_Collection,</entry>
</row>
<row>
<entry/>
<entry>calingFactorFIFO)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>MVN = get first FMM from library in MVN_Collection initial</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>model list</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>scaledX = X</entry>
</row>
<row>
<entry/>
<entry>scaledPrunedX = prunedX</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* add simulated data from specific (generally rare) populations */</entry>
</row>
<row>
<entry/>
<entry>if (MVN.SimulateEvents)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>scaledPrunedX = addSimulatedEvents(MVN, scaledPrunedX)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* optimize FMM parameters */</entry>
</row>
<row>
<entry/>
<entry>if (MVN.MVNEMCallEM)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>if (MVN.SubsetSize &gt; 0)</entry>
</row>
<row>
<entry/>
<entry>scaledPrunedXSubset = select MVN.SubsetSize data vectors</entry>
</row>
<row>
<entry/>
<entry>randomly from scaledPrunedX</entry>
</row>
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>optimizedNVN = runModifiedEM(MVN, scaledPrunedXSubset)</entry>
</row>
<row>
<entry/>
<entry>if (MVN.EMOnEntireFile)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>finalMVN = runModifiedEM(optimizedMVN, scaledX)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>finalMVN = optimizedMVN</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* classify all events &amp; output to file */</entry>
</row>
<row>
<entry/>
<entry>XClasses = classifyEvents(scaledX, finalMVN)</entry>
</row>
<row>
<entry/>
<entry>OutputClassesToFile(XClasses)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>End</entry>
</row>
<row>
<entry>function addSimulatedEvents(MVN, X)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>for i=1 to length MVN.SimulateEventsForPopulations list</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>popIndex = index into MVN.Component(*) of ith population</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>index on list</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>scaledPopulationCovariance = MVN.Component</entry>
</row>
<row>
<entry/>
<entry>(popIndex) .Covar</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>* MVN.SimulateEventsPopulationCovarWeights (i)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>numEventsToSimulate =</entry>
</row>
<row>
<entry/>
<entry>MVN.SimulateEventsPopulationSizeScale</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>* MVN.SubsetSize</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>for j=1 to numEventsToSimulate</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>newDataPoint = random vector sampled from Gaussian</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>density with centroid =</entry>
</row>
<row>
<entry/>
<entry>MVN.Component(popIndex) .Mean and covariance =</entry>
</row>
<row>
<entry/>
<entry>scaledPopulationCovariance</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* add newDataPoint to end of list of input vectors</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>*/</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>X = [X, newDataPoint]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>return X</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>function runModifiedEM(MVN, X)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>previousTotalScore = 0</entry>
</row>
<row>
<entry/>
<entry>totalScoreDiff = infinity</entry>
</row>
<row>
<entry/>
<entry>do while (I &lt; MVN.MVNEMMaxIterations) or</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(totalScoreDiff &lt; MVN.MVNEMTotalScoreDiffThreshold)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* estimate EM hidden data */</entry>
</row>
<row>
<entry/>
<entry>probComponentIGivenXj = Estep(MVN, X)</entry>
</row>
<row>
<entry/>
<entry>/* apply expert rules */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>if (MVN.ApplyExpertRuleConstraintsWithinEM)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probComponentIGivenXj = applyExpertRules (MVN,</entry>
</row>
<row>
<entry/>
<entry>probComponentIGivenXj, X)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* update FMM parameters using hidden data and observed</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>data */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>MVN = Mstep(MVN, probComponentIGivenXj, X)</entry>
</row>
<row>
<entry/>
<entry>/* compute metric for convergence test */</entry>
</row>
<row>
<entry/>
<entry>totalScore = totalLikelihoodScore(MVN,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probComponentIGivenXj, X)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>totalScoreDiff = totalScore − previousTotalScore</entry>
</row>
<row>
<entry/>
<entry>previousTotalScore = totalScore</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>optimizedMVN = MVN</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>return optimizedMVN</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>function classifyEvents(scaledX, MVN)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* compute EM hidden data for all inputs */</entry>
</row>
<row>
<entry/>
<entry>probComponentIGivenXj = Estep(MVN, scaledX)</entry>
</row>
<row>
<entry/>
<entry>/* assign most likely class to each event */</entry>
</row>
<row>
<entry/>
<entry>foreach i in 1 to number of vectors X in scaledX</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>class (i) = argmax(probComponentIGivenXj(i, *))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>return classes</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>function Estep(MVN, X)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>numEvents = length(X)</entry>
</row>
<row>
<entry/>
<entry>/* compute the probability of each event given the current</entry>
</row>
<row>
<entry/>
<entry>parameters for each component density function in the FMM.</entry>
</row>
<row>
<entry/>
<entry>Specifically, compute</entry>
</row>
<row>
<entry/>
<entry>Pr(x_j | C_I) ~ exp[ (x_j − M) S{circumflex over ( )}−1 (x_j − M)′ ], where</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>M = current estimate for centroid of cluster i</entry>
</row>
<row>
<entry/>
<entry>S = current estimate for covariance of cluster i */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>for i=1 to MVN.NumComponents</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>if (MVN.Component(i) .Active)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>for j=1 to numEvents</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probXjGivenComponentI(j,i) = probability of x<sub>j</sub></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>given current Gaussian parameters</entry>
</row>
<row>
<entry/>
<entry>for component i in MVN</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else /* inactive component */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probXjGivenComponentI = 0 matrix</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* compute the probability of observation x_j given the model,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>which is a denominator in the last calculation. Specifically,</entry>
</row>
<row>
<entry/>
<entry>compute</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Pr(x_j | FMM) = sum_i { Pr(C_i) * Pr(x_j | C_i) } */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>for j=1 to numEvents</entry>
</row>
<row>
<entry/>
<entry>partialTermInSum(j, i) = MVN.Component(i) .Prior *</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probXjGivenComponentI(j, i)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probXjGivenFMM(j) = sum over i (partialTermInSum(j,i))</entry>
</row>
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* compute posterior probability of each component given an</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>event. Specifically, compute</entry>
</row>
<row>
<entry/>
<entry>Pr(C_i | x_j) = Pr(x_j | C_i)*Pr(C_i) / Pr(x_j | FMM) */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>for i=1 to MVN.NumComponents</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>for j=1 to numEvents</entry>
</row>
<row>
<entry/>
<entry>ProbComponentIGivenXj = partialTermInSum(j,i) /</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="98pt" align="left"/>
<colspec colname="1" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probXjGivenFMM(j)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>return probComponentIGivenXj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>function applyExpertRules(MVN, probComponentIGivenXj, X)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* compute expert transform output vectors */</entry>
</row>
<row>
<entry/>
<entry>sort expert transforms by CONSTRUCT_ORDER so that any</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>transform's inputs are computed prior to being referenced by</entry>
</row>
<row>
<entry/>
<entry>another transform</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>foreach expert transform E in sorted order</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>compute transform E's output vectors</entry>
</row>
<row>
<entry/>
<entry>foreach output vector created by E</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>translate output values to expert defined zero point</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>/* apply expert rules */</entry>
</row>
<row>
<entry/>
<entry>foreach expert rule R</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* find points in True and false domains */</entry>
</row>
<row>
<entry/>
<entry>T(X) = identify data points satisfying R's logical</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>statement</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>F(X) = compliment of T(X) in X</entry>
</row>
<row>
<entry/>
<entry>/* loop over R's effected populations */</entry>
</row>
<row>
<entry/>
<entry>foreach class C in R's true domain effected populations</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>list</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>adjustmentTrue(C) = C's adjustment factor for True</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="98pt" align="left"/>
<colspec colname="1" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>domain</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ProbComponentIGivenXj(T(X), C) = adjustmentTrue(C) *</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ProbComponentIGivenXj(T(X), C)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>adjustmentFalse(C) = C's adjustment factor for False</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="98pt" align="left"/>
<colspec colname="1" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>domain</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ProbComponentIGivenXj(F(X), C) = adjustmentFalse(C) *</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ProbComponentIGivenXj(F(X), C)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>return probComponentIGivenXj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>function Mstep(MVN, probComponentIGivenXj, X)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>/* update finite mixture model parameters using following</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>formulas */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>foreach class C<sub>i </sub>in finite mixture model</entry>
</row>
<row>
<entry/>
<entry> </entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>
<maths id="MATH-US-00013" num="00013">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>Pr</mi>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <msub>
          <mi>C</mi>
          <mi>i</mi>
        </msub>
        <mo>|</mo>
        <msup>
          <mi>Ω</mi>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>s</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
            <mo>)</mo>
          </mrow>
        </msup>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <munderover>
      <mrow>
        <mo>∑</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </mrow>
      <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <mo>⁢</mo>
    <mrow>
      <msubsup>
        <mi>z</mi>
        <mi>ij</mi>
        <mrow>
          <mo>(</mo>
          <mi>s</mi>
          <mo>)</mo>
        </mrow>
      </msubsup>
      <mo>/</mo>
      <mi>n</mi>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
</entry>
</row>
<row>
<entry/>
<entry> </entry>
</row>
<row>
<entry/>
<entry>
<maths id="MATH-US-00014" num="00014">
<math overflow="scroll">
<mrow>
  <msubsup>
    <mi>μ</mi>
    <mi>i</mi>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mi>s</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
      <mo>)</mo>
    </mrow>
  </msubsup>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mrow>
        <munderover>
          <mo>∑</mo>
          <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mi>n</mi>
        </munderover>
        <mo>⁢</mo>
        <msubsup>
          <mi>z</mi>
          <mi>ij</mi>
          <mrow>
            <mo>(</mo>
            <mi>s</mi>
            <mo>)</mo>
          </mrow>
        </msubsup>
        <mo>⁢</mo>
        <msub>
          <mi>y</mi>
          <mi>j</mi>
        </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
        <msub>
          <mi>κ</mi>
          <mi>i</mi>
        </msub>
        <mo>⁢</mo>
        <msubsup>
          <mi>μ</mi>
          <mi>i</mi>
          <mrow>
            <mo>(</mo>
            <mn>0</mn>
            <mo>)</mo>
          </mrow>
        </msubsup>
      </mrow>
    </mrow>
    <mrow>
      <mrow>
        <munderover>
          <mo>∑</mo>
          <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mi>n</mi>
        </munderover>
        <mo>⁢</mo>
        <msubsup>
          <mi>z</mi>
          <mi>ij</mi>
          <mrow>
            <mo>(</mo>
            <mi>s</mi>
            <mo>)</mo>
          </mrow>
        </msubsup>
      </mrow>
      <mo>+</mo>
      <msub>
        <mi>κ</mi>
        <mi>i</mi>
      </msub>
    </mrow>
  </mfrac>
</mrow>
</math>
</maths>
</entry>
</row>
<row>
<entry/>
<entry> </entry>
</row>
<row>
<entry/>
<entry>
<maths id="MATH-US-00015" num="00015">
<math overflow="scroll">
<mrow>
  <msubsup>
    <mi>V</mi>
    <mi>i</mi>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mi>s</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
      <mo>)</mo>
    </mrow>
  </msubsup>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <munderover>
        <mo>∑</mo>
        <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mi>n</mi>
      </munderover>
      <mo>⁢</mo>
      <mrow>
        <msubsup>
          <mi>z</mi>
          <mi>ij</mi>
          <mrow>
            <mo>(</mo>
            <mi>s</mi>
            <mo>)</mo>
          </mrow>
        </msubsup>
        <mo>⁡</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mi>y</mi>
              <mi>j</mi>
            </msub>
            <mo>-</mo>
            <msubsup>
              <mi>μ</mi>
              <mi>i</mi>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>s</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
                <mo>)</mo>
              </mrow>
            </msubsup>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>⁢</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mi>y</mi>
              <mi>j</mi>
            </msub>
            <mo>-</mo>
            <msubsup>
              <mi>μ</mi>
              <mi>i</mi>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>s</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
                <mo>)</mo>
              </mrow>
            </msubsup>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mi>t</mi>
      </msup>
    </mrow>
    <mrow>
      <munderover>
        <mo>∑</mo>
        <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mi>n</mi>
      </munderover>
      <mo>⁢</mo>
      <msubsup>
        <mi>z</mi>
        <mi>ij</mi>
        <mrow>
          <mo>(</mo>
          <mi>s</mi>
          <mo>)</mo>
        </mrow>
      </msubsup>
    </mrow>
  </mfrac>
</mrow>
</math>
</maths>
</entry>
</row>
<row>
<entry/>
<entry> </entry>
</row>
<row>
<entry/>
<entry>
<maths id="MATH-US-00016" num="00016">
<math overflow="scroll">
<mrow>
  <mtable>
    <mtr>
      <mtd>
        <mrow>
          <msubsup>
            <mi>Σ</mi>
            <mi>i</mi>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>s</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <mo>)</mo>
            </mrow>
          </msubsup>
          <mo>=</mo>
        </mrow>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mrow>
          <msup>
            <mrow>
              <mo>(</mo>
              <msubsup>
                <mi>Σ</mi>
                <mi>i</mi>
                <mrow>
                  <mo>(</mo>
                  <mn>0</mn>
                  <mo>)</mo>
                </mrow>
              </msubsup>
              <mo>)</mo>
            </mrow>
            <mrow>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msup>
          <mo>+</mo>
          <mrow>
            <msubsup>
              <mi>V</mi>
              <mi>i</mi>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>r</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
                <mo>)</mo>
              </mrow>
            </msubsup>
            <mo>⁢</mo>
            <mrow>
              <munderover>
                <mo>∑</mo>
                <mrow>
                  <mi>j</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mi>n</mi>
              </munderover>
              <mo>⁢</mo>
              <msubsup>
                <mi>z</mi>
                <mi>ij</mi>
                <mrow>
                  <mo>(</mo>
                  <mi>s</mi>
                  <mo>)</mo>
                </mrow>
              </msubsup>
            </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
            <mfrac>
              <mrow>
                <msub>
                  <mi>ρ</mi>
                  <mi>i</mi>
                </msub>
                <mo>⁢</mo>
                <mrow>
                  <munderover>
                    <mo>∑</mo>
                    <mrow>
                      <mi>j</mi>
                      <mo>=</mo>
                      <mn>1</mn>
                    </mrow>
                    <mi>n</mi>
                  </munderover>
                  <mo>⁢</mo>
                  <msubsup>
                    <mi>z</mi>
                    <mi>ij</mi>
                    <mrow>
                      <mo>(</mo>
                      <mi>s</mi>
                      <mo>)</mo>
                    </mrow>
                  </msubsup>
                </mrow>
              </mrow>
              <mrow>
                <msub>
                  <mi>ρ</mi>
                  <mi>i</mi>
                </msub>
                <mo>+</mo>
                <mrow>
                  <munderover>
                    <mo>∑</mo>
                    <mrow>
                      <mi>j</mi>
                      <mo>=</mo>
                      <mn>1</mn>
                    </mrow>
                    <mi>n</mi>
                  </munderover>
                  <mo>⁢</mo>
                  <msubsup>
                    <mi>z</mi>
                    <mi>ij</mi>
                    <mrow>
                      <mo>(</mo>
                      <mi>s</mi>
                      <mo>)</mo>
                    </mrow>
                  </msubsup>
                </mrow>
              </mrow>
            </mfrac>
            <mo>⁢</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <msubsup>
                  <mi>μ</mi>
                  <mi>i</mi>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mi>r</mi>
                      <mo>+</mo>
                      <mn>1</mn>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </msubsup>
                <mo>-</mo>
                <msubsup>
                  <mi>μ</mi>
                  <mi>i</mi>
                  <mrow>
                    <mo>(</mo>
                    <mn>0</mn>
                    <mo>)</mo>
                  </mrow>
                </msubsup>
              </mrow>
              <mo>)</mo>
            </mrow>
            <mo>⁢</mo>
            <msup>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <msubsup>
                    <mi>μ</mi>
                    <mi>i</mi>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mi>r</mi>
                        <mo>+</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </msubsup>
                  <mo>-</mo>
                  <msubsup>
                    <mi>μ</mi>
                    <mi>i</mi>
                    <mrow>
                      <mo>(</mo>
                      <mn>0</mn>
                      <mo>)</mo>
                    </mrow>
                  </msubsup>
                </mrow>
                <mo>)</mo>
              </mrow>
              <mi>t</mi>
            </msup>
          </mrow>
        </mrow>
      </mtd>
    </mtr>
  </mtable>
  <mo> </mo>
</mrow>
</math>
</maths>
</entry>
</row>
<row>
<entry/>
<entry> </entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>return MVN</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>function totalLikelihoodScore(MVN, probComponentIGivenXj, X)</entry>
</row>
<row>
<entry> </entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>
<maths id="MATH-US-00017" num="00017">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>return</mi>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.8em" height="0.8ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mi>Pr</mi>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mi>X</mi>
        <mo>|</mo>
        <msub>
          <mi>Ω</mi>
          <mi>k</mi>
        </msub>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <munderover>
      <mo>∏</mo>
      <mrow>
        <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mi>…N</mi>
      </mrow>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
    </munderover>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <munderover>
        <mo>∑</mo>
        <mrow>
          <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mi>…G</mi>
        </mrow>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </munderover>
      <mo>⁢</mo>
      <mrow>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>C</mi>
                <mi>i</mi>
              </msub>
              <mo>|</mo>
              <msub>
                <mi>Ω</mi>
                <mi>k</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mrow>
                <msub>
                  <mi>x</mi>
                  <mi>j</mi>
                </msub>
                <mo>|</mo>
                <msub>
                  <mi>C</mi>
                  <mi>i</mi>
                </msub>
              </mrow>
              <mo>,</mo>
              <msub>
                <mi>Ω</mi>
                <mi>k</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
</entry>
</row>
<row>
<entry/>
<entry> </entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>Function ScaleFactorSearch</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>InitializeParameters( )</entry>
</row>
<row>
<entry/>
<entry>FIFOScore = TestFactor(LastFIFOFactor)</entry>
</row>
<row>
<entry/>
<entry>EoverOScore = TestFactor(ECPCentroid ./ OCPCentroid)</entry>
</row>
<row>
<entry/>
<entry>BestF = argmin(FIFOScore, EoverOScore)</entry>
</row>
<row>
<entry/>
<entry>BestScore = min(FIFOScore, EoverOScore)</entry>
</row>
<row>
<entry/>
<entry>Iter = 0</entry>
</row>
<row>
<entry/>
<entry>Do while (Iter &lt; MaxIter) &amp; (BestScore &gt; a(n))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Let f be randomly sampled from a Gaussian distribution with</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>centroid BestF and covariance Σ</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>TestScore = TestFactor(f)</entry>
</row>
<row>
<entry/>
<entry>BestScore = min(BestScore, TestScore)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>End</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>Function InitializeParameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>X = (x<sub>1</sub>, x<sub>2</sub>, . . . , x<sub>n</sub>)be a list of input vectors</entry>
</row>
<row>
<entry/>
<entry>Λ = a classifying system library</entry>
</row>
<row>
<entry/>
<entry>F(Λ) = (f<sub>1</sub>, f<sub>2</sub>, . . . , f<sub>p</sub>) be the Scaling Factor FIFO associated with</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Λ, ordered by increasing date of discovery</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>If cov(F(Λ)) is symmetric positive definite</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Σ = cov(F(Λ))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Let Σ be ε*I<sub>d </sub>for ε defined outside algorithm</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>End</entry>
</row>
<row>
<entry/>
<entry>a(n) = acceptance log likelihood threshold</entry>
</row>
<row>
<entry/>
<entry>MM = argmax(Prior Pr(M<sub>k</sub>) |M<sub>k </sub>a partition system in )</entry>
</row>
<row>
<entry/>
<entry>ECPCentroid = <sub>g </sub>for g identified as the sample control particle</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(latex)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>OCPCentroid = observed control particle centroid</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>Function TestFactor(f)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>s(f) = −Log Pr(X|MM)</entry>
</row>
<row>
<entry/>
<entry>If (s(f) &lt; a(n))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ScaledX = X .* f</entry>
</row>
<row>
<entry/>
<entry>Push f onto F( )</entry>
</row>
<row>
<entry/>
<entry>Exit ScaleFactorSearch</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Return s(f)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>End</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0168" num="0171">Data Structures</p>
<p id="p-0169" num="0172">Multivariate Normal, Finite Mixture Model (FMM) Library (Collection)</p>
<p id="p-0170" num="0173">An ASCII (text) file defines a finite mixture model library. The file has three primary sections (or types of data): Header data, which is key name, value paired on each record, Cluster data, which defines the Gaussian density function parameters, and the InitialModelList section, which provides a means to restrict the library to specific combinations of density functions as opposed to all combinations. The sections must appear in the file in the order: Header, Clusters, Model List. Any record (in any section) that starts with a ‘#’ character is considered a comment and plays no role in either the file parse or algorithm execution. The format of these three sections is described next.</p>
<p id="p-0171" num="0174">Once this file is loaded into memory, the ExpertTransform, ExpertMetric, and ExpertRule structures are added to this one so that the MVN_Collection structure becomes the primary algorithm structure used throughout the code. After the initial FMM has been selected, the MVN_Collection structure is transferred to an MVN structure which is identical to the MVN_Collection with the exception of moving the ‘.Cluster(*).Component(*).’ subfield to a ‘.Component.’ subfield.</p>
<p id="p-0172" num="0175">MVN_Collection Header</p>
<p id="p-0173" num="0176">The Header section of the MVN Collection file contains one key name, value pair per record. There is no restriction on name length. A comma (and any number of spaces) separates a Key name from its associated value. The Matlab function ReadMVN_Collection_ASCII places the Key/Value pairs in the returned structure with fieldnames identical to the key name. The associated values may be converted to numerical, Boolean, or string types according to the type of value being read. Consult the conversion data structure found in ReadMVN_Collection_ASCII to determine which value type is returned.</p>
<p id="p-0174" num="0177">Appendix A contains a table describing the currently expected/supported key/value pairs together with a brief description of the parameter's role in the algorithm.</p>
<p id="p-0175" num="0178">Expert Transforms</p>
<p id="p-0176" num="0179">Expert transforms can be defined by a list of structures in the programming language MATLAB. The fields for such structures are described in Appendix B.</p>
<p id="p-0177" num="0180">Expert Rules</p>
<p id="p-0178" num="0181">Expert Rules can likewise be defined by a Matlab list of structures. The fields of each structure are described in Appendix C.</p>
<p id="p-0179" num="0182">While a number of exemplary aspects and embodiments have been discussed above, those of skill in the art will recognize certain modifications, permutations, additions and sub-combinations thereof. It is therefore intended that the following appended claims and claims hereafter introduced are interpreted to include all such modifications, permutations, additions and sub-combinations as are within their true spirit and scope.</p>
<p id="p-0180" num="0183">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="336pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">APPENDIX A</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>MVN Collection Header Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="49pt" align="left"/>
<colspec colname="3" colwidth="210pt" align="left"/>
<tbody valign="top">
<row>
<entry>Key name</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Version</entry>
<entry>String</entry>
<entry>Model version number. Is placed in FCS file.</entry>
</row>
<row>
<entry>Species</entry>
<entry>String</entry>
<entry>Identifies species. Tested for equality against</entry>
</row>
<row>
<entry/>
<entry/>
<entry>IDXSpecies value in FCS file.</entry>
</row>
<row>
<entry>CellType</entry>
<entry>String</entry>
<entry>Identifies ‘Red’, ‘White’, or ‘NBC’. Tested for equality</entry>
</row>
<row>
<entry/>
<entry/>
<entry>against IDXCellType value in FCS file.</entry>
</row>
<row>
<entry>NumClusters</entry>
<entry>Integer</entry>
<entry>Number of clusters in library. Each cluster may have many</entry>
</row>
<row>
<entry/>
<entry/>
<entry>examples (components). Generally expect one cluster per</entry>
</row>
<row>
<entry/>
<entry/>
<entry>event population to be modeled.</entry>
</row>
<row>
<entry>NumDimensions</entry>
<entry>Integer</entry>
<entry>Number of input channels. This is redundant with the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>number of channels listed in the CoordinateOrder</entry>
</row>
<row>
<entry/>
<entry/>
<entry>string.</entry>
</row>
<row>
<entry>CoordinateOrder</entry>
<entry>String</entry>
<entry>Comma separated list of input channels to be retrieved from</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the input FCS file. The number of substrings must equal</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the NumDimensions value specified above. Substrings</entry>
</row>
<row>
<entry/>
<entry/>
<entry>must match the Channel names found in the FCS file header</entry>
</row>
<row>
<entry/>
<entry/>
<entry>key IDXChannel&lt;integer&gt;. Note that the ‘_’</entry>
</row>
<row>
<entry/>
<entry/>
<entry>character takes the place of a space character in the FCS</entry>
</row>
<row>
<entry/>
<entry/>
<entry>file's field.</entry>
</row>
<row>
<entry>Include</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, a Background (Junk Collector) Gaussian</entry>
</row>
<row>
<entry>Background</entry>
<entry/>
<entry>density is added to the finite mixture model. This assumes</entry>
</row>
<row>
<entry>Component</entry>
<entry/>
<entry>that the last cluster in the MVNCollection Cluster list</entry>
</row>
<row>
<entry/>
<entry/>
<entry>defines the Background cluster.</entry>
</row>
<row>
<entry>CallFindLatex</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, Latex events are found and its estimated</entry>
</row>
<row>
<entry/>
<entry/>
<entry>centroid will be considered if a scaling factor search is</entry>
</row>
<row>
<entry/>
<entry/>
<entry>requested. In order to mask (or hide) Latex events during</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the EM optimization step, this Boolean and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMHideLatexEventsDuringEM must both be set</entry>
</row>
<row>
<entry/>
<entry/>
<entry>to true.</entry>
</row>
<row>
<entry>SubsetSize</entry>
<entry>Integer</entry>
<entry>Determines the size of the random event subset (of entire</entry>
</row>
<row>
<entry/>
<entry/>
<entry>FCS file) to be used for optimization steps.</entry>
</row>
<row>
<entry>SearchForScaling</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, search for scaling factors prior to EM</entry>
</row>
<row>
<entry>Factors</entry>
<entry/>
<entry>optimization. If Boolean is false, no search is performed</entry>
</row>
<row>
<entry/>
<entry/>
<entry>and the first component from each cluster will be selected</entry>
</row>
<row>
<entry/>
<entry/>
<entry>as the initial FMM.</entry>
</row>
<row>
<entry>ScaleFactor</entry>
<entry/>
<entry>Prefix for parameters used in the scale factor search code.</entry>
</row>
<row>
<entry>Search &lt;Suffix&gt;</entry>
<entry/>
<entry>Example key name:</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ScaleFactorSearchHistoryFIFOLen</entry>
</row>
<row>
<entry>HistoryFIFOLen</entry>
<entry>Integer</entry>
<entry>Number of prior scaling factors to be recorded for each</entry>
</row>
<row>
<entry/>
<entry/>
<entry>instrument. FIFO (plus additional data) is stored in the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Matlab binary file:</entry>
</row>
<row>
<entry/>
<entry/>
<entry>“White_&lt;SerialNumber&gt;_ScalingHistory.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>mat”</entry>
</row>
<row>
<entry>SufficientScore</entry>
<entry>Real</entry>
<entry>Sets “acceptable” scaling factor performance threshold. If</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the total negative log likelihood value associated with a</entry>
</row>
<row>
<entry/>
<entry/>
<entry>particular scaling factor vector drops below this value, the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>scaling factor search terminates, returning the associated</entry>
</row>
<row>
<entry/>
<entry/>
<entry>scaling factor. Default: −7000.0</entry>
</row>
<row>
<entry>GenericMaxNumRandom</entry>
<entry>Integer</entry>
<entry>Sets the default number of time the scaling factor search</entry>
</row>
<row>
<entry>Steps</entry>
<entry/>
<entry>algorithm will test random factors. This value will be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>changed if:</entry>
</row>
<row>
<entry/>
<entry/>
<entry>No scaling history exists for the instrument, or</entry>
</row>
<row>
<entry/>
<entry/>
<entry>The initial total log likelihood value (min of</entry>
</row>
<row>
<entry/>
<entry/>
<entry>history value and latex based value) exceeds the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ScaleFactorSearchMinInitialScore</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Threshold</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Regardless of the maximum number of iterations allowed,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>if the total log likelihood estimate falls below the sufficient</entry>
</row>
<row>
<entry/>
<entry/>
<entry>score threshold, the search terminates prior to this</entry>
</row>
<row>
<entry/>
<entry/>
<entry>maximum iteration number.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Default: 50</entry>
</row>
<row>
<entry>MinInitialScore</entry>
<entry>Real</entry>
<entry>If the initial total log likelihood score exceeds this value</entry>
</row>
<row>
<entry>Threshold</entry>
<entry/>
<entry>then presumably the data deviates radically from the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>expected (model), and it is likely more scaling factor</entry>
</row>
<row>
<entry/>
<entry/>
<entry>iterations will be needed to adjust the data.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Default: 5000.0</entry>
</row>
<row>
<entry>WeakInitial</entry>
<entry>Integer</entry>
<entry>Maximum number of scaling factor search iterations to be</entry>
</row>
<row>
<entry>MaxNumRandom</entry>
<entry/>
<entry>performed if initial total log likelihood score exceeds</entry>
</row>
<row>
<entry>Steps</entry>
<entry/>
<entry>ScaleFactorSearchMinInitialScoreThreshold.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Default: 75</entry>
</row>
<row>
<entry>NewMachine</entry>
<entry>Integer</entry>
<entry>Maximum number of scaling factor search iterations to be</entry>
</row>
<row>
<entry>MaxNumRandom</entry>
<entry/>
<entry>performed in the absence of ScalingFactor History FIFO.</entry>
</row>
<row>
<entry>Steps</entry>
<entry/>
<entry>Default: 100</entry>
</row>
<row>
<entry>UseHistory</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, the scaling factor with the lowest total</entry>
</row>
<row>
<entry/>
<entry/>
<entry>log likelihood score in the Scaling Factor FIFO is tested</entry>
</row>
<row>
<entry/>
<entry/>
<entry>against the Latex based total log likelihood score. The</entry>
</row>
<row>
<entry/>
<entry/>
<entry>factor amongst these two will serve as the seed for the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>scaling factor search algorithm. If this Boolean is false, the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>search algorithm will be seeded with the Latex based</entry>
</row>
<row>
<entry/>
<entry/>
<entry>scaling factor.</entry>
</row>
<row>
<entry>RandomWalk</entry>
<entry>Real</entry>
<entry>Determines the spread of the random sampling process used</entry>
</row>
<row>
<entry>Covariance</entry>
<entry/>
<entry>to search for an optimal scaling factor. This parameter</entry>
</row>
<row>
<entry>Epsilon</entry>
<entry/>
<entry>loosely plays the role of a “step size” in a gradient ascent-</entry>
</row>
<row>
<entry/>
<entry/>
<entry>like search, in the sense that large epsilon values produce</entry>
</row>
<row>
<entry/>
<entry/>
<entry>search algorithms that flop about a great deal and are unable</entry>
</row>
<row>
<entry/>
<entry/>
<entry>to find and follow valleys. On the other hand, when epsilon</entry>
</row>
<row>
<entry/>
<entry/>
<entry>is too small, convergence is slow because the random test</entry>
</row>
<row>
<entry/>
<entry/>
<entry>points are too near the last minimum score. The default</entry>
</row>
<row>
<entry/>
<entry/>
<entry>value was found through a process of trial and error.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Default: 0.0001</entry>
</row>
<row>
<entry>ScoreThreshold</entry>
<entry>Real</entry>
<entry>If the total log likelihood for the final scaling factor and</entry>
</row>
<row>
<entry>ForFixed</entry>
<entry/>
<entry>optimal model falls below this threshold value, all the</entry>
</row>
<row>
<entry>Population</entry>
<entry/>
<entry>covariance matrices are toggled to FIXED so that the M-</entry>
</row>
<row>
<entry>Covariance</entry>
<entry/>
<entry>step will never modify the individual population's</entry>
</row>
<row>
<entry/>
<entry/>
<entry>covariance estimates.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Default: −10,000.0</entry>
</row>
<row>
<entry>MinThresholds</entry>
<entry>Real vector</entry>
<entry>Comma separated vector of real numbers (one for each</entry>
</row>
<row>
<entry/>
<entry/>
<entry>input channel) that determines the lowest scaling factor.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>This threshold is considered after a random scaling factor</entry>
</row>
<row>
<entry/>
<entry/>
<entry>candidate is generated and before the total log likelihood</entry>
</row>
<row>
<entry/>
<entry/>
<entry>score is computed. Any coordinate of the candidate found</entry>
</row>
<row>
<entry/>
<entry/>
<entry>below the corresponding minimum defined here is set back</entry>
</row>
<row>
<entry/>
<entry/>
<entry>to the minimum value. These are intended to globally</entry>
</row>
<row>
<entry/>
<entry/>
<entry>constrain the search algorithm to a region of scale factor</entry>
</row>
<row>
<entry/>
<entry/>
<entry>space known to be acceptable.</entry>
</row>
<row>
<entry>MaxThresholds</entry>
<entry>Real vector</entry>
<entry>Same as ScaleFactorSearchMinThresholds but</entry>
</row>
<row>
<entry/>
<entry/>
<entry>with respect to a maximum rather than a minimum</entry>
</row>
<row>
<entry>UseInitial</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, restricts the search for an initial FMM to</entry>
</row>
<row>
<entry>ModelList</entry>
<entry/>
<entry>those defined on the initial model list. This is currently</entry>
</row>
<row>
<entry/>
<entry/>
<entry>overridden in the code to always being false (ECT</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Oct. 12, 2005).</entry>
</row>
<row>
<entry>NumInitialModels</entry>
<entry>Integer</entry>
<entry>Used during MVNCollection file parse to determine the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>number of initial model definitions to read from file. If this</entry>
</row>
<row>
<entry/>
<entry/>
<entry>number is less than the actual number in the list, those</entry>
</row>
<row>
<entry/>
<entry/>
<entry>initial models beyond this index in the list will be ignored.</entry>
</row>
<row>
<entry>IntialModelList</entry>
<entry>Real</entry>
<entry>If the search for an initial FMM is constrained to the initial</entry>
</row>
<row>
<entry>MaxNegLogP</entry>
<entry/>
<entry>model list, but no model on the list produces a total log</entry>
</row>
<row>
<entry/>
<entry/>
<entry>likelihood score lower than this value, then the search is</entry>
</row>
<row>
<entry/>
<entry/>
<entry>extended to all possible models.</entry>
</row>
<row>
<entry>EMOnEntireFile</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, EM algorithm (together with</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ExpertRules) will be run on all events in the input file after</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the model optimization step is completed on a random</entry>
</row>
<row>
<entry/>
<entry/>
<entry>subset of the same file. This has generally not been found</entry>
</row>
<row>
<entry/>
<entry/>
<entry>to be useful in this application.</entry>
</row>
<row>
<entry>MVNEM &lt;Suffix&gt;</entry>
<entry>Integer</entry>
<entry>Prefix for parameters used in the Expectation-Maximization</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(model optimization) portion of the algorithm. Example</entry>
</row>
<row>
<entry/>
<entry/>
<entry>key name: MVNEMCallEM</entry>
</row>
<row>
<entry>CallEM</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, EM algorithm will be used to optimize</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the FMM parameters after the scaling factor search</entry>
</row>
<row>
<entry/>
<entry/>
<entry>algorithm selects the optimal initial model. If False, a</entry>
</row>
<row>
<entry/>
<entry/>
<entry>primitive Latex classification will take place, but all other</entry>
</row>
<row>
<entry/>
<entry/>
<entry>events will be classified as UNK (== BG).</entry>
</row>
<row>
<entry>MaxIterations</entry>
<entry>Integer</entry>
<entry>Upper bound on the number of EM iterations to be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>performed</entry>
</row>
<row>
<entry>HideLatexEvents</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, events thought to be Latex during the</entry>
</row>
<row>
<entry>DuringEM</entry>
<entry/>
<entry>FindLatexAndRescale function will be removed</entry>
</row>
<row>
<entry/>
<entry/>
<entry>from the data during model optimization. After EM</entry>
</row>
<row>
<entry/>
<entry/>
<entry>terminates, and before the event classification is computed,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the latex events will be returned to the data set and the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Latex component of the FMM will be reactivated. This</entry>
</row>
<row>
<entry/>
<entry/>
<entry>speeds up model optimization convergence (as latex is</entry>
</row>
<row>
<entry/>
<entry/>
<entry>generally easy to find), while still allowing the latex</entry>
</row>
<row>
<entry/>
<entry/>
<entry>component to participate in the Bayesian classification step</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(hence Latex class remains Gaussian irrespective of any</entry>
</row>
<row>
<entry/>
<entry/>
<entry>tricks used to remove the events in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>FindLatexAndRescale).</entry>
</row>
<row>
<entry>SimulateEvents</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, events will be added to the collected data</entry>
</row>
<row>
<entry/>
<entry/>
<entry>according to the Gaussian density functions for each</entry>
</row>
<row>
<entry/>
<entry/>
<entry>specified population. For example, if</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMSimulateEventsForPopulations</entry>
</row>
<row>
<entry/>
<entry/>
<entry>contains the string EOS, the optimal initial FMM</entry>
</row>
<row>
<entry/>
<entry/>
<entry>component for EOS (with covariance scaled by S) would be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>randomly sampled from N times, and these events would be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>added to the optimization data subset. N is defined by the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>index-matched fraction found in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMSimulateEventsPopulationSizeScale.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>S is defined by the index-matched real found in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMSimulateEventsPopulationCovarWeights.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>So, for example if the ForPopulations,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>PopulationCovarWeights, and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>PopulationSizeScale values were ‘EOS, MONO’</entry>
</row>
<row>
<entry/>
<entry/>
<entry>‘0.5, 1.0’, and ‘0.01, 0.05’, and the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>SubsetSize = 4000, then 0.01 * 4000 = 40 events</entry>
</row>
<row>
<entry/>
<entry/>
<entry>would be randomly sampled from the EOS Gaussian</entry>
</row>
<row>
<entry/>
<entry/>
<entry>density function with covariance scaled by 0.5, and 0.05 * 4000 = 200</entry>
</row>
<row>
<entry/>
<entry/>
<entry>events would be randomly sampled from the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MONO Gaussian density function with covariance as</entry>
</row>
<row>
<entry/>
<entry/>
<entry>defined in the FMM.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>If Boolean is false, no random events will be generated.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Default: False</entry>
</row>
<row>
<entry>SimulateEvents</entry>
<entry/>
<entry>Prefix for parameters used in the simulated events portion</entry>
</row>
<row>
<entry>&lt;Suffix&gt;</entry>
<entry/>
<entry>of the algorithm. Example key name:</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMSimulateEventsForPopulations</entry>
</row>
<row>
<entry>ForPopulations</entry>
<entry>Comma</entry>
<entry>Comma separated string that identifies which Gaussian</entry>
</row>
<row>
<entry/>
<entry>separated text</entry>
<entry>density functions need to be randomly sampled. Values</entry>
</row>
<row>
<entry/>
<entry/>
<entry>between commas must be exact matches to the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>InternalClassNames found in the FMM structure.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Example: EOS, MONO</entry>
</row>
<row>
<entry>PopulationCovar</entry>
<entry>Real vector</entry>
<entry>Comma separated row vector of scalar values used to shrink</entry>
</row>
<row>
<entry>Weights</entry>
<entry/>
<entry>or expand the covariance matrix used for random sampling.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Smaller weights (less than 1.0) cause the density function to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>be more “concentrated” near the population's centroid,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>while larger values (greater than 1.0) cause the sampled</entry>
</row>
<row>
<entry/>
<entry/>
<entry>events to be more widely distributed. Values are index-</entry>
</row>
<row>
<entry/>
<entry/>
<entry>matched with the population names listed in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMSimulateEventsForPopulations.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Hence, expanding on the example provided for that string,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>if</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMSimulateEventsPopulationCovarWeights</entry>
</row>
<row>
<entry/>
<entry/>
<entry>is 0.5, 1.0, the EOS covariance matrix would</entry>
</row>
<row>
<entry/>
<entry/>
<entry>be multiplied by 0.5 prior to random sampling.</entry>
</row>
<row>
<entry>PopulationSize</entry>
<entry>Real vector</entry>
<entry>Comma separated row vector of fractions used to define</entry>
</row>
<row>
<entry>Scale</entry>
<entry/>
<entry>how many simulation events to be generated for each</entry>
</row>
<row>
<entry/>
<entry/>
<entry>population specified on</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMSimulateEventsForPopulations.</entry>
</row>
<row>
<entry>ApplyExpertRule</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, Expert Rules of type</entry>
</row>
<row>
<entry>Constraints</entry>
<entry/>
<entry>DuringOptimization will be applied to the hidden</entry>
</row>
<row>
<entry>WithinEM</entry>
<entry/>
<entry>data of the EM algorithm (Pr(Class_I|Obs_j)). Expert</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Rules are defined in a file separate from this file and are</entry>
</row>
<row>
<entry/>
<entry/>
<entry>explained below. If False, no rules are used.</entry>
</row>
<row>
<entry>Reactivate</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, any population designed as a</entry>
</row>
<row>
<entry>Counted</entry>
<entry/>
<entry>CountedCell (see Cluster Structure below), that is</entry>
</row>
<row>
<entry>Populations</entry>
<entry/>
<entry>inactivated during model optimization (EM steps) will be</entry>
</row>
<row>
<entry>PostEM</entry>
<entry/>
<entry>reactivated prior to classification steps. Since these</entry>
</row>
<row>
<entry/>
<entry/>
<entry>components became inactive for mathematical reasons</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(covariance failed to be symmetric positive definite for</entry>
</row>
<row>
<entry/>
<entry/>
<entry>example), the current model parameters ought to be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>regarded as suspect. For this reason, the Covariance matrix</entry>
</row>
<row>
<entry/>
<entry/>
<entry>and Mean vector found in the initial FMM structure are</entry>
</row>
<row>
<entry/>
<entry/>
<entry>copied back into the optimized FMM structure, while the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>component prior is left at its last observed value.</entry>
</row>
<row>
<entry>ApplyPostEM</entry>
<entry/>
<entry>Prefix for parameters used after Expectation-Maximization</entry>
</row>
<row>
<entry>&lt;Suffix&gt;</entry>
<entry/>
<entry>(model optimization) portion of the algorithm terminates.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Example key name:</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMApplyPostEMDimensionReduction</entry>
</row>
<row>
<entry>PreClassification</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, Expert Rules of type</entry>
</row>
<row>
<entry>Expert</entry>
<entry/>
<entry>DuringOptimization will be applied to the hidden</entry>
</row>
<row>
<entry>Rules</entry>
<entry/>
<entry>data of the EM algorithm without the final M-step updates.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>This option is obsolete as it is likely to “over-drive” the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>hidden data probabilities used for classification. If true, one</entry>
</row>
<row>
<entry/>
<entry/>
<entry>will likely stop getting “elliptical” shaped clusters.</entry>
</row>
<row>
<entry>Dimension</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, the EXT_Int and RAS_Int channel</entry>
</row>
<row>
<entry>Reduction</entry>
<entry/>
<entry>data will be ignored during the classification step. This</entry>
</row>
<row>
<entry/>
<entry/>
<entry>option pre-dates the use of a predicted EXT_Int channel,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>which works better than this option. Hence, this should not</entry>
</row>
<row>
<entry/>
<entry/>
<entry>be used (ECT Oct. 13, 2005).</entry>
</row>
<row>
<entry>DropBackground</entry>
<entry>Boolean</entry>
<entry>If Boolean is true, the Background (BG) component is</entry>
</row>
<row>
<entry>PostEMPre-</entry>
<entry/>
<entry>inactivated prior to classification. The remaining</entry>
</row>
<row>
<entry>Classification</entry>
<entry/>
<entry>population priors are adjusted appropriately (proportional to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>current priors). This results in zero UNK events in the final</entry>
</row>
<row>
<entry/>
<entry/>
<entry>classification.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0181" num="0184">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>MVN_Collection Clusters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="140pt" align="left"/>
<tbody valign="top">
<row>
<entry>Key name</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Cluster</entry>
<entry>Integer</entry>
<entry>Identifies the cluster index within the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVN_Collection.Clusters structure. Integers</entry>
</row>
<row>
<entry/>
<entry/>
<entry>must be sequential starting at 1.</entry>
</row>
<row>
<entry>NumComponents</entry>
<entry>Integer</entry>
<entry>Determines the number of components</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(Gaussian density function parameters) to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>expect for a iven cluster (population).</entry>
</row>
<row>
<entry>CountAsCell</entry>
<entry>Boolean</entry>
<entry>If set to true for a cluster, events classified to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>that cluster are expected to be white blood</entry>
</row>
<row>
<entry/>
<entry/>
<entry>cells. While this designation does not control</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the final WBC count (which is computed by</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ResCalc.EXE), it does designate this cluster as</entry>
</row>
<row>
<entry/>
<entry/>
<entry>being distinguished amongst all clusters. See</entry>
</row>
<row>
<entry/>
<entry/>
<entry>for example</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVNEMReactivateCountedPopulations</entry>
</row>
<row>
<entry/>
<entry/>
<entry>PostEM above.</entry>
</row>
<row>
<entry>InternalClassCode</entry>
<entry>Integer</entry>
<entry>Event classification code used within the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>algorithm. Since all references are generally</entry>
</row>
<row>
<entry/>
<entry/>
<entry>made through the InternalClassName,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>this value is not commonly found in the code</entry>
</row>
<row>
<entry/>
<entry/>
<entry>itself. The ability to have multiple clusters all</entry>
</row>
<row>
<entry/>
<entry/>
<entry>mapping onto the same output class. For</entry>
</row>
<row>
<entry/>
<entry/>
<entry>example, two lymphocyte clusters both with</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the same ReportedClassName and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ReportedClassCode but with distinct</entry>
</row>
<row>
<entry/>
<entry/>
<entry>InternalClassCode and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>InternalClassName allows the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>developer more flexibility when it comes to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>modeling non-Gaussian populations.</entry>
</row>
<row>
<entry>InternalClassName</entry>
<entry>String</entry>
<entry>String defines how this cluster will be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>referenced from within the algorithm. This</entry>
</row>
<row>
<entry/>
<entry/>
<entry>value, and all references to it are case</entry>
</row>
<row>
<entry/>
<entry/>
<entry>sensitive.</entry>
</row>
<row>
<entry>ReportedClassCode</entry>
<entry>Integer</entry>
<entry>Event classification code referenced outside</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the algorithm. These values determine the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>final Classifier values that are output to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the FCS file.</entry>
</row>
<row>
<entry>ReportedClassName</entry>
<entry>String</entry>
<entry>String defines how this cluster will be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>referenced outside the algorithm. This value,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>and all references to it are case sensitive. This</entry>
</row>
<row>
<entry/>
<entry/>
<entry>string will contribute to the IDXRegion</entry>
</row>
<row>
<entry/>
<entry/>
<entry>values.</entry>
</row>
<row>
<entry>Component</entry>
<entry>Integer</entry>
</row>
<row>
<entry>ComponentName</entry>
<entry>String</entry>
</row>
<row>
<entry>Prior</entry>
<entry>Real</entry>
</row>
<row>
<entry>MinPrior</entry>
<entry>Real</entry>
</row>
<row>
<entry>MeanPriorCount</entry>
<entry>Real</entry>
</row>
<row>
<entry>CovarTetheringWeight</entry>
<entry>Real</entry>
</row>
<row>
<entry>FixedMeanParams</entry>
<entry>Boolean</entry>
</row>
<row>
<entry>FixedCovarParams</entry>
<entry>Boolean</entry>
</row>
<row>
<entry>Mean</entry>
<entry>Real vector</entry>
</row>
<row>
<entry>CovarianceScalingFactor</entry>
<entry>Real</entry>
</row>
<row>
<entry>Covariance</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0182" num="0185">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Collection Initial Models List</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Key name</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry> </entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0183" num="0186">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="371pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Expert Transform Structure Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="105pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="210pt" align="left"/>
<tbody valign="top">
<row>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>NAME</entry>
<entry>String</entry>
<entry>User defined name for transform. Not referenced any place.</entry>
</row>
<row>
<entry>TYPE</entry>
<entry>String</entry>
<entry>Transform type determines the constructor function used to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>instantiate the output vectors. See list below of supported</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Transform Types.</entry>
</row>
<row>
<entry>CONSTRUCT_ORDER</entry>
<entry>Real number</entry>
<entry>Transforms are sorted (ascending) by this value and constructed</entry>
</row>
<row>
<entry/>
<entry/>
<entry>accordingly. Transform outputs required for other transforms must</entry>
</row>
<row>
<entry/>
<entry/>
<entry>have smaller CONSTRUCT_ORDER than the transforms using them.</entry>
</row>
<row>
<entry>INPUTS</entry>
<entry>List of IOStructs</entry>
<entry>Defines the input vectors for transformation</entry>
</row>
<row>
<entry>OUTPUTS</entry>
<entry>List of IOStructs</entry>
<entry>Defines the output vectors for transformation</entry>
</row>
<row>
<entry>PARAMETERS</entry>
<entry>Struct</entry>
<entry>Type specific parameters</entry>
</row>
<row>
<entry>MIN_CUT</entry>
<entry>List of real values</entry>
<entry>Lower limit for acceptable cut value. List length must equal</entry>
</row>
<row>
<entry/>
<entry/>
<entry>OUTPUTS length, and limit applies to the output with the same</entry>
</row>
<row>
<entry/>
<entry/>
<entry>index.</entry>
</row>
<row>
<entry>MAX_CUT</entry>
<entry>List of real values</entry>
<entry>Upper limit for acceptable cut value. List length must equal</entry>
</row>
<row>
<entry/>
<entry/>
<entry>OUTPUTS length, and limit applies to the output with the same</entry>
</row>
<row>
<entry/>
<entry/>
<entry>index.</entry>
</row>
<row>
<entry>OUT_OF_RANGE_RESPONSE</entry>
<entry>String</entry>
<entry>Defines transform behavior when candidate cut falls outside interval</entry>
</row>
<row>
<entry/>
<entry/>
<entry>defined by [MIN_CUT, MAX_CUT]</entry>
</row>
<row>
<entry/>
<entry/>
<entry>UNAVAILABLE → Outputs labeled unavailable</entry>
</row>
<row>
<entry/>
<entry/>
<entry>TRUNCATE → Cut set at MIN_CUT if less than MIN_CUT, and set</entry>
</row>
<row>
<entry/>
<entry/>
<entry>at MAX_CUT if greater than MAX_CUT</entry>
</row>
<row>
<entry/>
<entry/>
<entry>IGNORE → Ignores Min and Max values</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0007" level="1">Appendix B</heading>
<heading id="h-0008" level="1">Expert Transforms</heading>
<p id="p-0184" num="0187">Expert Transforms are defined by a Matlab list of structures. The fields of each structure are described here.</p>
<p id="p-0185" num="0188">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>IOStructs Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="140pt" align="left"/>
<tbody valign="top">
<row>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>NAME</entry>
<entry>String</entry>
<entry>User defined name for transform.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Not referenced any place.</entry>
</row>
<row>
<entry>TYPE</entry>
<entry>String</entry>
<entry>Either:</entry>
</row>
<row>
<entry/>
<entry/>
<entry>CHANNEL → Name refers to one of the initial</entry>
</row>
<row>
<entry/>
<entry/>
<entry>input vectors, e.g. RAS_Peak</entry>
</row>
<row>
<entry/>
<entry/>
<entry>METRIC → Name refers to an output vector</entry>
</row>
<row>
<entry/>
<entry/>
<entry>from an ExpertTransform</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0186" num="0189">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>ExpertTransform Types</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="140pt" align="left"/>
<colspec colname="2" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry>Transform Name</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>COORDINATE</entry>
<entry>Copies inputs to outputs while providing a number of ways</entry>
</row>
<row>
<entry/>
<entry>to define the cut point relative to a population's centroid.</entry>
</row>
<row>
<entry/>
<entry>Cut point methods include:</entry>
</row>
<row>
<entry/>
<entry>Absolute: Moves the zero point to a fixed</entry>
</row>
<row>
<entry/>
<entry>location in the input coordinate.</entry>
</row>
<row>
<entry/>
<entry>PopulationRelative: Allows one to</entry>
</row>
<row>
<entry/>
<entry>move the zero point in each input to some offset</entry>
</row>
<row>
<entry/>
<entry>(covariance based) from a population's centroid.</entry>
</row>
<row>
<entry/>
<entry>One can specify whether the centroid and</entry>
</row>
<row>
<entry/>
<entry>covariance estimates come from the latest EM</entry>
</row>
<row>
<entry/>
<entry>estimate of these population parameters or those of</entry>
</row>
<row>
<entry/>
<entry>the input FMM model.</entry>
</row>
<row>
<entry/>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Note: All parameters are vectors to allow for multiple</entry>
</row>
<row>
<entry/>
<entry>outputs relative to one population, e.g. Mono(RAS){Dyn},</entry>
</row>
<row>
<entry/>
<entry>Mono(RAS + ISD){Dyn}, can all be defined in one</entry>
</row>
<row>
<entry/>
<entry>transform.</entry>
</row>
<row>
<entry>BARYCENTRIC_1D</entry>
<entry>Projects all data onto a line (in n-space) joining two</entry>
</row>
<row>
<entry/>
<entry>population centroids such that values near zero will have</entry>
</row>
<row>
<entry/>
<entry>projected near one population centroid and those near one</entry>
</row>
<row>
<entry/>
<entry>have projected near the second population centroid. If x<sub>0</sub>, x<sub>1</sub></entry>
</row>
<row>
<entry/>
<entry>are the centroids of the two populations (as vectors in the</entry>
</row>
<row>
<entry/>
<entry>input space to this transform), then the output value</entry>
</row>
<row>
<entry/>
<entry>associated with event y is the real number that satisfies the</entry>
</row>
<row>
<entry/>
<entry>equation y = t * x<sub>1 </sub>+ (1 − t) * x<sub>0</sub>. Projecting all events onto</entry>
</row>
<row>
<entry/>
<entry>this t coordinate produces a one-dimensional measurement</entry>
</row>
<row>
<entry/>
<entry>system from any number of input coordinates. Moreover,</entry>
</row>
<row>
<entry/>
<entry>the two population centroids reside at known coordinates</entry>
</row>
<row>
<entry/>
<entry>(zero and one). Hence, an expert is able to construct any</entry>
</row>
<row>
<entry/>
<entry>number of new coordinates by measuring an event's</entry>
</row>
<row>
<entry/>
<entry>location relative to any two populations. This coordinate is</entry>
</row>
<row>
<entry/>
<entry>the output metric for this transform.</entry>
</row>
<row>
<entry/>
<entry>Cut point Methods: Ideally, a histogram constructed in the</entry>
</row>
<row>
<entry/>
<entry>resulting barycentric coordinate will have a large number of</entry>
</row>
<row>
<entry/>
<entry>points at zero and one with a valley between them. The</entry>
</row>
<row>
<entry/>
<entry>goal of this cut point method is to find this valley. Sadly,</entry>
</row>
<row>
<entry/>
<entry>histograms derived from all the events under consideration</entry>
</row>
<row>
<entry/>
<entry>can fail to have a valley because events far from the line</entry>
</row>
<row>
<entry/>
<entry>may project between the two anchoring populations. Near</entry>
</row>
<row>
<entry/>
<entry>the populations one might expect this problem to go away.</entry>
</row>
<row>
<entry/>
<entry>And we accomplish this restriction by considering only</entry>
</row>
<row>
<entry/>
<entry>those points within a fixed distance of the population-</entry>
</row>
<row>
<entry/>
<entry>joining line using the magnitude of the vector perpendicular</entry>
</row>
<row>
<entry/>
<entry>to the population-joining line to each event.</entry>
</row>
<row>
<entry/>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = Barycentric (t) value</entry>
</row>
<row>
<entry>POLAR_ANGLE</entry>
<entry>Transforms the rectilinear input coordinates into polar</entry>
</row>
<row>
<entry/>
<entry>coordinates and outputs the angle. The first input is taken</entry>
</row>
<row>
<entry/>
<entry>as the X-axis and the second the Y-axis. Angles are</entry>
</row>
<row>
<entry/>
<entry>measured from X to Y and lie between 0 and pi.</entry>
</row>
<row>
<entry/>
<entry>Cut point method: Transform parameters define a rectangle</entry>
</row>
<row>
<entry/>
<entry>in (modulus, angle) coordinates based on population means.</entry>
</row>
<row>
<entry/>
<entry>A histogram in the angular coordinate is built from the</entry>
</row>
<row>
<entry/>
<entry>events falling within this rectangle and a valley is sought</entry>
</row>
<row>
<entry/>
<entry>between the edges of the minimum and maximum angular</entry>
</row>
<row>
<entry/>
<entry>bounds.</entry>
</row>
<row>
<entry/>
<entry>Num Inputs: Two - X = first input, Y = second input</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = Angle between event and the first</entry>
</row>
<row>
<entry/>
<entry>input axis, i.e. second input == 0</entry>
</row>
<row>
<entry>MAHALANOBIS</entry>
<entry>Computes the Mahalanobis distance using the centroid and</entry>
</row>
<row>
<entry/>
<entry>covariance (either runtime estimated from the EM hidden</entry>
</row>
<row>
<entry/>
<entry>data, or from the model inputs) parameters for a specified</entry>
</row>
<row>
<entry/>
<entry>population. Since the inputs can be any subset of the</entry>
</row>
<row>
<entry/>
<entry>original channels (or outputs from other transforms) this</entry>
</row>
<row>
<entry/>
<entry>transform allows one to “weight” the hidden data values</entry>
</row>
<row>
<entry/>
<entry>based on density properties found in subspaces. This, in a</entry>
</row>
<row>
<entry/>
<entry>sense, weights the contribution of some input channels.</entry>
</row>
<row>
<entry/>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One</entry>
</row>
<row>
<entry>CHANNEL_SATURATION</entry>
<entry>This is an attempt to find a natural separation between the</entry>
</row>
<row>
<entry/>
<entry>region of space containing true data and those events that</entry>
</row>
<row>
<entry/>
<entry>tend to accumulate at or near the saturation point on a given</entry>
</row>
<row>
<entry/>
<entry>channel. Two inputs are required. One is expected to</entry>
</row>
<row>
<entry/>
<entry>contain the saturation events while the other defines a</entry>
</row>
<row>
<entry/>
<entry>region in which to search for a natural cut point. This has</entry>
</row>
<row>
<entry/>
<entry>been used most often with TOF as the saturation channel</entry>
</row>
<row>
<entry/>
<entry>and FSH Peak as the second input.</entry>
</row>
<row>
<entry/>
<entry>Num Inputs: Two</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = Input Y coordinate values</entry>
</row>
<row>
<entry>NEG_LOG_FMM</entry>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = negative log likelihood ratio of two</entry>
</row>
<row>
<entry/>
<entry>FMMs</entry>
</row>
<row>
<entry>NEG_LOG_MVN_PDF</entry>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = negative log of Gaussian probability</entry>
</row>
<row>
<entry/>
<entry>values for each data point</entry>
</row>
<row>
<entry>CONSTRAINED_NEG_LOG_MVN_PDF</entry>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One</entry>
</row>
<row>
<entry>LOGICAL_OR</entry>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = Boolean vector resulting from Logical</entry>
</row>
<row>
<entry/>
<entry>OR of all inputs.</entry>
</row>
<row>
<entry>TRIANGLE_AREA</entry>
<entry>Num Inputs: Two</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = signed triangle area</entry>
</row>
<row>
<entry>ORIGINAL_R8_CUT</entry>
<entry>Num Inputs: Two</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = radial distance from “wedge” origin</entry>
</row>
<row>
<entry>PCA</entry>
<entry>Num Inputs: Arbitrary</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: Arbitrary</entry>
</row>
<row>
<entry>WHITE_TRASH</entry>
<entry>Num Inputs: Two</entry>
</row>
<row>
<entry/>
<entry>Num Outputs: One = vertical distance from arc</entry>
</row>
<row>
<entry>BAYESIAN_CLASSIFIER</entry>
<entry>There is a serious bug in this transform that renders it</entry>
</row>
<row>
<entry/>
<entry>useless. The original intention was to perform an</entry>
</row>
<row>
<entry/>
<entry>intermediate classification before completing the EM</entry>
</row>
<row>
<entry/>
<entry>algorithm. Output was expected to be a Boolean with True</entry>
</row>
<row>
<entry/>
<entry>values for events classified to be a specified population in</entry>
</row>
<row>
<entry/>
<entry>the FMM. Left as s stub in case anyone else figures out my</entry>
</row>
<row>
<entry/>
<entry>error. ECT Oct. 14, 2005</entry>
</row>
<row>
<entry>HIERARCHICAL_CLUSTERING</entry>
<entry>Attempted to use a nearest neighbor joining algorithm to</entry>
</row>
<row>
<entry/>
<entry>classify event clusters. Intended to be used in a</entry>
</row>
<row>
<entry/>
<entry>PostClassification type Rule. Found the version 6.5 matlab</entry>
</row>
<row>
<entry/>
<entry>of linkage too slow to be useful and ran out of time to write</entry>
</row>
<row>
<entry/>
<entry>a faster one. Left this as a stub in case anyone else started</entry>
</row>
<row>
<entry/>
<entry>down this path later. ECT Oct. 14, 2005</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0187" num="0190">
<tables id="TABLE-US-00008" num="00008">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>COORDINATE ExpertTransform Parameter Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<colspec colname="3" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>StandardizeData</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>CutMethod</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>CutMethodParameters</entry>
<entry>CutMethodStruct</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0188" num="0191">
<tables id="TABLE-US-00009" num="00009">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>CutMethodStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Population</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>UseModelMean</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>UseCovarOffset</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>UseModelCovar</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>OffsetScaling</entry>
<entry>List of real</entry>
</row>
<row>
<entry/>
<entry/>
<entry>numbers</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0189" num="0192">
<tables id="TABLE-US-00010" num="00010">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>BARYCENTRIC_1D ExpertTransform Parameter Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<colspec colname="2" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>PointAt1</entry>
<entry>PointStruct</entry>
</row>
<row>
<entry/>
<entry>PointAt0</entry>
<entry>Struct</entry>
</row>
<row>
<entry/>
<entry>RegionOfInterestParameters</entry>
<entry>ROIStruct</entry>
</row>
<row>
<entry/>
<entry>HistogramValleyParameters</entry>
<entry>HistoStruct</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0190" num="0193">
<tables id="TABLE-US-00011" num="00011">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>PointStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Name</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>UseModalMean</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0191" num="0194">
<tables id="TABLE-US-00012" num="00012">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>ROIStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>MaxDistanceFromLine</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>MinBinT</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>MaxBinT</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0192" num="0195">
<tables id="TABLE-US-00013" num="00013">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>HistoStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>NumBins</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>PopulationMeanOffset</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>PopulationCommonSD</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>FirstPopulationPrior</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0193" num="0196">
<tables id="TABLE-US-00014" num="00014">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>POLARANGLE ExpertTransform Parameter Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="119pt" align="left"/>
<colspec colname="2" colwidth="49pt" align="left"/>
<colspec colname="3" colwidth="49pt" align="left"/>
<tbody valign="top">
<row>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>MinModulus</entry>
<entry>ModulusStruct</entry>
<entry/>
</row>
<row>
<entry>MaxModulus</entry>
<entry>ModulusStruct</entry>
</row>
<row>
<entry>MinAngle</entry>
<entry>AngleStruct</entry>
</row>
<row>
<entry>MaxAngle</entry>
<entry>AngleStruct</entry>
</row>
<row>
<entry>MinModulusDifference</entry>
<entry>Real number</entry>
</row>
<row>
<entry>MinInAnnulusToUse</entry>
<entry>Real number</entry>
</row>
<row>
<entry>SparseAnnulusMinModulusAdjustment</entry>
<entry>Real number</entry>
</row>
<row>
<entry>SparseAnnulusMaxModulusAdjustment</entry>
<entry>Real number</entry>
</row>
<row>
<entry>UseModulusHisto</entry>
<entry>Boolean</entry>
</row>
<row>
<entry>ModulusHisto</entry>
<entry>HistoStruct</entry>
</row>
<row>
<entry>AngularHisto</entry>
<entry>HistoStruct</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0194" num="0197">
<tables id="TABLE-US-00015" num="00015">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>ModulusStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>UseAbsolute</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>AbsoluteValue</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>UseModelMean</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>Population</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>UseModelCovarOffset</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>ModelCovarOffset</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>CovarCoordinate</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0195" num="0198">
<tables id="TABLE-US-00016" num="00016">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>AngleStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>UseAbsolute</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>AbsoluteValue</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry>UseModelMean</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>Population</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>OffsetDegrees</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0196" num="0199">
<tables id="TABLE-US-00017" num="00017">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>MAHALANOBIS ExpertTransform Parameter Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<colspec colname="3" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Population</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>UseModelMean</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>UseModelCovar</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>CutMethod</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>CutMethodParameters</entry>
<entry>CutMethodString</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0197" num="0200">
<tables id="TABLE-US-00018" num="00018">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>CHANNEL_SATURATION ExpertTransform Parameter Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<colspec colname="2" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Population</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>SaturationInput</entry>
<entry>InputStruct</entry>
</row>
<row>
<entry/>
<entry>BoundingBoxInput</entry>
<entry>InputStruct</entry>
</row>
<row>
<entry/>
<entry>HistogramValleyParameters</entry>
<entry>HistoStruct</entry>
</row>
<row>
<entry/>
<entry>CovarBoundingOffsetScale</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0198" num="0201">
<tables id="TABLE-US-00019" num="00019">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>InputStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Type</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>Name</entry>
<entry>String</entry>
</row>
<row>
<entry/>
<entry>UseModalMean</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>UseCovarOffset</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>UseModelCovar</entry>
<entry>Boolean</entry>
</row>
<row>
<entry/>
<entry>OffsetScaling</entry>
<entry>Real number</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0009" level="1">Appendix C</heading>
<p id="p-0199" num="0202">Expert Rules</p>
<p id="p-0200" num="0203">Expert Rules are defined by a Matlab list of structures. The fields of each structure are described here.</p>
<p id="p-0201" num="0204">
<tables id="TABLE-US-00020" num="00020">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="287pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Expert Rule Structure Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="119pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="left"/>
<colspec colname="3" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>NAME</entry>
<entry>String</entry>
<entry>User defined name for transform.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Not referenced any place.</entry>
</row>
<row>
<entry>TYPE</entry>
<entry>String</entry>
<entry>Determines when during</entry>
</row>
<row>
<entry/>
<entry/>
<entry>algorithm execution Rule is used.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Current types:</entry>
</row>
<row>
<entry/>
<entry/>
<entry>‘DuringOptimization’ →</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Rule is applied between</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Expectation and Maximization</entry>
</row>
<row>
<entry/>
<entry/>
<entry>step while optimizing the FMM</entry>
</row>
<row>
<entry/>
<entry/>
<entry>parameters</entry>
</row>
<row>
<entry/>
<entry/>
<entry>‘PostClassification’ →</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Rule is applied after event classes</entry>
</row>
<row>
<entry/>
<entry/>
<entry>have been assigned and before</entry>
</row>
<row>
<entry/>
<entry/>
<entry>classification is written to final</entry>
</row>
<row>
<entry/>
<entry/>
<entry>FCS file</entry>
</row>
<row>
<entry>PARAMETERS</entry>
<entry>Structure</entry>
<entry>Structure contains parameters</entry>
</row>
<row>
<entry/>
<entry/>
<entry>used by the specific rule instance.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Different rule Types have</entry>
</row>
<row>
<entry/>
<entry/>
<entry>different expected parameters.</entry>
</row>
<row>
<entry>HUMAN_RULES_AND_METRICS</entry>
<entry>List of MetricStructs</entry>
<entry>List identifies the Expert</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Transform Outputs that define the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>True Domain. Use is able to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>select the “&gt;” or “&lt;” zero regions,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>and whether each output is</entry>
</row>
<row>
<entry/>
<entry/>
<entry>essential for the rule definition.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Logical “AND” is used to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>combine the Transform Output</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Logicals.</entry>
</row>
<row>
<entry>EFFECT</entry>
<entry>List of EffectStructs</entry>
<entry>List of populations effected</entry>
</row>
<row>
<entry/>
<entry/>
<entry>within the True Domain and the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>multiplicative weights used to</entry>
</row>
<row>
<entry/>
<entry/>
<entry>adjust the hidden data for the EM</entry>
</row>
<row>
<entry/>
<entry/>
<entry>algorithm.</entry>
</row>
<row>
<entry>OUT_EFFECT</entry>
<entry>List of EffectStructs</entry>
<entry>List of populations effected in the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>False Domain for this rule.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Similar to EFFECT otherwise.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0202" num="0205">
<tables id="TABLE-US-00021" num="00021">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>MetricStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="49pt" align="left"/>
<colspec colname="3" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Metric</entry>
<entry>String</entry>
<entry>First character of string must be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>either ‘&gt;’ or ‘&lt;’, while the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>remainder must match identically</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(case included) with a transform</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Output Vector name.</entry>
</row>
<row>
<entry>EssentialForRule-</entry>
<entry>Boolean</entry>
<entry>If True and metric referenced by</entry>
</row>
<row>
<entry>Availability</entry>
<entry/>
<entry>Metric string is UNAVAILABLE,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>then Rule will be not be applied.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>If False and metric references by</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Metric string is UNAVAILABLE,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>then individual metric is skipped in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the True Domain definition.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>If metric referenced by Metric</entry>
</row>
<row>
<entry/>
<entry/>
<entry>String is AVAILABLE, Boolean</entry>
</row>
<row>
<entry/>
<entry/>
<entry>value is irrelevant.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0203" num="0206">
<tables id="TABLE-US-00022" num="00022">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>EffectStruct Definition</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry>Fieldname</entry>
<entry>Value Type</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Population</entry>
<entry>String</entry>
<entry>User defined name for Population</entry>
</row>
<row>
<entry/>
<entry/>
<entry>as it appears in the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>InternalClassName in the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>MVN_Collection structure.</entry>
</row>
<row>
<entry>ProbabilityAdjustment</entry>
<entry>Real number</entry>
<entry>The EM hidden data for specified</entry>
</row>
<row>
<entry/>
<entry/>
<entry>population is multiplied by this</entry>
</row>
<row>
<entry/>
<entry/>
<entry>value.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US07299135-20071120-M00001.NB">
<img id="EMI-M00001" he="7.03mm" wi="76.20mm" file="US07299135-20071120-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US07299135-20071120-M00002.NB">
<img id="EMI-M00002" he="7.03mm" wi="76.20mm" file="US07299135-20071120-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00003" nb-file="US07299135-20071120-M00003.NB">
<img id="EMI-M00003" he="7.03mm" wi="76.20mm" file="US07299135-20071120-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00004" nb-file="US07299135-20071120-M00004.NB">
<img id="EMI-M00004" he="6.35mm" wi="76.20mm" file="US07299135-20071120-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00005" nb-file="US07299135-20071120-M00005.NB">
<img id="EMI-M00005" he="7.45mm" wi="76.20mm" file="US07299135-20071120-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00006" nb-file="US07299135-20071120-M00006.NB">
<img id="EMI-M00006" he="7.45mm" wi="76.20mm" file="US07299135-20071120-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00007" nb-file="US07299135-20071120-M00007.NB">
<img id="EMI-M00007" he="7.45mm" wi="76.20mm" file="US07299135-20071120-M00007.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00008" nb-file="US07299135-20071120-M00008.NB">
<img id="EMI-M00008" he="22.27mm" wi="76.20mm" file="US07299135-20071120-M00008.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00009" nb-file="US07299135-20071120-M00009.NB">
<img id="EMI-M00009" he="7.79mm" wi="76.20mm" file="US07299135-20071120-M00009.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00010" nb-file="US07299135-20071120-M00010.NB">
<img id="EMI-M00010" he="10.58mm" wi="76.20mm" file="US07299135-20071120-M00010.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00011" nb-file="US07299135-20071120-M00011.NB">
<img id="EMI-M00011" he="17.61mm" wi="76.20mm" file="US07299135-20071120-M00011.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00012 MATH-US-00012-2" nb-file="US07299135-20071120-M00012.NB">
<img id="EMI-M00012" he="41.99mm" wi="76.20mm" file="US07299135-20071120-M00012.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00013" nb-file="US07299135-20071120-M00013.NB">
<img id="EMI-M00013" he="8.81mm" wi="27.52mm" file="US07299135-20071120-M00013.TIF" alt="embedded image " img-content="table" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00014" nb-file="US07299135-20071120-M00014.NB">
<img id="EMI-M00014" he="17.61mm" wi="26.84mm" file="US07299135-20071120-M00014.TIF" alt="embedded image " img-content="table" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00015" nb-file="US07299135-20071120-M00015.NB">
<img id="EMI-M00015" he="17.61mm" wi="40.98mm" file="US07299135-20071120-M00015.TIF" alt="embedded image " img-content="table" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00016" nb-file="US07299135-20071120-M00016.NB">
<img id="EMI-M00016" he="22.27mm" wi="65.96mm" file="US07299135-20071120-M00016.TIF" alt="embedded image " img-content="table" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00017" nb-file="US07299135-20071120-M00017.NB">
<img id="EMI-M00017" he="8.13mm" wi="58.59mm" file="US07299135-20071120-M00017.TIF" alt="embedded image " img-content="table" img-format="tif"/>
</us-math>
<us-claim-statement>I claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. In a computing system for identifying populations of events in a multi-dimensional data set obtained from a flow cytometer, the populations associated with blood components in a sample of human or animal blood, the improvement comprising:
<claim-text>one or more machine readable storage media for use with the computing system, the machine readable storage media storing:</claim-text>
<claim-text>a) data representing a finite mixture model, the model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set;</claim-text>
<claim-text>b) an expert knowledge set comprising (1) one or more data transformations and (2) one or more logical statements, the transformations and logical statements encoding a priori expectations as to the populations of events in the data set; and</claim-text>
<claim-text>c) program code for the computing system comprising instructions for operating on the multi-dimensional data using the finite mixture model and the expert knowledge set to thereby identify populations of events in the multi-dimensional data set associated with said blood components.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The improvement of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the expert knowledge set encodes a process modifying a probability estimate that an event is in one of the populations.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The improvement of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the program code iteratively executes an expectation operation, application of the expert knowledge set and a maximization operation to thereby adjust parameters associated with the finite mixture model.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The improvement of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the expert knowledge set includes at least one geometric transformation for transforming the multidimensional data set.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The improvement of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the program code comprises:
<claim-text>a pre-optimization module performing scaling of the multi-dimensional data set;</claim-text>
<claim-text>an optimization module iteratively performing (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density functions of the finite mixture model based on the application of the exert knowledge set; and</claim-text>
<claim-text>a classification module responsive to the output of the maximization operation for classifying the multidimensional data set into one or more populations.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The improvement of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the program code further comprises a post-classification module modifying the classification of the multidimensional data set using one or more expert rules from the expert knowledge set.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The improvement of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the optimization module executes a transformation algorithm defining a zero point defining a true domain and a false domain and a logical operation assigning one value to an event if the event is in the true domain and a second value if the event is in the false domain.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The improvement of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the optimization module defines at least two zero points.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The improvement of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the expert knowledge set includes at least one logical statement modifying a probability estimate for an event depending on the relationship of the event to the true domain.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The improvement of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to at least one predetermined expected population.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The improvement of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to each expected population.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The improvement of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the machine readable storage media is coupled to a data processing unit associated with a flow cytometer.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The improvement of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the instructions further comprise instructions for presenting the identification of populations in a human perceptible form.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method of identifying populations of events in a multi-dimensional data set obtained from a flow cytometer, comprising the steps of:
<claim-text>(a) processing a sample with flow cytometer to thereby obtain a multi-dimensional data set;</claim-text>
<claim-text>(b) storing the data set in a machine-readable memory;</claim-text>
<claim-text>(c) providing a finite mixture model, the model comprising a weighted sum of multi-dimensional Gaussian probability density functions associated with populations of events expected in the data set; and</claim-text>
<claim-text>(d) operating on the multi-dimensional data and the finite mixture model with the aid of an expert knowledge set to thereby identify populations of events in the multi-dimensional data set, wherein the expert knowledge set comprises one or more data transformations for operation on the multi-dimensional data set and one or more logical statements, the transformations and logical statements encoding a priori expectations as to the populations of events in the data set.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising the step of presenting the results of the identification of populations of events in a human perceptible form.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the flow cytometer processes a sample of human or animal blood and the multi-dimensional data represents event data associated with the sample.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the populations comprise populations of blood components in the blood sample.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the expert knowledge set includes at least one geometric transformation for transforming the multi-dimensional data set.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein step (d) comprises:
<claim-text>a pre-optimization step performing scaling of the multi-dimensional data set;</claim-text>
<claim-text>an optimization step iteratively performing (1) an expectation operation on at least a subset of the multi-dimensional data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the density functions of the finite mixture model; and</claim-text>
<claim-text>a classification step responsive to the output of the maximization operation for classifying the multidimensional data set into one or more populations.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein step (d) further comprises a post-classification step modifying the classification of the multidimensional data set using one or more expert rules from the expert knowledge set.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the optimization module executes a transformation algorithm defining a zero point defining a true domain and a false domain, and a logical operation assigning one value to an event if the event is in the true domain relative and a second value if the event is in a false domain.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the optimization step defines at least two zero points.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the expert knowledge set includes at least one logical statement modifying a probability estimate of an event depending on the relationship of the event to the true domain.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to at least one predetermined expected population.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The method of <claim-ref idref="CLM-00024">claim 24</claim-ref>, wherein the expectation operation computes, for each event in the multi-dimensional data set, a probability that the event belongs to each expected population.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the method further comprises performing a pre-optimization step applying a set of scaling factors to the data so as to maximize the likelihood the data arose from a specified finite mixture model selected from a library of finite mixture models.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The method of <claim-ref idref="CLM-00026">claim 26</claim-ref>, wherein the scaling factors adjust the data for machine to machine variability for machines generating the multi-dimensional data given the specified finite mixture model's parameters.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. A flow cytometry system comprising
<claim-text>a flow cytometer; and</claim-text>
<claim-text>a data processing unit for processing a multidimensional data set obtained from the flow cytometer; and</claim-text>
<claim-text>a memory storing a data representing a finite mixture model, code representing an expert knowledge set comprising logical operations and data transformations for operation on the multidimensional data set, the logical operations and data transformations encoding a priori expectations as to the populations of events in the data set, and program code for execution by the processing unit for using the expert knowledge set and the finite mixture model to identify populations of events in the data set obtained from the flow cytometer.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The system of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the program code comprises:
<claim-text>a pre-optimization module performing scaling of the data set;</claim-text>
<claim-text>an optimization module iteratively performing (1) an expectation operation on at least a subset of the data set, (2) an application of the expert knowledge set to data resulting from the expectation operation, and (3) a maximization operation updating parameters associated with the finite mixture model; and</claim-text>
<claim-text>a classification module responsive to the output of the maximization operation for classifying the data set into one or more populations.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
