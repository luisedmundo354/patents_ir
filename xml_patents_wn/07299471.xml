<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299471-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299471</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10125048</doc-number>
<date>20020417</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>409</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>718107</main-classification>
<further-classification>718100</further-classification>
<further-classification>718106</further-classification>
</classification-national>
<invention-title id="d0e53">Common thread server</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5129086</doc-number>
<kind>A</kind>
<name>Coyle, Jr. et al.</name>
<date>19920700</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>395650</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5630136</doc-number>
<kind>A</kind>
<name>Davidson et al.</name>
<date>19970500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718106</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5951653</doc-number>
<kind>A</kind>
<name>Hill et al.</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719315</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6125382</doc-number>
<kind>A</kind>
<name>Brobst et al.</name>
<date>20000900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718102</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6260077</doc-number>
<kind>B1</kind>
<name>Rangarajan et al.</name>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>709328</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6857122</doc-number>
<kind>B1</kind>
<name>Takeda et al.</name>
<date>20050200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718107</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2002/0073135</doc-number>
<kind>A1</kind>
<name>Meyer</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709107</main-classification></classification-national>
</citation>
</references-cited>
<number-of-claims>9</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>718100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718107</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030200253</doc-number>
<kind>A1</kind>
<date>20031023</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Cheung</last-name>
<first-name>Tom Thuan</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Donn</last-name>
<first-name>Siyi Terry</first-name>
<address>
<city>Saratoga</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Min, Hsieh &amp; Hack, LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Thomson</last-name>
<first-name>William</first-name>
<department>2194</department>
</primary-examiner>
<assistant-examiner>
<last-name>Hoang</last-name>
<first-name>Phuong N</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Disclosed are a method, system, and program product for calling a Common Thread Object from a running process. This is done by comprising invoking a Thread Invocation Object from the running process; creating a Generic Request Object from the Thread Invocation Object and populating the Generic Request Object with Common Thread Object and running process data; and passing data from the Generic Request Object to the Common Thread Object to initiate the common thread task.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="167.72mm" wi="190.33mm" file="US07299471-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="224.62mm" wi="177.38mm" orientation="landscape" file="US07299471-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="115.57mm" wi="162.48mm" orientation="landscape" file="US07299471-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="115.06mm" wi="165.44mm" orientation="landscape" file="US07299471-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="118.28mm" wi="169.16mm" orientation="landscape" file="US07299471-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">Our invention relates to dividing the processor bandwidth of a computer between multiple threads or sub-processes, including saving and restoring state data (i.e., context) of a task, process, or thread in a multitasking system. In this regard, our invention relates to managing or supervising a switch between discrete threads.</p>
<heading id="h-0002" level="1">DEFINITIONS</heading>
<p id="p-0003" num="0002">As used herein, a “thread” is a container for information associated with a single use of a program that can handle multiple concurrent users. From the program's point-of-view, the thread is the information needed to serve one individual user or a particular service request.</p>
<p id="p-0004" num="0003">As used herein, a “thread-safe” routine is a routine that can be called from multiple programming threads without unwanted interaction between the threads. “Thread-safety” is a term used to describe a property of a routine that can be called from multiple programming threads without unwanted interaction between the threads.</p>
<p id="p-0005" num="0004">As used herein an “application program interface” or “API” is the set of routines that a program uses to request and carry out tasks. The requesting program is typically a higher level program, as an application program, and the tasks are typically lower level tasks, as operating system tasks and maintenance chores such as managing files and displaying information on the display. The application program interface is the vehicle through which the application program communicates requests for these services.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0006" num="0005">A “thread” is the basic unit of CPU (central processing unit) utilization. An individual thread has little non-shared state, usually just its own register state and its own stack. Normally, a group of peer threads share code, address space, and operating system resources. The environment in which a thread executes is called a task. A task does nothing if it does not contain threads, and a thread can only be in one task.</p>
<p id="p-0007" num="0006">The “thread” functions as a placeholder or container for information associated with a single user of a program that can handle multiple concurrent users. From the program's point-of-view, the thread is the information needed to serve the one individual user or a particular service request. If multiple users are using the program or concurrent requests from other programs occur, a separate thread is created and maintained for each of them. The thread allows a program to know which user is being served as the program alternately gets re-entered on behalf of different users. (One way in which thread information is kept is by storing it in a special data area and putting the address of that data area in a register. The operating system always saves the contents of the register when the program is interrupted and restores it when it gives the program control again.)</p>
<p id="p-0008" num="0007">In the context of “threads” and “tasks” and “multitasking” and “multithreading,”“multithreading” and “tasks” are often confused. As used herein, “tasks” are made up of and contain one or more “threads.” Multiple tasks may be instantiated and appear to be running simultaneously. While some computers can only execute one program instruction at a time, because they operate so fast, they appear to run many programs and serve many users simultaneously. The computer operating system gives each program a “turn” at running, then, based upon various external and internal events or happenings, the operating system requires the current program or task to wait while another program gets a turn. Each of these programs is viewed by the operating system as a “task” for which certain resources are identified and kept track of. The operating system manages each application program as a separate task and lets the user look at and control items on a “task list.”</p>
<p id="p-0009" num="0008">By way of illustration, if the program initiates an I/O request, such as reading a file or writing to a printer, it creates a thread so that the program will be reentered at the right place when the I/O operation completes. Meanwhile, other concurrent uses of the program are maintained on other threads. The extensive sharing of code, address space, and operating system resources among threads make the creation of threads and switching between threads relatively inexpensive in terms of computer resources.</p>
<p id="p-0010" num="0009">Moreover, most modern operating systems provide support for both multitasking and multithreading. They also allow multithreading within program processes so that the system is saved the overhead of creating a new process for each thread.</p>
<p id="p-0011" num="0010">Another aspect of multi-thread operations is “thread safety.” As used herein, “thread-safe” is a term used to describe a routine that can be called from multiple programming threads without unwanted interaction between the threads. Thread safety is of particular importance to Java programmers, since Java is a programming language that provides built-in support for threads. By using thread-safe routines, the risk that one thread will interfere and modify data elements of another thread is eliminated by circumventing potential data race situations with coordinated access to shared data.</p>
<p id="p-0012" num="0011">It is possible to ensure that a routine is thread-safe by making sure that concurrent threads use synchronized algorithms that cooperate with each other, and confining the address of a shared object to one thread whenever an unsynchronized algorithm is active.</p>
<p id="p-0013" num="0012">Modern operating systems typically provide a set of application program interfaces that allow a programmer to include thread support in a program. Higher-level program development tools and application subsystems and “middleware” also offer thread management facilities. Object-oriented programming languages also accommodate and encourage multithreading in several ways. For example, Java supports multithreading by including synchronization modifiers in the language syntax, by providing classes developed for multithreading that can be inherited by other classes, and by doing background “garbage collection” (recovering data areas that are no longer being used) for multiple threads.</p>
<p id="p-0014" num="0013">One particular challenge is multi-threading in the context of single-threaded code logic. Moreover, single threaded logic is non-trivial. It is the low level low level glue that provides I/O, opening and closing files, writing output to the monitor, printer, and diskdrives, services interrupts, traps exceptions, and the like. The single threaded logic applications provide vital substance to the high level applications. Single-threaded code logic is usually in the form of APIs or subroutines that have areas of memory or variables that cannot be shared by multiple threads of execution simultaneously. This is usually due to fixed memory addressing logic and/or shared resource usage. The problem arises because calling a single threaded application from within a multi-threaded process or sub-process can cause memory over-writes and other problems. The single threaded application is not “thread safe.” Thus, a need exists for the capability of incorporating single-threaded code logic into a multi-threaded software environment.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0015" num="0014">Our invention meets this challenge by providing a data flow design, method, system, process and program product that facilitates incorporating single-threaded code logic into a multi-threaded software environment. We call this capability the Common Thread Server. The basis of the Common Thread Server is to uniquely serialize the invocation of the single-threaded code logic by multiple threads of execution within a single process space.</p>
<p id="p-0016" num="0015">We accomplish this by calling a single thread process from a running process. This is done by invoking a call from the running process. This invocation creates a request (container in object oriented terminology) from the call and directly or indirectly populates the request (container) with single thread process and running process data. That is, the single thread process and running process data may be supplied by and/or called from the thread invocation object or the common thread object or a repository. Next, the method passes data from the request (container) to the single thread process to initiate the common thread process.</p>
<p id="p-0017" num="0016">In an object oriented environment, serialization of the invocation of single thread code logic is accomplished through the following simplified constructs:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0017">(A) Thread Invocation Object</li>
    <li id="ul0001-0002" num="0018">(B) Generic Request Object</li>
    <li id="ul0001-0003" num="0019">(C) Common Thread Object</li>
</ul>
</p>
<p id="p-0018" num="0020">According to our invention, an executing process wishing to invoke a single threaded process (a Common Thread Object process) first invokes a Thread Invocation Object. The Thread Invocation Object may either create and populate a Generic Request Object, as a container, with data, or set a flag or generate a signal to have or request the Common Thread Object populate the Generic Request Object. The Generic Request Object is used to encompass all possible requests that need to be processed by the Common Thread Object. The data carried by the Generic Request Object (whether supplied by the Thread Invocation Object or the Common Thread Object or both of them) is program and Common Thread Object data, and includes, at a minimum, a reference to the calling Thread Invocation Object, the request name, an empty results object, and an array of parameter objects. This is a private data class used within the Common Thread Object. This data is passed from the Generic Request Object, as a container, to the Common Thread Object to initiate the common thread task.</p>
<p id="p-0019" num="0021">The Common Thread Object is the single thread of execution solely responsible for invocation of the single-threaded code logic. It processes Generic Request Objects in a predetermined order (FIFO, assigned priority, etc).</p>
<p id="p-0020" num="0022">The Thread Invocation Object represents a thread of execution that is registered with the Common Thread Object. The Thread Invocation Object sends a request to be processed via a reference call to the Common Thread Object, waits until the request is completed and then immediately evaluates the result.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">THE FIGURES</heading>
<p id="p-0021" num="0023">Various aspects of our invention are illustrated in the FIGURES appended hereto.</p>
<p id="p-0022" num="0024"><figref idref="DRAWINGS">FIG. 1</figref> illustrates the environment of the invention, with two running processes, <b>11</b><i>a</i>, <b>11</b><i>b</i>, seeking to access a single thread process, <b>19</b>, through associated Thread Invocation Objects, <b>13</b><i>a</i>, <b>13</b><i>b</i>, and Generic Request Objects, <b>15</b><i>a</i>, <b>15</b><i>b</i>, as containers of invocation data, to a Common Thread Object, <b>17</b>.</p>
<p id="p-0023" num="0025"><figref idref="DRAWINGS">FIG. 2</figref> illustrates a high level flow chart for the method, system, and program product of the invention. Specifically, in block <b>21</b> an executing process invokes a Thread Invocation Object. Next, as shown in block <b>23</b>, one or both of the Thread Invocation Object and the Common Thread Object, <b>17</b>, create and populate a Generic Request Object, as a container, with program and Common Thread Object data. Next, as shown in block <b>25</b>, this data is passed from Generic Request Object, as a container, to the Common Thread Object to initiate the single thread task</p>
<p id="p-0024" num="0026"><figref idref="DRAWINGS">FIG. 3</figref> illustrates a flow chart for a more specific exemplification of the method, system, and program product of the invention where the Thread Invocation Object drives the process. Specifically, in block <b>21</b> an executing process invokes a Thread Invocation Object. Next, as shown in block <b>23</b>, the Thread Invocation Object creates and populates a Generic Request Object, as a container, with program and Common Thread Object data. Next, as shown in block <b>25</b>, this data is passed from Generic Request Object, as a container, to the Common Thread Object to initiate the single thread task.</p>
<p id="p-0025" num="0027"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a flow chart for the method, system, and program product of the invention where the Thread Invocation Object initiates the process and the Common Thread Object drives the process once initiated. Specifically, in block <b>21</b> an executing process invokes a Thread Invocation Object Next, as shown in block <b>23</b><i>a</i>, the Thread Invocation Object sets a flag or other signal or register that calls upon the Common Thread Object to create and populate a Generic Request Object, as a container, with program and Common Thread Object data. Next, as shown in block <b>25</b>, this data is passed from Generic Request Object, as a container, to the Common Thread Object to initiate the single thread task.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0026" num="0028">The basis of our Common Thread Server lies in serializing the invocation of the single-threaded code logic by multiple threads of execution within a single process space. This is accomplished through the use of the following constructs:
<ul id="ul0002" list-style="none">
    <li id="ul0002-0001" num="0029">(A) Thread Invocation Object</li>
    <li id="ul0002-0002" num="0030">(B) Generic Request Object</li>
    <li id="ul0002-0003" num="0031">(C) Common Thread Object</li>
</ul>
</p>
<p id="p-0027" num="0032"><figref idref="DRAWINGS">FIG. 1</figref> illustrates the environment of the invention. Specifically, <figref idref="DRAWINGS">FIG. 1</figref> illustrates two running processes, <b>11</b><i>a</i>, <b>11</b><i>b</i>. Both processes, <b>11</b><i>a</i>, <b>11</b><i>b</i>, are capable of accessing a single thread process, <b>19</b>. This access is through associated Thread Invocation Objects, <b>13</b><i>a</i>, <b>13</b><i>b</i>, and Generic Request Objects, <b>15</b><i>a</i>, <b>15</b><i>b</i>. The Generic Request Objects, <b>15</b><i>a</i>, <b>15</b><i>b</i>, are containers of invocation data, to be passed between a Thread Invocation Object, <b>13</b><i>a </i>or <b>13</b><i>b</i>, and a Common Thread Object, <b>17</b>.</p>
<p id="p-0028" num="0033"><figref idref="DRAWINGS">FIG. 2</figref> illustrates one high level flow chart for the method, system, and program product of the invention. Specifically, in block <b>21</b> an executing process (as processes <b>11</b><i>a </i>and <b>11</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>) invokes a Thread Invocation Object (as elements <b>13</b><i>a </i>and <b>13</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>). Next, as shown in block <b>23</b>, the Thread Invocation Object (as elements <b>13</b><i>a </i>and <b>13</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>) initiates the creation and population of a Generic Request Object (as elements <b>15</b><i>a </i>and <b>15</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>), as a container or container class, with program and Common Thread Object data. This initiation and population can come about through passing data from the Thread Invocation Object (elements <b>13</b><i>a</i>, <b>13</b><i>b</i>), or from the Common Thread Object (as element <b>17</b>), or both the Thread Invocation Object (elements <b>13</b><i>a</i>, <b>13</b><i>b</i>) and the Common Thread Object (element <b>17</b>). Next, as shown in block <b>25</b>, this data is passed from Generic Request Object, (elements <b>15</b><i>a </i>and <b>15</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>), as a container, to the Common Thread Object (element <b>17</b>) to initiate the single thread task (element <b>19</b>).</p>
<p id="p-0029" num="0034">The Common Thread Object, <b>17</b>, is the single thread of execution solely responsible for invocation of the single-threaded code logic. The Common Thread Object, <b>17</b>, processes Generic Request Objects in a predetermined order (FIFO, priority, etc.). As each request is issued by a Thread Invocation Object, <b>13</b><i>a</i>, <b>13</b><i>b</i>, the request is independently processed. The results are returned to the calling Thread Invocation Object, <b>13</b><i>a </i>or <b>13</b><i>b</i>. Each Thread Invocation Object. <b>13</b><i>a</i>, <b>13</b><i>b</i>, is registered with the Common Thread Object, <b>17</b>. When there are no more registered Thread Invocation Objects, the Common Thread Object cleans itself and terminates.</p>
<p id="p-0030" num="0035">The Generic Request Object, <b>15</b><i>a</i>, <b>15</b><i>b</i>, is used to encompass all possible requests that need to be processed by the Common Thread Object, <b>17</b> It minimally consists of a reference to the calling Thread Invocation Object, the request name, an empty results object, and an array of parameter objects. This is a private data class used within the Common Thread Object, <b>17</b>. The Generic Request Object, <b>15</b><i>a</i>, <b>15</b><i>b</i>, may be initiated as well as populated by a Thread Invocation Objection, <b>13</b><i>a</i>, <b>13</b><i>b</i>, or by the Common Thread Object, <b>17</b>, or by both, with various communication modes between them.</p>
<p id="p-0031" num="0036">The Thread Invocation Object represents a thread of execution that is registered with the Common Thread Object. It sends a request to be processed via a reference call to the Common Thread Object, <b>17</b>, waits until the request is completed and then immediately evaluates the result.</p>
<p id="p-0032" num="0037">In the embodiment shown in <figref idref="DRAWINGS">FIG. 3</figref> the Thread Invocation Object, <b>13</b><i>a</i>, <b>13</b><i>b</i>, directly initiates and populates the Generic Request Object, <b>15</b><i>a</i>, <b>15</b><i>b</i>. Specifically, <figref idref="DRAWINGS">FIG. 1</figref> illustrates a flow chart for one particular embodiment of the method, system, and program product of the invention. Specifically, in block <b>21</b> an executing process (as processes <b>11</b><i>a </i>and <b>11</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>) invokes a Thread Invocation Object (as elements <b>13</b><i>a </i>and <b>13</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>). Next, as shown in block <b>23</b>, the Thread Invocation Object (as elements <b>13</b><i>a </i>and <b>13</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>) initiates the creation and population of a Generic Request Object (as elements <b>15</b><i>a </i>and <b>15</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>), as a container or container class, with program and Common Thread Object data. This initiation and population comes about through passing data from the Thread Invocation Object (elements <b>13</b><i>a</i>, <b>13</b><i>b</i>). Next, as shown in block <b>25</b>, this data is passed from Generic Request Object, (elements <b>15</b><i>a </i>and <b>15</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>), as a container, to the Common Thread Object (element <b>17</b>) to initiate the single thread task (element <b>19</b>).</p>
<p id="p-0033" num="0038">In the embodiment shown in <figref idref="DRAWINGS">FIG. 4</figref>, the Thread Invocation Object, <b>13</b><i>a</i>, <b>13</b><i>b</i>, broadcasts or transmits or otherwise sigvalsa request for the Common Thread Object, <b>17</b>, and the Common Thread Object, <b>17</b>, initiates and populates the Generic Request Object, <b>15</b><i>a</i>, <b>15</b><i>b</i>. <figref idref="DRAWINGS">FIG. 4</figref> illustrates a flow chart for an alternative exemplification of the method, system, and program product of the invention, where the Common Thread Object, <b>17</b>, populates the Generic Request Object, <b>15</b><i>a</i>, <b>15</b><i>b</i>. Specifically, in block <b>21</b> an executing process (as processes <b>11</b><i>a </i>and <b>11</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>) invokes a Thread Invocation Object (as elements <b>13</b><i>a </i>and <b>13</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>). Next, as shown in block <b>23</b><i>a</i>, the Thread Invocation Object (as elements <b>13</b><i>a </i>and <b>13</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>) initiates the creation and population of a Generic Request Object (as elements <b>15</b><i>a </i>and <b>15</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>), as a container or container class, with program and Common Thread Object data. This initiation and population comes about through passing data from the Common Thread Object (as element <b>17</b>). Next, as shown in block <b>25</b> this_data is passed from Generic Request Object, (elements <b>15</b><i>a </i>and <b>15</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>), as a container, to the Common Thread Object (element <b>17</b>) to initiate the single thread task (element <b>19</b>).</p>
<p id="p-0034" num="0039">The three objects (threadInvocationObject, genericRequestObject, and commonThreadObject) have the pseudocode shown in the Appendix. Specifically, the The threadInvocationObject (represented by elements <b>13</b><i>a </i>and <b>13</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref>) references a commonThreadObject and is responsible for interaction with the commonThreadObject for work done on single threaded API calls. That is, it instantiates the commonThreadObject.</p>
<p id="p-0035" num="0040">The class threadInvocationObject extends thread working through class variables and static commonThreadObject reference. It has constructors, and common thread server specific methods. These include methods for manipulation of commonThreadObject, where each manipulation is uniquely identified by a command (cmd). The current cmd includes initialization and destruction of commonThreadObject, and a private static synchronized void cmdCommonThreadObjectRef(String cmd). Also included is a method to initialize commonThreadObject if necessary. Also included is a private static synchronized void initCommonThreadObject().</p>
<p id="p-0036" num="0041">A further class is a method to destroy commonThreadObject, and a private static synchronized void destroyCommonThreadObject(). Still further included classes include other methods, unique to specific request, such as an object to contain request parameters and information, all specific requests are to be derived from the base class if using multiple request object classes.</p>
<p id="p-0037" num="0042">The class genericRequestObject, represented by elements <b>15</b><i>a </i>and <b>15</b><i>b </i>in <figref idref="DRAWINGS">FIG. 1</figref> encompasses class variables as well as exact variables (which will be dependent on request object definition). These are generally for specific solutions, such as public String requestString; public Object[] parameters; public Object requestor (which is a thread invocation object), and public Object result; (which is a result object). Also included are various constructors, and other methods such as set/get methods if necessary.</p>
<p id="p-0038" num="0043">The class commonThreadObject is an object that executes request for processing of single threaded APIs, and extends the thread, includes the class variable static flag initiallized (which is a flag to indicate that the common thread object has already been initiallized), a private Vector requests, (which is a queue of requests to process), a private Vector threadInvocationObjects (which is a queue of invocation objects), private int references, (which represents the number of invocation objects referencing this object).</p>
<p id="p-0039" num="0044">The commonThreadObject class also includes constructors and common thread server specific methods, for example, a method to add a request to the request queue so that it can be handled by the commonThreadObject. This method returns a predefined results object. The commonThreadObject class also includes a public Object addRequest(String req, Object[] parameters, Object requester), which is a method to wait for and execute all request in queue one by one.</p>
<p id="p-0040" num="0045">In a preferred exemplification, the Common Thread Server has the following prerequisites (which makes it compatible with the majority of existing application projects): First, in a preferred exemplification, it uses object oriented program language to more easily map the base components. Synchronization control and inheritance are favorable, however these can be programmed in or worked around.</p>
<p id="p-0041" num="0046">As used herein, a program product is computer readable program code on one or more media, where the program code is capable of controlling and configuring a computer system having one or more computers to carry out the method of calling a Common Thread Object from a running process by invoking a Thread Invocation Object from the running process, creating a Generic Request Object from the Thread Invocation Object and populating the Generic Request Object with Common Thread Object and running process data; and passing data from the Generic Request Object to the Common Thread Object to initiate the common thread task. The one or more computers may be configured and controlled to carry out the method described herein. Alternatively, the program may be one or more of encrypted or compressed for subsequent installation, and may be resident on installation media or on an installation server.</p>
<p id="p-0042" num="0047">While our common thread server has been described with respect to certain preferred embodiments and exemplifications, it is not intended to limit the scope of the invention thereby, but solely by the claims appended hereto.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of calling a single thread process from a running process, wherein the single thread process is exclusively invoked by a common thread object, said method comprising:
<claim-text>a. invoking a call to the single thread process from the running process;</claim-text>
<claim-text>b. creating a request object container from the call and populating the request object container with common thread object data and running process data from the common thread object;</claim-text>
<claim-text>c. populating the request object container with the common thread object data and running process data from a thread invocation object associated with the running process; and</claim-text>
<claim-text>d. passing data from the request object container to the single thread process via the common thread object.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> comprising populating the request object container with the common thread object data and running process data from an object associated with the common thread object.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A method of calling a Common Thread Object that exclusively controls invocation of a single-threaded code logic from a running process comprising:
<claim-text>a. invoking a Thread Invocation Object from the running process;</claim-text>
<claim-text>b. creating a Generic Request Object as a container from the Thread Invocation Object that is coupled to the Common Thread Object and populating the Generic Request Object with Common Thread Object data and running process data; and</claim-text>
<claim-text>c. passing data from the Generic Request Object to the single threaded code logic via the Common Thread Object to initiate the single threaded code logic.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref> comprising the creating the Generic Request Object as a container from the Thread Invocation Object and populating the Generic Request Object as a container with the Common Thread Object data and running process data from the Thread Invocation Object.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref> comprising the creating the Generic Request Object as a container from the Common Thread Object and populating the Generic Request Object as a container with the Common Thread Object data and running process data.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A system comprising computer readable code in a computer storage medium when executing by a processor, said computer readable code adapted to configure and control at least one computer configured and controlled to run a multi-thread process and a single thread process, wherein the single thread process is exclusively invoked by a Common Thread Object, and wherein the system is further controlled to:
<claim-text>a. invoke a Thread Invocation Object from the running multi-thread process;</claim-text>
<claim-text>b. create a Generic Request Object as a container and populate the Generic Request Object as a container with Common Thread Object data and running process data for the Common Thread Object; and</claim-text>
<claim-text>c. pass data from the Generic Request Object to the single thread process via the Common Thread Object to initiate the single thread process.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A program product comprising computer readable code in a computer storage medium when executing by a processor, said computer readable code adapted to configure and control a computer to call a single thread process that is exclusively invoked by a Common Thread Object from a running process by a method comprising:
<claim-text>a. invoking a Thread Invocation Object from the running process;</claim-text>
<claim-text>b. creating a Generic Request Object and populating the Generic Request Object with Common Thread Object data and running process data for the Common Thread Object wherein the computer readable code is further adapted to create the Generic Request Object as a container and populate the Generic Request Object as a container with the Common Thread Object data and running process data; and</claim-text>
<claim-text>c. passing data from the Generic Request Object to the single thread process via the Common Thread Object to initiate the single thread process.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The program product of <claim-ref idref="CLM-00007">claim 7</claim-ref> wherein the computer readable code is further adapted to create the Generic Request Object as a container and populate the Generic Request Object as a container with the Common Thread Object data and running process data.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The program product of <claim-ref idref="CLM-00007">claim 7</claim-ref> is encrypted and/or compressed for subsequent installation.</claim-text>
</claim>
</claims>
</us-patent-grant>
