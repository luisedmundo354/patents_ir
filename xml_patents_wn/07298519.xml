<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298519-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298519</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11003481</doc-number>
<date>20041206</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>AU</country>
<doc-number>PP7024</doc-number>
<date>19981109</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>125</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>K</subclass>
<main-group>15</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>358  116</main-classification>
<further-classification>358  13</further-classification>
</classification-national>
<invention-title id="d0e71">Data register arrangement for an inkjet printer</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5511206</doc-number>
<kind>A</kind>
<name>Yasuda</name>
<date>19960400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5630063</doc-number>
<kind>A</kind>
<name>McConnell</name>
<date>19970500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5754193</doc-number>
<kind>A</kind>
<name>Elhatem</name>
<date>19980500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5774634</doc-number>
<kind>A</kind>
<name>Honma et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5867183</doc-number>
<kind>A</kind>
<name>Cornell</name>
<date>19990200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5982395</doc-number>
<kind>A</kind>
<name>Olson</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>5992961</doc-number>
<kind>A</kind>
<name>Ishikawa et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6019449</doc-number>
<kind>A</kind>
<name>Bullock et al.</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>347 14</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6070958</doc-number>
<kind>A</kind>
<name>Kanome</name>
<date>20000600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6126265</doc-number>
<kind>A</kind>
<name>Childers et al.</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>347 23</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6145065</doc-number>
<kind>A</kind>
<name>Takahashi</name>
<date>20001100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6318828</doc-number>
<kind>B1</kind>
<name>Barbour et al.</name>
<date>20011100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>347  9</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6384854</doc-number>
<kind>B1</kind>
<name>Ibs et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>347211</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6493112</doc-number>
<kind>B1</kind>
<name>Arce</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6559962</doc-number>
<kind>B1</kind>
<name>Fukunaga et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>358  115</main-classification></classification-national>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>6600573</doc-number>
<kind>B2</kind>
<name>Shaked</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>6652052</doc-number>
<kind>B2</kind>
<name>Silverbrook</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>347  5</main-classification></classification-national>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2002/0158924</doc-number>
<kind>A1</kind>
<name>Silverbrook</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>347  5</main-classification></classification-national>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2003/0202205</doc-number>
<kind>A1</kind>
<name>Kuronuma et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>358  115</main-classification></classification-national>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2005/0073712</doc-number>
<kind>A1</kind>
<name>Silverbrook et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>358  114</main-classification></classification-national>
</citation>
<citation>
<patcit num="00021">
<document-id>
<country>EP</country>
<doc-number>0262801</doc-number>
<kind>A2</kind>
<date>19880400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00022">
<document-id>
<country>EP</country>
<doc-number>390202</doc-number>
<date>19901000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00023">
<document-id>
<country>EP</country>
<doc-number>842777</doc-number>
<kind>A</kind>
<date>19980500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00024">
<document-id>
<country>FR</country>
<doc-number>2716593</doc-number>
<kind>A1</kind>
<date>19950800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00025">
<document-id>
<country>WO</country>
<doc-number>WO-95/35623</doc-number>
<kind>A</kind>
<date>19951200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00026">
<document-id>
<country>WO</country>
<doc-number>WO99/04368</doc-number>
<date>19990100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>6</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>358  116</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>358  13</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>358468</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>358  115</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>358  14</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>358  19</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>358  118</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>34</number-of-drawing-sheets>
<number-of-figures>42</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>10636247</doc-number>
<kind>00</kind>
<date>20030808</date>
</document-id>
<parent-status>PENDING</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>11003481</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<division>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>09436747</doc-number>
<kind>00</kind>
<date>19991109</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>6687022</doc-number>
<kind>A </kind>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>10636247</doc-number>
</document-id>
</child-doc>
</relation>
</division>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050088467</doc-number>
<kind>A1</kind>
<date>20050428</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Silverbrook</last-name>
<first-name>Kia</first-name>
<address>
<city>Balmain</city>
<country>AU</country>
</address>
</addressbook>
<nationality>
<country>AU</country>
</nationality>
<residence>
<country>AU</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Lapstun</last-name>
<first-name>Paul</first-name>
<address>
<city>Balmain</city>
<country>AU</country>
</address>
</addressbook>
<nationality>
<country>AU</country>
</nationality>
<residence>
<country>AU</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Walmsley</last-name>
<first-name>Simon Robert</first-name>
<address>
<city>Balmain</city>
<country>AU</country>
</address>
</addressbook>
<nationality>
<country>AU</country>
</nationality>
<residence>
<country>AU</country>
</residence>
</applicant>
</applicants>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Silverbrook Research Pty Ltd</orgname>
<role>03</role>
<address>
<city>Balmain, NSW</city>
<country>AU</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Grant</last-name>
<first-name>Jerome</first-name>
<department>2625</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Communication between a micromechanical printhead interface and a printer processor involves the exchange of numerous operational parameters. A register is provided to allow the processor to parameterize a print as well as received print progress feedback from the printhead interface. Printhead feedback parameters that are stored in the register include: printhead nozzle temperature; actuator voltage; actuator heater resistivity; and actuator heater width.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="158.92mm" wi="220.39mm" file="US07298519-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="213.78mm" wi="121.16mm" orientation="landscape" file="US07298519-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="257.64mm" wi="167.39mm" file="US07298519-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="246.13mm" wi="150.88mm" orientation="landscape" file="US07298519-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="252.22mm" wi="168.91mm" orientation="landscape" file="US07298519-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="213.87mm" wi="148.84mm" orientation="landscape" file="US07298519-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="254.25mm" wi="141.39mm" orientation="landscape" file="US07298519-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="148.67mm" wi="168.99mm" file="US07298519-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="226.31mm" wi="156.46mm" orientation="landscape" file="US07298519-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="157.23mm" wi="159.94mm" file="US07298519-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="223.60mm" wi="145.37mm" file="US07298519-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="214.88mm" wi="150.28mm" file="US07298519-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="191.94mm" wi="153.42mm" file="US07298519-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="230.04mm" wi="154.86mm" orientation="landscape" file="US07298519-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="233.51mm" wi="170.86mm" orientation="landscape" file="US07298519-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="222.50mm" wi="143.09mm" file="US07298519-20071120-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="186.18mm" wi="170.43mm" orientation="landscape" file="US07298519-20071120-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="191.52mm" wi="171.37mm" orientation="landscape" file="US07298519-20071120-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="190.67mm" wi="167.22mm" file="US07298519-20071120-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="194.90mm" wi="175.34mm" orientation="landscape" file="US07298519-20071120-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="217.25mm" wi="152.91mm" file="US07298519-20071120-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="220.13mm" wi="169.25mm" file="US07298519-20071120-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="234.19mm" wi="170.18mm" orientation="landscape" file="US07298519-20071120-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="234.78mm" wi="160.61mm" file="US07298519-20071120-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="229.62mm" wi="164.85mm" file="US07298519-20071120-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00025" num="00025">
<img id="EMI-D00025" he="229.19mm" wi="152.99mm" orientation="landscape" file="US07298519-20071120-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00026" num="00026">
<img id="EMI-D00026" he="193.97mm" wi="153.25mm" orientation="landscape" file="US07298519-20071120-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00027" num="00027">
<img id="EMI-D00027" he="246.72mm" wi="167.64mm" orientation="landscape" file="US07298519-20071120-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00028" num="00028">
<img id="EMI-D00028" he="201.93mm" wi="155.11mm" file="US07298519-20071120-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00029" num="00029">
<img id="EMI-D00029" he="249.26mm" wi="154.01mm" file="US07298519-20071120-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00030" num="00030">
<img id="EMI-D00030" he="233.51mm" wi="136.06mm" file="US07298519-20071120-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00031" num="00031">
<img id="EMI-D00031" he="248.16mm" wi="138.51mm" file="US07298519-20071120-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00032" num="00032">
<img id="EMI-D00032" he="251.04mm" wi="160.87mm" file="US07298519-20071120-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00033" num="00033">
<img id="EMI-D00033" he="241.05mm" wi="165.35mm" file="US07298519-20071120-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00034" num="00034">
<img id="EMI-D00034" he="214.21mm" wi="156.04mm" file="US07298519-20071120-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This Application is a Continuation of U.S. Ser. No. 10/636,247 filed on Aug. 8, 2003 which is a Divisional of Ser. No. 09/436,747 filed on Nov. 9, 1999, now U.S. Pat. No. 6,687,022, all of which are herein incorporated by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">TECHNICAL FIELD</heading>
<p id="p-0003" num="0002">This invention concerns a resource held in computer memory and multiple parallel processors which require simultaneous access to the resource. The resource may be a dither matrix or dither volume used for digitally halftoning a contone color image, in the form of an array of contone color pixel values, to bi-level dots, and this may be required to be accessed by different thresholding units in parallel. In another aspect the invention is a method of accessing such a resource.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">Where multiple parallel processors require simultaneous access to a resource held in computer memory, several strategies are possible. First, the processors could take turns to access the resource, however this reduces the performance of the processors. Second, multi-ported memory could be employed, and third, the entire resource could be replicated in different memory banks; both the last options are expensive.</p>
<p id="p-0005" num="0004">A particular example of a resource held in computer memory is a dither matrix or dither volume used for digitally halftoning a contone color image. When dither cell registration is not desired between different color planes of the image, a set thresholding units handling the dithering of individual color components may require simultaneous access to a different dither cell locations.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0006" num="0005">In one broad form the invention comprises a method of determining the amount of ink in a printer reservoir, after a page is printed, comprising the steps of:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0006">determining the volume of ink remaining in the reservoir, prior to printing;</li>
    <li id="ul0001-0002" num="0007">counting the number of dots of ink discharged in the printing of the page;</li>
    <li id="ul0001-0003" num="0008">multiplying the said number of dots by the volume of each dot to determine the volume of ink used in the printing of the page; and</li>
    <li id="ul0001-0004" num="0009">subtracting the calculated volume of ink, used in printing of the page, from the volume of ink in the reservoir prior to printing of that page to obtain the volume of ink in the reservoir after printing that page.</li>
</ul>
</p>
<p id="p-0007" num="0010">In a further form the invention comprises an apparatus for determining the volume of ink in a cartridge after a page is printed, by a printhead through nozzles discharging dots of ink from said cartridge to form the image, comprising:
<ul id="ul0002" list-style="none">
    <li id="ul0002-0001" num="0011">a processor and memory unit associate with the ink cartridge and containing data on the characteristics of the ink and the volume of ink in the cartridge;</li>
    <li id="ul0002-0002" num="0012">a sensor associated with said printhead to count the number of dots of ink discharged from said nozzles;</li>
    <li id="ul0002-0003" num="0013">a processor unit for extracting data from the processor and memory unit to determine the volume of the an ink dot discharged from the nozzles and in communication with said sensor to receive data on the number of dots printed for the last page, multiplying the dot volume by the number of dots to determine the amount of ink used in printing the page, and inputing this data to the processor and memory unit, to update the volume of ink remaining in the cartridge.</li>
</ul>
</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0008" num="0014">An example of a printer embodying the invention will now be described with reference to the accompanying drawings, in which:</p>
<p id="p-0009" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a table which illustrates the sustained printing rate achievable with double-buffering in the printer.</p>
<p id="p-0010" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> is a flowchart showing the conceptual data flow from application to printed page.</p>
<p id="p-0011" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> is a pictorial view of the iPrint printer in its closed configuration.</p>
<p id="p-0012" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> is a pictorial view of the iPrint printer in its open configuration.</p>
<p id="p-0013" num="0019"><figref idref="DRAWINGS">FIG. 5</figref> is a cutaway diagram showing the paper path through the printer.</p>
<p id="p-0014" num="0020"><figref idref="DRAWINGS">FIG. 6</figref> is a pictorial cutaway view of a MEMJET printhead cartridge and printhead capping mechanism.</p>
<p id="p-0015" num="0021"><figref idref="DRAWINGS">FIG. 7</figref> is a sectional view of the MEMJET printhead cartridge and printhead capping mechanism of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0016" num="0022"><figref idref="DRAWINGS">FIG. 8</figref> is a pictorial view of the printer controller.</p>
<p id="p-0017" num="0023"><figref idref="DRAWINGS">FIG. 9</figref> is an example of coding a simple black and white image.</p>
<p id="p-0018" num="0024"><figref idref="DRAWINGS">FIG. 10</figref> is a schematic diagram of a pod of ten printing nozzles numbered in firing order.</p>
<p id="p-0019" num="0025"><figref idref="DRAWINGS">FIG. 11</figref> is a schematic diagram of the same pod of ten printing nozzles numbered in load order.</p>
<p id="p-0020" num="0026"><figref idref="DRAWINGS">FIG. 12</figref> is a schematic diagram of a chromapod.</p>
<p id="p-0021" num="0027"><figref idref="DRAWINGS">FIG. 13</figref> is a schematic diagram of a podgroup of five chromapods.</p>
<p id="p-0022" num="0028"><figref idref="DRAWINGS">FIG. 14</figref> is a schematic diagram of a phasegroup of two podgroups.</p>
<p id="p-0023" num="0029"><figref idref="DRAWINGS">FIG. 15</figref> is a schematic diagram showing the relationship between Segments, Firegroups, Phasegroups, Podgroups and Chromapods.</p>
<p id="p-0024" num="0030"><figref idref="DRAWINGS">FIG. 16</figref> is a phase diagram of the AEnable and BEnable lines during a typical Print Cycle.</p>
<p id="p-0025" num="0031"><figref idref="DRAWINGS">FIG. 17</figref> is a diagram of the Printer controller architecture.</p>
<p id="p-0026" num="0032"><figref idref="DRAWINGS">FIG. 18</figref> is a flowchart summarising the page expansion and printing data flow.</p>
<p id="p-0027" num="0033"><figref idref="DRAWINGS">FIG. 19</figref> is a block diagram of the EDRL expander unit.</p>
<p id="p-0028" num="0034"><figref idref="DRAWINGS">FIG. 20</figref> is a block diagram of the EDRL stream decoder.</p>
<p id="p-0029" num="0035"><figref idref="DRAWINGS">FIG. 21</figref> is a block diagram of the Runlength Decoder.</p>
<p id="p-0030" num="0036"><figref idref="DRAWINGS">FIG. 22</figref> is a block diagram of the Runlength Encoder.</p>
<p id="p-0031" num="0037"><figref idref="DRAWINGS">FIG. 23</figref> is a block diagram of the JPEG decoder.</p>
<p id="p-0032" num="0038"><figref idref="DRAWINGS">FIG. 24</figref> is a block diagram of the Halftoner/Compositor unit.</p>
<p id="p-0033" num="0039"><figref idref="DRAWINGS">FIG. 25</figref> is a series of page lines that show the relatiorships between page widths and margins.</p>
<p id="p-0034" num="0040"><figref idref="DRAWINGS">FIG. 26</figref> is a block diagram of a Multi-threshold dither.</p>
<p id="p-0035" num="0041"><figref idref="DRAWINGS">FIG. 27</figref> is a block diagram of the logic of the Triple-threshold unit.</p>
<p id="p-0036" num="0042"><figref idref="DRAWINGS">FIG. 28</figref> is a block diagram of the internal structure of the Printhead Interface.</p>
<p id="p-0037" num="0043"><figref idref="DRAWINGS">FIG. 29</figref> is a diagram of the conceptual overview of double buffering during print lines N and N+1.</p>
<p id="p-0038" num="0044"><figref idref="DRAWINGS">FIG. 30</figref> is a block diagram of the structure of the LLFU.</p>
<p id="p-0039" num="0045"><figref idref="DRAWINGS">FIG. 31</figref> is a diagram of the conceptual structure of a Buffer.</p>
<p id="p-0040" num="0046"><figref idref="DRAWINGS">FIG. 32</figref> is a diagram of the logical structure of a Buffer.</p>
<p id="p-0041" num="0047"><figref idref="DRAWINGS">FIG. 33</figref> is a block diagram of the generation of AEnable and BEnable Pulse Widths.</p>
<p id="p-0042" num="0048"><figref idref="DRAWINGS">FIG. 34</figref> is a diagram of the Dot Count logic.</p>
<p id="p-0043" num="0049"><figref idref="DRAWINGS">FIG. 35</figref> is a block diagram of the speaker interface.</p>
<p id="p-0044" num="0050"><figref idref="DRAWINGS">FIG. 36</figref> is a diagram of a two-layer page buffer.</p>
<p id="p-0045" num="0051"><figref idref="DRAWINGS">FIG. 37</figref> is a series of diagrams showing the compositing of a black object onto a white image.</p>
<p id="p-0046" num="0052"><figref idref="DRAWINGS">FIG. 38</figref> is a series of diagrams showing the compositing of a contone object onto a white image.</p>
<p id="p-0047" num="0053"><figref idref="DRAWINGS">FIG. 39</figref> is a series of diagrams showing the compositing of a black object onto an image containing a contone object.</p>
<p id="p-0048" num="0054"><figref idref="DRAWINGS">FIG. 40</figref> is a series of diagrams showing the compositing of an opaque contone object onto an image containing a black object.</p>
<p id="p-0049" num="0055"><figref idref="DRAWINGS">FIG. 41</figref> is a series of diagrams showing the compositing of a transparent contone object onto an image containing a black object.</p>
<p id="p-0050" num="0056"><figref idref="DRAWINGS">FIG. 42</figref> is a block diagram of the Windows 9x/NT printing system with printer driver components.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DESCRIPTION OF PREFERRED AND OTHER EMBODIMENTS</heading>
<p id="h-0007" num="0000">1 Introduction</p>
<p id="p-0051" num="0057">The invention will be described with reference to a high-performance color printer which combines photographic-quality image reproduction with magazine-quality text reproduction. The printer utilizes an 8″ page-width drop-on-demand microelectromechanical inkjet (“MEMJET”) printhead which produces 1600 dots per inch (dpi) bi-level CMYK (Cyan, Magenta, Yellow, blacK). It prints 30 full-color A4 or Letter pages per minute, and is intended as an entry-level desktop printer. The printer has been designated as iprint and will be referred to by that name in the following description.</p>
<p id="h-0008" num="0000">1.1 Operational Overview</p>
<p id="p-0052" num="0058">iPrint reproduces black text and graphics directly using bi-level black, and continuous-tone (contone) images and graphics using dithered bi-level CMYK. For practical purposes, iprint supports a black resolution of 800 dpi, and a contone resolution of 267 pixels per inch (ppi).</p>
<p id="p-0053" num="0059">iPrint is, in use, attached to a workstation or personal computer (PC) via a relatively low-speed (1.5 MBytes/s) universal serial bus (USB) connection [15]. iPrint relies on the PC to render each page to the level of contone pixels and black dots. The PC compresses each rendered page to less than 3 MB for sub-two-second delivery to the printer. iPrint decompresses and prints the page line by line at the speed of the MEMJET printhead. iPrint contains sufficient buffer memory for two compressed pages (6 MB), allowing it to print one page while receiving the next, but does not contain sufficient buffer memory for even a single uncompressed page (119 MB).</p>
<p id="h-0009" num="0000">1.2 Page Width</p>
<p id="p-0054" num="0060">The standard MEMJET nozzle layout has a half-inch unit cell, and so can be trivially adapted to page widths which are multiples of half an inch. Arbitrary page widths can be achieved with custom nozzle layouts, in markets which justify such specialisation. The initial MEMJET building block is a widely useful four-inch printhead which makes efficient use of a six-inch silicon wafer. The iPrint design therefore assumes an eight-inch MEMJET printhead, made up of two four-inch printheads joined together. The use of a wider printhead to achieve full bleed on A4/Letter pages only affects a few aspects of the iPrint design—specifically the exact mechanical design, and the logic of the printhead interface.</p>
<p id="h-0010" num="0000">2 MEMJET-Based Printing</p>
<p id="p-0055" num="0061">A MEMJET printhead produces 1600 dpi bi-level CMYK. On low-diffusion paper, each ejected drop forms an almost perfectly circular 22.5 micron diameter dot. Dots are easily produced in isolation, allowing dispersed-dot dithering to be exploited to its fullest. Since the MEMJET printhead is page-width and operates with a constant paper velocity, the four color planes are printed in perfect registration, allowing ideal dot-on-dot printing. Since there is consequently no spatial interaction between color planes, the same dither matrix is used for each color plane.</p>
<p id="p-0056" num="0062">A page layout may contain a mixture of images, graphics and text. Continuous-tone (contone) images and graphics are reproduced using a stochastic dispersed-dot dither. Unlike a clustered-dot (or amplitude-modulated) dither, a dispersed-dot (or frequency-modulated) dither reproduces high spatial frequencies (i.e. image detail) almost to the limits of the dot resolution, while simultaneously reproducing lower spatial frequencies to their full color depth. A stochastic dither matrix is carefully designed to be free of objectionable low-frequency patterns when tiled across the image. As such its size typically exceeds the minimum size required to support a number of intensity levels (i.e. 16×16×8 bits for 257 intensity levels). iPrint uses a dither volume of size 64×64×3×8 bits. The dither volume provides an extra degree of freedom during the design of the dither by allowing a dot to change states multiple times through the intensity range [12], rather than just once as in a conventional dither matrix.</p>
<p id="p-0057" num="0063">Human contrast sensitivity peaks at a spatial frequency of about 3 cycles per degree of visual field and then falls off logarithmically, decreasing by a factor of 100 and becoming difficult to measure beyond about 40 cycles per degree [2]. At a normal viewing distance of between 400 mm and 250 mm, this translates roughly to 150-250 cycles per inch (cpi) on the printed page, or 300-500 samples per inch according to Nyquist's theorem. Taking into account the fact that color sensitivity is less acute than grayscale sensitivity, contone resolution beyond about 400 pixels per inch (ppi) is therefore of limited utility, and in fact contributes slightly to color error through the dither.</p>
<p id="p-0058" num="0064">Black text and graphics are reproduced directly using bi-level black dots, and are therefore not antialiased (i.e. low-pass filtered) before being printed. Text is therefore supersampled beyond the perceptual limits discussed above, to produce smooth edges when spatially integrated. Text resolution up to about 1200 dpi continues to contribute to perceived text sharpness (assuming low-diffusion paper, of course).</p>
<p id="h-0011" num="0000">3.1 Constraints</p>
<p id="p-0059" num="0065">USB (Universal Serial Bus) is the standard low-speed peripheral connection on new PCs [4]. The standard high-speed peripheral connection, IEEE 1394, is recommended but unfortunately still optional in the PC 99 specification [5], and so may not be in widespread use when iPrint is first launched. iPrint therefore connects to a personal computer (PC) or workstation via USB, and the speed of the USB connection therefore imposes the most significant constraint on the architecture of the iPrint system. At a sustained printing rate of 30 pages/minute, USB at 1.5 MByte/s imposes an average limit of 3 MB/page. Since the act of interrupting a MEMJET-based printer during the printing of a page produces a visible discontinuity, it is advantageous for the printer to receive the entire page before commencing printing, to eliminate the possibility of buffer underrun. Since the printer can contain only limited buffer memory, i.e. two pages' worth or 6 MB, then the 3 MB/page limit must be considered absolute.</p>
<p id="p-0060" num="0066"><figref idref="DRAWINGS">FIG. 1</figref> illustrates the sustained printing rate achievable with double-buffering in the printer. The first stage 1 requires the first page to be rendered in the PC, and this takes up to two seconds. During the second stage 2 the next page is rendered and the first page is transferred to the printer, again this takes up to two seconds. In the third stage 3 the first page is printed, the second page is transferred and a third page is rendered, this takes two seconds. As a result it takes up to six seconds for the first page to be printed and thereafter a page can be printed every two seconds.</p>
<p id="p-0061" num="0067">Other desktop connection options provide similar bandwidth to USB, and so impose similar constraints on the architecture. These include the parallel port at 2 MB/s, and 10Base-T Ethernet at around 1 MB/s</p>
<p id="h-0012" num="0000">3.2 Page Rendering and Compression</p>
<p id="p-0062" num="0068">Page rendering (or rasterization) can be split between the PC and printer in various ways. Some printers support a full page description language (PDL) such as Postscript, and contain correspondingly sophisticated renderers. Other printers provide special support only for rendering text, to achieve high text resolution. This usually includes support for built-in or downloadable fonts. In each case the use of an embedded renderer reduces the rendering burden on the PC and reduces the amount of data transmitted from the PC to the printer. However, this comes at a price. These printers are more complex than they might be, and are often unable to provide full support for the graphics system of the PC, through which application programs construct, render and print pages. They often fail to exploit the high performance of current PCs, and are unable to leverage projected exponential growth in PC performance.</p>
<p id="p-0063" num="0069">iPrint relies on the PC 4 to render pages, i.e. contone images and graphics to the pixel level, and black text and graphics to the dot level. iPrint 5 contains only a simple rendering engine which dithers the contone data and combines the results with any foreground bi-level black text and graphics. This strategy keeps the printer simple, and independent of any page description language or graphics system. It fully exploits the high performance of current PCs. The downside of this strategy is the potentially large amount of data which must be transmitted from the PC to the printer. We consequently use compression to reduce this data to the 3 MB/page required to allow a sustained printing rate of 30 pages/minute.</p>
<p id="p-0064" num="0070"><figref idref="DRAWINGS">FIG. 2</figref> is a flowchart illustrating the conceptual data flow from an application <b>6</b> to a printed page <b>7</b>.</p>
<p id="p-0065" num="0071">An 8″ by 11.7″ A4 page has a bi-level CMYK pagesize of 114.3 MBytes at 1600 dpi, and a contone CMYK pagesize of 32.1 MB at 300 ppi.</p>
<p id="p-0066" num="0072">In the printer driver <b>8</b>, we use JPEG compression <b>9</b> to compress the contone data. Although JPEG is inherently lossy, for compression ratios of 10:1 or less the loss is usually negligible [17]. To obtain an integral contone to bi-level ratio, and to provide some compression leeway, we choose a contone resolution of 267 ppi. This yields a contone CMYK pagesize of 25.5 MB, a corresponding compression ratio of 8.5:1 to fit within the 3 MB/page limit, and a contone to bi-level ratio of 1:6 in each dimension.</p>
<p id="p-0067" num="0073">A full page of black text (and/or graphics) rasterized at printer resolution (1600 dpi) yields a bi-level image of 28.6 MB. Since rasterizing text at 1600 dpi places a heavy burden on the PC for a small gain, we choose to rasterize text at a fully acceptable 800 dpi. This yields a bi-level image of 7.1 MB, requiring a lossless compression ratio of less than 2.5:1 to fit within the 3 MB/page limit. We achieve this with a two-dimensional compression scheme adapted from Group 4 Facsimile, all indicated generally at 10.</p>
<p id="p-0068" num="0074">As long as the image and text regions of a page are non-overlapping, any combination of the two fits  within the 3 MB limit. If text lies on top of a background image, then the worst case is a compressed pagesize approaching 6 MB (depending on the actual text compression ratio). This fits within the printer's page buffer memory, but prevents double-buffering of pages in the printer, thereby reducing the printer's page rate by two-thirds, i.e. to 10 pages/minute.</p>
<p id="h-0013" num="0000">3.3 Page Expansion and Printing</p>
<p id="p-0069" num="0075">As described above, the PC renders contone images and graphics to the pixel level, and black text and graphics to the dot level. These are compressed <b>11</b> by different means and transmitted together to the printer.</p>
<p id="p-0070" num="0076">The printer contains two 3 MB page buffers—one <b>12</b> for the page being received from the PC, and one <b>13</b> for the page being printed. The printer expands the compressed page as it is being printed. This expansion consists of decompressing the 267 ppi contone CMYK image data <b>14</b>, halftoning the resulting contone pixels to 1600 dpi bi-level CMYK dots <b>15</b>, decompressing the 800 dpi bi-level black text data <b>16</b>, and compositing the resulting bi-level black text dots over the corresponding bi-level CMYK image dots <b>17</b>.</p>
<p id="p-0071" num="0077">The conceptual data flow from the application to the printed page is illustrated in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="h-0014" num="0000">4 Printer Hardware</p>
<p id="p-0072" num="0078">Because of the simplicity of the page width MEMJET printhead, iPrint is very compact. It measures just 270 mm wide×85 mm deep×77 mm high when closed. <figref idref="DRAWINGS">FIG. 3</figref> is a pictorial view of the iPrint <b>21</b> when closed.</p>
<p id="p-0073" num="0079">The cover <b>22</b> opens to form part of the paper tray, as shown in <figref idref="DRAWINGS">FIG. 4</figref>. A second part <b>23</b> is hinged within cover <b>22</b> and opens to extend the paper tray. A paper exit tray <b>24</b> is slideably extendable from the front of the printer.</p>
<p id="p-0074" num="0080">The front panel <b>25</b>, revealed when cover <b>22</b> is opened, contains the user interface—the power button <b>26</b> and power indicator LED <b>27</b>, the paper feed button <b>28</b>, and the out-of-paper <b>29</b> and ink low <b>30</b> LEDs.</p>
<p id="h-0015" num="0000">4.1 Paper Path</p>
<p id="p-0075" num="0081">iPrint uses a standard paper transport mechanism. The paper path <b>50</b> is illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, in which a single stepper motor <b>51</b> drives both the sheet feed roller <b>52</b> and the paper transport. When running in the forward direction the stepper motor drives the paper drive roller <b>53</b> and the pinch wheels <b>54</b> at the start and end of the active paper path, respectively. When reversed, the stepper motor drives the sheet feed roller <b>52</b> which grabs the topmost sheet from the sheet feeder and transports it the short distance to the paper drive roller <b>53</b> where it is detected by the mechanical media sensor <b>55</b>.</p>
<p id="p-0076" num="0082">The paper centering sliders <b>56</b> ensure that the paper is centered. This ensures that a single centered media sensor detects the sheet, and also ensures that sheets wider than the printhead are printed with balanced margins.</p>
<p id="h-0016" num="0000">4.1.1 MEMJET Printhead</p>
<p id="p-0077" num="0083">The replaceable MEMJET printhead cartridge <b>60</b> is also shown in <figref idref="DRAWINGS">FIG. 5</figref>. This represents one of the four possible ways to deploy the printhead in conjunction with the ink cartridge in a product such as iPrint:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0084">permanent printhead, replaceable ink cartridge (as shown here)</li>
    <li id="ul0003-0002" num="0085">separate replaceable printhead and ink cartridges</li>
    <li id="ul0003-0003" num="0086">refillable combined printhead and ink cartridge</li>
    <li id="ul0003-0004" num="0087">disposable combined printhead and ink cartridge</li>
</ul>
</p>
<p id="p-0078" num="0088">Under the printhead cartridge <b>60</b> is a printhead assembly <b>61</b> and a printhead capping mechanism <b>62</b>, illustrated in pictorial cut away view in <figref idref="DRAWINGS">FIG. 6</figref> and in section in <figref idref="DRAWINGS">FIG. 7</figref>. When not in use, the MEMJET printhead <b>63</b> remains filled with ink, and so must be capped to prevent evaporation of ink through the nozzles. Ink evaporation can lead to gradual deposition of ink components which can impair nozzle operation.</p>
<p id="p-0079" num="0089">iPrint includes a mechanical page width capping mechanism <b>62</b> which consists of a pivoting capping molding <b>64</b> with an elastomeric seal <b>65</b> and sponge <b>66</b>. When the printhead is not in use, the capping molding <b>64</b> is held by a spring against the face of the printhead assembly <b>61</b>, and the elastomeric seal <b>65</b> conforms to the face of the printhead assembly and creates an airtight seal around the printhead <b>63</b>. The sponge <b>66</b> is used to catch drops ejected during the printhead cleaning cycle. When the printhead is in use, the capping molding <b>64</b> is held away from the printhead assembly <b>61</b> and out of the paper path.</p>
<p id="p-0080" num="0090">The capping molding <b>64</b> is offset by a set of flexible arms <b>68</b> from a rod <b>69</b>. The capping molding <b>64</b> and arms <b>68</b> pivot with the rod <b>69</b> about its axis. A slip wheel <b>70</b> is mounted at the end of rod <b>69</b>. The slip wheel <b>70</b> makes contact with a drive wheel <b>71</b>. When printing is occurring, the drive wheel <b>71</b> is coupled to the paper transport motor and is driven in the uncapping direction <b>72</b>. This causes the slip wheel <b>70</b> and rod <b>69</b> to rotate about its axis and swings the capping molding <b>64</b> away from the printhead. Once the slip wheel rotates to the uncapping slip point <b>73</b>, the slip wheel and the capping molding stop rotating. When printing is complete, the drive wheel is reversed and driven in the capping direction <b>74</b>. Once the slip wheel rotates to the capping slip point <b>75</b>, the slip wheel and the capping molding stop rotating, and the capping spring holds the capping plate in place against the face of the printhead assembly. The flexible arms <b>68</b> help the capping plate <b>67</b> conform to the face of the printhead assembly <b>61</b>.</p>
<p id="h-0017" num="0000">4.2 Printer Controller</p>
<p id="p-0081" num="0091">The printer controller <b>80</b> is illustrated in <figref idref="DRAWINGS">FIG. 8</figref>, and consists of a small PCB <b>81</b> with only a few components—a 64 Mbit RDRAM <b>82</b>, the iPrint Central Processor (ICP) chip <b>83</b>, a speaker <b>84</b> for notifying the user of error conditions, a QA chip <b>85</b>, an external 3V DC power connection <b>86</b>, an external USB connection <b>87</b>, a connection <b>88</b> to the paper transport stepper motor <b>51</b>, and the flex PCB <b>89</b> which connects to the media sensor <b>55</b>, LEDs <b>27</b>, <b>29</b> and <b>30</b>, buttons <b>26</b> and <b>28</b>, and a link <b>90</b> the printhead <b>63</b>.</p>
<p id="h-0018" num="0000">4.3 Ink Cartridge and Ink Path</p>
<p id="p-0082" num="0092">There are two versions of the ink cartridge—one large, one small. Both fit in the same ink cartridge slot at the back of the iPrint unit.</p>
<p id="h-0019" num="0000">5 Printer Control Protocol</p>
<p id="p-0083" num="0093">This section describes the printer control protocol used between a host and iPrint. It includes control and status handling as well as the actual page description.</p>
<p id="h-0020" num="0000">5.1 Control and Status</p>
<p id="p-0084" num="0094">The USB device class definition for printers [16] provides for emulation of both unidirectional and bidirectional IEEE 1284 parallel ports [3]. At its most basic level, this allows the host to determine printer capabilities (via GET_DEVICE_ID), obtain printer status (via GET_PORT_STATUS), and reset the printer (via SOFT_RESET). Centronics/IEEE 1284 printer status fields are described in Table 1 below.</p>
<p id="p-0085" num="0095">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 1</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Centronics/IEEE 1284 printer status</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>field</entry>
<entry>description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Select</entry>
<entry>The printer is selected and available for</entry>
</row>
<row>
<entry/>
<entry/>
<entry>data transfer.</entry>
</row>
<row>
<entry/>
<entry>Paper</entry>
<entry>A paper empty condition exists in the printer.</entry>
</row>
<row>
<entry/>
<entry>Empty</entry>
</row>
<row>
<entry/>
<entry>Fault</entry>
<entry>A fault condition exists in the printer</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(includes Paper Empty and not Select).</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0086" num="0096">Personal computer printing subsystems typically provide some level of IEEE 1284 support. Compatibility with IEEE 1284 in a printer therefore simplifies the development of the corresponding printer driver. The USB device class definition for printers seeks to leverage this same compatibility.</p>
<p id="p-0087" num="0097">iPrint supports no control protocol beyond the USB device class definition for printers. Note that, if a higher-level control protocol were defined, then conditions such as out-of-ink could also be reported to the user (rather than just via the printer's out-of-ink LED).</p>
<p id="p-0088" num="0098">iPrint receives page descriptions as raw transfers, i.e. not encapsulated in any higher-level control protocol.</p>
<p id="h-0021" num="0000">5.2 Page Description</p>
<p id="p-0089" num="0099">iPrint reproduces black at full dot resolution (1600 dpi), but reproduces contone color at a somewhat lower resolution using halftoning. The page description is therefore divided into a black layer and a contone layer. The black layer is defined to composite over the contone layer.</p>
<p id="p-0090" num="0100">The black layer consists of a bitmap containing a 1-bit opacity for each pixel. This black layer matte has a resolution which is an integer factor of the printer's dot resolution. The highest supported resolution is 1600 dpi, i.e. the printer's full dot resolution.</p>
<p id="p-0091" num="0101">The contone layer consists of a bitmap containing a 32-bit CMYK color for each pixel. This contone image has a resolution which is an integer factor of the printer's dot resolution. The highest supported resolution is 267 ppi, i.e. one-sixth the printer's dot resolution.</p>
<p id="p-0092" num="0102">The contone resolution is also typically an integer factor of the black resolution, to simplify calculations in the printer driver. This is not a requirement, however.</p>
<p id="p-0093" num="0103">The black layer and the contone layer are both in compressed form for efficient transmission over the low-speed USB connection to the printer.</p>
<p id="h-0022" num="0000">5.2.1 Page Structure</p>
<p id="p-0094" num="0104">iPrint has a printable page area which is determined by the width of its printhead, the characteristics of its paper path, and the size of the currently selected print medium.</p>
<p id="p-0095" num="0105">The printable page area has a maximum width of 8″. If the physical page width exceeds 8″, then symmetric left and right margins are implicitly created. If the physical page width is less than 8″, then the printable page width is reduced accordingly. The printable page area has no maximum length. It is simply the physical page length, less the top and bottom margins imposed by the characteristics of the paper path.</p>
<p id="p-0096" num="0106">The target page size is constrained by the printable page area, less the explicit (target) left and top margins specified in the page description.</p>
<p id="p-0097" num="0107">In theory iPrint does not impose a top or bottom margin—i.e. it allows full bleed in the vertical direction. In practice, however, since iPrint is not designed as a full-bleed A4/Letter printer because it uses an 8″ printhead, an artificial top and bottom margin is imposed to avoid having to include a sponge large enough to cope with regular off-edge printing.</p>
<p id="h-0023" num="0000">5.2.2 Page Description Format</p>
<p id="p-0098" num="0108">Table 2 shows the format of the page description expected by iPrint.</p>
<p id="p-0099" num="0109">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 2</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Page description format</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry>field</entry>
<entry>format</entry>
<entry>description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>signature</entry>
<entry>16-bit integer</entry>
<entry>Page description format</entry>
</row>
<row>
<entry/>
<entry/>
<entry>signature.</entry>
</row>
<row>
<entry>version</entry>
<entry>16-bit integer</entry>
<entry>Page description format</entry>
</row>
<row>
<entry/>
<entry/>
<entry>version number.</entry>
</row>
<row>
<entry>structure size</entry>
<entry>16-bit integer</entry>
<entry>Size of fixed-size part</entry>
</row>
<row>
<entry/>
<entry/>
<entry>of page description.</entry>
</row>
<row>
<entry>target resolution</entry>
<entry>16-bit integer</entry>
<entry>Resolution of target page.</entry>
</row>
<row>
<entry>(dpi)</entry>
<entry/>
<entry>This is always</entry>
</row>
<row>
<entry/>
<entry/>
<entry>1600 for iPrint.</entry>
</row>
<row>
<entry>target page width</entry>
<entry>16-bit integer</entry>
<entry>Width of target page, in dots.</entry>
</row>
<row>
<entry>target page height</entry>
<entry>16-bit integer</entry>
<entry>Height of target page, in dots.</entry>
</row>
<row>
<entry>target left margin</entry>
<entry>16-bit integer</entry>
<entry>Width of target left margin,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>in dots.</entry>
</row>
<row>
<entry>target top margin</entry>
<entry>16-bit integer</entry>
<entry>Height of target top margin,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>in dots.</entry>
</row>
<row>
<entry>black scale factor</entry>
<entry>16-bit integer</entry>
<entry>Scale factor from black</entry>
</row>
<row>
<entry/>
<entry/>
<entry>resolution to target resolution</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(must be 2 or greater).</entry>
</row>
<row>
<entry>black page width</entry>
<entry>16-bit integer</entry>
<entry>Width of black page, in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>black pixels.</entry>
</row>
<row>
<entry>black page height</entry>
<entry>16-bit integer</entry>
<entry>Height of black page, in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>black pixels.</entry>
</row>
<row>
<entry>black page data size</entry>
<entry>32-bit integer</entry>
<entry>Size of black page data,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>in bytes.</entry>
</row>
<row>
<entry>contone scale factor</entry>
<entry>16-bit integer</entry>
<entry>Scale factor from contone</entry>
</row>
<row>
<entry/>
<entry/>
<entry>resolution to target resolution</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(must be 6 or greater).</entry>
</row>
<row>
<entry>contone page width</entry>
<entry>16-bit integer</entry>
<entry>Width of contone page, in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>contone pixels.</entry>
</row>
<row>
<entry>contone page height</entry>
<entry>16-bit integer</entry>
<entry>Height of contone page, in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>contone pixels.</entry>
</row>
<row>
<entry>contone page data</entry>
<entry>32-bit integer</entry>
<entry>Size of contone page data,</entry>
</row>
<row>
<entry>size</entry>
<entry/>
<entry>in bytes.</entry>
</row>
<row>
<entry>black page data</entry>
<entry>EDRL</entry>
<entry>Compressed bi-level black</entry>
</row>
<row>
<entry/>
<entry>bytestream</entry>
<entry>page data.</entry>
</row>
<row>
<entry>contone page data</entry>
<entry>JPEG bytestream</entry>
<entry>Compressed contone CMYK</entry>
</row>
<row>
<entry/>
<entry/>
<entry>page data.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0100" num="0110">Apart from being implicitly defined in relation to the printable page area, each page description is complete and self-contained. There is no data transmitted to the printer separately from the page description to which the page description refers.</p>
<p id="p-0101" num="0111">The page description contains a signature and version which allow the printer to identify the page description format. If the signature and/or version are missing or incompatible with the printer, then the printer can reject the page.</p>
<p id="p-0102" num="0112">The page description defines the resolution and size of the target page. The black and contone layers are clipped to the target page if necessary. This happens whenever the black or contone scale factors are not factors of the target page width or height.</p>
<p id="p-0103" num="0113">The target left and top margins define the positioning of the target page within the printable page area.</p>
<p id="p-0104" num="0114">The black layer parameters define the pixel size of the black layer, its integer scale factor to the target resolution, and the size of its compressed page data. The variable-size black page data follows the fixed-size parts of the page description.</p>
<p id="p-0105" num="0115">The contone layer parameters define the pixel size of the contone layer, its integer scale factor to the target resolution, and the size of its compressed page data. The variable-size contone page data follows the variable-size black page data.</p>
<p id="p-0106" num="0116">All integers in the page description are stored in big-endian byte order.</p>
<p id="p-0107" num="0117">The variable-size black page data and the variable-size contone page data are aligned to 8-byte boundaries. The size of the required padding is included in the size of the fixed-size part of the page description structure and the variable-size black data.</p>
<p id="p-0108" num="0118">The entire page description has a target size of less than 3 MB, and a maximum size of 6 MB, in accordance with page buffer memory in the printer.</p>
<p id="p-0109" num="0119">The following sections describe the format of the compressed black layer and the compressed contone layer.</p>
<p id="h-0024" num="0000">5.2.3 Bi-Level Black Layer Compression</p>
<p id="h-0025" num="0000">5.2.3.1 Group 3 and 4 Facsimile Compression</p>
<p id="p-0110" num="0120">The Group 3 Facsimile compression algorithm [1] losslessly compresses bi-level data for transmission over slow and noisy telephone lines. The bi-level data represents scanned black text and graphics on a white background, and the algorithm is tuned for this class of images (it is explicitly not tuned, for example, for halftoned bi-level images). The 1D Group 3 algorithm runlength-encodes each scanline and then Huffman-encodes the resulting runlengths. Runlengths in the range 0 to 63 are coded with terminating codes. Runlengths in the range 64 to 2623 are coded with make-up codes, each representing a multiple of 64, followed by a terminating code. Runlengths exceeding 2623 are coded with multiple make-up codes followed by a terminating code. The Huffman tables are fixed, but are separately tuned for black and white runs (except for make-up codes above 1728, which are common). When possible, the 2D Group 3 algorithm encodes a scanline as a set of short edge deltas (0, ±1, ±2, ±3) with reference to the previous scanline. The delta symbols are entropy-encoded (so that the zero delta symbol is only one bit long etc.) Edges within a 2D-encoded line which can't be delta-encoded are runlength-encoded, and are identified by a prefix. 1D- and 2D-encoded lines are marked differently. 1D-encoded lines are generated at regular intervals, whether actually required or not, to ensure that the decoder can recover from line noise with minimal image degradation. 2D Group 3 achieves compression ratios of up to 6:1 [14].</p>
<p id="p-0111" num="0121">The Group 4 Facsimile algorithm [1] losslessly compresses bi-level data for transmission over error-free communications lines (i.e. the lines are truly error-free, or error-correction is done at a lower protocol level). The Group 4 algorithm is based on the 2D Group 3 algorithm, with the essential modification that since transmission is assumed to be error-free, ID-encoded lines are no longer generated at regular intervals as an aid to error-recovery. Group 4 achieves compression ratios ranging from 20:1 to 60:1 for the CCITT set of test images [14].</p>
<p id="p-0112" num="0122">The design goals and performance of the Group 4 compression algorithm qualify it as a compression algorithm for the bi-level black layer. However, its Huffman tables are tuned to a lower scanning resolution (100-400 dpi), and it encodes runlengths exceeding 2623 awkwardly. At 800 dpi, our maximum runlength is currently 6400. Although a Group 4 decoder core might be available for use in the printer controller chip (Section 7), it might not handle runlengths exceeding those normally encountered in 400 dpi facsimile applications, and so would require modification.</p>
<p id="p-0113" num="0123">Since most of the benefit of Group 4 comes from the delta-encoding, a simpler algorithm based on delta-encoding alone is likely to meet our requirements. This approach is described in detail below.</p>
<p id="h-0026" num="0000">5.2.3.2 Bi-Level Edge Delta and Runlength (EDRL) Compression Format</p>
<p id="p-0114" num="0124">The edge delta and runlength (EDRL) compression format is based loosely on the Group 4 compression format and its precursors [1][18].</p>
<p id="p-0115" num="0125">EDRL uses three kinds of symbols, appropriately entropy-coded. These are create edge, kill edge, and edge delta. Each line is coded with reference to its predecessor. The predecessor of the first line is defined to a line of white. Each line is defined to start off white. If a line actually starts of black (the less likely situation), then it must define a black edge at offset zero. Each line must define an edge at its left-hand end, i.e. at offset page width.</p>
<p id="p-0116" num="0126">An edge can be coded with reference to an edge in the previous line if there is an edge within the maximum delta range with the same sense (white-to-black or black-to-white). This uses one of the edge delta codes. The shorter and likelier deltas have the shorter codes. The maximum delta range (±2) is chosen to match the distribution of deltas for typical glyph edges. This distribution is mostly independent of point size. A typical example is given in Table 3.</p>
<p id="p-0117" num="0127">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 3</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Edge delta distribution for 10 point Times at 800 dpi</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="28pt" align="center"/>
<colspec colname="2" colwidth="140pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>|delta|</entry>
<entry>probability</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="28pt" align="char" char="."/>
<colspec colname="2" colwidth="140pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>0</entry>
<entry>65%</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>23%</entry>
</row>
<row>
<entry/>
<entry>2</entry>
<entry> 7%</entry>
</row>
<row>
<entry/>
<entry>≧3</entry>
<entry> 5%</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0118" num="0128">An edge can also be coded using the length of the run from the previous edge in the same line. This uses one of the create edge codes for short (7-bit) and long (13-bit) runlengths. For simplicity, and unlike Group 4, runlengths are not entropy-coded. In order to keep edge deltas implicitly synchronised with edges in the previous line, each unused edge in the previous line is ‘killed’ when passed in the current line. This uses the kill edge code. The end-of-page code signals the end of the page to the decoder.</p>
<p id="p-0119" num="0129">Note that 7-bit and 13-bit runlengths are specifically chosen to support 800 dpi A4/Letter pages. Longer runlengths could be supported without significant impact on compression performance. For example, if supporting 1600 dpi compression, the runlengths should be at least 8-bit and 14-bit respectively. A general-purpose choice might be 8-bit and 16-bit, thus supporting up to 40″ wide 1600 dpi pages.</p>
<p id="p-0120" num="0130">The full set of codes is defined in Table 4. Note that there is no end-of-line code. The decoder uses the page width to detect the end of the line. The lengths of the codes are ordered by the relative probabilities of the codes' occurrence.</p>
<p id="p-0121" num="0131">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 4</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>EDRL codewords</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="42pt" align="left"/>
<colspec colname="4" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry>code</entry>
<entry>encoding</entry>
<entry>suffix</entry>
<entry>description</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="char" char="."/>
<colspec colname="3" colwidth="42pt" align="left"/>
<colspec colname="4" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry>Δ0</entry>
<entry>1</entry>
<entry>—</entry>
<entry>don't move corresponding</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>edge</entry>
</row>
<row>
<entry>Δ + 1</entry>
<entry>010</entry>
<entry>—</entry>
<entry>move corresponding edge +1</entry>
</row>
<row>
<entry>Δ − 1</entry>
<entry>011</entry>
<entry>—</entry>
<entry>move corresponding edge −1</entry>
</row>
<row>
<entry>Δ + 2</entry>
<entry>00010</entry>
<entry>—</entry>
<entry>move corresponding edge +2</entry>
</row>
<row>
<entry>Δ − 2</entry>
<entry>00011</entry>
<entry>—</entry>
<entry>move corresponding edge −2</entry>
</row>
<row>
<entry>kill edge</entry>
<entry>0010</entry>
<entry>—</entry>
<entry>kill corresponding edge</entry>
</row>
<row>
<entry>create</entry>
<entry>0011</entry>
<entry>7-bit RL</entry>
<entry>create edge from short</entry>
</row>
<row>
<entry>near edge</entry>
<entry/>
<entry/>
<entry>runlength (RL)</entry>
</row>
<row>
<entry>create</entry>
<entry>00001</entry>
<entry>13-bit RL</entry>
<entry>create edge from long</entry>
</row>
<row>
<entry>far edge</entry>
<entry/>
<entry/>
<entry>runlength (RL)</entry>
</row>
<row>
<entry>end-of-page</entry>
<entry>000001</entry>
<entry>—</entry>
<entry>end-of-page marker</entry>
</row>
<row>
<entry>(EOP)</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0122" num="0132"><figref idref="DRAWINGS">FIG. 9</figref> shows an example of coding a simple black and white image <b>90</b>. The image is arranged as lines <b>91</b> of pixels <b>92</b>. The first line <b>91</b> is assumed to be white and, since it is, is coded as Δ0. Note that the common situation of an all-white line following another all-white line is coded using a single bit (Δ0), and an all-black line following another all-black line is coded using two bits (Δ0, Δ0). Where an edge occurs in a line, such as the fourth line <b>93</b>, the create code is used to define the edges. In the next line <b>94</b>, the Δ−1 and Δ+1 codes are used to move the edges. In the next line <b>95</b>, it is more convenient to create a new edge and kill the old edge rather than move it.</p>
<heading id="h-0027" level="1">EDRL ENCODING EXAMPLE</heading>
<p id="p-0123" num="0133">Note that the foregoing describes the compression format, not the compression algorithm per se. A variety of equivalent encodings can be produced for the same image, some more compact than others. For example, a pure runlength encoding conforms to the compression format. The goal of the compression algorithm is to discover a good, if not the best, encoding for a given image.</p>
<p id="p-0124" num="0134">The following is a simple algorithm for producing the EDRL encoding of a line with reference to its predecessor.</p>
<p id="p-0125" num="0135">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="126pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>#define SHORT_RUN_PRECISION7</entry>
<entry> // precision of short run</entry>
</row>
<row>
<entry>#define LONG_RUN_PRECISION13</entry>
<entry> // precision of long run</entry>
</row>
<row>
<entry>EDRL_CompressLine</entry>
</row>
<row>
<entry>(</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Byte prevLine[ ],</entry>
<entry>// previous (reference)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>bi-level line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Byte currLine[ ],</entry>
<entry>// current (coding)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>bi-level line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int lineLen,</entry>
<entry>// line length</entry>
</row>
<row>
<entry/>
<entry>BITSTREAM s</entry>
<entry>// output (compressed)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>bitstream</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int prevEdge = 0</entry>
<entry>// current edge offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>in previous line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int currEdge = 0</entry>
<entry>// current edge offset in</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>current line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int codedEdge = currEdge</entry>
<entry>// most recent coded</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(output) edge</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int prevColor = 0</entry>
<entry>// current color in</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>previous line (0 = white)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int currColor = 0</entry>
<entry>// current color in</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>current line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int prevRun</entry>
<entry>// current run in previous</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int currRun</entry>
<entry>// current run in current</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="126pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>bool bUpdatePrevEdge = true</entry>
<entry>// force first edge update</entry>
</row>
<row>
<entry/>
<entry>bool bUpdateCurrEdge = true</entry>
<entry>// force first edge update</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>while (codedEdge &lt; lineLen)</entry>
</row>
<row>
<entry/>
<entry>// possibly update current edge in previous line</entry>
</row>
<row>
<entry/>
<entry>if (bUpdatePrevEdge)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>if (prevEdge &lt; lineLen)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>prevRun = GetRun(prevLine, prevEdge, lineLen,</entry>
</row>
<row>
<entry/>
<entry>prevColor)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>prevRun = 0</entry>
</row>
<row>
<entry/>
<entry>prevEdge += prevRun</entry>
</row>
<row>
<entry/>
<entry>prevColor = !prevColor</entry>
</row>
<row>
<entry/>
<entry>bUpdatePrevEdge = false</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// possibly update current edge in current line</entry>
</row>
<row>
<entry/>
<entry>if (bUpdateCurrEdge)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>if (currEdge &lt; lineLen)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>currRun = GetRun(currLine, currEdge, lineLen,</entry>
</row>
<row>
<entry/>
<entry>currColor)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
<row>
<entry/>
<entry>currRun = 0</entry>
</row>
<row>
<entry/>
<entry>currEdge += currRun</entry>
</row>
<row>
<entry/>
<entry>currColor = !currColor</entry>
</row>
<row>
<entry/>
<entry>bUpdateCurrEdge = false</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>// output delta whenever possible, i.e. when</entry>
</row>
<row>
<entry>// edge senses match, and delta is small enough</entry>
</row>
<row>
<entry>if (prevColor == currColor)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>delta = currEdge − prevEdge</entry>
</row>
<row>
<entry/>
<entry>if (abs(delta) &lt;= MAX_DELTA)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>PutCode(s, EDGE_DELTA0 + delta)</entry>
</row>
<row>
<entry/>
<entry>codedEdge = currEdge</entry>
</row>
<row>
<entry/>
<entry>bUpdatePrevEdge = true</entry>
</row>
<row>
<entry/>
<entry>bUpdateCurrEdge = true</entry>
</row>
<row>
<entry/>
<entry>continue</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// kill unmatched edge in previous line</entry>
</row>
<row>
<entry/>
<entry>if (prevEdge &lt;= currEdge)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>PutCode(s, KILL_EDGE)</entry>
</row>
<row>
<entry/>
<entry>bUpdatePrevEdge = true</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// create unmatched edge in current line</entry>
</row>
<row>
<entry/>
<entry>if (currEdge &lt;= prevEdge)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>PutCode(s, CREATE_EDGE)</entry>
</row>
<row>
<entry/>
<entry>if (currRun &lt; 128)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>PutCode(s, CREATE_NEAR_EDGE)</entry>
</row>
<row>
<entry/>
<entry>PutBits(currRun, SHORT_RUN_PRECISION)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>PutCode(s, CREATE_FAR_EDGE)</entry>
</row>
<row>
<entry/>
<entry>PutBits(currRun, LONG_RUN_PRECISION)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>codedEdge = currEdge</entry>
</row>
<row>
<entry/>
<entry>bUpdateCurrEdge = true</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0126" num="0136">Note that the algorithm is blind to actual edge continuity between lines, and may in fact match the “wrong” edges between two lines. Happily the compression format has nothing to say about this, since it decodes correctly, and it is difficult for a “wrong” match to have a detrimental effect on the compression ratio.</p>
<p id="p-0127" num="0137">For completeness the corresponding decompression algorithm is given below. It forms the core of the EDRL Expander unit in the printer controller chip (Section 7).</p>
<p id="p-0128" num="0138">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>EDRL_DecompressLine</entry>
</row>
<row>
<entry>(</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>BITSTREAM s,</entry>
<entry> // input (compressed) bitstream</entry>
</row>
<row>
<entry/>
<entry>Byte prevLine[ ],</entry>
<entry>// previous (reference)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="98pt" align="left"/>
<colspec colname="1" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>bi-level line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Byte currLine[ ],</entry>
<entry>// current (coding) bi-level line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="left"/>
<colspec colname="3" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int lineLen</entry>
<entry/>
<entry>// line length</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int prevEdge = 0</entry>
<entry>// current edge offset in</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="98pt" align="left"/>
<colspec colname="1" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>previous line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int currEdge = 0</entry>
<entry>// current edge offset in</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="98pt" align="left"/>
<colspec colname="1" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>current line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int prevColor = 0</entry>
<entry>// current color in previous line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="98pt" align="left"/>
<colspec colname="1" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(0 = white)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>int currColor = 0</entry>
<entry>// current color in current line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>while (currEdge &lt; lineLen)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>code = GetCode(s)</entry>
</row>
<row>
<entry/>
<entry>switch (code)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>case EDGE_DELTA_MINUS2:</entry>
</row>
<row>
<entry/>
<entry>case EDGE_DELTA_MINUS1:</entry>
</row>
<row>
<entry/>
<entry>case EDGE_DELTA_0:</entry>
</row>
<row>
<entry/>
<entry>case EDGE_DELTA_PLUS1:</entry>
</row>
<row>
<entry/>
<entry>case EDGE_DELTA_PLUS2:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// create edge from delta</entry>
</row>
<row>
<entry/>
<entry>int delta = code − EDGE_DELTA_0</entry>
</row>
<row>
<entry/>
<entry>int run = prevEdge + delta − currEdge</entry>
</row>
<row>
<entry/>
<entry>FillBitRun(currLine, currEdge, currColor, run)</entry>
</row>
<row>
<entry/>
<entry>currEdge += run</entry>
</row>
<row>
<entry/>
<entry>currColor = !currColor</entry>
</row>
<row>
<entry/>
<entry>prevEdge += GetRun(prevLine, prevEdge,</entry>
</row>
<row>
<entry/>
<entry>lineLen, prevColor)</entry>
</row>
<row>
<entry/>
<entry>prevColor = !prevColor</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>case KILL_EDGE:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// discard unused reference edge</entry>
</row>
<row>
<entry/>
<entry>prevEdge += GetRun(prevLine, prevEdge,</entry>
</row>
<row>
<entry/>
<entry>lineLen, prevColor)</entry>
</row>
<row>
<entry/>
<entry>prevColor = !prevColor</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>case CREATE_NEAR_EDGE:</entry>
</row>
<row>
<entry/>
<entry>case CREATE_FAR_EDGE:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// create edge explicitly</entry>
</row>
<row>
<entry/>
<entry>int run</entry>
</row>
<row>
<entry/>
<entry>if (code == CREATE_NEAR_EDGE)</entry>
</row>
<row>
<entry/>
<entry>run = GetBits(s, SHORT_RUN_PRECISION)</entry>
</row>
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>run = GetBits(s, LONG_RUN_PRECISION)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>FillBitRun(currLine, currEdge, currColor, run)</entry>
</row>
<row>
<entry/>
<entry>currColor = !currColor</entry>
</row>
<row>
<entry/>
<entry>currEdge += run</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
5.2.3.3 EDRL Compression Performance
</p>
<p id="p-0129" num="0139">Table 5 shows the compression performance of Group 4 and EDRL on the CCITT test documents used to select the Group 4 algorithm. Each document represents a single page scanned at 400 dpi. Group 4's superior performance is due to its entropy-coded runlengths, tuned to 400 dpi features.</p>
<p id="p-0130" num="0140">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 5</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Group 4 and EDRL compression performance</entry>
</row>
<row>
<entry>on standard CCITTT documents at 400 dpi</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77pt" align="center"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="77pt" align="center"/>
<tbody valign="top">
<row>
<entry>CCITT document</entry>
<entry>Group 4</entry>
<entry>EDRL</entry>
</row>
<row>
<entry>number</entry>
<entry>compression ratio</entry>
<entry>compression ratio</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77pt" align="center"/>
<colspec colname="2" colwidth="63pt" align="char" char="."/>
<colspec colname="3" colwidth="77pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>29.1</entry>
<entry>21.6</entry>
</row>
<row>
<entry>2</entry>
<entry>49.9</entry>
<entry>41.3</entry>
</row>
<row>
<entry>3</entry>
<entry>17.9</entry>
<entry>14.1</entry>
</row>
<row>
<entry>4</entry>
<entry>7.3</entry>
<entry>5.5</entry>
</row>
<row>
<entry>5</entry>
<entry>15.8</entry>
<entry>12.4</entry>
</row>
<row>
<entry>6</entry>
<entry>31.0</entry>
<entry>25.5</entry>
</row>
<row>
<entry>7</entry>
<entry>7.4</entry>
<entry>5.3</entry>
</row>
<row>
<entry>8</entry>
<entry>26.7</entry>
<entry>23.4</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0131" num="0141">Magazine text is typically typeset in a typeface with serifs (such as Times) at a point size of 10. At this size an A4/Letter page holds up to 14,000 characters, though a typical magazine page holds only about 7,000 characters. Text is seldom typeset at a point size smaller than 5. At 800 dpi, text cannot be meaningfully rendered at a point size lower than 2 using a standard typeface. Table 6 illustrates the legibility of various point sizes.</p>
<p id="p-0132" num="0142">
<tables id="TABLE-US-00008" num="00008">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 6</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Text at different point sizes</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28pt" align="center"/>
<colspec colname="2" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry>point</entry>
<entry/>
</row>
<row>
<entry>size</entry>
<entry>sample text (in Times)</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28pt" align="char" char="."/>
<colspec colname="2" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry>8</entry>
<entry><chemistry id="CHEM-US-00001" num="00001">
<img id="EMI-C00001" he="2.88mm" wi="52.32mm" file="US07298519-20071120-C00001.TIF" alt="embedded image" img-content="table" img-format="tif"/>
</chemistry>
</entry>
</row>
<row>
<entry> </entry>
</row>
<row>
<entry>9</entry>
<entry><chemistry id="CHEM-US-00002" num="00002">
<img id="EMI-C00002" he="3.22mm" wi="58.93mm" file="US07298519-20071120-C00002.TIF" alt="embedded image" img-content="table" img-format="tif"/>
</chemistry>
</entry>
</row>
<row>
<entry> </entry>
</row>
<row>
<entry>10</entry>
<entry><chemistry id="CHEM-US-00003" num="00003">
<img id="EMI-C00003" he="3.64mm" wi="65.45mm" file="US07298519-20071120-C00003.TIF" alt="embedded image" img-content="table" img-format="tif"/>
</chemistry>
</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0133" num="0143">Table 7 shows Group 4 and EDRL compression performance on pages of text of varying point sizes, rendered at 800 dpi. Note that EDRL achieves the required compression ratio of 2.5 for an entire page of text typeset at a point size of 3. The distribution of characters on the test pages is based on English-language statistics [13].</p>
<p id="p-0134" num="0144">
<tables id="TABLE-US-00009" num="00009">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 7</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Group 4 and EDRL compression performance on text at 800 dpi</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="28pt" align="center"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="42pt" align="center"/>
<colspec colname="4" colwidth="70pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry/>
<entry/>
<entry>Group 4</entry>
<entry>EDRL</entry>
</row>
<row>
<entry/>
<entry>point</entry>
<entry>characters/</entry>
<entry>compression</entry>
<entry>compression</entry>
</row>
<row>
<entry/>
<entry>size</entry>
<entry>A4 page</entry>
<entry>ratio</entry>
<entry>ratio</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="28pt" align="char" char="."/>
<colspec colname="2" colwidth="63pt" align="char" char="."/>
<colspec colname="3" colwidth="42pt" align="char" char="."/>
<colspec colname="4" colwidth="70pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry/>
<entry>2</entry>
<entry>340,000</entry>
<entry>2.3</entry>
<entry>1.7</entry>
</row>
<row>
<entry/>
<entry>3</entry>
<entry>170,000</entry>
<entry>3.2</entry>
<entry>2.5</entry>
</row>
<row>
<entry/>
<entry>4</entry>
<entry>86,000</entry>
<entry>4.7</entry>
<entry>3.8</entry>
</row>
<row>
<entry/>
<entry>5</entry>
<entry>59,000</entry>
<entry>5.5</entry>
<entry>4.9</entry>
</row>
<row>
<entry/>
<entry>6</entry>
<entry>41,000</entry>
<entry>6.5</entry>
<entry>6.1</entry>
</row>
<row>
<entry/>
<entry>7</entry>
<entry>28,000</entry>
<entry>7.7</entry>
<entry>7.4</entry>
</row>
<row>
<entry/>
<entry>8</entry>
<entry>21,000</entry>
<entry>9.1</entry>
<entry>9.0</entry>
</row>
<row>
<entry/>
<entry>9</entry>
<entry>17,000</entry>
<entry>10.2</entry>
<entry>10.4</entry>
</row>
<row>
<entry/>
<entry>10</entry>
<entry>14,000</entry>
<entry>10.9</entry>
<entry>11.3</entry>
</row>
<row>
<entry/>
<entry>11</entry>
<entry>12,000</entry>
<entry>11.5</entry>
<entry>12.4</entry>
</row>
<row>
<entry/>
<entry>12</entry>
<entry>8,900</entry>
<entry>13.5</entry>
<entry>14.8</entry>
</row>
<row>
<entry/>
<entry>13</entry>
<entry>8,200</entry>
<entry>13.5</entry>
<entry>15.0</entry>
</row>
<row>
<entry/>
<entry>14</entry>
<entry>7,000</entry>
<entry>14.6</entry>
<entry>16.6</entry>
</row>
<row>
<entry/>
<entry>15</entry>
<entry>5,800</entry>
<entry>16.1</entry>
<entry>18.5</entry>
</row>
<row>
<entry/>
<entry>20</entry>
<entry>3,400</entry>
<entry>19.8</entry>
<entry>23.9</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0135" num="0145">For a point size of 9 or greater, EDRL slightly outperforms Group 4, simply because Group 4's runlength codes are tuned to 400 dpi.</p>
<p id="p-0136" num="0146">These compression results bear out the observation that entropy-encoded runlengths contribute much less to compression than 2D encoding, unless the data is poorly correlated vertically, such as in the case of very small characters.</p>
<p id="h-0028" num="0000">5.2.4 Contone Layer Compression</p>
<p id="h-0029" num="0000">5.2.4.1 JPEG Compression</p>
<p id="p-0137" num="0147">The JPEG compression algorithm [6] lossily compresses a contone image at a specified quality level. It introduces imperceptible image degradation at compression ratios below 5:1, and negligible image degradation at compression ratios below 10:1 [17].</p>
<p id="p-0138" num="0148">JPEG typically first transforms the image into a color space which separates luminance and chrominance into separate color channels. This allows the chrominance channels to be subsampled without appreciable loss because of the human visual system's relatively greater sensitivity to luminance than chrominance. After this first step, each color channel is compressed separately.</p>
<p id="p-0139" num="0149">The image is divided into 8×8 pixel blocks. Each block is then transformed into the frequency domain via a discrete cosine transform (DCT). This transformation has the effect of concentrating image energy in relatively lower-frequency coefficients, which allows higher-frequency coefficients to be more crudely quantized. This quantization is the principal source of compression in JPEG. Further compression is achieved by ordering coefficients by frequency to maximise the likelihood of adjacent zero coefficients, and then runlength-encoding runs of zeroes. Finally, the runlengths and non-zero frequency coefficients are entropy coded. Decompression is the inverse process of compression.</p>
<p id="h-0030" num="0000">5.2.4.2 CMYK Contone JPEG Compression Format</p>
<p id="p-0140" num="0150">The CMYK contone layer is compressed to an interleaved color JPEG bytestream. The interleaving is required for space-efficient decompression in the printer, but may restrict the decoder to two sets of Huffman tables rather than four (i.e. one per color channel) [17]. If luminance and chrominance are separated, then the luminance channels can share one set of tables, and the chrominance channels the other set.</p>
<p id="p-0141" num="0151">If luminance/chrominance separation is deemed necessary, either for the purposes of table sharing or for chrominance subsampling, then CMY is converted to YCrCb and Cr and Cb are duly subsampled. K is treated as a luminance channel and is not subsampled.</p>
<p id="p-0142" num="0152">The JPEG bytestream is complete and self-contained. It contains all data required for decompression, including quantization and Huffman tables.</p>
<p id="h-0031" num="0000">6 MEMJET Printhead</p>
<p id="p-0143" num="0153">An 8-inch MEMJET printhead consists of two standard 4-inch MEMJET printheads joined together side by side.</p>
<p id="p-0144" num="0154">The two 4-inch printheads are wired up together in a specific way for use in iPrint. Since the wiring requires knowledge of the 4-inch printhead, an overview of the 4-inch printhead is presented here.</p>
<p id="h-0032" num="0000">6.1 Composition of a 4-Inch Printhead</p>
<p id="p-0145" num="0155">Each 4-inch printhead consists of 8 segments, each segment ½ an inch in length. Each of the segments prints bi-level cyan, magenta, yellow and black dots over a different part of the page to produce the final image.</p>
<p id="p-0146" num="0156">Since the printhead prints dots at 1600 dpi, each dot is approximately 22.5 microns in diameter, and spaced 15.875 microns apart. Thus each half-inch segment prints 800 dots, with the 8 segments corresponding to the positions shown in Table 8.</p>
<p id="p-0147" num="0157">
<tables id="TABLE-US-00010" num="00010">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 8</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Final image dots addressed by each segment</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="center"/>
<colspec colname="2" colwidth="7pt" align="center"/>
<colspec colname="3" colwidth="70pt" align="center"/>
<colspec colname="4" colwidth="7pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>Printhead 1</entry>
<entry/>
<entry>Printhead 2</entry>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="56pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="49pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="center"/>
<colspec colname="5" colwidth="49pt" align="center"/>
<tbody valign="top">
<row>
<entry>Segment</entry>
<entry>First dot</entry>
<entry>Last dot</entry>
<entry>First dot</entry>
<entry>Last dot</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="56pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="char" char="."/>
<colspec colname="3" colwidth="49pt" align="char" char="."/>
<colspec colname="4" colwidth="28pt" align="char" char="."/>
<colspec colname="5" colwidth="49pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>0</entry>
<entry>799</entry>
<entry>6,400</entry>
<entry>7,199</entry>
</row>
<row>
<entry>1</entry>
<entry>800</entry>
<entry>1,599</entry>
<entry>7,200</entry>
<entry>7,999</entry>
</row>
<row>
<entry>2</entry>
<entry>1,600</entry>
<entry>2,399</entry>
<entry>8,000</entry>
<entry>8,799</entry>
</row>
<row>
<entry>3</entry>
<entry>2,400</entry>
<entry>3,199</entry>
<entry>8,800</entry>
<entry>9,599</entry>
</row>
<row>
<entry>4</entry>
<entry>3,200</entry>
<entry>3,999</entry>
<entry>9,600</entry>
<entry>10,399</entry>
</row>
<row>
<entry>5</entry>
<entry>4,000</entry>
<entry>4,799</entry>
<entry>10,400</entry>
<entry>11,199</entry>
</row>
<row>
<entry>6</entry>
<entry>4,800</entry>
<entry>5,599</entry>
<entry>11,200</entry>
<entry>11,999</entry>
</row>
<row>
<entry>7</entry>
<entry>5,600</entry>
<entry>6,399</entry>
<entry>12,000</entry>
<entry>12,799</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0148" num="0158">Although each segment produces 800 dots of the final image, each dot is represented by a combination of bi-level cyan, magenta, yellow and black ink. Because the printing is bi-level, the input image should be there or error-diffused for best results.</p>
<p id="p-0149" num="0159">Each segment then contains 3,200 nozzles: 800 each of cyan, magenta, yellow and black. A four-inch printhead contains 8 such segments for a total of 25,600 nozzles.</p>
<p id="h-0033" num="0000">6.1.1. Grouping of Nozzles Within a Segment</p>
<p id="p-0150" num="0160">The nozzles within a single segment are grouped for reasons of physical stability as well as minimization of power consumption during printing. In terms of physical stability, a total of 10 nozzles share the same ink reservoir. In terms of power consumption, groupings are made to enable a low-speed and a high-speed printing mode.</p>
<p id="p-0151" num="0161">The printhead supports two printing speeds to allow speed/power consumption trade-offs to be made in different product configurations.</p>
<p id="p-0152" num="0162">In the low-speed printing mode, 128 nozzles are fired simultaneously from each 4-inch printhead. The fired nozzles should be maximally distant, so 16 nozzles are fired from each segment. To fire all 25,600 nozzles, 200 different sets of 128 nozzles must be fired.</p>
<p id="p-0153" num="0163">In the high-speed printing mode, 256 nozzles are fired simultaneously from each 4-inch printhead. The fired nozzles should be maximally distant, so 32 nozzles are fired from each segment. To fire all 25,600 nozzles, 100 different sets of 256 nozzles must be fired.</p>
<p id="p-0154" num="0164">The power consumption in the low-speed mode is half that of the high-speed mode. Note, however, that the energy consumed to print a page is the same in both cases.</p>
<p id="h-0034" num="0000">6.1.1.1. Ten Nozzles Make a Pod</p>
<p id="p-0155" num="0165">A single pod <b>100</b> consists of 10 nozzles <b>101</b> sharing a common ink reservoir. 5 nozzles are in one row, and 5 are in another. Each nozzle produces dots 22.5 microns in diameter spaced on a 15.875 micron grid. <figref idref="DRAWINGS">FIG. 10</figref> shows the arrangement of a single pod <b>100</b>, with the nozzles <b>101</b> numbered according to the order in which they must be fired.</p>
<p id="p-0156" num="0166">Although the nozzles are fired in this order, the relationship of nozzles and physical placement of dots on the printed page is different. The nozzles from one row represent the even dots from one line on the page, and the nozzles on the other row represent the odd dots from the adjacent line on the page. <figref idref="DRAWINGS">FIG. 11</figref> shows the same pod <b>100</b> with the nozzles numbered according to the order in which they must be loaded.</p>
<p id="p-0157" num="0167">The nozzles within a pod are therefore logically separated by the width of 1 dot. The exact distance between the nozzles will depend on the properties of the MEMJET firing mechanism. The printhead is designed with staggered nozzles designed to match the flow of paper.</p>
<p id="h-0035" num="0000">6.1.1.2 One Pod of Each Color Makes a Chromapod</p>
<p id="p-0158" num="0168">One pod of each color, that is cyan <b>121</b>, magenta <b>122</b>, yellow <b>123</b> and black <b>124</b>, are grouped into a chromapod <b>125</b>. A chromapod represents different color components of the same horizontal set of 10 dots on different lines. The exact distance between different color pods depends on the MEMJET operating parameters, and may vary from one MEMJET design to another. The distance is considered to be a constant number of dot-widths, and must therefore be taken into account when printing: the dots printed by the cyan nozzles will be for different lines than those printed by the magenta, yellow or black nozzles. The printing algorithm must allow for a variable distance up to about 8 dot-widths between colors. <figref idref="DRAWINGS">FIG. 12</figref> illustrates a single chromapod.</p>
<p id="h-0036" num="0000">6.1.13 Five Chromapods Make a Podgroup</p>
<p id="p-0159" num="0169">5 chromapods <b>125</b> are organized into a single podgroup <b>126</b>. Since each chromapod contains 40 nozzles, each podgroup contains 200 nozzles: 50 cyan, 50 magenta, 50 yellow, and 50 black nozzles. The arrangement is shown in <figref idref="DRAWINGS">FIG. 13</figref>, with chromapods numbered 0-4. Note that the distance between adjacent chromapods is exaggerated for clarity.</p>
<p id="h-0037" num="0000">6.1.1.4 Two Podgroups Make a Phasegroup</p>
<p id="p-0160" num="0170">2 podgroups <b>126</b> are organized into a single phasegroup <b>127</b>. The phasegroup is so named because groups of nozzles within a phasegroup are fired simultaneously during a given firing phase (this is explained in more detail below). The formation of a phasegroup from 2 podgroups is entirely for the purposes of low-speed and high-speed printing via 2 PodgroupEnable lines.</p>
<p id="p-0161" num="0171">During low-speed printing, only one of the two PodgroupEnable lines is set in a given firing pulse, so only one podgroup of the two fires nozzles. During high-speed printing, both PodgroupEnable lines are set, so both podgroups fire nozzles. Consequently a low-speed print takes twice as long as a high-speed print, since the high-speed print fires twice as many nozzles at once.</p>
<p id="p-0162" num="0172"><figref idref="DRAWINGS">FIG. 14</figref> illustrates the composition of a phasegroup. The distance between adjacent podgroups is exaggerated for clarity.</p>
<p id="h-0038" num="0000">6.1.1.5 Two Phasegroups Make a Firegroup</p>
<p id="p-0163" num="0173">Two phasegroups <b>127</b> (PhasegroupA and PhasegroupB) are organized into a single firegroup <b>128</b>, with 4 firegroups in each segment <b>129</b>. Firegroups are so named because they all fire the same nozzles simultaneously. Two enable lines, AEnable and BEnable, allow the firing of PhasegroupA nozzles and PhasegroupB nozzles independently as different firing phases. The arrangement is shown in <figref idref="DRAWINGS">FIG. 15</figref>. The distance between adjacent groupings is exaggerated for clarity.</p>
<p id="h-0039" num="0000">6.1.1.6 Nozzle Grouping Summary</p>
<p id="p-0164" num="0174">Table 9 is a summary of the nozzle groupings in a printhead.</p>
<p id="p-0165" num="0175">
<tables id="TABLE-US-00011" num="00011">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 9</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Nozzle Groupings for a single 4-inch printhead</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<colspec colname="3" colwidth="49pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="center"/>
<tbody valign="top">
<row>
<entry>Name of</entry>
<entry/>
<entry>Replication</entry>
<entry>Nozzle</entry>
</row>
<row>
<entry>Grouping</entry>
<entry>Composition</entry>
<entry>Ratio</entry>
<entry>Count</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<colspec colname="3" colwidth="49pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>Nozzle</entry>
<entry>Base unit</entry>
<entry>1:1</entry>
<entry>1</entry>
</row>
<row>
<entry>Pod</entry>
<entry>Nozzles per pod</entry>
<entry>10:1 </entry>
<entry>10</entry>
</row>
<row>
<entry>Chromapod</entry>
<entry>Pods per CMYK chromapod</entry>
<entry>4:1</entry>
<entry>40</entry>
</row>
<row>
<entry>Podgroup</entry>
<entry>Chromapods per podgroup</entry>
<entry>5:1</entry>
<entry>200</entry>
</row>
<row>
<entry>Phasegroup</entry>
<entry>Podgroups per phasegroup</entry>
<entry>2:1</entry>
<entry>400</entry>
</row>
<row>
<entry>Firegroup</entry>
<entry>Phasegroups per firegroup</entry>
<entry>2:1</entry>
<entry>800</entry>
</row>
<row>
<entry>Segment</entry>
<entry>Firegroups per segment</entry>
<entry>4:1</entry>
<entry>3,200</entry>
</row>
<row>
<entry>4-inch</entry>
<entry>Segments per 4-inch</entry>
<entry>8:1</entry>
<entry>25,600</entry>
</row>
<row>
<entry>printhead</entry>
<entry>printhead</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0166" num="0176">An 8-inch printhead consists of two 4-inch printheads for a total of 51,200 nozzles.</p>
<p id="h-0040" num="0000">6.1.2 Load and Print Cycles</p>
<p id="p-0167" num="0177">A single 4-inch printhead contains a total of 25,600 nozzles. A Print Cycle involves the firing of up to all of these nozzles, dependent on the information to be printed. A Load Cycle involves the loading up of the printhead with the information to be printed during the subsequent Print Cycle.</p>
<p id="p-0168" num="0178">Each nozzle has an associated NozzleEnable bit that determines whether or not the nozzle will fire during the Print Cycle. The NozzleEnable bits (one per nozzle) are loaded via a set of shift registers.</p>
<p id="p-0169" num="0179">Logically there are 4 shift registers per segment (one per color), each 800 deep. As bits are shifted into the shift register for a given color they are directed to the lower and upper nozzles on alternate pulses. Internally, each 800-deep shift register is comprised of two 400-deep shift registers: one for the upper nozzles, and one for the lower nozzles. Alternate bits are shifted into the alternate internal registers. As far as the external interface is concerned however, there is a single 800 deep shift register.</p>
<p id="p-0170" num="0180">Once all the shift registers have been fully loaded (800 load pulses), all of the bits are transferred in parallel to the appropriate NozzleEnable bits. This equates to a single parallel transfer of 25,600 bits. Once the transfer has taken place, the Print Cycle can begin The Print Cycle and the Load Cycle can occur simultaneously as long as the parallel load of all NozzleEnable bits occurs at the end of the Print Cycle.</p>
<p id="h-0041" num="0000">6.1.2.1 Load Cycle</p>
<p id="p-0171" num="0181">The Load Cycle is concerned with loading the printhead's shift registers with the next Print Cycle's NozzleEnable bits.</p>
<p id="p-0172" num="0182">Each segment has 4 inputs directly related to the cyan, magenta, yellow and black shift registers. These inputs are called CDataIn, MDataIn, YDataIn and KDataIn. Since there are 8 segments, there are a total of 32 color input lines per 4-inch printhead. A single pulse on the SRClock line (shared between all 8 segments) transfers the 32 bits into the appropriate shift registers. Alternate pulses transfer bits to the lower and upper nozzles respectively. Since there are 25,600 nozzles, a total of 800 pulses are required for the transfer. Once all 25,600 bits have been transferred, a single pulse on the shared PTransfer line causes the parallel transfer of data from the shift registers to the appropriate NozzleEnable bits.</p>
<p id="p-0173" num="0183">The parallel transfer via a pulse on PTransfer must take place after the Print Cycle has finished. Otherwise the NozzleEnable bits for the line being printed will be incorrect.</p>
<p id="p-0174" num="0184">Since all 8 segments are loaded with a single SRClock pulse, any printing process must produce the data in the correct sequence for the printhead. As an example, the first SRClock pulse will transfer the CMYK bits for the next Print Cycle's dot <b>0</b>, <b>800</b>, <b>1600</b>, <b>2400</b>, <b>3200</b>, <b>4000</b>, <b>4800</b>, and <b>5600</b>. The second SRClock pulse will transfer the CMYK bits for the next Print Cycle's dot <b>1</b>, <b>801</b>, <b>1601</b>, <b>2401</b>, <b>3201</b>, <b>4001</b>, <b>4801</b> and <b>5601</b>. After 800 SRClock pulses, the PTransfer pulse can be given.</p>
<p id="p-0175" num="0185">It is important to note that the odd and even CMYK outputs, although printed during the same Print Cycle, do not appear on the same physical output line. The physical separation of odd and even nozzles within the printhead, as well as separation between nozzles of different colors ensures that they will produce dots on different lines of the page. This relative difference must be accounted for when loading the data into the printhead. The actual difference in lines depends on the characteristics of the inkjet mechanism used in the printhead. The differences can be defined by variables D<sub>1 </sub>and D<sub>2 </sub>where D<sub>1 </sub>is the distance between nozzles of different colors, and D<sub>2 </sub>is the distance between nozzles of the same color. Table 10 shows the dots transferred to segment n of a printhead on the first 4 pulses.</p>
<p id="p-0176" num="0186">
<tables id="TABLE-US-00012" num="00012">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 10</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Order of Dots Transferred to a 4-inch Printhead</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="28pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="left"/>
<colspec colname="3" colwidth="49pt" align="left"/>
<colspec colname="4" colwidth="42pt" align="left"/>
<colspec colname="5" colwidth="56pt" align="left"/>
<colspec colname="6" colwidth="49pt" align="left"/>
<tbody valign="top">
<row>
<entry>Pulse</entry>
<entry>Dot</entry>
<entry>Black Line</entry>
<entry>Yellow Line</entry>
<entry>Magenta Line</entry>
<entry>Cyan Line</entry>
</row>
<row>
<entry namest="1" nameend="6" align="center" rowsep="1"/>
</row>
<row>
<entry>1</entry>
<entry>800S<sup>a</sup></entry>
<entry>N</entry>
<entry>N + D<sub>1</sub><sup>b</sup></entry>
<entry>N + 2D<sub>1</sub></entry>
<entry>N + 3D<sub>1</sub></entry>
</row>
<row>
<entry>2</entry>
<entry>800S + 1</entry>
<entry>N + D<sub>2</sub><sup>c</sup></entry>
<entry>N + D<sub>1 </sub>+ D<sub>2</sub></entry>
<entry>N + 2D<sub>1 </sub>+ D<sub>2</sub></entry>
<entry>N + 3D<sub>1 </sub>+ D<sub>2</sub></entry>
</row>
<row>
<entry>3</entry>
<entry>800S + 2</entry>
<entry>N</entry>
<entry>N + D<sub>1</sub></entry>
<entry>N + 2D<sub>1</sub></entry>
<entry>N + 3D<sub>1</sub></entry>
</row>
<row>
<entry>4</entry>
<entry>800S + 3</entry>
<entry>N + D<sub>2</sub></entry>
<entry>N + D<sub>1 </sub>+ D<sub>2</sub></entry>
<entry>N + 2D<sub>1 </sub>+ D<sub>2</sub></entry>
<entry>N + 3D<sub>1 </sub>+ D<sub>2</sub></entry>
</row>
<row>
<entry namest="1" nameend="6" align="center" rowsep="1"/>
</row>
<row>
<entry namest="1" nameend="6" align="left" id="FOO-00001"><sup>a</sup>S = segment number (0–7)</entry>
</row>
<row>
<entry namest="1" nameend="6" align="left" id="FOO-00002"><sup>b</sup>D<sub>1 </sub>= number of lines between the nozzles of one color and the next (likely = 4–8)</entry>
</row>
<row>
<entry namest="1" nameend="6" align="left" id="FOO-00003"><sup>c</sup>D<sub>2 </sub>= number of lines between two rows of nozzles of the same color (likely = 1)</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0177" num="0187">And so on for all 800 pulses.</p>
<p id="p-0178" num="0188">Data can be clocked into the printhead at a maximum rate of 20 MHz, which will load the entire data for the next line in 40 Ts.</p>
<p id="h-0042" num="0000">6.1.2.2 Print Cycle</p>
<p id="p-0179" num="0189">A 4-inch printhead contains 25,600 nozzles. To fire them all at once would consume too much power and be problematic in terms of ink refill and nozzle interference. Consequently two firing modes are defined: a low-speed printing mode and a high-speed printing mode:
<ul id="ul0004" list-style="none">
    <li id="ul0004-0001" num="0190">In the low-speed print mode, there are 200 phases, with each phase firing 128 nozzles. This equates to 16 nozzles per segment, or 4 per firegroup.</li>
    <li id="ul0004-0002" num="0191">In the high-speed print mode, there are 100 phases, with each phase firing 256 nozzles. This equates to 32 nozzles per segment, or 8 per firegroup.</li>
</ul>
</p>
<p id="p-0180" num="0192">The nozzles to be fired in a given firing pulse are determined by
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0193">3 bits ChromapodSelect (select 1 of 5 chromapods from a firegroup)</li>
    <li id="ul0005-0002" num="0194">4 bits NozzleSelect (select 1 of 10 nozzles from a pod)</li>
    <li id="ul0005-0003" num="0195">2 bits of PodgroupEnable lines (select 0, 1, or 2 podgroups to fire)</li>
</ul>
</p>
<p id="p-0181" num="0196">When one of the PodgroupEnable lines is set, only the specified Podgroup's 4 nozzles will fire as determined by ChromapodSelect and NozzleSelect. When both of the PodgroupEnable lines are set, both of the podgroups will fire their nozzles. For the low-speed mode, two fire pulses are required, with PodgroupEnable=10 and 01 respectively. For the high-speed mode, only one fire pulse is required, with PodgroupEnable=11.</p>
<p id="p-0182" num="0197">The duration of the firing pulse is given by the AEnable and BEnable lines, which fire the PhasegroupA and PhasegroupB nozzles from all firegroups respectively. The typical duration of a firing pulse is 1.3-1.8 Ts. The duration of a pulse depends on the viscosity of the ink (dependent on temperature and ink characteristics) and the amount of power available to the printhead. See Section 6.1.3 for details on feedback from the printhead in order to compensate for temperature change.</p>
<p id="p-0183" num="0198">The AEnable and BEnable are separate lines in order that the firing pulses can overlap. Thus the 200 phases of a low-speed Print Cycle consist of 100 A phases and 100 B phases, effectively giving 100 sets of Phase A and Phase B. Likewise, the 100 phases of a high-speed print cycle consist of 50 A phases and 50 B phases, effectively giving 50 phases of phase A and phase B.</p>
<p id="p-0184" num="0199"><figref idref="DRAWINGS">FIG. 16</figref> shows the Aenable <b>130</b> and Benable <b>131</b> lines during a typical Print Cycle. In a high-speed print there are 50 cycles of 2 Ts each, while in a low-speed print there are 100 cycles of 2 Ts each. As shown in the Figure, slight variations in minimum and maximum half cycle times about the nominal, are acceptable.</p>
<p id="p-0185" num="0200">For the high-speed printing mode, the firing order is:
<ul id="ul0006" list-style="none">
    <li id="ul0006-0001" num="0201">ChromapodSelect <b>0</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
    <li id="ul0006-0002" num="0202">ChromapodSelect <b>1</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
    <li id="ul0006-0003" num="0203">ChromapodSelect <b>2</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
    <li id="ul0006-0004" num="0204">ChromapodSelect <b>3</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
    <li id="ul0006-0005" num="0205">ChromapodSelect <b>4</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
    <li id="ul0006-0006" num="0206">ChromapodSelect <b>0</b>, NozzleSelect <b>1</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
    <li id="ul0006-0007" num="0207">ChromapodSelect <b>3</b>, NozzleSelect <b>9</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
    <li id="ul0006-0008" num="0208">ChromapodSelect <b>4</b>, NozzleSelect <b>9</b>, PodgroupEnable <b>11</b> (Phases A and B)</li>
</ul>
</p>
<p id="p-0186" num="0209">For the low-speed printing mode, the firing order is similar. For each phase of the high speed mode where PodgroupEnable was 11, two phases of PodgroupEnable=01 and 10 are substituted as follows:
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0210">ChromapodSelect <b>0</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>01</b> (Phases A and B)</li>
    <li id="ul0007-0002" num="0211">ChromapodSelect <b>0</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>10</b> (Phases A and B)</li>
    <li id="ul0007-0003" num="0212">ChromapodSelect <b>1</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>01</b> (Phases A and B)</li>
    <li id="ul0007-0004" num="0213">ChromapodSelect <b>1</b>, NozzleSelect <b>0</b>, PodgroupEnable <b>10</b> (Phases A and B)</li>
    <li id="ul0007-0005" num="0214">. . .</li>
    <li id="ul0007-0006" num="0215">ChromapodSelect <b>3</b>, NozzleSelect <b>9</b>, PodgroupEnable <b>01</b> (Phases A and B)</li>
    <li id="ul0007-0007" num="0216">ChromapodSelect <b>3</b>, NozzleSelect <b>9</b>, PodgroupEnable <b>10</b> (Phases A and B)</li>
    <li id="ul0007-0008" num="0217">ChromapodSelect <b>4</b>, NozzleSelect <b>9</b>, PodgroupEnable <b>10</b> (Phases A and B)</li>
    <li id="ul0007-0009" num="0218">ChromapodSelect <b>4</b>, NozzleSelect <b>9</b>, PodgroupEnable <b>10</b> (Phases A and B)</li>
</ul>
</p>
<p id="p-0187" num="0219">When a nozzle fires, it takes approximately 100 Ts to refill. The nozzle cannot be fired before this refill time has elapsed. This limits the fastest printing speed to 100 Ts per line. In the high-speed print mode, the time to print a line is 100 Ts, so the time between firing a nozzle from one line to the next matches the refill time. The low-speed print mode is slower than this, so is also acceptable.</p>
<p id="p-0188" num="0220">The firing of a nozzle also causes acoustic perturbations for a limited time within the common ink reservoir of that nozzle's pod. The perturbations can interfere with the firing of another nozzle within the same pod. Consequently, the firing of nozzles within a pod should be offset from each other as long as possible. We therefore fire four nozzles from a chromapod (one nozzle per color) and then move onto the next chromapod within the podgroup.</p>
<p id="p-0189" num="0221">In the low-speed printing mode the podgroups are fired separately. Thus the 5 chromapods within both podgroups must all fire before the first chromapod fires again, totalling 10×2 T cycles. Consequently each pod is fired once per 20 Ts.</p>
<p id="p-0190" num="0222">In the high-speed printing mode, the podgroups are fired together. Thus the 5 chromapods within a single podgroups must all fire before the first chromapod fires again, totalling 5×2 T cycles. Consequently each pod is fired once per 10 Ts.</p>
<p id="p-0191" num="0223">As the ink channel is 300 microns long and the velocity of sound in the ink is around 1500 m/s, the resonant frequency of the ink channel is 2.5 MHz. Thus the low-speed mode allows 50 resonant cycles for the acoustic pulse to dampen, and the high-speed mode allows 25 resonant cycles. Consequently any acoustic interference is minimal in both cases.</p>
<p id="h-0043" num="0000">6.1.3 Feedback from the Printhead</p>
<p id="p-0192" num="0224">The printhead produces several lines of feedback (accumulated from the 8 segments). The feedback lines are used to adjust the timing of the firing pulses. Although each segment produces the same feedback, the feedback from all segments share the same tri-state bus lines. Consequently only one segment at a time can provide feedback.</p>
<p id="p-0193" num="0225">A pulse on the SenseSegSelect line ANDed with data on Cyan selects which segment will provide the feedback. The feedback sense lines will come from the selected segment until the next SenseSegSelect pulse. The feedback sense lines are as follows:
<ul id="ul0008" list-style="none">
    <li id="ul0008-0001" num="0226">Tsense informs the controller how hot the printhead is. This allows the controller to adjust timing of firing pulses, since temperature affects the viscosity of the ink.</li>
    <li id="ul0008-0002" num="0227">Vsense informs the controller how much voltage is available to the actuator. This allows the controller to compensate for a flat battery or high voltage source by adjusting the pulse width.</li>
    <li id="ul0008-0003" num="0228">Rsense informs the controller of the resistivity (Ohms per square) of the actuator heater. This allows the controller to adjust the pulse widths to maintain a constant energy irrespective of the heater resistivity.</li>
    <li id="ul0008-0004" num="0229">Wsense informs the controller of the width of the critical part of the heater, which may vary up to ±5% due to lithographic and etching variations. This allows the controller to adjust the pulse width appropriately.
<br/>
6.1.4 Preheat Cycle
</li>
</ul>
</p>
<p id="p-0194" num="0230">The printing process has a strong tendency to stay at the equilibrium temperature. To ensure that the first section of the printed photograph has a consistent dot size, the equilibrium temperature must be met before printing any dots. This is accomplished via a preheat cycle.</p>
<p id="p-0195" num="0231">The Preheat cycle involves a single Load Cycle to all nozzles with Is (i.e. setting all nozzles to fire), and a number of short firing pulses to each nozzle. The duration of the pulse must be insufficient to fire the drops, but enough to heat up the ink. Altogether about 200 pulses for each nozzle are required, cycling through in the same sequence as a standard Print Cycle.</p>
<p id="p-0196" num="0232">Feedback during the Preheat mode is provided by Tsense, and continues until equilibrium temperature is reached (about 30° C. above ambient). The duration of the Preheat mode is around 50 milliseconds, and depends on the ink composition.</p>
<p id="p-0197" num="0233">Preheat is performed before each print job. This does not affect performance as it is done while the data is being transferred to the printer.</p>
<p id="h-0044" num="0000">6.1.5 Cleaning Cycle</p>
<p id="p-0198" num="0234">In order to reduce the chances of nozzles becoming clogged, a cleaning cycle can be undertaken before each print job. Each nozzle is fired a number of times into an absorbent sponge.</p>
<p id="p-0199" num="0235">The cleaning cycle involves a single Load Cycle to all nozzles with 1s (i.e. setting all nozzles to fire), and a number of firing pulses to each nozzle. The nozzles are cleaned via the same nozzle firing sequence as a standard Print Cycle. The number of times that each nozzle is fired depends upon the ink composition and the time that the printer has been idle. As with preheat, the cleaning cycle has no effect on printer performance.</p>
<p id="h-0045" num="0000">6.1.6 Printhead Interface Summary</p>
<p id="p-0200" num="0236">A single 4inch printhead has the connections shown in Table 11:</p>
<p id="p-0201" num="0237">
<tables id="TABLE-US-00013" num="00013">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 11</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Four-inch Printhead Connections</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry>Name</entry>
<entry>#Pins</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry>ChromapodSelect</entry>
<entry>3</entry>
<entry>Select which chromapod will</entry>
</row>
<row>
<entry/>
<entry/>
<entry>fire (0–4)</entry>
</row>
<row>
<entry>NozzleSelect</entry>
<entry>4</entry>
<entry>Select which nozzle from the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>pod will fire (0–9)</entry>
</row>
<row>
<entry>PodgroupEnable</entry>
<entry>2</entry>
<entry>Enable the podgroups to fire</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(choice of: 01, 10, 11)</entry>
</row>
<row>
<entry>AEnable</entry>
<entry>1</entry>
<entry>Firing pulse for phasegroup A</entry>
</row>
<row>
<entry>BEnable</entry>
<entry>1</entry>
<entry>Firing pulse for phasegroup B</entry>
</row>
<row>
<entry>CDataIn[0–7]</entry>
<entry>8</entry>
<entry>Cyan input to cyan shift register</entry>
</row>
<row>
<entry/>
<entry/>
<entry>of segments 0–7</entry>
</row>
<row>
<entry>MDataIn[0–7]</entry>
<entry>8</entry>
<entry>Magenta input to magenta shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>YDataIn[0–7]</entry>
<entry>8</entry>
<entry>Yellow input to yellow shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>KDataIn[0–7]</entry>
<entry>8</entry>
<entry>Black input to black shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>SRClock</entry>
<entry>1</entry>
<entry>A pulse on SRClock</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(ShiftRegisterClock) loads the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>current values from</entry>
</row>
<row>
<entry/>
<entry/>
<entry>CDataIn[0–7], MDataIn[0–7],</entry>
</row>
<row>
<entry/>
<entry/>
<entry>YDataIn[0–7] and KDataIn[0–7]</entry>
</row>
<row>
<entry/>
<entry/>
<entry>into the 32 shift registers.</entry>
</row>
<row>
<entry>PTransfer</entry>
<entry>1</entry>
<entry>Parallel transfer of data from the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>shift registers to the internal</entry>
</row>
<row>
<entry/>
<entry/>
<entry>NozzleEnable bits (one per nozzle).</entry>
</row>
<row>
<entry>SenseSegSelect</entry>
<entry>1</entry>
<entry>A pulse on SenseSegSelect ANDed</entry>
</row>
<row>
<entry/>
<entry/>
<entry>with data on CDataIn[n] selects</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the sense lines for segment n.</entry>
</row>
<row>
<entry>Tsense</entry>
<entry>1</entry>
<entry>Temperature sense</entry>
</row>
<row>
<entry>Vsense</entry>
<entry>1</entry>
<entry>Voltage sense</entry>
</row>
<row>
<entry>Rsense</entry>
<entry>1</entry>
<entry>Resistivity sense</entry>
</row>
<row>
<entry>Wsense</entry>
<entry>1</entry>
<entry>Width sense</entry>
</row>
<row>
<entry>Logic GND</entry>
<entry>1</entry>
<entry>Logic ground</entry>
</row>
<row>
<entry>Logic PWR</entry>
<entry>1</entry>
<entry>Logic power</entry>
</row>
<row>
<entry>V−</entry>
<entry>Bus</entry>
<entry>Actuator Ground</entry>
</row>
<row>
<entry>V+</entry>
<entry>bars</entry>
<entry>Actuator Power</entry>
</row>
<row>
<entry>TOTAL</entry>
<entry>52</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0202" num="0238">Internal to the 4-inch printhead, each segment has the connections to the bond pads shown in Table 12:</p>
<p id="p-0203" num="0239">
<tables id="TABLE-US-00014" num="00014">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 12</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Four Inch Printhead Internal Segment Connections</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Name</entry>
<entry>#Pins</entry>
<entry>Description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="char" char="."/>
<colspec colname="3" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Chromapod</entry>
<entry>3</entry>
<entry>Select which chromapod will</entry>
</row>
<row>
<entry/>
<entry>Select</entry>
<entry/>
<entry>fire (0–4)</entry>
</row>
<row>
<entry/>
<entry>NozzleSelect</entry>
<entry>4</entry>
<entry>Select which nozzle from the</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>pod will fire (0–9)</entry>
</row>
<row>
<entry/>
<entry>PodgroupEnable</entry>
<entry>2</entry>
<entry>Enable the podgroups to fire</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>(choice of: 01, 10, 11)</entry>
</row>
<row>
<entry/>
<entry>AEnable</entry>
<entry>1</entry>
<entry>Firing pulse for podgroup A</entry>
</row>
<row>
<entry/>
<entry>BEnable</entry>
<entry>1</entry>
<entry>Firing pulse for podgroup B</entry>
</row>
<row>
<entry/>
<entry>CDataIn</entry>
<entry>1</entry>
<entry>Cyan input to cyan shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register</entry>
</row>
<row>
<entry/>
<entry>MDataIn</entry>
<entry>1</entry>
<entry>Magenta input to magenta shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register</entry>
</row>
<row>
<entry/>
<entry>YDataIn</entry>
<entry>1</entry>
<entry>Yellow input to yellow shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register</entry>
</row>
<row>
<entry/>
<entry>KDataIn</entry>
<entry>1</entry>
<entry>Black input to black shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register</entry>
</row>
<row>
<entry/>
<entry>SRClock</entry>
<entry>1</entry>
<entry>A pulse on SRClock</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>(ShiftRegisterClock) loads the</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>current values from CDataIn,</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>MDataIn, YDataIn and KDataIn</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>into the 4 shift registers.</entry>
</row>
<row>
<entry/>
<entry>PTransfer</entry>
<entry>1</entry>
<entry>Parallel transfer of data</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>from the shift registers to</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>the internal NozzleEnable</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>bits (one per nozzle).</entry>
</row>
<row>
<entry/>
<entry>SenseSegSelect</entry>
<entry>1</entry>
<entry>A pulse on SenseSegSelect</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>ANDed with data on</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>CDataIn selects the sense</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>lines for this segment.</entry>
</row>
<row>
<entry/>
<entry>Tsense</entry>
<entry>1</entry>
<entry>Temperature sense</entry>
</row>
<row>
<entry/>
<entry>Vsense</entry>
<entry>1</entry>
<entry>Voltage sense</entry>
</row>
<row>
<entry/>
<entry>Rsense</entry>
<entry>1</entry>
<entry>Resistivity sense</entry>
</row>
<row>
<entry/>
<entry>Wsense</entry>
<entry>1</entry>
<entry>Width sense</entry>
</row>
<row>
<entry/>
<entry>Logic GND</entry>
<entry>1</entry>
<entry>Logic ground</entry>
</row>
<row>
<entry/>
<entry>Logic PWR</entry>
<entry>1</entry>
<entry>Logic power</entry>
</row>
<row>
<entry/>
<entry>V−</entry>
<entry>21</entry>
<entry>Actuator Ground</entry>
</row>
<row>
<entry/>
<entry>V+</entry>
<entry>21</entry>
<entry>Actuator Power</entry>
</row>
<row>
<entry/>
<entry>TOTAL</entry>
<entry>66</entry>
<entry>(66 × 8 segments =</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>528 for all segments)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
6.2 8-Inch Printhead Considerations
</p>
<p id="p-0204" num="0240">An 8-inch MEMJET printhead is simply two 4-inch printheads physically placed together. The printheads are wired together and share many common connections in order that the number of pins from a controlling chip is reduced and that the two printheads can print simultaneously. A number of details must be considered because of this.</p>
<p id="h-0046" num="0000">6.2.1 Connections</p>
<p id="p-0205" num="0241">Since firing of nozzles from the two printheads occurs simultaneously, the ChromapodSelect, NozzleSelect, AEnable and BEnable lines are shared. For loading the printheads with data, the 32 lines of CDataIn, MDataIn, YDataIn and KDataIn are shared, and 2 different SRClock lines are used to determine which of the two printheads is to be loaded. A single PTransfer pulse is used to transfer the loaded data into the NozzleEnable bits for both printheads. Similarly, the Tsense, Vsense, Rsense, and Wsense lines are shared, with 2 SenseEnable lines to distinguish between the two printheads.</p>
<p id="p-0206" num="0242">Therefore the two 4-inch printheads share all connections except SRClock and SenseEnable. These two connections are repeated, once for each printhead. The actual connections are shown here in Table 13:</p>
<p id="p-0207" num="0243">
<tables id="TABLE-US-00015" num="00015">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 13</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>8-inch Printhead Connections</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry>Name</entry>
<entry>#Pins</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry>Chrompod Select</entry>
<entry>3</entry>
<entry>Select which chromapod will</entry>
</row>
<row>
<entry/>
<entry/>
<entry>fire (0–4)</entry>
</row>
<row>
<entry>NozzleSelect</entry>
<entry>4</entry>
<entry>Select which nozzle from the pod</entry>
</row>
<row>
<entry/>
<entry/>
<entry>will fire (0–9)</entry>
</row>
<row>
<entry>PodgroupEnable</entry>
<entry>2</entry>
<entry>Enable the podgroups to fire</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(choice of: 01, 10, 11)</entry>
</row>
<row>
<entry>AEnable</entry>
<entry>1</entry>
<entry>Firing pulse for podgroup A</entry>
</row>
<row>
<entry>BEnable</entry>
<entry>1</entry>
<entry>Firing pulse for podgroup B</entry>
</row>
<row>
<entry>CDataIn[0–7]</entry>
<entry>8</entry>
<entry>Cyan input to cyan shift register</entry>
</row>
<row>
<entry/>
<entry/>
<entry>of segments 0–7</entry>
</row>
<row>
<entry>MDataIn[0–7]</entry>
<entry>8</entry>
<entry>Magenta input to magenta shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>YDataIn[0–7]</entry>
<entry>8</entry>
<entry>Yellow input to yellow shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>KDataIn[0–7]</entry>
<entry>8</entry>
<entry>Black input to black shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>SRClock1</entry>
<entry>1</entry>
<entry>A pulse on SRClock</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(ShiftRegisterClock) loads the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>current values from</entry>
</row>
<row>
<entry/>
<entry/>
<entry>CDataIn[0–7], MDataIn[0–7],</entry>
</row>
<row>
<entry/>
<entry/>
<entry>YDataIn[0–7] and KDataIn[0–7]</entry>
</row>
<row>
<entry/>
<entry/>
<entry>into the 32 shift registers for</entry>
</row>
<row>
<entry/>
<entry/>
<entry>4-inch printhead 1.</entry>
</row>
<row>
<entry>SRClock2</entry>
<entry>1</entry>
<entry>A pulse on SRClock</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(ShiftRegisterClock) loads the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>current values from</entry>
</row>
<row>
<entry/>
<entry/>
<entry>CDataIn[0–7], MDataIn[0–7]</entry>
</row>
<row>
<entry/>
<entry/>
<entry>YDataIn[0–7] and KDataIn[0–7]</entry>
</row>
<row>
<entry/>
<entry/>
<entry>into the 32 shift registers</entry>
</row>
<row>
<entry/>
<entry/>
<entry>for 4-inch printhead 2.</entry>
</row>
<row>
<entry>PTransfer</entry>
<entry>1</entry>
<entry>Parallel transfer of data from</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the shift registers to the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>internal NozzleEnable bits</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(one per nozzle).</entry>
</row>
<row>
<entry>SenseSegSelect1</entry>
<entry>1</entry>
<entry>A pulse on 4-inch printhead</entry>
</row>
<row>
<entry/>
<entry/>
<entry>1's SenseSegSelect line</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ANDed with data on CDataIn[n]</entry>
</row>
<row>
<entry/>
<entry/>
<entry>selects the sense lines for segment n.</entry>
</row>
<row>
<entry>SenseSegSelect2</entry>
<entry>1</entry>
<entry>A pulse on 4-inch printhead</entry>
</row>
<row>
<entry/>
<entry/>
<entry>2's SenseSegSelect line</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ANDed with data on CDataIn[n]</entry>
</row>
<row>
<entry/>
<entry/>
<entry>selects the sense lines for segment n.</entry>
</row>
<row>
<entry>Tsense</entry>
<entry>1</entry>
<entry>Temperature sense</entry>
</row>
<row>
<entry>Vsense</entry>
<entry>1</entry>
<entry>Voltage sense</entry>
</row>
<row>
<entry>Rsense</entry>
<entry>1</entry>
<entry>Resistivity sense</entry>
</row>
<row>
<entry>Wsense</entry>
<entry>1</entry>
<entry>Width sense</entry>
</row>
<row>
<entry>Logic GND</entry>
<entry>1</entry>
<entry>Logic ground</entry>
</row>
<row>
<entry>Logic PWR</entry>
<entry>1</entry>
<entry>Logic power</entry>
</row>
<row>
<entry>V−</entry>
<entry>Bus</entry>
<entry>Actuator Ground</entry>
</row>
<row>
<entry>V+</entry>
<entry>bars</entry>
<entry>Actuator Power</entry>
</row>
<row>
<entry>TOTAL</entry>
<entry>54</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
6.2.2 Timing
</p>
<p id="p-0208" num="0244">The joining of two 4-inch printheads and wiring of appropriate connections enables an 8-inch wide image to be printed as fast as a 4-inch wide image. However, there is twice as much data to transfer to the 2 printheads before the next line can be printed. Depending on the desired speed for the output image to be printed, data must be generated and transferred at appropriate speeds in order to keep up.</p>
<heading id="h-0047" level="1">6.2.2.1 EXAMPLE</heading>
<p id="p-0209" num="0245">As an example, consider the timing of printing an 8″×12″ page in 2 seconds. In order to print this page in 2 seconds, the 8-inch printhead must print 19,200 lines (12×1600). Rounding up to 20,000 lines in 2 seconds yields a line time of 100 Ts. A single Print Cycle and a single Load Cycle must both finish within this time. In addition, a physical process external to the printhead must move the paper an appropriate amount.</p>
<p id="p-0210" num="0246">From the printing point of view, the high-speed print mode allows a 4-inch printhead to print an entire line in 100 Ts. Both 4-inch printheads must therefore be run in high-speed print mode to print simultaneously. Therefore 512 nozzles fire per firing pulse, thereby enabling the printing of an 8-inch line within the specified time.</p>
<p id="p-0211" num="0247">The 800 SRClock pulses to both 4-inch printheads (each clock pulse transferring 32 bits) must also take place within the 100 T line time. If both printheads are loaded simultaneously (64 data lines), the length of an SRClock pulse cannot exceed 100 Ts/800=125 nanoseconds, indicating that the printhead must be clocked at 8 MHz. If the two printheads are loaded one at a time (32 shared data lines), the length of an SRClock pulse cannot exceed 100 Ts/1600=62.5 nanoseconds. The printhead must therefore be clocked at 16 MHz. In both instances, the average time to calculate each bit value (for each of the 51,200 nozzles) must not exceed 100 Ts/51,200=2 nanoseconds. This requires a dot generator running at one of the following speeds:
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0248">500 MHz generating 1 bit (dot) per cycle</li>
    <li id="ul0009-0002" num="0249">250 MHz generating 2 bits (dots) per cycle</li>
    <li id="ul0009-0003" num="0250">125 MHz generating 4 bits (dots) per cycle
<br/>
7 Printer Controller
<br/>
7.1 Printer Controller Architecture
</li>
</ul>
</p>
<p id="p-0212" num="0251">The printer controller consists of the iPrint central processor (ICP) chip <b>83</b>, a 64 MBit RDRAM <b>82</b>, and the master QA chip <b>85</b>, as shown in <figref idref="DRAWINGS">FIG. 8</figref>.</p>
<p id="p-0213" num="0252">The ICP <b>83</b> contains a general-purpose processor <b>139</b> and a set of purpose-specific functional units controlled by the processor via the processor bus, as shown in <figref idref="DRAWINGS">FIG. 17</figref>. Only three functional units are non-standard—the EDRL expander <b>140</b>, the halftoner/compositor <b>141</b>, and the printhead interface <b>142</b> which controls the MEMJET printhead.</p>
<p id="p-0214" num="0253">Software running on the processor coordinates the various functional units to receive, expand and print pages. This is described in the next section.</p>
<p id="p-0215" num="0254">The various functional units of the ICP are described in subsequent sections.</p>
<p id="h-0048" num="0000">7.2 Page Expansion and Printing</p>
<p id="p-0216" num="0255">Page expansion and printing proceeds as follows. A page description is received from the host via the USB interface <b>146</b> and is stored in main memory. 6 MB of main memory is dedicated to page storage. This can hold two pages each not exceeding 3 MB, or one page up to 6 MB. If the host generates pages not exceeding 3 MB, then the printer operates in streaming mode—i.e. it prints one page while receiving the next. If the host generates pages exceeding 3 MB, then the printer operates in single-page mode—i.e. it receives each page and prints it before receiving the next. If the host generates pages exceeding 6 MB then they are rejected by the printer. In practice the printer driver prevents this from happening.</p>
<p id="p-0217" num="0256">A page consists of two parts—the bi-level black layer, and the contone layer. These are compressed in distinct formats—the bi-level black layer in EDRL format, the contone layer in JPEG format. The first stage of page expansion consists of decompressing the two layers in parallel. The bi-level layer is decompressed 16 by the EDRL expander unit <b>140</b>, the contone layer <b>14</b> by the JPEG decoder <b>143</b>.</p>
<p id="p-0218" num="0257">The second stage of page expansion consists of halftoning <b>15</b> the contone CMYK data to bi-level CMYK, and then compositing <b>17</b> the bi-level black layer over the bi-level CMYK layer. The halftoning and compositing is carried out by the halftoner/compositor unit <b>141</b>.</p>
<p id="p-0219" num="0258">Finally, the composited bi-level CMYK image is printed <b>18</b> via the printhead interface unit <b>142</b>, which controls the MEMJET printhead.</p>
<p id="p-0220" num="0259">Because the MEMJET printhead prints at high speed, the paper must move past the printhead at a constant velocity. If the paper is stopped because data can't be fed to the printhead fast enough, then visible printing irregularities will occur. It is therefore important to transfer bi-level CMYK data to the printhead interface at the required rate.</p>
<p id="p-0221" num="0260">A fully-expanded 1600 dpi bi-level CMYK page has a size of 114.3 MB. Because it is impractical to store an expanded page in printer memory, each page is expanded in real time during printing. Thus the various stages of page expansion and printing are pipelined. The page expansion and printing data flow is described in Table 14. The aggregate traffic to/from main memory of 174 MB/s is well within the capabilities of current technologies such as Rambus.</p>
<p id="p-0222" num="0261">
<tables id="TABLE-US-00016" num="00016">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 14</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Page expansion and printing data flow</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry/>
<entry>input</entry>
<entry/>
<entry>output</entry>
<entry>input</entry>
<entry>output</entry>
</row>
<row>
<entry>process</entry>
<entry>input</entry>
<entry>window</entry>
<entry>output</entry>
<entry>window</entry>
<entry>rate</entry>
<entry>rate</entry>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="center"/>
<colspec colname="7" colwidth="21pt" align="right"/>
<colspec colname="8" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>receive</entry>
<entry>—</entry>
<entry>—</entry>
<entry>JPEG</entry>
<entry>1</entry>
<entry>—</entry>
<entry>1.5</entry>
<entry>MB/s</entry>
</row>
<row>
<entry>contone</entry>
<entry/>
<entry/>
<entry>stream</entry>
<entry/>
<entry>—</entry>
<entry>3.3</entry>
<entry>Mp/s</entry>
</row>
<row>
<entry>receive</entry>
<entry>—</entry>
<entry>—</entry>
<entry>EDRL</entry>
<entry>1</entry>
<entry>—</entry>
<entry>1.5</entry>
<entry>MB/s</entry>
</row>
<row>
<entry>bi-level</entry>
<entry/>
<entry/>
<entry>stream</entry>
<entry/>
<entry>—</entry>
<entry>30</entry>
<entry>Mp/s</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="right"/>
<colspec colname="7" colwidth="21pt" align="left"/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>decompress</entry>
<entry>JPEG</entry>
<entry>—</entry>
<entry>32-bit</entry>
<entry>8</entry>
<entry>1.5</entry>
<entry>MB/s</entry>
<entry>13</entry>
<entry>MB/s</entry>
</row>
<row>
<entry>contone</entry>
<entry>stream</entry>
<entry/>
<entry>CMYK</entry>
<entry/>
<entry>3.3</entry>
<entry>Mp/s</entry>
<entry>3.3</entry>
<entry>Mp/s</entry>
</row>
<row>
<entry>decompress</entry>
<entry>EDRL</entry>
<entry>—</entry>
<entry>1-bit K</entry>
<entry>1</entry>
<entry>1.5</entry>
<entry>MB/s</entry>
<entry>14</entry>
<entry>MB/s</entry>
</row>
<row>
<entry>bi-level</entry>
<entry>stream</entry>
<entry/>
<entry/>
<entry/>
<entry>30</entry>
<entry>Mp/s<sup>a</sup></entry>
<entry>120</entry>
<entry>Mp/s</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="right"/>
<colspec colname="7" colwidth="21pt" align="left"/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>halftone</entry>
<entry>32-bit</entry>
<entry>1</entry>
<entry>—<sup>b</sup></entry>
<entry>—</entry>
<entry>13</entry>
<entry>MB/s</entry>
<entry>—</entry>
</row>
<row>
<entry/>
<entry>CMYK</entry>
<entry/>
<entry/>
<entry/>
<entry>3.3</entry>
<entry>Mp/s<sup>c</sup></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="right"/>
<colspec colname="7" colwidth="21pt" align="left"/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>composite</entry>
<entry>1-bit K</entry>
<entry>1</entry>
<entry>4-bit</entry>
<entry>1</entry>
<entry>14</entry>
<entry>MB/s</entry>
<entry>57</entry>
<entry>MB/s</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>CMYK</entry>
<entry/>
<entry>120</entry>
<entry>Mp/s</entry>
<entry>120</entry>
<entry>Mp/s</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="right"/>
<colspec colname="7" colwidth="21pt" align="left"/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>print</entry>
<entry>4-bit</entry>
<entry>24, 1<sup>d</sup></entry>
<entry>—</entry>
<entry>—</entry>
<entry>57</entry>
<entry>MB/s</entry>
<entry>—</entry>
</row>
<row>
<entry/>
<entry>CMYK</entry>
<entry/>
<entry/>
<entry/>
<entry>120</entry>
<entry>Mp/s</entry>
<entry>—</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="right"/>
<colspec colname="7" colwidth="21pt" align="left"/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>87</entry>
<entry>MB/s</entry>
<entry>87</entry>
<entry>MB/s</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>174</entry>
<entry>MB/s</entry>
</row>
<row>
<entry namest="1" nameend="9" align="center" rowsep="1"/>
</row>
<row>
<entry namest="1" nameend="9" align="left" id="FOO-00004"><sup>a</sup>800 dpi <img id="CUSTOM-CHARACTER-00001" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  1600 dpi (2 × 2 expansion)</entry>
</row>
<row>
<entry namest="1" nameend="9" align="left" id="FOO-00005"><sup>b</sup>halftone combines with composite, so there is no external data flow between them</entry>
</row>
<row>
<entry namest="1" nameend="9" align="left" id="FOO-00006"><sup>c</sup>267 ppi <img id="CUSTOM-CHARACTER-00002" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  1600 dpi (6 × 6 expansion)</entry>
</row>
<row>
<entry namest="1" nameend="9" align="left" id="FOO-00007"><sup>d</sup>Needs a window of 24 lines, but only advances 1 line</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0223" num="0262">Each stage communicates with the next via a shared FIFO in main memory. Each FIFO is organised into lines, and the minimum size (in lines) of each FIFO is designed to accommodate the output window (in lines) of the producer and the input window (in lines) of the consumer. The inter-stage main memory buffers are described in Table 15. The aggregate buffer space usage of 6.3 MB leaves 1.7 MB free for program code and scratch memory (out of the 8 MB available).</p>
<p id="p-0224" num="0263">
<tables id="TABLE-US-00017" num="00017">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 15</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Page expansion and printing main memory buffers</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<colspec colname="3" colwidth="49pt" align="center"/>
<colspec colname="4" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>organisation</entry>
<entry/>
<entry>buffer</entry>
</row>
<row>
<entry>buffer</entry>
<entry>and line size</entry>
<entry>number of lines</entry>
<entry>size</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<colspec colname="3" colwidth="49pt" align="center"/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>compressed page buffer</entry>
<entry>byte stream</entry>
<entry>—</entry>
<entry>6</entry>
<entry>MB</entry>
</row>
<row>
<entry>146</entry>
<entry>(one or two pages)</entry>
</row>
<row>
<entry/>
<entry>—</entry>
</row>
<row>
<entry>contone CMYK buffer</entry>
<entry>32-bit interleaved CMYK</entry>
<entry> 8 × 2 = 16</entry>
<entry>134</entry>
<entry>KB</entry>
</row>
<row>
<entry>147</entry>
<entry>(267 ppi × 8″ × 32 = 8.3 KB)</entry>
</row>
<row>
<entry>bi-level K buffer</entry>
<entry>1-bit K</entry>
<entry>1 × 2 = 2</entry>
<entry>3</entry>
<entry>KB</entry>
</row>
<row>
<entry>148</entry>
<entry>(800 dpi × 8″ × 1 = 1.5 KB)</entry>
</row>
<row>
<entry>bi-level CMYK buffer</entry>
<entry>4-bit planar odd/even CMYK</entry>
<entry>24 + 1 = 25</entry>
<entry>156</entry>
<entry>KB</entry>
</row>
<row>
<entry>149</entry>
<entry>(1600 dpi × 8″ × 4 = 6.3 KB)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="217pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="right"/>
<colspec colname="3" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>6.3</entry>
<entry>MB</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0225" num="0264">The overall data flow, including FIFOs, is illustrated in <figref idref="DRAWINGS">FIG. 18</figref>.</p>
<p id="p-0226" num="0265">Contone page decompression is carried out by the JPEG decoder <b>143</b>. Bi-level page decompression is carried out by the EDRL expander <b>140</b>. Halftoning and compositing is carried out by the halftoner/compositor unit <b>141</b>. These functional units are described in the following sections.</p>
<p id="h-0049" num="0000">7.2.1 DMA Approach</p>
<p id="p-0227" num="0266">Each functional unit contains one or more on-chip input and/or output FIFOs. Each FIFO is allocated a separate channel in the multi-channel DMA controller <b>144</b>. The DMA controller <b>144</b> handles single-address rather than double-address transfers, and so provides a separate request/acknowledge interface for each channel.</p>
<p id="p-0228" num="0267">Each functional unit stalls gracefully whenever an input FIFO is exhausted or an output FIFO is filled.</p>
<p id="p-0229" num="0268">The processor <b>139</b> programs each DMA transfer. The DMA controller <b>144</b> generates the address for each word of the transfer on request from the functional unit connected to the channel. The functional unit latches the word onto or off the data bus <b>145</b> when its request is acknowledged by the DMA controller <b>144</b>. The DMA controller <b>144</b> interrupts the processor <b>139</b> when the transfer is complete, thus allowing the processor <b>139</b> to program another transfer on the same channel in a timely fashion.</p>
<p id="p-0230" num="0269">In general the processor <b>139</b> will program another transfer on a channel as soon as the corresponding main memory FIFO is available (i.e. non-empty for a read, non-full for a write).</p>
<p id="p-0231" num="0270">The granularity of channel servicing implemented in the DMA controller <b>144</b> depends somewhat on the latency of main memory.</p>
<p id="h-0050" num="0000">7.2.2 EDRL Expander</p>
<p id="p-0232" num="0271">The EDRL expander unit (EEU) <b>140</b>, shown in <figref idref="DRAWINGS">FIG. 19</figref>, decompresses an EDRL-compressed bi-level image.</p>
<p id="p-0233" num="0272">The input to the EEU is an EDRL bitstream <b>150</b>. The output from the EEU is a set of bi-level image lines <b>151</b>, scaled horizontally from the resolution of the expanded bi-level image by an integer scale factor to 1600 dpi.</p>
<p id="p-0234" num="0273">Once started, the EEU proceeds until it detects an end-of-page code in the EDRL bitstream, or until it is explicitly stopped via its control register.</p>
<p id="p-0235" num="0274">The EEU relies on an explicit page width to decode the bitstream. This must be written to the page width register <b>152</b> prior to starting the EEU.</p>
<p id="p-0236" num="0275">The scaling of the expanded bi-level image relies on an explicit scale factor. This must be written to the scalefactor register <b>153</b> prior to starting the EEU.</p>
<p id="p-0237" num="0276">
<tables id="TABLE-US-00018" num="00018">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 16</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>EDRL expander control and configuration registers</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="49pt" align="center"/>
<colspec colname="3" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>register</entry>
<entry>width</entry>
<entry>description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="49pt" align="char" char="."/>
<colspec colname="3" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>start</entry>
<entry>1</entry>
<entry>Start the EEU.</entry>
</row>
<row>
<entry/>
<entry>stop</entry>
<entry>1</entry>
<entry>Stop the EEU.</entry>
</row>
<row>
<entry/>
<entry>page width</entry>
<entry>13</entry>
<entry>Page width used during</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>decoding to detect end-of-line.</entry>
</row>
<row>
<entry/>
<entry>scale factor</entry>
<entry>4</entry>
<entry>Scale factor used during</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>scaling of expanded image.</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0238" num="0277">The EDRL compression format is described in Section 5.2.3. It represents a bi-level image in terms of its edges. Each edge in each line is coded relative to an edge in the previous line, or relative to the previous edge in the same line. No matter how it is coded, each edge is ultimately decoded to its distance from the previous edge in the same line. This distance, or runlength, is then decoded to the string of one bits or zero bits which represent the corresponding part of the image. The decompression algorithm is also defined in Section 5.2.3.2.</p>
<p id="p-0239" num="0278">The EEU consists of a bitstream decoder <b>154</b>, a state machine <b>155</b>, edge calculation logic <b>156</b>, two runlength decoders <b>157</b> and <b>158</b>, and a runlength (re)encoder <b>159</b>.</p>
<p id="p-0240" num="0279">The bitstream decoder <b>154</b> decodes an entropy-coded codeword from the bitstream and passes it to the state machine <b>155</b>. The state machine <b>155</b> returns the size of the codeword to the bitstream decoder <b>154</b>, which allows the decoder <b>154</b> to advance to the next codeword. In the case of a create edge code, the state machine <b>155</b> uses the bitstream decoder to extract the corresponding runlength from the bitstream. The state machine controls the edge calculation logic and runlength decoding/encoding as defined in Table 18.</p>
<p id="p-0241" num="0280">The edge calculation logic is quite simple. The current edge offset in the previous (reference) and current (coding) lines are maintained in the reference edge register <b>160</b> and edge register <b>161</b> respectively. The runlength associated with a create edge code is output directly to the runlength decoders, and is added to the current edge. A delta code is translated into a runlength by adding the associated delta to the reference edge and subtracting the current edge. The generated runlength is output to the runlength decoders, and is added to the current edge. The next runlength is extracted from the runlength encoder <b>159</b> and added to the reference edge <b>160</b>. A kill edge code simply causes the current reference edge to be skipped. Again the next runlength is extracted from the runlength encoder and added to the reference edge.</p>
<p id="p-0242" num="0281">Each time the edge calculation logic <b>156</b> generates a runlength representing an edge, it is passed to the runlength decoders. While the runlength decoder decodes the run it generates a stall signal to the state machine. Since the runlength decoder <b>157</b> is slower than the edge calculation logic, there's not much point in decoupling it. The expanded line accumulates in a line buffer <b>162</b> large enough to hold an 8″ 800 dpi line (800 bytes).</p>
<p id="p-0243" num="0282">The previously expanded line is also buffered <b>163</b>. It acts as a reference for the decoding of the current line. The previous line is re-encoded as runlengths on demand. This is less expensive than buffering the decoded runlengths of the previous line, since the worst case is one 13-bit runlength for each pixel (20 KB at 1600 dpi). While the runlength encoder <b>159</b> encodes the run it generates a stall signal to the state machine. The runlength encoder uses the page width <b>152</b> to detect end-of-line. The (current) line buffer <b>162</b> and the previous line buffer <b>163</b> are concatenated and managed as a single FIFO to simplify the runlength encoder <b>159</b>.</p>
<p id="p-0244" num="0283">Runlength decoder <b>158</b> decodes the output runlength to a line buffer <b>164</b> large enough to hold an 8″ 1600 dpi line (1600 bytes). The runlength passed to this output runlength decoder is multiplied by the scale factor <b>153</b>, so this decoder produces 1600 dpi lines. The line is output scale factor times through the output pixel FIFO <b>165</b>. This achieves the required vertical scaling by simple line replication. The EEU could be designed with edge smoothing integrated into its image scaling. A simple smoothing scheme based on template-matching can be very effective [10]. This would require a multi-line buffer between the low-resolution runlength decoder and the smooth scaling unit, but would eliminate the high-resolution runlength decoder.</p>
<p id="h-0051" num="0000">7.2.2.1 EDRL Stream Decoder</p>
<p id="p-0245" num="0284">The EDRL stream decoder <b>154</b>, illustrated in <figref idref="DRAWINGS">FIG. 20</figref>, decodes entropy-coded EDRL codewords in the input bitstream. It uses a two-byte input buffer <b>167</b> viewed through a 16-bit barrel shifter <b>168</b> whose left (most significant) edge is always aligned to a codeword boundary in the bitstream. The decoder <b>169</b> connected to the barrel shifter <b>168</b> decodes a codeword according to Table 17, and supplies the state machine <b>155</b> with the corresponding code.</p>
<p id="p-0246" num="0285">
<tables id="TABLE-US-00019" num="00019">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 17</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>EDRL stream codeword decoding table</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="77pt" align="left"/>
<colspec colname="3" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>input codeword</entry>
<entry/>
<entry>output code</entry>
</row>
<row>
<entry/>
<entry>bit pattern<sup>a</sup></entry>
<entry>output code</entry>
<entry>bit pattern</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>1xxx xxxx</entry>
<entry>Δ0</entry>
<entry>1 0000 0000</entry>
</row>
<row>
<entry/>
<entry>010x xxxx</entry>
<entry>Δ + 1</entry>
<entry>0 1000 0000</entry>
</row>
<row>
<entry/>
<entry>011x xxxx</entry>
<entry>Δ − 1</entry>
<entry>0 0100 0000</entry>
</row>
<row>
<entry/>
<entry>0010 xxxx</entry>
<entry>kill edge</entry>
<entry>0 0010 0000</entry>
</row>
<row>
<entry/>
<entry>0011 xxxx</entry>
<entry>create near edge</entry>
<entry>0 0001 0000</entry>
</row>
<row>
<entry/>
<entry>0001 0xxx</entry>
<entry>Δ + 2</entry>
<entry>0 0000 1000</entry>
</row>
<row>
<entry/>
<entry>0001 1xxx</entry>
<entry>Δ − 2</entry>
<entry>0 0000 0100</entry>
</row>
<row>
<entry/>
<entry>0000 1xxx</entry>
<entry>create far edge</entry>
<entry>0 0000 0010</entry>
</row>
<row>
<entry/>
<entry>0000 01xx</entry>
<entry>end-of-page (EOP)</entry>
<entry>0 0000 0001</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="left" id="FOO-00008"><sup>a</sup>x = don't care</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0247" num="0286">The state machine <b>155</b> in turn outputs the length of the code. This is added <b>170</b>, modulo-<b>8</b>, to the current codeword bit offset to yield the next codeword bit offset. The bit offset in turn controls the barrel shifter <b>168</b>. If the codeword bit offset wraps, then the carry bit controls the latching of the next byte from the input FIFO <b>166</b>. At this time byte <b>2</b> is latched to byte <b>1</b>, and the FIFO output is latched to byte <b>2</b>. It takes two cycles of length <b>8</b> to fill the input buffer. This is handled by starting states in the state machine <b>155</b>.</p>
<p id="h-0052" num="0000">7.2.2.2 EDRL Expander State Machine</p>
<p id="p-0248" num="0287">The EDRL expander state machine <b>155</b> controls the edge calculation and runlength expansion logic in response to codes supplied by the EDRL stream decoder <b>154</b>. It supplies the EDRL stream decoder with the length of the current codeword and supplies the edge calculation logic with the delta value associated with the current delta code. The state machine also responds to start and stop control signals from the control register, and the end-of-line (EOL) signal from the edge calculation logic.</p>
<p id="p-0249" num="0288">The state machine also controls the multi-cycle fetch of the runlength associated with a create edge code.</p>
<p id="p-0250" num="0289">
<tables id="TABLE-US-00020" num="00020">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 18</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>EDRL expander state machine</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="21pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="left"/>
<colspec colname="4" colwidth="35pt" align="left"/>
<colspec colname="5" colwidth="21pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="98pt" align="left"/>
<tbody valign="top">
<row>
<entry>input</entry>
<entry>input</entry>
<entry>current</entry>
<entry>next</entry>
<entry>code</entry>
<entry/>
<entry/>
</row>
<row>
<entry>signal</entry>
<entry>code</entry>
<entry>state</entry>
<entry>state</entry>
<entry>len</entry>
<entry>delta</entry>
<entry>actions</entry>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
<row>
<entry>start</entry>
<entry>—</entry>
<entry>stopped</entry>
<entry>starting</entry>
<entry>8</entry>
<entry>—</entry>
<entry>—</entry>
</row>
<row>
<entry>—</entry>
<entry>—</entry>
<entry>starting</entry>
<entry>idle</entry>
<entry>8</entry>
<entry>—</entry>
<entry>—</entry>
</row>
<row>
<entry>stop</entry>
<entry>—</entry>
<entry>—</entry>
<entry>stopped</entry>
<entry>0</entry>
<entry>—</entry>
<entry>reset RL decoders and FIFOs</entry>
</row>
<row>
<entry>EOL</entry>
<entry>—</entry>
<entry>—</entry>
<entry>EOL 1</entry>
<entry>0</entry>
<entry>—</entry>
<entry>reset RL encoder;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>reset RL decoders;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>reset ref. edge and edge</entry>
</row>
<row>
<entry>—</entry>
<entry>—</entry>
<entry>EOL 1</entry>
<entry>idle</entry>
<entry/>
<entry/>
<entry>RL encoder <img id="CUSTOM-CHARACTER-00003" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  ref. RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>ref. edge += ref. RL</entry>
</row>
<row>
<entry>—</entry>
<entry>D0</entry>
<entry>idle</entry>
<entry>idle</entry>
<entry>1</entry>
<entry>0</entry>
<entry>RL = edge − ref. edge + delta;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>edge += RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL <img id="CUSTOM-CHARACTER-00004" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  RL decoder;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL encoder <img id="CUSTOM-CHARACTER-00005" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  ref. RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>ref. edge += ref. RL</entry>
</row>
<row>
<entry>—</entry>
<entry>Δ + 1</entry>
<entry>idle</entry>
<entry>idle</entry>
<entry>2</entry>
<entry>+1</entry>
<entry>RL = edge − ref. edge + delta;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>edge += RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL <img id="CUSTOM-CHARACTER-00006" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  RL decoder;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL encoder <img id="CUSTOM-CHARACTER-00007" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  ref. RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>ref. edge += ref. RL</entry>
</row>
<row>
<entry>—</entry>
<entry>Δ − 1</entry>
<entry>idle</entry>
<entry>idle</entry>
<entry>3</entry>
<entry>−1</entry>
<entry>RL = edge − ref. edge + delta;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>edge += RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL <img id="CUSTOM-CHARACTER-00008" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  RL decoder;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL encoder <img id="CUSTOM-CHARACTER-00009" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  ref. RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>ref. edge += ref. RL</entry>
</row>
<row>
<entry>—</entry>
<entry>Δ + 2</entry>
<entry>idle</entry>
<entry>idle</entry>
<entry>4</entry>
<entry>+2</entry>
<entry>RL = edge − ref. edge + delta;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>edge += RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL <img id="CUSTOM-CHARACTER-00010" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  RL decoder;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL encoder <img id="CUSTOM-CHARACTER-00011" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  ref. RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>ref. edge += ref. RL</entry>
</row>
<row>
<entry>—</entry>
<entry>Δ − 2</entry>
<entry>idle</entry>
<entry>idle</entry>
<entry>5</entry>
<entry>−2</entry>
<entry>RL = edge − ref. edge + delta;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>edge += RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL <img id="CUSTOM-CHARACTER-00012" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  RL decoder;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL encoder <img id="CUSTOM-CHARACTER-00013" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  ref. RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>ref. edge += ref. RL</entry>
</row>
<row>
<entry>—</entry>
<entry>kill edge</entry>
<entry>idle</entry>
<entry>idle</entry>
<entry>6</entry>
<entry>—</entry>
<entry>RL encoder <img id="CUSTOM-CHARACTER-00014" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  ref. RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>ref. edge += ref. RL</entry>
</row>
<row>
<entry>—</entry>
<entry>create</entry>
<entry>idle</entry>
<entry>create RL</entry>
<entry>7</entry>
<entry>—</entry>
<entry>reset create RL</entry>
</row>
<row>
<entry/>
<entry>near edge</entry>
<entry/>
<entry>lo 7</entry>
</row>
<row>
<entry>—</entry>
<entry>create</entry>
<entry>idle</entry>
<entry>create RL</entry>
<entry>8</entry>
<entry>—</entry>
<entry>—</entry>
</row>
<row>
<entry/>
<entry>far edge</entry>
<entry/>
<entry>hi 6</entry>
</row>
<row>
<entry>—</entry>
<entry>EOP</entry>
<entry>idle</entry>
<entry>stopped</entry>
<entry>8</entry>
<entry>—</entry>
<entry>—</entry>
</row>
<row>
<entry>—</entry>
<entry>—</entry>
<entry>create RL</entry>
<entry>create RL</entry>
<entry>6</entry>
<entry>—</entry>
<entry>latch create RL hi 6</entry>
</row>
<row>
<entry/>
<entry/>
<entry>hi 6</entry>
<entry>lo 7</entry>
</row>
<row>
<entry>—</entry>
<entry>—</entry>
<entry>create RL</entry>
<entry>create</entry>
<entry>7</entry>
<entry>—</entry>
<entry>latch create RL lo 7</entry>
</row>
<row>
<entry/>
<entry/>
<entry>lo 7</entry>
<entry>edge</entry>
</row>
<row>
<entry>—</entry>
<entry>—</entry>
<entry>create</entry>
<entry>idle</entry>
<entry>0</entry>
<entry>—</entry>
<entry>RL = create RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>edge</entry>
<entry/>
<entry/>
<entry/>
<entry>edge += RL;</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>RL <img id="CUSTOM-CHARACTER-00015" he="2.12mm" wi="2.46mm" file="US07298519-20071120-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>  RL encoder</entry>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.2.23 Runlength Decoder
</p>
<p id="p-0251" num="0290">The runlength decoder <b>157</b>/<b>158</b>, shown in <figref idref="DRAWINGS">FIG. 21</figref>, expands a runlength into a sequence of zero bits or one bits of the corresponding length in the output stream. The first run in a line is assumed to be white (color 0). Each run is assumed to be of the opposite color to its predecessor. If the first run is actually black (color 1), then it must be preceded by a zero-length white run. The runlength decoder keeps track of the current color internally.</p>
<p id="p-0252" num="0291">The runlength decoder appends a maximum of 8 bits to the output stream every clock. Runlengths are typically not an integer multiple of 8, and so runs other than the first in an image are typically not byte-aligned. The run decoder maintains, in the byte space register <b>180</b>, the number of bits available in the byte currently being built. This is initialised to 8 at the beginning of decoding, and on the output of every byte.</p>
<p id="p-0253" num="0292">The decoder starts outputting a run of bits as soon as the next run line latches a non-zero value into the runlength register <b>181</b>. The decoder effectively stalls when the runlength register goes to zero.</p>
<p id="p-0254" num="0293">A number of bits of the current color are shifted into the output byte register <b>182</b> each clock. The current color is maintained in the 1-bit color register <b>183</b>. The number of bits actually output is limited by the number of bits left in the runlength, and by the number of spare bits left in the output byte. The number of bits output is subtracted from the runlength and the byte space. When the runlength goes to zero it has been completely decoded, although the trailing bits of the run may still be in the output byte register, pending output. When the byte space goes to zero the output byte is full and is appended to the output stream.</p>
<p id="p-0255" num="0294">The 16-bit barrel shifter <b>184</b>, the output byte register <b>182</b> and the color register <b>183</b> together implement an 8-bit shift register which can be shifted multiple bit positions every clock, with the color as the serial input.</p>
<p id="p-0256" num="0295">The external reset line is used to reset the runlength decoder at the start of a line. The external next run line is used to request the decoding of a new runlength. It is accompanied by a runlength on the external runlength lines. The next run line should not be set on the same clock as the reset line. Because next run inverts the current color, the reset of the color sets it to one, not zero. The extemalflush line is used to flush the last byte of the run, if incomplete. It can be used on a line-by-line basis to yield byte-aligned lines, or on an image basis to yield a byte-aligned image.</p>
<p id="p-0257" num="0296">The external ready line indicates whether the runlength decoder is ready to decode a runlength. It can be used to stall the external logic.</p>
<p id="h-0053" num="0000">7.2.2.4 Runlength Encoder</p>
<p id="p-0258" num="0297">The runlength encoder <b>159</b>, shown in <figref idref="DRAWINGS">FIG. 22</figref>, detects a run of zero or one bits in the input stream. The first run in a line is assumed to be white (color 0). Each run is assumed to be of the opposite color to its predecessor. If the first run is actually black (color 1), then the runlength encoder generates a zero-length white run at the start of the line. The runlength decoder keeps track of the current color internally.</p>
<p id="p-0259" num="0298">The runlength encoder reads a maximum of 8 bits from the input stream every clock. It uses a two-byte input buffer <b>190</b> viewed through a 16-bit barrel shifter <b>191</b> whose left (most significant) edge is always aligned to the current position in the bitstream. The encoder <b>192</b> connected to the barrel shifter encodes an 8-bit (partial) runlength according to Table 19. The encoder <b>192</b> uses the current color to recognise runs of the appropriate color.</p>
<p id="p-0260" num="0299">The 8-bit runlength generated by the 8-bit runlength encoder is added to the value in the runlength register <b>193</b>. When the 8-bit runlength encoder recognises the end of the current run it generates an end-of-run signal which is latched by the ready register <b>194</b>. The output of the ready register <b>194</b> indicates that the encoder has completed encoding the current runlength, accumulated in the runlength register <b>193</b>. The output of the ready register <b>194</b> is also used to stall the 8-bit runlength encoder <b>192</b>. When stalled the 8-bit runlength encoder <b>192</b> outputs a zero-length run and a zero end-of-run signal, effectively stalling the entire runlength encoder.</p>
<p id="p-0261" num="0300">
<tables id="TABLE-US-00021" num="00021">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 19</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>8-bit runlength encoder table</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="28pt" align="center"/>
<colspec colname="2" colwidth="70pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="70pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>color</entry>
<entry>input</entry>
<entry>length</entry>
<entry>end-of-run</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>0000 0000</entry>
<entry>8</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>0000 0001</entry>
<entry>7</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>0000 001x</entry>
<entry>6</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>0000 01xx</entry>
<entry>5</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>0000 1xxx</entry>
<entry>4</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>0001 xxxx</entry>
<entry>3</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>001x xxxx</entry>
<entry>2</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>01xx xxxx</entry>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>1xxx xxxx</entry>
<entry>0</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1111 1111</entry>
<entry>8</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1111 1110</entry>
<entry>7</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1111 110x</entry>
<entry>6</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1111 10xx</entry>
<entry>5</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1111 0xxx</entry>
<entry>4</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1110 xxxx</entry>
<entry>3</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>110x xxxx</entry>
<entry>2</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>10xx xxxx</entry>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>0xxx xxxx</entry>
<entry>0</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0262" num="0301">The output of the 8-bit runlength encoder <b>192</b> is limited by the remaining page width. The actual 8-bit runlength is subtracted from the remaining page width, and is added <b>195</b> to the modulo-<b>8</b> bit position used to control the barrel shifter <b>191</b> and clock the byte stream input.</p>
<p id="p-0263" num="0302">The external reset line is used to reset the runlength encoder at the start of a line. It resets the current color and latches the page width into the page width register. The external next run line is used to request another runlength from the runlength encoder. It inverts the current color, and resets the runlength register and ready register. The externalflush line is used to flush the last byte of the run, if incomplete. It can be used on a line-by-line basis to process byte-aligned lines, or on an image basis to process a byte-aligned image.</p>
<p id="p-0264" num="0303">The external ready line indicates that the runlength encoder is ready to encode a runlength, and that the current runlength is available on the runlength lines. It can be used to stall the external logic.</p>
<p id="h-0054" num="0000">7.2.3 JPEG Decoder</p>
<p id="p-0265" num="0304">The JPEG decoder <b>143</b>, shown in <figref idref="DRAWINGS">FIG. 23</figref>, decompresses a JPEG-compressed CMYK contone image.</p>
<p id="p-0266" num="0305">The input to the JPEG decoder is a JPEG bitstream. The output from the JPEG decoder is a set of contone CMYK image lines.</p>
<p id="p-0267" num="0306">When decompressing, the JPEG decoder writes its output in the form of 8×8 pixel blocks. These are sometimes converted to full-width lines via an page width×8 strip buffer closely coupled with the codec. This would require a 67 KB buffer. We instead use 8 parallel pixel FIFOs with shared bus access and 8 corresponding DMA channels, as shown in <figref idref="DRAWINGS">FIG. 23</figref>.</p>
<p id="h-0055" num="0000">7.2.4 Halftoner/Compositor</p>
<p id="p-0268" num="0307">The halftoner/compositor unit (HCU) <b>141</b>, shown in <figref idref="DRAWINGS">FIG. 24</figref>, combines the functions of halftoning the contone CMYK layer to bi-level CMYK, and compositing the black layer over the halftoned contone layer.</p>
<p id="p-0269" num="0308">The input to the HCU is an expanded 267 ppi CMYK contone layer <b>200</b>, and an expanded 1600 dpi black layer <b>201</b>. The output from the HCU is a set of 1600 dpi bi-level CMYK image lines <b>202</b>.</p>
<p id="p-0270" num="0309">Once started, the HCU proceeds until it detects an end-of-page condition, or until it is explicitly stopped via its control register.</p>
<p id="p-0271" num="0310">The HCU generates a page of dots of a specified width and length. The width and length must be written to the page width and page length registers prior to starting the HCU. The page width corresponds to the width of the printhead <b>171</b>. The page length corresponds to the length of the target page.</p>
<p id="p-0272" num="0311">The HCU generates target page data between specified left and right margins relative to the page width. The positions of the left and right margins must be written to the left margin and right margin registers prior to starting the HCU. The distance from the left margin to the right margin corresponds to the target page width.</p>
<p id="p-0273" num="0312">The HCU consumes black and contone data according to specified black <b>172</b> and contone <b>173</b> page widths. These page widths must be written to the black page width and contone page width registers prior to starting the HCU. The HCU clips black and contone data to the target page width <b>174</b>. This allows the black and contone page widths to exceed the target page width without requiring any special end-of-line logic at the input FIFO level.</p>
<p id="p-0274" num="0313">The relationships between the page width <b>171</b>, the black <b>172</b> and contone <b>173</b> page widths, and the margins are illustrated in <figref idref="DRAWINGS">FIG. 25</figref>.</p>
<p id="p-0275" num="0314">The HCU scales contone data to printer resolution both horizontally and vertically based on a specified scale factor. This scale factor must be written to the contone scalefactor register prior to starting the HCU.</p>
<p id="p-0276" num="0315">
<tables id="TABLE-US-00022" num="00022">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 20</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Halftoner/compositor control and configuration registers</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry>register</entry>
<entry>width</entry>
<entry>description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="char" char="."/>
<colspec colname="3" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry>start</entry>
<entry>1</entry>
<entry>Start the HCU.</entry>
</row>
<row>
<entry>stop</entry>
<entry>1</entry>
<entry>Stop the HCU.</entry>
</row>
<row>
<entry>page width</entry>
<entry>14</entry>
<entry>Page width of printed page,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>in dots. This is the number of dots</entry>
</row>
<row>
<entry/>
<entry/>
<entry>which have to be generated for each line.</entry>
</row>
<row>
<entry>left margin</entry>
<entry>14</entry>
<entry>Position of left margin, in dots.</entry>
</row>
<row>
<entry>right margin</entry>
<entry>14</entry>
<entry>Position of right margin, in dots.</entry>
</row>
<row>
<entry>page length</entry>
<entry>15</entry>
<entry>Page length of printed page, in dots.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>This is the number of lines which have</entry>
</row>
<row>
<entry/>
<entry/>
<entry>to be generated for each page.</entry>
</row>
<row>
<entry>black page width</entry>
<entry>14</entry>
<entry>Page width of black layer, in dots.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Used to detect the end of a black line.</entry>
</row>
<row>
<entry>contone page</entry>
<entry>14</entry>
<entry>Page width of contone layer, in dots.</entry>
</row>
<row>
<entry>width</entry>
<entry/>
<entry>Used to detect the end of a contone line.</entry>
</row>
<row>
<entry>contone</entry>
<entry>4</entry>
<entry>Scale factor used to scale contone data</entry>
</row>
<row>
<entry>scale factor</entry>
<entry/>
<entry>to bi-level resolution.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0277" num="0316">The consumer of the data produced by the HCU is the printhead interface. The printhead interface requires bi-level CMYK image data in planar format, i.e. with the color planes separated. Further, it also requires that even and odd pixels are separated. The output stage of the HCU therefore uses <b>8</b> parallel pixel FIFOs, one each for even cyan, odd cyan, even magenta, odd magenta, even yellow, odd yellow, even black, and odd black.</p>
<p id="p-0278" num="0317">The input contone CMYK FIFO is a full 8 KB line buffer. The line is used contone scale factor times to effect vertical up-scaling via line replication. FIFO write address wrapping is disabled until the start of the last use of the line. An alternative is to read the line from main memory contone scale factor times, increasing memory traffic by 65 MB/s, but avoiding the need for the on-chip 8 KB line buffer.</p>
<p id="h-0056" num="0000">7.2.4.1 Multi-Threshold Dither</p>
<p id="p-0279" num="0318">A general 256-layer dither volume provides great flexibility in dither cell design, by decoupling different intensity levels. General dither volumes can be large—a 64×64×256 dither volume, for example, has a size of 128 KB. They are also inefficient to access since each color component requires the retrieval of a different bit from the volume. In practice, there is no need to filly decouple each layer of the dither volume. Each dot column of the volume can be implemented as a fixed set of thresholds rather than 256 separate bits. Using three 8-bit thresholds, for example, only consumes 24 bits. Now, n thresholds define n+1 intensity intervals, within which the corresponding dither cell location is alternately not set or set. The contone pixel value being dithered uniquely selects one of the n+1 intervals, and this determines the value of the corresponding output dot.</p>
<p id="p-0280" num="0319">We dither the contone data using a triple-threshold 64×64×3×8-bit (12 KB) dither volume. The three thresholds form a convenient 24-bit value which can be retrieved from the dither cell ROM in one cycle. If dither cell registration is desired between color planes, then the same triple-threshold value can be retrieved once and used to dither each color component. If dither cell registration is not desired, then the dither cell can be split into four sub-cells and stored in four separately addressable ROMs from which four different triple-threshold values can be retrieved in parallel in one cycle. Using the addressing scheme shown in <figref idref="DRAWINGS">FIG. 26</figref>, the four color planes share the same dither cell at vertical and/or horizontal offsets of 32 dots from each other.</p>
<p id="p-0281" num="0320">The Multi-threshold dither <b>203</b> is shown in <figref idref="DRAWINGS">FIG. 26</figref>. The triple-threshold unit <b>204</b> converts a triple-threshold value and an intensity value into an interval and thence a one or zero bit. The triple-thresholding rules are shown in Table 21. The corresponding logic <b>208</b> is shown in <figref idref="DRAWINGS">FIG. 27</figref>.</p>
<p id="p-0282" num="0321">Referring to <figref idref="DRAWINGS">FIG. 26</figref> in more detail, four separate triple threshold units indicated generally at <b>204</b> each receive a series of contone color pixel values for respective color components of the CMYK signal. The dither volume is split into four dither subcells A, B, C and D, indicated generally at <b>205</b>. A dither cell address generator <b>206</b> and four gates indicated generally at <b>207</b>, control the retrieval of the four different triple threshold values which can be retrieved in parallel in one cycle for the different colors.</p>
<p id="p-0283" num="0322">
<tables id="TABLE-US-00023" num="00023">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 21</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Triple-thresholding rules</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>interval</entry>
<entry>output</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>V ≦ T<sub>1</sub></entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>T<sub>1 </sub>&lt; V ≦ T<sub>2</sub></entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>T<sub>2 </sub>&lt; V ≦ T<sub>3</sub></entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>T<sub>3 </sub>&lt; V</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.2.4.2 Composite
</p>
<p id="p-0284" num="0323">The composite unit <b>205</b> composites a black layer dot over a halftoned CMYK layer dot. If the black layer opacity is one, then the halftoned CMY is set to zero.</p>
<p id="p-0285" num="0324">Given a 4-bit halftoned color C<sub>c</sub>M<sub>c</sub>Y<sub>c</sub>K<sub>c </sub>and a 1-bit black layer opacity K<sub>b</sub>, the composite and clip logic is as defined in Table 22.</p>
<p id="p-0286" num="0325">
<tables id="TABLE-US-00024" num="00024">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 22</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Composite logic</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="140pt" align="center"/>
<colspec colname="2" colwidth="77pt" align="left"/>
<tbody valign="top">
<row>
<entry>color channel</entry>
<entry>condition</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>C</entry>
<entry>C<sub>c </sub><img id="CUSTOM-CHARACTER-00016" he="2.12mm" wi="1.78mm" file="US07298519-20071120-P00002.TIF" alt="custom character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00017" he="1.78mm" wi="1.44mm" file="US07298519-20071120-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> K<sub>b</sub></entry>
</row>
<row>
<entry>M</entry>
<entry>M<sub>c </sub><img id="CUSTOM-CHARACTER-00018" he="2.12mm" wi="1.78mm" file="US07298519-20071120-P00002.TIF" alt="custom character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00019" he="1.78mm" wi="1.44mm" file="US07298519-20071120-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> K<sub>b</sub></entry>
</row>
<row>
<entry>Y</entry>
<entry>Y<sub>c </sub><img id="CUSTOM-CHARACTER-00020" he="2.12mm" wi="1.78mm" file="US07298519-20071120-P00002.TIF" alt="custom character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00021" he="1.78mm" wi="1.44mm" file="US07298519-20071120-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> K<sub>b</sub></entry>
</row>
<row>
<entry>K</entry>
<entry>K<sub>c </sub><img id="CUSTOM-CHARACTER-00022" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/> K<sub>b</sub></entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.2.43 Clock Enable Generator
</p>
<p id="p-0287" num="0326">The clock enable generator <b>206</b> generates enable signals for clocking the contone CMYK pixel input, the black dot input, and the CMYK dot output.</p>
<p id="p-0288" num="0327">As described earlier, the contone pixel input buffer is used as both a line buffer and a FIFO. Each line is read once and then used contone scale factor times. FIFO write address wrapping is disabled until the start of the final replicated use of the line, at which time the clock enable generator generates a contone line advance enable signal which enables wrapping.</p>
<p id="p-0289" num="0328">The clock enable generator also generates an even signal which is used to select the even or odd set of output dot FIFOs, and a margin signal which is used to generate white dots when the current dot position is in the left or right margin of the page.</p>
<p id="p-0290" num="0329">The clock enable generator uses a set of counters. The internal logic of the counters is defined in Table 23. The logic of the clock enable signals is defined in Table 24.</p>
<p id="p-0291" num="0330">
<tables id="TABLE-US-00025" num="00025">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 23</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Clock enable generator counter logic</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="left"/>
<colspec colname="3" colwidth="14pt" align="center"/>
<colspec colname="4" colwidth="49pt" align="left"/>
<colspec colname="5" colwidth="49pt" align="left"/>
<colspec colname="6" colwidth="84pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry/>
<entry/>
<entry/>
<entry>load</entry>
<entry>decrement</entry>
</row>
<row>
<entry>counter</entry>
<entry>abbr.</entry>
<entry>w.</entry>
<entry>data</entry>
<entry>condition</entry>
<entry>condition</entry>
</row>
<row>
<entry namest="1" nameend="6" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="left"/>
<colspec colname="3" colwidth="14pt" align="char" char="."/>
<colspec colname="4" colwidth="49pt" align="left"/>
<colspec colname="5" colwidth="49pt" align="left"/>
<colspec colname="6" colwidth="84pt" align="left"/>
<tbody valign="top">
<row>
<entry>dot</entry>
<entry>D</entry>
<entry>14</entry>
<entry>page width</entry>
<entry>RP<sup>a</sup><img id="CUSTOM-CHARACTER-00023" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  EOL<sup>b</sup></entry>
<entry>(D &gt; 0) {circumflex over ( )}clk</entry>
</row>
<row>
<entry>line</entry>
<entry>L</entry>
<entry>15</entry>
<entry>page length</entry>
<entry>RP</entry>
<entry>(L &gt; 0) {circumflex over ( )}EOL</entry>
</row>
<row>
<entry>left margin</entry>
<entry>LM</entry>
<entry>14</entry>
<entry>left margin</entry>
<entry>RP <img id="CUSTOM-CHARACTER-00024" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  EOL</entry>
<entry>(LM &gt; 0) {circumflex over ( )}clk</entry>
</row>
<row>
<entry>right margin</entry>
<entry>RM</entry>
<entry>14</entry>
<entry>right margin</entry>
<entry>RP <img id="CUSTOM-CHARACTER-00025" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  EOL</entry>
<entry>(RM &gt; 0) {circumflex over ( )}clk</entry>
</row>
<row>
<entry>even/odd dot</entry>
<entry>E</entry>
<entry>1</entry>
<entry>0</entry>
<entry>RP <img id="CUSTOM-CHARACTER-00026" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  EOL</entry>
<entry>clk</entry>
</row>
<row>
<entry>black dot</entry>
<entry>BD</entry>
<entry>14</entry>
<entry>black width</entry>
<entry>RP <img id="CUSTOM-CHARACTER-00027" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  EOL</entry>
<entry>(LM = 0) {circumflex over ( )}(BD &gt; 0) {circumflex over ( )}clk</entry>
</row>
<row>
<entry>contone dot</entry>
<entry>CD</entry>
<entry>14</entry>
<entry>contone width</entry>
<entry>RP <img id="CUSTOM-CHARACTER-00028" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  EOL</entry>
<entry>(LM = 0) {circumflex over ( )}(CD &gt; 0) {circumflex over ( )}clk</entry>
</row>
<row>
<entry>contone</entry>
<entry>CSP</entry>
<entry>4</entry>
<entry>contone scale</entry>
<entry>RP <img id="CUSTOM-CHARACTER-00029" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  EOL <img id="CUSTOM-CHARACTER-00030" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  </entry>
<entry>(LM = 0) {circumflex over ( )}clk</entry>
</row>
<row>
<entry>sub-pixel</entry>
<entry/>
<entry/>
<entry>factor</entry>
<entry>(CSP = 0)</entry>
</row>
<row>
<entry>contone</entry>
<entry>CSL</entry>
<entry>4</entry>
<entry>contone scale</entry>
<entry>RP<img id="CUSTOM-CHARACTER-00031" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/>  (CSL = 0)</entry>
<entry>EOL {circumflex over ( )}clk</entry>
</row>
<row>
<entry>sub-line</entry>
<entry/>
<entry/>
<entry>factor</entry>
</row>
<row>
<entry namest="1" nameend="6" align="center" rowsep="1"/>
</row>
<row>
<entry namest="1" nameend="6" align="left" id="FOO-00009"><sup>a</sup>RP (reset page) condition: external signal</entry>
</row>
<row>
<entry namest="1" nameend="6" align="left" id="FOO-00010"><sup>b</sup>EOL (end-of-line) condition: (D = 0) {circumflex over ( )}(BD = 0) {circumflex over ( )}(CD = 0)</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0292" num="0331">
<tables id="TABLE-US-00026" num="00026">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 24</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Clock enable generator output signal logic</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="91pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry>output signal</entry>
<entry>condition</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>output dot clock enable</entry>
<entry>(D &gt; 0) {circumflex over ( )}<img id="CUSTOM-CHARACTER-00032" he="1.78mm" wi="1.44mm" file="US07298519-20071120-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> EOP<sup>a</sup></entry>
</row>
<row>
<entry>black dot clock enable</entry>
<entry>(LM = 0) {circumflex over ( )}(BD &gt; 0) <img id="CUSTOM-CHARACTER-00033" he="2.12mm" wi="1.78mm" file="US07298519-20071120-P00002.TIF" alt="custom character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00034" he="1.78mm" wi="1.44mm" file="US07298519-20071120-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> EOP</entry>
</row>
<row>
<entry>contone pixel clock enable</entry>
<entry>(LM = 0) {circumflex over ( )}(CD &gt; 0) {circumflex over ( )}(CSP = 0) {circumflex over ( )}<img id="CUSTOM-CHARACTER-00035" he="1.78mm" wi="1.44mm" file="US07298519-20071120-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> EOP</entry>
</row>
<row>
<entry>contone line advance enable</entry>
<entry>(CSL = 0) {circumflex over ( )}<img id="CUSTOM-CHARACTER-00036" he="1.78mm" wi="1.44mm" file="US07298519-20071120-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> EOP</entry>
</row>
<row>
<entry>even</entry>
<entry>E = 0</entry>
</row>
<row>
<entry>margin</entry>
<entry>(LM = 0) <img id="CUSTOM-CHARACTER-00037" he="2.46mm" wi="1.78mm" file="US07298519-20071120-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/> (RM = 0)</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry namest="1" nameend="2" align="left" id="FOO-00011"><sup>a</sup>EOP (end-of-page) condition: L = 0</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.3 Printhead Interface
</p>
<p id="p-0293" num="0332">The printhead interface (PHI) <b>142</b> is the means by which the processor loads the MEMJET printhead with the dots to be printed, and controls the actual dot printing process. The PHI contains:
<ul id="ul0010" list-style="none">
    <li id="ul0010-0001" num="0333">a line loader/format unit (LLFU) <b>209</b> which loads the dots for a given print line into local buffer storage and formats them into the order required for the MEMJET printhead.</li>
    <li id="ul0010-0002" num="0334">a MEMJET interface (MJI) <b>210</b>, which transfers data to the MEMJET printhead <b>63</b>, and controls the nozzle firing sequences during a print.</li>
</ul>
</p>
<p id="p-0294" num="0335">The units within the PHI are controlled by a number of registers that are programmed by the processor <b>139</b>. In addition, the processor is responsible for setting up the appropriate parameters in the DMA controller <b>144</b> for the transfers from memory to the LLFU. This includes loading white (all 0's) into appropriate colors during the start and end of a page so that the page has clean edges. The internal structure of the Printhead Interface <b>142</b> is shown in <figref idref="DRAWINGS">FIG. 28</figref>.</p>
<p id="h-0057" num="0000">7.3.1 Line Loader/Format Unit</p>
<p id="p-0295" num="0336">The line loader/format unit (LLFU) <b>209</b> loads the dots for a given print line into local buffer storage and formats them into the order required for the MEMJET printhead. It is responsible for supplying the pre-calculated nozzleEnable bits to the MEMJET interface for the eventual printing of the page.</p>
<p id="p-0296" num="0337">A single line in the 8-inch printhead consists of 12,800 4-color dots. At 1 bit per color, a single print line consists of 51,200 bits. These bits must be supplied in the correct order for being sent on to the printhead. See Section 6.1.2.1 for more information concerning the Load Cycle dot loading order, but in summary, 32 bits are transferred at a time to each of the two 4-inch printheads, with the 32 bits representing 4 dots for each of the 8 segments.</p>
<p id="p-0297" num="0338">The printing uses a double buffering scheme for preparing and accessing the dot-bit information. While one line is being loaded into the first buffer <b>213</b>, the pre-loaded line in the second buffer <b>214</b> is being read in MEMJET dot order. Once the entire line has been transferred from the second buffer <b>214</b> to the printhead via the MEMJET interface, the reading and writing processes swap buffers. The first buffer <b>213</b> is now read and the second buffer is loaded up with the new line of data. This is repeated throughout the printing process, as can be seen in the conceptual overview of <figref idref="DRAWINGS">FIG. 29</figref></p>
<p id="p-0298" num="0339">The actual implementation of the LLFU is shown in <figref idref="DRAWINGS">FIG. 30</figref>. Since one buffer is being read from while the other is being written to, two sets of address lines must be used. The <b>32</b>-bits DataIn from the common data bus are loaded depending on the WriteEnables, which are generated by the State Machine in response to the DMA Acknowledges.</p>
<p id="p-0299" num="0340">A multiplexor <b>215</b> chooses between the two 4-bit outputs of Buffer <b>0</b>, <b>213</b> and Buffer <b>1</b>, <b>214</b>, and sends the result to an 8-entry by 4-bit shift register <b>216</b>. After the first 8 read cycles, and whenever an Advance pulse comes from the MJI, the current 32-bit value from the shift register is gated into the 32-bit Transfer register <b>217</b>, where it can be used by the MJI.</p>
<p id="h-0058" num="0000">7.3.1.1 Buffers</p>
<p id="p-0300" num="0341">Each of the two buffers <b>213</b> and <b>214</b> is broken into 4 sub-buffers <b>220</b>, <b>221</b>, <b>222</b> and <b>223</b>, 1 per color. All the even dots are placed before the odd dots in each color's buffer, as shown in <figref idref="DRAWINGS">FIG. 31</figref>.</p>
<p id="p-0301" num="0342">The 51,200 bits representing the dots in the next line to be printed are stored 12,800 bits per color buffer, stored as 400 32-bit words. The first 200 32-bit words (6400 bits) represent the even dots for the color, while the second 200 32-bit words (6400 bits) represent the odd dots for the color.</p>
<p id="p-0302" num="0343">The addressing decoding circuitry is such that in a given cycle, a single 32-bit access can be made to all 4 sub-buffers—either a read from all 4 or a write to one of the 4. Only one bit of the 32-bits read from each color buffer is selected, for a total of 4 output bits. The process is shown in <figref idref="DRAWINGS">FIG. 32</figref>. 13 bits of address allow the reading of a particular bit by means of 8-bits of address being used to select 32 bits, and 5-bits of address choose 1-bit from those 32. Since all color buffers share this logic, a single 13-bit address gives a total of 4 bits out, one per color. Each buffer has its own WriteEnable line, to allow a single 32-bit value to be written to a particular color buffer in a given cycle. The 32-bits of DataIn are shared, since only one buffer will actually clock the data in.</p>
<p id="h-0059" num="0000">7.3.1.2 Address Generation</p>
<p id="h-0060" num="0000">7.3.1.2.1 Reading</p>
<p id="p-0303" num="0344">Address Generation for reading is straightforward. Each cycle we generate a bit address which is used to fetch 4 bits representing 1-bit per color for the particular segment. By adding 400 to the current bit address, we advance to the next segment's equivalent dot. We add 400 (not 800) since the odd and even dots are separated in the buffer. We do this 16 times to retrieve the two sets of 32 bits for the two sets of 8 segments representing the even dots (the resultant data is transferred to the MJI 32 bits at a time) and another 16 times to load the odd dots. This 32-cycle process is repeated 400 times, incrementing the start address each time. Thus in 400×32 cycles, a total of 400×32×4 (51,200) dot values are transferred in the order required by the printhead.</p>
<p id="p-0304" num="0345">In addition, we generate the TransferWriteEnable control signal. Since the LLFU starts before the MJI, we must transfer the first value before the Advance pulse from the MJI. We must also generate the next 32-bit value in readiness for the first Advance pulse. The solution is to transfer the first 32-bit value to the Transfer register after 8 cycles, and then to stall 8-cycles later, waiting for the Advance pulse to start the next 8-cycle group. Once the first Advance pulse arrives, the LLFU is synchronized to the MJI. However, the MJI must be started at least 16 cycles after the LLFU so that the initial Transfer value is valid and the next 32-bit value is ready to be loaded into the Transfer register.</p>
<p id="p-0305" num="0346">The read process is shown in the following pseudocode:</p>
<p id="p-0306" num="0347">
<tables id="TABLE-US-00027" num="00027">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>DotCount = 0</entry>
</row>
<row>
<entry/>
<entry>For DotInSegment0 = 0 to 400</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>CurrAdr = DotInSegment0</entry>
</row>
<row>
<entry/>
<entry>Do</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>V1 = (CurrAdr=0) OR (CurrAdr=3200)</entry>
</row>
<row>
<entry/>
<entry>V2 = Low 3 bits of DotCount = 0</entry>
</row>
<row>
<entry/>
<entry>TransferWriteEnable = V1 OR ADVANCE</entry>
</row>
<row>
<entry/>
<entry>Stall = V2 AND (NOT TransferWriteEnable)</entry>
</row>
<row>
<entry/>
<entry>If (NOT Stall)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Shift Register=Fetch 4-bits from</entry>
</row>
<row>
<entry/>
<entry>CurrReadBuffer:CurrAdr</entry>
</row>
<row>
<entry/>
<entry>CurrAdr = CurrAdr + 400</entry>
</row>
<row>
<entry/>
<entry>DotCount = (DotCount + 1) MOD 32</entry>
</row>
<row>
<entry/>
<entry>(odd&amp;even, printheads 1&amp;2, segments 0–7)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>EndIf</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Until (DotCount=0) AND (NOT Stall)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>EndFor</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0307" num="0348">Once the line has finished, the CurrReadBuffer value must be toggled by the processor.</p>
<p id="h-0061" num="0000">7.3.1.2.2 Writing</p>
<p id="p-0308" num="0349">The write process is also straightforward. 4 DMA request lines are output to the DMA controller. As requests are satisfied by the return DMA Acknowledge lines, the appropriate 8-bit destination address is selected (the lower 5 bits of the 13-bit output address are don't care values) and the acknowledge signal is passed to the correct buffer's WriteEnable control line (the Current Write Buffer is CurrentReadBuffer). The 8-bit destination address is selected from the 4 current addresses, one address per color. As DMA requests are satisfied the appropriate destination address is incremented, and the corresponding TransfersRemaining counter is decremented. The DMA request line is only set when the number of transfers remaining for that color is non-zero.</p>
<p id="p-0309" num="0350">The following pseudocode illustrates the Write process:</p>
<p id="p-0310" num="0351">
<tables id="TABLE-US-00028" num="00028">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>CurrentAdr[0–3] = 0</entry>
</row>
<row>
<entry>While (TransfersRemaining[0–3] are all non-zero)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>DMARequest[0–3] = TransfersRemaining[0–3] != 0</entry>
</row>
<row>
<entry/>
<entry>If DMAAknowledge[N]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>CurrWriteBuffer:CurrentAdr[N] = Fetch 32-bits from data bus</entry>
</row>
<row>
<entry/>
<entry>CurrentAdr[N] = CurrentAdr[N] + 1</entry>
</row>
<row>
<entry/>
<entry>TransfersRemaining[N] = TransfersRemaining[N] − 1 (floor 0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>EndIf</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>EndWhile</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.3.1.3 Registers
</p>
<p id="p-0311" num="0352">The following registers are contained in the LLFU:</p>
<p id="p-0312" num="0353">
<tables id="TABLE-US-00029" num="00029">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 25</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Line Load/Format Unit Registers</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry>Register Name</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>CurrentReadBuffer</entry>
<entry>The current buffer being read from.</entry>
</row>
<row>
<entry/>
<entry>When Buffer0 is being read from,</entry>
</row>
<row>
<entry/>
<entry>Buffer1 is written to and vice versa.</entry>
</row>
<row>
<entry/>
<entry>Should be toggled with each AdvanceLine</entry>
</row>
<row>
<entry/>
<entry>pulse from the MJI.</entry>
</row>
<row>
<entry>Go</entry>
<entry>Bits 0 and 1 control the starting of</entry>
</row>
<row>
<entry/>
<entry>the read and write processes respectively.</entry>
</row>
<row>
<entry/>
<entry>A non-zero write to the appropriate bit</entry>
</row>
<row>
<entry/>
<entry>starts the process.</entry>
</row>
<row>
<entry>Stop</entry>
<entry>Bits 0 and 1 control the stopping of the</entry>
</row>
<row>
<entry/>
<entry>read and write processes respectively.</entry>
</row>
<row>
<entry/>
<entry>A non-zero write to the appropriate bit</entry>
</row>
<row>
<entry/>
<entry>stops the process.</entry>
</row>
<row>
<entry>TransfersRemainingC</entry>
<entry>The number of 32-bit transfers remaining</entry>
</row>
<row>
<entry/>
<entry>to be read into the Cyan buffer</entry>
</row>
<row>
<entry>TransfersRemainingM</entry>
<entry>The number of 32-bit transfers remaining</entry>
</row>
<row>
<entry/>
<entry>to be read into the Magenta buffer</entry>
</row>
<row>
<entry>TransfersRemainingY</entry>
<entry>The number of 32-bit transfers remaining</entry>
</row>
<row>
<entry/>
<entry>to be read into the Yellow buffer</entry>
</row>
<row>
<entry>TransfersRemainingK</entry>
<entry>The number of 32-bit transfers remaining</entry>
</row>
<row>
<entry/>
<entry>to be read into the Black buffer</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.3.2 MEMJET Interface
</p>
<p id="p-0313" num="0354">The MEMJET interface (MJI) <b>210</b> transfers data to the MEMJET printhead <b>63</b>, and controls the nozzle firing sequences during a print.</p>
<p id="p-0314" num="0355">The MJI is simply a State Machine (see <figref idref="DRAWINGS">FIG. 28</figref>) which follows the Printhead loading and firing order described in Section 6.1.2, and includes the functionality of the Preheat Cycle and Cleaning Cycle as described in Section 6.1.4 and Section 6.1.5. Both high-speed and low-speed printing modes are available.</p>
<p id="p-0315" num="0356">Dot counts for each color are also kept by the MJI.</p>
<p id="p-0316" num="0357">The MJI loads data into the printhead from a choice of 2 data sources:</p>
<p id="p-0317" num="0358">All 1s. This means that all nozzles will fire during a subsequent Print cycle, and is the standard mechanism for loading the printhead for a preheat or cleaning cycle.</p>
<p id="p-0318" num="0359">From the 32-bit input held in the Transfer register of the LLFU. This is the standard means of printing an image. The 32-bit value from the LLFU is directly sent to the printhead and a 1-bit ‘Advance’ control pulse is sent to the LLFU. At the end of each line, a 1-bit ‘AdvanceLine’ pulse is also available.</p>
<p id="p-0319" num="0360">The MJI must be started after the LLFU has already prepared the first 32-bit transfer value. This is so the 32-bit data input will be valid for the first transfer to the printhead.</p>
<p id="p-0320" num="0361">The MJI is therefore directly connected to the LLFU and the external MEMJET printhead.</p>
<p id="h-0062" num="0000">7.3.2.1 Connections to Printhead</p>
<p id="p-0321" num="0362">The MJI <b>210</b> has the following connections to the printhead <b>63</b>, with the sense of input and output with respect to the MJI. The names match the pin connections on the printhead (see Section 6.2.1 for an explanation of the way the 8-inch printhead is wired up).</p>
<p id="p-0322" num="0363">
<tables id="TABLE-US-00030" num="00030">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 26</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>MEMJET Interface Connections</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="14pt" align="center"/>
<colspec colname="4" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry>Name</entry>
<entry>#Pins</entry>
<entry>I/O</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="char" char="."/>
<colspec colname="3" colwidth="14pt" align="center"/>
<colspec colname="4" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry>Chromapod Select</entry>
<entry>3</entry>
<entry>O</entry>
<entry>Select which chromapod will</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>fire (0–4)</entry>
</row>
<row>
<entry>NozzleSelect</entry>
<entry>4</entry>
<entry>O</entry>
<entry>Select which nozzle from</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>the pod will fire (0–9)</entry>
</row>
<row>
<entry>PodgroupEnable</entry>
<entry>2</entry>
<entry>O</entry>
<entry>Enable the podgroups to fire</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>(choice of: 01, 10, 11)</entry>
</row>
<row>
<entry>AEnable</entry>
<entry>1</entry>
<entry>O</entry>
<entry>Firing pulse for podgroup A</entry>
</row>
<row>
<entry>BEnable</entry>
<entry>1</entry>
<entry>O</entry>
<entry>Firing pulse for podgroup B</entry>
</row>
<row>
<entry>CDataIn[0–7]</entry>
<entry>8</entry>
<entry>O</entry>
<entry>Cyan output to cyan shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>MDataIn[0–7]</entry>
<entry>8</entry>
<entry>O</entry>
<entry>Magenta input to magenta shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>YDataIn[0–7]</entry>
<entry>8</entry>
<entry>O</entry>
<entry>Yellow input to yellow shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register of segments 0–7</entry>
</row>
<row>
<entry>KDataIn[0–7]</entry>
<entry>8</entry>
<entry>O</entry>
<entry>Black input to black shift</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>register of segment 0–7</entry>
</row>
<row>
<entry>SRClock1</entry>
<entry>1</entry>
<entry>O</entry>
<entry>A pulse on SRClock1</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>(ShiftRegisterClock1) loads the</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>current values from CDataIn[0–7],</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>MDataIn[0–7], YDataIn[0–7]</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>and KDataIn[0–7] into the</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>32 shift registers of 4-inch</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>printhead 1</entry>
</row>
<row>
<entry>SRClock2</entry>
<entry>1</entry>
<entry>O</entry>
<entry>A pulse on SRClock2</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>(ShiftRegisterClock2) loads the</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>current values from CDataIn[0–7],</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>MDataIn[0–7], YDataIn[0–7]</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>and KDataIn[0–7] into the</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>32 shift registers of 4-inch</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>printhead 2</entry>
</row>
<row>
<entry>PTransfer</entry>
<entry>1</entry>
<entry>O</entry>
<entry>Parallel transfer of data from</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>the shift registers to the</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>printhead's internal NozzleEnable</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>bits (one per nozzle).</entry>
</row>
<row>
<entry>SenseSegSelect1</entry>
<entry>1</entry>
<entry>O</entry>
<entry>A pulse on SenseSegEnable1 ANDed</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>with data on CDataIn[n]</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>enables the sense lines for</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>segment n in 4-inch printhead 1.</entry>
</row>
<row>
<entry>SenseSegEnable2</entry>
<entry>1</entry>
<entry>O</entry>
<entry>A pulse on SenseSegEnable2 ANDed</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>with data on CDataIn[n] enables</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>the sense lines for segment n in</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>4-inch printhead 2.</entry>
</row>
<row>
<entry>Tsense</entry>
<entry>1</entry>
<entry>I</entry>
<entry>Temperature sense</entry>
</row>
<row>
<entry>Vsense</entry>
<entry>1</entry>
<entry>I</entry>
<entry>Voltage sense</entry>
</row>
<row>
<entry>Rsense</entry>
<entry>1</entry>
<entry>I</entry>
<entry>Resistivity sense</entry>
</row>
<row>
<entry>Wsense</entry>
<entry>1</entry>
<entry>I</entry>
<entry>Width sense</entry>
</row>
<row>
<entry>TOTAL</entry>
<entry>52</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.3.2.2 Firing Pulse Duration
</p>
<p id="p-0323" num="0364">The duration of firing pulses on the AEnable and BEnable lines depend on the viscosity of the ink (which is dependant on temperature and ink characteristics) and the amount of power available to the printhead. The typical pulse duration range is 1.3 to 1.8 Ts. The MJI therefore contains a programmable pulse duration table <b>230</b>, indexed by feedback from the printhead. The table of pulse durations allows the use of a lower cost power supply, and aids in maintaining more accurate drop ejection.</p>
<p id="p-0324" num="0365">The Pulse Duration table has 256 entries, and is indexed by the current Vsense <b>231</b> and Tsense <b>232</b> settings. The upper 4-bits of address come from Vsense, and the lower 4-bits of address come from Tsense. Each entry is 8-bits, and represents a fixed point value in the range of 0-4 Ts. The process of generating the AEnable and BEnable lines is shown in <figref idref="DRAWINGS">FIG. 33</figref>. The analog Vsense <b>231</b> and Tsense <b>232</b> signals are received by respective sample and hold circuits <b>233</b> and <b>234</b>, and then converted to digital words in respective converters <b>235</b> and <b>236</b>, before being applied to the pulse duration table <b>230</b>. The output of the pulse duration table <b>230</b> is applied to a pulse width generator <b>237</b> to generate the firing pulses.</p>
<p id="p-0325" num="0366">The 256-byte table is written by the CPU before printing the first page. The table may be updated in between pages if desired. Each 8-bit pulse duration entry in the table combines:
<ul id="ul0011" list-style="none">
    <li id="ul0011-0001" num="0367">User brightness settings (from the page description)</li>
    <li id="ul0011-0002" num="0368">Viscosity curve of ink (from the QA Chip)</li>
    <li id="ul0011-0003" num="0369">Rsense</li>
    <li id="ul0011-0004" num="0370">Wsense</li>
    <li id="ul0011-0005" num="0371">Vsense</li>
    <li id="ul0011-0006" num="0372">Tsense
<br/>
7.3.2.3 Dot Counts
</li>
</ul>
</p>
<p id="p-0326" num="0373">The MJI <b>210</b> maintains a count of the number of dots of each color fired from the printhead in a dot count register <b>240</b>. The dot count for each color is a 32-bit value, individually cleared, by a signal <b>241</b>, under processor control. At 32-bits length, each dot count can hold a maximum coverage dot count of 17 12-inch pages, although in typical usage, the dot count will be read and cleared after each page.</p>
<p id="p-0327" num="0374">The dot counts are used by the processor to update the QA chip <b>85</b> (see Section 7.5.4.1) in order to predict when the ink cartridge runs out of ink. The processor knows the volume of ink in the cartridge for each of C, M, Y, and K from the QA chip. Counting the number of drops eliminates the need for ink sensors, and prevents the ink channels from running dry. An updated drop count is written to the QA chip after each page. A new page will not be printed unless there is enough ink left, and allows the user to change the ink without getting a dud half-printed page which must be reprinted.</p>
<p id="p-0328" num="0375">The layout of the dot counter for cyan is shown in <figref idref="DRAWINGS">FIG. 34</figref>. The remaining 3 dot counters (MDotCount, YDotCount, and KDotCount for magenta, yellow, and black respectively) are identical in structure.</p>
<p id="h-0063" num="0000">7.3.2.4 Registers</p>
<p id="p-0329" num="0376">The processor <b>139</b> communicates with the MJI <b>210</b> via a register set. The registers allow the processor to parameterize a print as well as receive feedback about print progress.</p>
<p id="p-0330" num="0377">The following registers are contained in the MJI:</p>
<p id="p-0331" num="0378">
<tables id="TABLE-US-00031" num="00031">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 27</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>MEMJET Interface Registers</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry>Register Name</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>Print Parameters</entry>
<entry/>
</row>
<row>
<entry>NumTransfers</entry>
<entry>The number of transfers required to</entry>
</row>
<row>
<entry/>
<entry>load the Printhead (usually</entry>
</row>
<row>
<entry/>
<entry>1600). This is the number of pulses</entry>
</row>
<row>
<entry/>
<entry>for both SRClock lines and the</entry>
</row>
<row>
<entry/>
<entry>total number of 32-bit data values to</entry>
</row>
<row>
<entry/>
<entry>transfer for a given line.</entry>
</row>
<row>
<entry>PrintSpeed</entry>
<entry>Whether to print at low or high speed</entry>
</row>
<row>
<entry/>
<entry>(determines the value on the</entry>
</row>
<row>
<entry/>
<entry>PodgroupEnable lines during the print).</entry>
</row>
<row>
<entry>NumLines</entry>
<entry>The number of Load/Print cycles to</entry>
</row>
<row>
<entry/>
<entry>perform.</entry>
</row>
<row>
<entry>Monitoring the Print</entry>
<entry/>
</row>
<row>
<entry>Status</entry>
<entry>The MEMJET Interface's Status Register</entry>
</row>
<row>
<entry>LinesRemaining</entry>
<entry>The number of lines remaining to be</entry>
</row>
<row>
<entry/>
<entry>printed. Only valid while Go = 1.</entry>
</row>
<row>
<entry/>
<entry>Starting value is NumLines.</entry>
</row>
<row>
<entry>TransfersRemaining</entry>
<entry>The number of transfers remaining before</entry>
</row>
<row>
<entry/>
<entry>the Printhead is considered</entry>
</row>
<row>
<entry/>
<entry>loaded for the current line.</entry>
</row>
<row>
<entry/>
<entry>Only valid while Go = 1.</entry>
</row>
<row>
<entry>SenseSegment</entry>
<entry>The 8-bit value to place on the Cyan data</entry>
</row>
<row>
<entry/>
<entry>lines during a subsequent feedback</entry>
</row>
<row>
<entry/>
<entry>SenseSegSelect pulse. Only 1 of the 8 bits</entry>
</row>
<row>
<entry/>
<entry>should be set, corresponding to one of</entry>
</row>
<row>
<entry/>
<entry>the 8 segments. See SenseSegSelect for how</entry>
</row>
<row>
<entry/>
<entry>to determine which of the two 4-inch</entry>
</row>
<row>
<entry/>
<entry>printheads to sense.</entry>
</row>
<row>
<entry>SetAllNozzles</entry>
<entry>If non-zero, the 32-bit value written</entry>
</row>
<row>
<entry/>
<entry>to the printhead during the LoadDots</entry>
</row>
<row>
<entry/>
<entry>process is all 1s, so that all nozzles</entry>
</row>
<row>
<entry/>
<entry>will be fired during the subsequent</entry>
</row>
<row>
<entry/>
<entry>PrintDots process. This is used</entry>
</row>
<row>
<entry/>
<entry>during the preheat and cleaning cycles.</entry>
</row>
<row>
<entry/>
<entry>If 0, the 32-bit value written to the</entry>
</row>
<row>
<entry/>
<entry>printhead comes from the LLFU. This is the</entry>
</row>
<row>
<entry/>
<entry>case during the actual printing of regular</entry>
</row>
<row>
<entry/>
<entry>images.</entry>
</row>
<row>
<entry>Actions</entry>
<entry/>
</row>
<row>
<entry>Reset</entry>
<entry>A write to this register resets the</entry>
</row>
<row>
<entry/>
<entry>MJI, stops any loading or printing</entry>
</row>
<row>
<entry/>
<entry>processes, and loads all registers with 0.</entry>
</row>
<row>
<entry>SenseSegSelect</entry>
<entry>A write to this register with any</entry>
</row>
<row>
<entry/>
<entry>value clears the FeedbackValid bit of the</entry>
</row>
<row>
<entry/>
<entry>Status register, and depending on the</entry>
</row>
<row>
<entry/>
<entry>low-order bit, sends a pulse on the</entry>
</row>
<row>
<entry/>
<entry>SenseEnable1 or SenseEnable2 line</entry>
</row>
<row>
<entry/>
<entry>if the LoadingDots and PrintingDots status</entry>
</row>
<row>
<entry/>
<entry>bits are all 0. If any of the status bits</entry>
</row>
<row>
<entry/>
<entry>are set, the Feedback bit is cleared and</entry>
</row>
<row>
<entry/>
<entry>nothing more is done. Once the various</entry>
</row>
<row>
<entry/>
<entry>sense lines have been tested, the values</entry>
</row>
<row>
<entry/>
<entry>are placed in the Tsense, Vsense, Rsense,</entry>
</row>
<row>
<entry/>
<entry>and Wsense registers, and then the Feedback</entry>
</row>
<row>
<entry/>
<entry>bit of the Status register is set.</entry>
</row>
<row>
<entry>Go</entry>
<entry>A write of 1 to this bit starts the</entry>
</row>
<row>
<entry/>
<entry>LoadDots/PrintDots cycles. A total</entry>
</row>
<row>
<entry/>
<entry>of NumLines lines are printed, each</entry>
</row>
<row>
<entry/>
<entry>containing NumTransfers 32 bit transfers.</entry>
</row>
<row>
<entry/>
<entry>As each line is printed, LinesRemaining</entry>
</row>
<row>
<entry/>
<entry>decrements, and TransfersRemaining is</entry>
</row>
<row>
<entry/>
<entry>reloaded with NumTransfers again. The status</entry>
</row>
<row>
<entry/>
<entry>register contains print status information.</entry>
</row>
<row>
<entry/>
<entry>Upon completion of NumLines, the</entry>
</row>
<row>
<entry/>
<entry>loading/printing process stops and the Go</entry>
</row>
<row>
<entry/>
<entry>bit is cleared. During the final print cycle,</entry>
</row>
<row>
<entry/>
<entry>nothing is loaded into the printhead. A write</entry>
</row>
<row>
<entry/>
<entry>of 0 to this bit stops the print process, but</entry>
</row>
<row>
<entry/>
<entry>does not clear any other registers.</entry>
</row>
<row>
<entry>ClearCounts</entry>
<entry>A write to this register clears the</entry>
</row>
<row>
<entry/>
<entry>CDotCount, MDotCount, YDotCount, and</entry>
</row>
<row>
<entry/>
<entry>KDotCount registers if</entry>
</row>
<row>
<entry/>
<entry>bits 0, 1, 2, or 3 respectively</entry>
</row>
<row>
<entry/>
<entry>are set. Consequently a write of 0 has</entry>
</row>
<row>
<entry/>
<entry>no effect.</entry>
</row>
<row>
<entry>Feedback</entry>
<entry/>
</row>
<row>
<entry>Tsense</entry>
<entry>Read only feedback of Tsense from the last</entry>
</row>
<row>
<entry/>
<entry>SenseSegSelect pulse sent to segment</entry>
</row>
<row>
<entry/>
<entry>SenseSegment. Is only valid if the</entry>
</row>
<row>
<entry/>
<entry>FeedbackValid bit of the Status register</entry>
</row>
<row>
<entry/>
<entry>is set.</entry>
</row>
<row>
<entry>Vsense</entry>
<entry>Read only feedback of Vsense from the last</entry>
</row>
<row>
<entry/>
<entry>SenseSegSelect pulse sent to segment</entry>
</row>
<row>
<entry/>
<entry>SenseSegment. Is only valid if the</entry>
</row>
<row>
<entry/>
<entry>FeedbackValid bit of the Status register</entry>
</row>
<row>
<entry/>
<entry>is set.</entry>
</row>
<row>
<entry>Rsense</entry>
<entry>Read only feedback of Rsense from the last</entry>
</row>
<row>
<entry/>
<entry>SenseSegSelect pulse sent to segment</entry>
</row>
<row>
<entry/>
<entry>SenseSegment. Is only valid if the</entry>
</row>
<row>
<entry/>
<entry>FeedbackValid bit of the Status register</entry>
</row>
<row>
<entry/>
<entry>is set.</entry>
</row>
<row>
<entry>Wsense</entry>
<entry>Read only feedback of Wsense from the last</entry>
</row>
<row>
<entry/>
<entry>SenseSegSelect pulse sent to segment</entry>
</row>
<row>
<entry/>
<entry>SenseSegment. Is only valid if the</entry>
</row>
<row>
<entry/>
<entry>FeedbackValid bit of the Status register</entry>
</row>
<row>
<entry/>
<entry>is set.</entry>
</row>
<row>
<entry>CDotCount</entry>
<entry>Read only 32-bit count of cyan dots sent to</entry>
</row>
<row>
<entry/>
<entry>the printhead.</entry>
</row>
<row>
<entry>MDotCount</entry>
<entry>Read only 32-bit count of magenta dots sent</entry>
</row>
<row>
<entry/>
<entry>to the printhead.</entry>
</row>
<row>
<entry>YDotCount</entry>
<entry>Read only 32-bit count of yellow dots sent</entry>
</row>
<row>
<entry/>
<entry>to the printhead</entry>
</row>
<row>
<entry>KDotCount</entry>
<entry>Read only 32-bit count of black dots sent</entry>
</row>
<row>
<entry/>
<entry>to the printhead</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0332" num="0379">The MJI's Status Register is a 16-bit register with bit interpretations as follows:</p>
<p id="p-0333" num="0380">
<tables id="TABLE-US-00032" num="00032">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 28</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>MJI Status Register</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="center"/>
<colspec colname="3" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry>Name</entry>
<entry>Bits</entry>
<entry>Description</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>LoadingDots</entry>
<entry>1</entry>
<entry>If set, the MJI is currently</entry>
</row>
<row>
<entry/>
<entry/>
<entry>loading dots, with the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>number of dots remaining to be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>transferred in TransfersRemaining.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>If clear, the MJI is not currently</entry>
</row>
<row>
<entry/>
<entry/>
<entry>loading dots</entry>
</row>
<row>
<entry>PrintingDots</entry>
<entry>1</entry>
<entry>If set, the MJI is currently</entry>
</row>
<row>
<entry/>
<entry/>
<entry>printing dots. If clear, the MJI is</entry>
</row>
<row>
<entry/>
<entry/>
<entry>not currently printing dots.</entry>
</row>
<row>
<entry>PrintingA</entry>
<entry>1</entry>
<entry>This bit is set while there is a</entry>
</row>
<row>
<entry/>
<entry/>
<entry>pulse on the AEnable line</entry>
</row>
<row>
<entry>PrintingB</entry>
<entry>1</entry>
<entry>This bit is set while there is a</entry>
</row>
<row>
<entry/>
<entry/>
<entry>pulse on the BEnable line</entry>
</row>
<row>
<entry>FeedbackValid</entry>
<entry>1</entry>
<entry>This bit is set while the feedback</entry>
</row>
<row>
<entry/>
<entry/>
<entry>values Tsense, Vsense, Rsense, and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Wsense are valid.</entry>
</row>
<row>
<entry>Reserved</entry>
<entry>3</entry>
<entry>—</entry>
</row>
<row>
<entry>PrintingChromapod</entry>
<entry>4</entry>
<entry>This holds the current chromapod</entry>
</row>
<row>
<entry/>
<entry/>
<entry>being fired while the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>PrintingDots status bit is set.</entry>
</row>
<row>
<entry>PrintingNozzles</entry>
<entry>4</entry>
<entry>This holds the current nozzle being</entry>
</row>
<row>
<entry/>
<entry/>
<entry>fired while the PrintingDots status</entry>
</row>
<row>
<entry/>
<entry/>
<entry>bit is set.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.3.2.5 Preheat and Cleaning Cycles
</p>
<p id="p-0334" num="0381">The Cleaning and Preheat cycles are simply accomplished by setting appropriate registers:
<ul id="ul0012" list-style="none">
    <li id="ul0012-0001" num="0382">SetAllNozzles=1</li>
    <li id="ul0012-0002" num="0383">Set the PulseDuration register to either a low duration (in the case of the preheat mode) or to an appropriate drop ejection duration for cleaning mode.</li>
    <li id="ul0012-0003" num="0384">Set NumLines to be the number of times the nozzles should be fired</li>
    <li id="ul0012-0004" num="0385">Set the Go bit and then wait for the Go bit to be cleared when the print cycles have completed.
<br/>
7.4 Processor and Memory
<br/>
7.4.1 Processor
</li>
</ul>
</p>
<p id="p-0335" num="0386">The processor <b>139</b> runs the control program which synchronises the other functional units during page reception, expansion and printing. It also runs the device drivers for the various external interfaces, and responds to user actions through the user interface.</p>
<p id="p-0336" num="0387">It must have low interrupt latency, to provide efficient DMA management, but otherwise does not need to be particularly high-performance DMA Controller.</p>
<p id="p-0337" num="0388">The DMA controller supports single-address transfers on 27 channels (see Table 29). It generates vectored interrupts to the processor on transfer completion.</p>
<p id="p-0338" num="0389">
<tables id="TABLE-US-00033" num="00033">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 29</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>DMA channel usage</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="77pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry/>
<entry>input</entry>
<entry>output</entry>
</row>
<row>
<entry/>
<entry>functional unit</entry>
<entry>channels</entry>
<entry>channels</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="77pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry/>
<entry>USB interface</entry>
<entry>—</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>EDRL expander</entry>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>JPEG decoder</entry>
<entry>1</entry>
<entry>8</entry>
</row>
<row>
<entry/>
<entry>halftoner/compositor</entry>
<entry>2</entry>
<entry>8</entry>
</row>
<row>
<entry/>
<entry>speaker interface</entry>
<entry>1</entry>
<entry>—</entry>
</row>
<row>
<entry/>
<entry>printhead interface</entry>
<entry>4</entry>
<entry>—</entry>
</row>
<row>
<entry/>
<entry/>
<entry>8</entry>
<entry>19</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>27</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.4.3 Program ROM
</p>
<p id="p-0339" num="0390">The program ROM holds the ICP control program which is loaded into main memory during system boot.</p>
<p id="h-0064" num="0000">7.4.4 Rambus Interface</p>
<p id="p-0340" num="0391">The Rambus interface provides the high-speed interface to the external 8 MB (64 Mbit) Rambus DRAM (RDRAM).</p>
<p id="h-0065" num="0000">7.5 External Interfaces</p>
<p id="h-0066" num="0000">7.5.1 USB Interface</p>
<p id="p-0341" num="0392">The Universal Serial Bus (USB) interface provides a standard USB device interface.</p>
<p id="h-0067" num="0000">7.5.2 Speaker Interface</p>
<p id="p-0342" num="0393">The speaker interface <b>250</b> (<figref idref="DRAWINGS">FIG. 35</figref>) contains a small FIFO <b>251</b> used for DMA-mediated transfers of sound clips from main memory, an 8-bit digital-to-analog converter (DAC) <b>252</b> which converts each 8-bit sample value to a voltage, and an amplifier <b>253</b> which feeds the external speaker. When the FIFO is empty it outputs a zero value.</p>
<p id="p-0343" num="0394">The speaker interface is clocked at the frequency of the sound clips.</p>
<p id="p-0344" num="0395">The processor outputs a sound clip to the speaker simply by programming the DMA channel of the speaker interface.</p>
<p id="h-0068" num="0000">7.53 Parallel Interface</p>
<p id="p-0345" num="0396">The parallel interface <b>231</b> provides I/O on a number of parallel external signal lines. It allows the processor to sense or control the devices listed in Table 30.</p>
<p id="p-0346" num="0397">
<tables id="TABLE-US-00034" num="00034">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 30</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Parallel Interface devices</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>parallel interface devices</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>power button</entry>
</row>
<row>
<entry/>
<entry>paper feed button</entry>
</row>
<row>
<entry/>
<entry>power LED</entry>
</row>
<row>
<entry/>
<entry>out-of-paper LED</entry>
</row>
<row>
<entry/>
<entry>ink low LED</entry>
</row>
<row>
<entry/>
<entry>media sensor</entry>
</row>
<row>
<entry/>
<entry>paper transport stepper motor</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
7.5.4 Serial Interface
</p>
<p id="p-0347" num="0398">The serial interface <b>232</b> provides two standard low-speed serial ports.</p>
<p id="p-0348" num="0399">One port is used to connect to the master QA chip <b>85</b>. The other is used to connect to the QA chip in the ink cartridge <b>233</b>. The processor-mediated protocol between the two is used to authenticate the ink cartridge. The processor can then retrieve ink characteristics from the QA chip, as well as the remaining volume of each ink. The processor uses the ink characteristics to properly configure the MEMJET printhead. It uses the remaining ink volumes, updated on a page-by-page basis with ink consumption information accumulated by the printhead interface, to ensure that it never allows the printhead to be damaged by running dry.</p>
<p id="h-0069" num="0000">7.5.4.1 Ink Cartridge QA Chip</p>
<p id="p-0349" num="0400">The QA chip <b>233</b> in the ink cartridge contains information required for maintaining the best possible print quality, and is implemented using an authentication chip. The 256 bits of data in the authentication chip are allocated as follows:</p>
<p id="p-0350" num="0401">
<tables id="TABLE-US-00035" num="00035">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 31</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Ink cartridge's 256 bits (16 entries of 16-bits)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="49pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="left"/>
<colspec colname="3" colwidth="28pt" align="left"/>
<colspec colname="4" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry>M[n]</entry>
<entry>access</entry>
<entry>width</entry>
<entry>description</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry>0</entry>
<entry>RO<sup>a</sup></entry>
<entry>16</entry>
<entry>Basic header, flags etc.</entry>
</row>
<row>
<entry>1</entry>
<entry>RO</entry>
<entry>16</entry>
<entry>Serial number.</entry>
</row>
<row>
<entry>2</entry>
<entry>RO</entry>
<entry>16</entry>
<entry>Batch number.</entry>
</row>
<row>
<entry>3</entry>
<entry>RO</entry>
<entry>16</entry>
<entry>Reserved for future expansion.</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>Must be 0.</entry>
</row>
<row>
<entry>4</entry>
<entry>RO</entry>
<entry>16</entry>
<entry>Cyan ink properties.</entry>
</row>
<row>
<entry>5</entry>
<entry>RO</entry>
<entry>16</entry>
<entry>Magenta ink properties.</entry>
</row>
<row>
<entry>6</entry>
<entry>RO</entry>
<entry>16</entry>
<entry>Yellow ink properties.</entry>
</row>
<row>
<entry>7</entry>
<entry>RO</entry>
<entry>16</entry>
<entry>Black ink properties.</entry>
</row>
<row>
<entry>8–9</entry>
<entry>DO<sup>b</sup></entry>
<entry>32</entry>
<entry>Cyan ink remaining, in</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>nanolitres.</entry>
</row>
<row>
<entry>10–11</entry>
<entry>DO</entry>
<entry>32</entry>
<entry>Magenta ink remaining,</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>in nanolitres.</entry>
</row>
<row>
<entry>12–13</entry>
<entry>DO</entry>
<entry>32</entry>
<entry>Yellow ink remaining,</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>in nanolitres.</entry>
</row>
<row>
<entry>14–15</entry>
<entry>DO</entry>
<entry>32</entry>
<entry>Black ink remaining,</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>in nanolitres.</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry namest="1" nameend="4" align="left" id="FOO-00012"><sup>a</sup>read only (RO)</entry>
</row>
<row>
<entry namest="1" nameend="4" align="left" id="FOO-00013"><sup>b</sup>decrement only (DO)</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0351" num="0402">Before each page is printed, the processor must check the amount of ink remaining to ensure there is enough for an entire worst-case page. Once the page has been printed, the processor multiplies the total number of drops of each color (obtained from the printhead interface) by the drop volume. The amount of printed ink is subtracted from the amount of ink remaining. The unit of measurement for ink remaining is nanolitres, so 32 bits can represent over 4 litres of ink. The amount of ink used for a page must be rounded up to the nearest nanolitre (i.e. approximately 1000 printed dots).</p>
<p id="h-0070" num="0000">7.5.5 JTAG Interface</p>
<p id="p-0352" num="0403">A standard JTAG (Joint Test Action Group) interface is included for testing purposes. Due to the complexity of the chip, a variety of testing techniques are required, including BIST (Built In Self Test) and functional block isolation. An overhead of 10% in chip area is assumed for overall chip testing circuitry.</p>
<p id="h-0071" num="0000">8 Generic Printer Driver</p>
<p id="p-0353" num="0404">This section describes generic aspects of any host-based printer driver for iPrint.</p>
<p id="h-0072" num="0000">8.1 Graphics and Imaging Model</p>
<p id="p-0354" num="0405">We assume that the printer driver is closely coupled with the host graphics system, so that the printer driver can provide device-specific handling for different graphics and imaging operations, in particular compositing operations and text operations.</p>
<p id="p-0355" num="0406">We assume that the host provides support for color management, so that device-independent color can be converted to iPrint-specific CMYK color in a standard way, based on a user-selected iPrint-specific ICC (International Color Consortium) color profile. The color profile is normally selected implicitly by the user when the user specifies the output medium in the printer (i.e. plain paper, coated paper, transparency, etc.). The page description sent to the printer always contains device-specific CMYK color.</p>
<p id="p-0356" num="0407">We assume that the host graphics system renders images and graphics to a nominal resolution specified by the printer driver, but that it allows the printer driver to take control of rendering text. In particular, the graphics system provides sufficient information to the printer driver to allow it to render and position text at a higher resolution than the nominal device resolution.</p>
<p id="p-0357" num="0408">We assume that the host graphics system requires random access to a contone page buffer at the nominal device resolution, into which it composites graphics and imaging objects, but that it allows the printer driver to take control of the actual compositing—i.e. it expects the printer driver to manage the page buffer.</p>
<p id="h-0073" num="0000">8.2 Two-Layer Page Buffer</p>
<p id="p-0358" num="0409">The printer's page description contains a 267 ppi contone layer and an 800 dpi black layer. The black layer is conceptually above the contone layer, i.e. the black layer is composited over the contone layer by the printer. The printer driver therefore maintains a page buffer <b>260</b> which correspondingly contains a medium-resolution contone layer <b>261</b> and a high-resolution black layer <b>262</b>.</p>
<p id="p-0359" num="0410">The graphics systems renders and composites objects into the page buffer bottom-up—i.e. later objects obscure earlier objects. This works naturally when there is only a single layer, but not when there are two layers which will be composited later. It is therefore necessary to detect when an object being placed on the contone layer obscures something on the black layer.</p>
<p id="p-0360" num="0411">When obscuration is detected, the obscured black pixels are composited with the contone layer and removed from the black layer. The obscuring object is then laid down on the contone layer, possibly interacting with the black pixels in some way. If the compositing mode of the obscuring object is such that no interaction with the background is possible, then the black pixels can simply be discarded without being composited with the contone layer. In practice, of course, there is little interaction between the contone layer and the black layer.</p>
<p id="p-0361" num="0412">The printer driver specifies a nominal page resolution of 267 ppi to the graphics system. Where possible the printer driver relies on the graphics system to render image and graphics objects to the pixel level at 267 ppi, with the exception of black text. The printer driver fields all text rendering requests, detects and renders black text at 800 dpi, but returns non-black text rendering requests to the graphics system for rendering at 267 ppi.</p>
<p id="p-0362" num="0413">Ideally the graphics system and the printer driver manipulate color in device-independent RGB, deferring conversion to device-specific CMYK until the page is complete and ready to be sent to the printer. This reduces page buffer requirements and makes compositing more rational. Compositing in CMYK color space is not ideal.</p>
<p id="p-0363" num="0414">Ultimately the graphics system asks the printer driver to composite each rendered object into the printer driver's page buffer. Each such object uses 24-bit contone RGB, and has an explicit (or implicitly opaque) opacity channel.</p>
<p id="p-0364" num="0415">The printer driver maintains the two-layer page buffer <b>260</b> in three parts. The first part is the medium-resolution (267 ppi) contone layer <b>261</b>. This consists of a 24-bit RGB bitmap. The second part is a medium-resolution black layer <b>263</b>. This consists of an 8-bit opacity bitmap. The third part is a high-resolution (800 dpi) black layer <b>262</b>. This consists of a 1-bit opacity bitmap. The medium-resolution black layer is a subsampled version of the high-resolution opacity layer. In practice, assuming the medium resolution is an integer factor n of the high resolution (e.g. n=800/267=3), each medium-resolution opacity value is obtained by averaging the corresponding n×n high-resolution opacity values. This corresponds to box-filtered subsampling. The subsampling of the black pixels effectively antialiases edges in the high-resolution black layer, thereby reducing ringing artefacts when the contone layer is subsequently JPEG-compressed and decompressed.</p>
<p id="p-0365" num="0416">The structure and size of the page buffer is illustrated in <figref idref="DRAWINGS">FIG. 36</figref>.</p>
<p id="h-0074" num="0000">8.3 Compositing Model</p>
<p id="p-0366" num="0417">For the purposes of discussing the page buffer compositing model, we define the following variables.</p>
<p id="p-0367" num="0418">
<tables id="TABLE-US-00036" num="00036">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 32</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Compositing variables</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<colspec colname="3" colwidth="42pt" align="left"/>
<colspec colname="4" colwidth="49pt" align="left"/>
<tbody valign="top">
<row>
<entry>variable</entry>
<entry>description</entry>
<entry>resolution</entry>
<entry>format</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry>n</entry>
<entry>medium to high resolution</entry>
<entry>—</entry>
<entry>—</entry>
</row>
<row>
<entry/>
<entry>scale factor</entry>
</row>
<row>
<entry>C<sub>BgM</sub></entry>
<entry>background contone layer</entry>
<entry>medium</entry>
<entry>8-bit color</entry>
</row>
<row>
<entry/>
<entry>color</entry>
<entry/>
<entry>component</entry>
</row>
<row>
<entry>C<sub>ObM</sub></entry>
<entry>contone object color</entry>
<entry>medium</entry>
<entry>8-bit color</entry>
</row>
<row>
<entry/>
<entry/>
<entry/>
<entry>component</entry>
</row>
<row>
<entry>α<sub>ObM</sub></entry>
<entry>contone object opacity</entry>
<entry>medium</entry>
<entry>8-bit opacity</entry>
</row>
<row>
<entry>α<sub>FgM</sub></entry>
<entry>medium-resolution</entry>
<entry>medium</entry>
<entry>8-bit opacity</entry>
</row>
<row>
<entry/>
<entry>foreground black</entry>
</row>
<row>
<entry/>
<entry>layer opacity</entry>
</row>
<row>
<entry>α<sub>FgH</sub></entry>
<entry>foreground black layer</entry>
<entry>high</entry>
<entry>1-bit opacity</entry>
</row>
<row>
<entry/>
<entry>opacity</entry>
</row>
<row>
<entry>α<sub>TxH</sub></entry>
<entry>black object opacity</entry>
<entry>high</entry>
<entry>1-bit opacity</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0368" num="0419">When a black object of opacity α<sub>T×H </sub>is composited with the black layer, the black layer is updated as follows:</p>
<p id="p-0369" num="0420">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <msub>
              <mi>α</mi>
              <mi>FgH</mi>
            </msub>
            <mo>⁡</mo>
            <mrow>
              <mo>[</mo>
              <mrow>
                <mi>x</mi>
                <mo>,</mo>
                <mi>y</mi>
              </mrow>
              <mo>]</mo>
            </mrow>
          </mrow>
          <mo>←</mo>
          <mrow>
            <msub>
              <mi>α</mi>
              <mi>FgH</mi>
            </msub>
            <mo>⁡</mo>
            <mrow>
              <mo>[</mo>
              <mrow>
                <mi>x</mi>
                <mo>,</mo>
                <mi>y</mi>
              </mrow>
              <mo>]</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo>⩔</mo>
        <mrow>
          <msub>
            <mi>α</mi>
            <mi>TxH</mi>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>[</mo>
            <mrow>
              <mi>x</mi>
              <mo>,</mo>
              <mi>y</mi>
            </mrow>
            <mo>]</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>Rule</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="1.1em" height="1.1ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mn>1</mn>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <msub>
            <mi>α</mi>
            <mi>FgM</mi>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>[</mo>
            <mrow>
              <mi>x</mi>
              <mo>,</mo>
              <mi>y</mi>
            </mrow>
            <mo>]</mo>
          </mrow>
        </mrow>
        <mo>←</mo>
        <mrow>
          <mfrac>
            <mn>1</mn>
            <msup>
              <mi>n</mi>
              <mn>2</mn>
            </msup>
          </mfrac>
          <mo>⁢</mo>
          <mrow>
            <munderover>
              <mo>∑</mo>
              <mrow>
                <mi>i</mi>
                <mo>=</mo>
                <mn>0</mn>
              </mrow>
              <mrow>
                <mi>n</mi>
                <mo>-</mo>
                <mn>1</mn>
              </mrow>
            </munderover>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <munderover>
                <mo>∑</mo>
                <mrow>
                  <mi>j</mi>
                  <mo>=</mo>
                  <mn>0</mn>
                </mrow>
                <mrow>
                  <mi>n</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                </mrow>
              </munderover>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mrow>
                <mn>255</mn>
                <mo>⁢</mo>
                <mrow>
                  <msub>
                    <mi>α</mi>
                    <mi>FgH</mi>
                  </msub>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>[</mo>
                    <mrow>
                      <mrow>
                        <mi>nx</mi>
                        <mo>+</mo>
                        <mi>i</mi>
                      </mrow>
                      <mo>,</mo>
                      <mrow>
                        <mi>ny</mi>
                        <mo>+</mo>
                        <mi>j</mi>
                      </mrow>
                    </mrow>
                    <mo>]</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>Rule</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="1.1em" height="1.1ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mn>2</mn>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0370" num="0421">The object opacity is simply ored with the black layer opacity (Rule 1), and the corresponding part of the medium-resolution black layer is re-computed from the high-resolution black layer (Rule 2).</p>
<p id="p-0371" num="0422">When a contone object of color C<sub>ObM </sub>and opacity α<sub>ObM </sub>is composited with the contone layer, the contone layer and the black layer are updated as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sub>BgM</sub><i>[x, y]←C</i><sub>BgM</sub><i>[x, y]</i>(1−α<sub>FgM</sub><i>[x, y]</i>) if α<sub>ObM</sub><i>[x, y]&gt;</i>0  (Rule 3)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>α<sub>FgM</sub><i>[x, y]←</i>0 if α<sub>ObM</sub><i>[x, y]&gt;</i>0  (Rule 4)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>α<sub>FgH</sub><i>[x, y]←</i>0 if α<sub>ObM</sub><i>[x/n, y/n]&gt;</i>0  (Rule 5)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sub>BgM</sub><i>[x, y]←C</i><sub>BgM</sub><i>[x, y]</i>(1−α<sub>ObM</sub><i>[x, y]</i>)+<i>C</i><sub>ObM</sub><i>[x, y]α</i><sub>ObM</sub><i>[x, y]</i>  (Rule 6)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0372" num="0423">Wherever the contone object obscures the black layer, even if not fully opaquely, the affected black layer pixels are pushed from the black layer to the contone layer, i.e. composited with the contone layer (Rule 3) and removed from the black layer (Rule 4 and Rule 5). The contone object is then composited with the contone layer (Rule 6).</p>
<p id="p-0373" num="0424">If a contone object pixel is fully opaque (i.e. α<sub>ObM</sub>[x, y]=255), then there is no need to push the corresponding black pixels into the background contone layer (Rule 3), since the background contone pixel will subsequently be completely obliterated by the foreground contone pixel (Rule 6).</p>
<p id="p-0374" num="0425"><figref idref="DRAWINGS">FIGS. 37 to 41</figref> illustrate the effect on the foreground black layer and the background contone layer of compositing objects of various types onto the image represented by the two layers. In each case the state of the two layers is shown before and after the object is composited. The different resolutions of the foreground and background layers are indicated by the layers' different pixel grid densities.</p>
<p id="p-0375" num="0426">The output image represented to the two layers is shown without a pixel grid, since the actual rendering of the image is not the focus of discussion here.</p>
<p id="p-0376" num="0427">The medium-resolution foreground black layer is not illustrated, but is implicitly present. Whenever Rule 1 is applied to the high-resolution foreground black layer, Rule 2 is implicitly applied to the medium-resolution foreground black layer. Whenever Rule 4 is applied, Rule 5 is also implicitly applied.</p>
<p id="p-0377" num="0428"><figref idref="DRAWINGS">FIG. 37</figref> illustrates the effect of compositing a black object <b>270</b> onto a white image. The black object is simply composited into the foreground black layer <b>271</b> (Rule 1). The background contone layer <b>272</b> is unaffected, and the output image <b>273</b> is the black object.</p>
<p id="p-0378" num="0429"><figref idref="DRAWINGS">FIG. 38</figref> illustrates the effect of compositing a contone object <b>280</b> onto a white image. The contone object <b>280</b> is simply composited into the background contone layer <b>282</b> (Rule 6). The foreground black layer <b>281</b> is unaffected, and the output image <b>283</b> is the contone object.</p>
<p id="p-0379" num="0430"><figref idref="DRAWINGS">FIG. 39</figref> illustrates the effect of compositing a black object <b>290</b> onto an image already containing a contone object <b>292</b>. Again the black object is simply composited into the foreground black layer <b>291</b> (Rule 1). The background contone layer is unaffected, and the output image <b>293</b> has the black object <b>290</b> over the contone object <b>292</b>.</p>
<p id="p-0380" num="0431"><figref idref="DRAWINGS">FIG. 40</figref> illustrates the effect of compositing an opaque contone object <b>300</b> onto an image already containing a black object <b>301</b>. Since the contone object obscures part of the existing black object, the affected parts of the existing bi-level object are removed from the foreground black layer <b>302</b> (Rule 4). There is no need to composite the affected parts into the contone layer because the contone object is fully opaque, and Rule 3 is therefore skipped. The contone object is composited into the background contone layer as usual <b>303</b> (Rule 6), and the output image <b>304</b> shows the contone object <b>300</b> over, and obscuring, the black object.</p>
<p id="p-0381" num="0432"><figref idref="DRAWINGS">FIG. 41</figref> illustrates the effect of compositing a partially transparent contone object <b>310</b> onto an image already containing a black object <b>311</b>. Since the contone object obscures part of the existing black object partially transparently, the affected parts of the black object are composited into the contone layer <b>312</b> (Rule 3), and are then removed from the foreground black layer <b>313</b> (Rule 4). The contone object is then composited into the background contone layer as usual <b>314</b> (Rule 6).</p>
<p id="p-0382" num="0433">The final image <b>315</b> shows darkening of those contone pixels which transparently obscure parts of the existing black object.</p>
<p id="h-0075" num="0000">8.4 Page Compression and Delivery</p>
<p id="p-0383" num="0434">Once page rendering is complete, the printer driver converts the contone layer to iPrint-specific CMYK with the help of color management functions in the graphics system.</p>
<p id="p-0384" num="0435">The printer driver then compresses and packages the black layer and the contone layer into an iPrint page description as described in Section 5.2. This page description is delivered to the printer via the standard spooler.</p>
<p id="p-0385" num="0436">Note that the black layer is manipulated as a set of 1-bit opacity values, but is delivered to the printer as a set of 1-bit black values. Although these two interpretations are different, they share the same representation, and so no data conversion is required.</p>
<p id="h-0076" num="0000">9 Windows 9X/NT Printer Driver</p>
<p id="h-0077" num="0000">9.1 Windows 9x/NT Printing System</p>
<p id="p-0386" num="0437">In the Windows 9x/NT printing system [8][9], a printer <b>320</b> is a graphics device, and an application <b>321</b> communicates with it via the graphics device interface <b>322</b> (GDI). The printer driver graphics DLL <b>323</b> (dynamic link library) implements the device-dependent aspects of the various graphics functions provided by GDI.</p>
<p id="p-0387" num="0438">The spooler <b>333</b> handles the delivery of pages to the printer, and may reside on a different machine to the application requesting printing. It delivers pages to the printer via aport monitor <b>334</b> which handles the physical connection to the printer. The optional language monitor <b>335</b> is the part of the printer driver which imposes additional protocol on communication with the printer, and in particular decodes status responses from the printer on behalf of the spooler.</p>
<p id="p-0388" num="0439">The printer driver user interface DLL <b>336</b> implements the user interface for editing printer-specific properties and reporting printer-specific events.</p>
<p id="p-0389" num="0440">The structure of the Windows 9x/NT printing system is illustrated in <figref idref="DRAWINGS">FIG. 42</figref>.</p>
<p id="p-0390" num="0441">Since iPrint uses USB IEEE-1284 emulation, there is no need to implement a language monitor for iPrint.</p>
<p id="p-0391" num="0442">The remainder of this section describes the design of the printer driver graphics DLL. It should be read in conjunction with the appropriate Windows 9x/NT DDK documentation [8][9].</p>
<p id="h-0078" num="0000">9.2 Windows 9x/NT Graphics Device Interface (GDI)</p>
<p id="p-0392" num="0443">GDI provides functions which allow an application to draw on a device surface, i.e. typically an abstraction of a display screen or a printed page. For a raster device, the device surface is conceptually a color bitmap. The application can draw on the surface in a device-independent way, i.e. independently of the resolution and color characteristics of the device.</p>
<p id="p-0393" num="0444">The application has random access to the entire device surface. This means that if a memory-limited printer device requires banded output, then GDI must buffer the entire page's GDI commands and replay them windowed into each band in turn. Although this provides the application with great flexibility, it can adversely affect performance.</p>
<p id="p-0394" num="0445">GDI supports color management, whereby device-independent colors provided by the application are transparently translated into device-dependent colors according to a standard ICC (International Color Consortium) color profile of the device. A printer driver can activate a different color profile depending, for example, on the user's selection of paper type on the driver-managed printer property sheet.</p>
<p id="p-0395" num="0446">GDI supports line and spline outline graphics (paths), images, and text. Outline graphics, including outline font glyphs, can be stroked and filled with bit-mapped brush patterns. Graphics and images can be geometrically transformed and composited with the contents of the device surface. While Windows 95/NT4 provides only boolean compositing operators, Windows 98/NT5 provides proper alpha-blending [9].</p>
<p id="h-0079" num="0000">9.3 Printer Driver Graphics DLL</p>
<p id="p-0396" num="0447">A raster printer can, in theory, utilize standard printer driver components under Windows 9x/NT, and this can make the job of developing a printer driver trivial. This relies on being able to model the device surface as a single bitmap. The problem with this is that text and images must be rendered at the same resolution. This either compromises text resolution, or generates too much output data, compromising performance.</p>
<p id="p-0397" num="0448">As described earlier, iPrint's approach is to render black text and images at different resolutions, to optimize the reproduction of each. The printer driver is therefore implemented according to the generic design described in Section 8.</p>
<p id="p-0398" num="0449">The driver therefore maintains a two-layer three-part page buffer as described in Section 8.2, and this means that the printer driver must take over managing the device surface, which in turn means that it must mediate all GDI access to the device surface.</p>
<p id="h-0080" num="0000">9.3.1 Managing the Device Surface</p>
<p id="p-0399" num="0450">The printer driver must support a number of standard functions, including the following:</p>
<p id="p-0400" num="0451">
<tables id="TABLE-US-00037" num="00037">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 33</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Standard graphics driver interface functions</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry>function</entry>
<entry>description</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>DrvEnableDriver</entry>
<entry>Initial entry point into the driver</entry>
</row>
<row>
<entry/>
<entry>graphics DLL. Returns addresses of functions</entry>
</row>
<row>
<entry/>
<entry>supported by the driver.</entry>
</row>
<row>
<entry>DrvEnablePDEV</entry>
<entry>Creates a logical representation of a physical</entry>
</row>
<row>
<entry/>
<entry>device with which the driver can associate a</entry>
</row>
<row>
<entry/>
<entry>drawing surface.</entry>
</row>
<row>
<entry>DrvEnableSurface</entry>
<entry>Creates a surface to be drawn on, associated</entry>
</row>
<row>
<entry/>
<entry>with a given PDEV.</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0401" num="0452">DrvEnablePDEV indicates to GDI, via the flGraphicsCaps member of the returned DEVINFO structure, the graphics rendering capabilities of the driver. This is discussed further below.</p>
<p id="p-0402" num="0453">DrvEnableSurface creates a device surface consisting of two conceptual layers and three parts: the 267 ppi contone layer 24-bit RGB color, the 267 ppi black layer 8-bit opacity, and the 800 dpi black layer 1-bit opacity. The virtual device surface which encapsulates these two layers has a nominal resolution of 267 ppi, so this is the resolution at which GDI operations take place.</p>
<p id="p-0403" num="0454">Although the aggregate page buffer requires about 33 MB of memory, the PC 99 office standard [5] specifies a minimum of 64 MB.</p>
<p id="p-0404" num="0455">In practice, managing the device surface and mediating GDI access to it means that the printer driver must support the following additional functions:</p>
<p id="p-0405" num="0456">
<tables id="TABLE-US-00038" num="00038">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 34</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Required graphics driver functions for a device-managed surface</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>function</entry>
<entry>description</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>DrvCopyBits</entry>
<entry>Translates between device-managed raster</entry>
</row>
<row>
<entry/>
<entry/>
<entry>surfaces and GDI-managed standard-format</entry>
</row>
<row>
<entry/>
<entry/>
<entry>bitmaps.</entry>
</row>
<row>
<entry/>
<entry>DrvStrokePath</entry>
<entry>Strokes a path.</entry>
</row>
<row>
<entry/>
<entry>DrvPaint</entry>
<entry>Paints a specified region.</entry>
</row>
<row>
<entry/>
<entry>DrvTextOut</entry>
<entry>Renders a set of glyphs at specified positions.</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0406" num="0457">Copying images, stroking paths and filling regions all occur on the contone layer, while rendering solid black text occurs on the bi-level black layer. Furthermore, rendering non-black text also occurs on the contone layer, since it isn't supported on the black layer. Conversely, stroking or filling with solid black can occur on the black layer (if we so choose).</p>
<p id="p-0407" num="0458">Although the printer driver is obliged to hook the aforementioned functions, it can punt function calls which apply to the contone layer back to the corresponding GDI implementations of the functions, since the contone layer is a standard-format bitmap. For every DrvXxx function there is a corresponding EngXxx function provided by GDI.</p>
<p id="p-0408" num="0459">As described in Section 8.2, when an object destined for the contone layer obscures pixels on the black layer, the obscured black pixels must be transferred from the black layer to the contone layer before the contone object is composited with the contone layer. The key to this process working is that obscuration is detected and handled in the hooked call, before it is punted back to GDI. This involves determining the pixel-by-pixel opacity of the contone object from its geometry, and using this opacity to selectively transfer black pixels from the black layer to the contone layer as described in Section 8.2.</p>
<p id="h-0081" num="0000">9.3.2 Determining Contone Object Geometry</p>
<p id="p-0409" num="0460">It is possible to determine the geometry of each contone object before it is rendered and thus determine efficiently which black pixels it obscures. In the case of DrvCopyBits and DrvPaint, the geometry is determined by a clip object (CLIPOBJ), which can be enumerated as a set of rectangles.</p>
<p id="p-0410" num="0461">In the case of DrvStrokePath, things are more complicated. DrvStrokePath supports both straight-line and Bezier-spline curve segments, and single-pixel-wide lines and geometric-wide lines. The first step is to avoid the complexity of Bezier-spline curve segments and geometric-wide lines altogether by clearing the corresponding capability flags (GCAPS_BEZIERS and GCAPS_GEOMETRICWIDE) in the flGraphicsCaps member of the driver's DEVINFO structure. This causes GDI to reformulate such calls as sets of simpler calls to DrvPaint. In general, GDI gives a driver the opportunity to accelerate high-level capabilities, but simulates any capabilities not provided by the driver.</p>
<p id="p-0411" num="0462">What remains is simply to determine the geometry of a single-pixel-wide straight line. Such a line can be solid or cosmetic. In the latter case, the line style is determined by a styling array in the specified line attributes (LINEATTRS). The styling array specifies how the line alternates between being opaque and transparent along its length, and so supports various dashed line effects etc.</p>
<p id="p-0412" num="0463">When the brush is solid black, straight lines can also usefully be rendered to the black layer, though with the increased width implied by the 800 dpi resolution.</p>
<p id="h-0082" num="0000">9.3.3 Rendering Text</p>
<p id="p-0413" num="0464">In the case of a DrvTextOut, things are also more complicated. Firstly, the opaque background, if any, is handled like any other fill on the contone layer (see DrvPaint). If the foreground brush is not black, or the mix mode is not effectively opaque, or the font is not scalable, or the font indicates outline stroking, then the call is punted to EngTextOut, to be applied to the contone layer. Before the call is punted, however, the driver determines the geometry of each glyph by obtaining its bitmap (via FONTOBJ_cGetGlyphs), and makes the usual obscuration check against the black layer.</p>
<p id="p-0414" num="0465">If punting a DrvTextOut call is not allowed (the documentation is ambiguous), then the driver should disallow complex text operations. This includes disallowing outline stroking (by clearing the GCAPS_VECTOR_FONT capability flag), and disallowing complex mix modes (by clearing the GCAPS_ARBMIXTXT capability flag).</p>
<p id="p-0415" num="0466">If the foreground brush is black and opaque, and the font is scalable and not stroked, then the glyphs are rendered on the black layer. In this case the driver determines the geometry of each glyph by obtaining its outline (again via FONTOBJ_cGetGlyphs, but as a PATHOBJ). The driver then renders each glyph from its outline at 800 dpi and writes it to the black layer. Although the outline geometry uses device coordinates (i.e. at 267 ppi), the coordinates are in fixed point format with plenty of fractional precision for higher-resolution rendering.</p>
<p id="p-0416" num="0467">Note that strikethrough and underline rectangles are added to the glyph geometry, if specified.</p>
<p id="p-0417" num="0468">The driver must set the GCAPS_HIGHRESTEXT flag in the DEVINFO to request that glyph positions (again in 267 ppi device coordinates) be supplied by GDI in high-precision fixed-point format, to allow accurate positioning at 800 dpi. The driver must also provide an implementation of the DrvGetGlyphMode function, so that it can indicate to GDI that glyphs should be cached as outlines rather than bitmaps. Ideally the driver should cache rendered glyph bitmaps for efficiency, memory allowing. Only glyphs below a certain point size should be cached.</p>
<p id="h-0083" num="0000">9.3.4 Compressing the Contone Layer</p>
<p id="p-0418" num="0469">As described earlier, the contone layer is compressed using JPEG. The forward discrete cosine transform (DCT) is the costliest part of JPEG compression. In current high-quality software implementations, the forward DCT of each 8×8 block requires 12 integer multiplications and 32 integer additions [7]. On a Pentium processor, an integer multiplication requires 10 cycles, and an integer addition requires 2 cycles [11]. This equates to a total cost per block of 184 cycles.</p>
<p id="p-0419" num="0470">The 25.5 MB contone layer consists of 417,588 JPEG blocks, giving an overall forward DCT cost of about 77 Mcycles. At 300 MHz, the PC 99 desktop standard [5], this equates to 0.26 seconds, which is well within the 2 second limit per page.</p>
<heading id="h-0084" level="1">10 REFERENCES</heading>
<p id="p-0420" num="0000">
<ul id="ul0013" list-style="none">
    <li id="ul0013-0001" num="0471">[1] ANSI/EIA 538-1988, <i>Facsimile Coding Schemes and Coding Control Functions for Group </i>4 <i>Facsimile Equipment</i>, August 1988</li>
    <li id="ul0013-0002" num="0472">[2] Humphreys, G. W., and V. Bruce, <i>Visual Cognition</i>, Lawrence Erlbaum Associates, 1989, p. 15</li>
    <li id="ul0013-0003" num="0473">[3] IEEE Std 1284-1994, <i>IEEE Standard Signaling Method for a Bidirectional Parallel Peripheral Interface for Personal Computers, </i>2 Dec. 1994</li>
    <li id="ul0013-0004" num="0474">[4] Intel Corp. and Microsoft Corp., <i>PC </i>98 <i>System Design Guide, </i>1997</li>
    <li id="ul0013-0005" num="0475">[5] Intel Corp. and Microsoft Corp., <i>PC </i>99 <i>System Design Guide, </i>1998</li>
    <li id="ul0013-0006" num="0476">[6] ISO/IEC 19018-1:1994, <i>Information technology—Digital compression and coding of continuous</i>-<i>tone still images: Requirements and guidelines, </i>1994</li>
    <li id="ul0013-0007" num="0477">[7] Loeffler, C., A. Ligtenberg and G. Moschytz, “Practical Fast 1-D DCT Algorithms with 11 Multiplications”, Proceedings of the International Conference on Acoustics, Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991</li>
    <li id="ul0013-0008" num="0478">[8] Microsoft Corp., <i>Microsoft Windows NT </i>4.0 <i>Device Driver Kit, </i>1997</li>
    <li id="ul0013-0009" num="0479">[9] Microsoft Corp., <i>Microsoft Windows NT </i>5.0 <i>Device Driver Kit, </i>1998</li>
    <li id="ul0013-0010" num="0480">[10] Olsen, J. “Smoothing Enlarged Monochrome Images”, in Glassner, A. S. (ed.), <i>Graphics Gems</i>, AP Professional, 1990</li>
    <li id="ul0013-0011" num="0481">[11] Schmit, M. L., <i>Pentium Processor Optimization Tools</i>, AP Professional, 1995</li>
    <li id="ul0013-0012" num="0482">[12] Sullivan, J. R., and R. L. Miller, “Digital halftoning with minimum visual modulation patterns”, U.S. Pat. No. 4,920,501, 24 Apr. 1990</li>
    <li id="ul0013-0013" num="0483">[13] Thompson, H. S., <i>Multilingual Corpus </i>1 CD-ROM, European Corpus Initiative</li>
    <li id="ul0013-0014" num="0484">[14] Urban, S. J., “Review of standards for electronic imaging for facsimile systems”, Journal of Electronic Imaging, Vol. 1(1), January 1992, pp. 5-21</li>
    <li id="ul0013-0015" num="0485">[15] USB Implementers Forum, <i>Universal Serial Bus Specification</i>, Rev 1.0, 1996</li>
    <li id="ul0013-0016" num="0486">[16] USB Implementers Forum, <i>Universal Serial Bus Device Class Definition for Printer Devices</i>, Version 1.07 Draft, 1998</li>
    <li id="ul0013-0017" num="0487">[17] Wallace, G. K., “The JPEG Still Picture Compression Standard”, <i>Communications of the ACM, </i>34(4), April 1991, pp. 30-44</li>
    <li id="ul0013-0018" num="0488">[18] Yasuda, Y., “Overview of Digital Facsimile Coding Techniques in Japan”, Proceedings of the IEEE, Vol. 68 (7), July 1980, pp. 830-845</li>
</ul>
</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-chemistry idref="CHEM-US-00001" cdx-file="US07298519-20071120-C00001.CDX" mol-file="US07298519-20071120-C00001.MOL"/>
<us-chemistry idref="CHEM-US-00002" cdx-file="US07298519-20071120-C00002.CDX" mol-file="US07298519-20071120-C00002.MOL"/>
<us-chemistry idref="CHEM-US-00003" cdx-file="US07298519-20071120-C00003.CDX" mol-file="US07298519-20071120-C00003.MOL"/>
<us-math idrefs="MATH-US-00001" nb-file="US07298519-20071120-M00001.NB">
<img id="EMI-M00001" he="14.48mm" wi="76.20mm" file="US07298519-20071120-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A printer including:
<claim-text>a data register to store printer operation parameters;</claim-text>
<claim-text>a processor in communication with the data register;</claim-text>
<claim-text>a memory device storing operational instructions for execution by the processor;</claim-text>
<claim-text>a micromechanical inkjet printhead in communication with the processor and with the data register; and</claim-text>
<claim-text>a printhead interface circuit facilitating communication between the data register and the micromechanical inkjet printhead, the data register being arranged to store one or more data feedback values from the printhead interface indicating one or more of the following: printhead nozzle temperature; actuator voltage; actuator heater resistance, actuator heater width, the operational instructions including instructions for the processor to adjust operation of the printhead on the basis of the one or more data feedback values.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A printer according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the data register is arranged to store data indicating the printhead interface's status.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A printer according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the operational instructions include instructions for the processor to determine the printhead interface's status from the data register.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A printer according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the data register is integrated with the processor.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A printer according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the operational instructions include instructions for the processor to write print parameter data to the data registers to modify print head operation.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A printer according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the print parameter data includes one or more of: data indicating a number of transfers required to load the printhead; data indicating low or high speed printing; data indicating a number of load or print cycles to be performed.</claim-text>
</claim>
</claims>
</us-patent-grant>
