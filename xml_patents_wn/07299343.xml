<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299343-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299343</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10256864</doc-number>
<date>20020927</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>434</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>712226</main-classification>
</classification-national>
<invention-title id="d0e53">System and method for cooperative execution of multiple branching instructions in a processor</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4969091</doc-number>
<kind>A</kind>
<name>Muller</name>
<date>19901100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712228</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5193157</doc-number>
<kind>A</kind>
<name>Barbour et al.</name>
<date>19930300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712234</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5768500</doc-number>
<kind>A</kind>
<name>Agrawal et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>39518401</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5951696</doc-number>
<kind>A</kind>
<name>Naaseh et al.</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714 34</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5974240</doc-number>
<kind>A</kind>
<name>Chan</name>
<date>19991000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712218</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6016543</doc-number>
<kind>A</kind>
<name>Suzuki et al.</name>
<date>20000100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>712233</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6047369</doc-number>
<kind>A</kind>
<name>Colwell et al.</name>
<date>20000400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712217</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6065115</doc-number>
<kind>A</kind>
<name>Sharangpani et al.</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712235</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6108766</doc-number>
<kind>A</kind>
<name>Hahn et al.</name>
<date>20000800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712 34</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6374346</doc-number>
<kind>B1</kind>
<name>Seshan et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>712221</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6574728</doc-number>
<kind>B1</kind>
<name>Chayut</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712234</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6662294</doc-number>
<kind>B1</kind>
<name>Kahle et al.</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712226</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6760831</doc-number>
<kind>B2</kind>
<name>Drabenstott et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712 22</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2002/0199090</doc-number>
<kind>A1</kind>
<name>Wilson</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712234</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>EP</country>
<doc-number>0 130 381</doc-number>
<kind>A2</kind>
<date>19850100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00016">
<othercit>“The PowerPC Architecture: A specification for a new family of RISC processors.” IBM, 2nd ed., May 1994, pp. 19-22, 32-40, 57, 384-388.—Author(s)—n/a.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>25</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>712234</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>712235</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>712236</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>712237</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>712226</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040064683</doc-number>
<kind>A1</kind>
<date>20040401</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Kalluri</last-name>
<first-name>Seshagiri P.</first-name>
<address>
<city>Richardson</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Trombetta</last-name>
<first-name>Ramon C.</first-name>
<address>
<city>Garland</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Krolnik</last-name>
<first-name>Adam C.</first-name>
<address>
<city>Allen</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>VeriSilicon Holdings (Cayman Islands) Co. Ltd.</orgname>
<role>02</role>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Chan</last-name>
<first-name>Eddie</first-name>
<department>2183</department>
</primary-examiner>
<assistant-examiner>
<last-name>Petranek</last-name>
<first-name>Jacob</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system for conditionally executing an instruction depending on a previously existing condition. The system disclosed is configured to handle conditional execution instructions typically specifying at least one target instruction, a processor register, and a condition within the register. The system saves a result of each of the target instructions dependent upon the existence of the condition in the specified register during execution of the conditional execution instruction. When the conditional execution instruction specifies a first flag register, the system copies the flag bits in the first flag register to a corresponding second flag register, and saves a result of each of the target instructions dependent upon the specified condition in the first flag register during execution of the conditional execution instruction. A subsequent conditional execution instruction may then specify a condition in the second flag register in order to conditionally execute target instructions based on a previously existing condition.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="218.61mm" wi="156.55mm" file="US07299343-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="182.63mm" wi="156.29mm" file="US07299343-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="84.58mm" wi="163.49mm" file="US07299343-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="115.82mm" wi="134.62mm" file="US07299343-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="172.72mm" wi="175.43mm" file="US07299343-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="162.64mm" wi="156.63mm" file="US07299343-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="173.48mm" wi="174.67mm" file="US07299343-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="130.64mm" wi="175.43mm" file="US07299343-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="219.54mm" wi="158.24mm" file="US07299343-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="136.23mm" wi="155.45mm" file="US07299343-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="191.52mm" wi="136.65mm" file="US07299343-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">This invention relates generally to data processing, and, more particularly, to apparatus and methods for conditionally executing software program instructions.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">Many modem processors employ a technique called pipelining to execute more software program instructions (instructions) per unit of time. In general, processor execution of an instruction involves fetching the instruction (e.g., from a memory system), decoding the instruction, obtaining needed operands, using the operands to perform an operation specified by the instruction, and saving a result. In a pipelined processor, the various steps of instruction execution are performed by independent units called pipeline stages. In the pipeline stages, corresponding steps of instruction execution are performed on different instructions independently, and intermediate results are passed to successive stages. By permitting the processor to overlap the executions of multiple instructions, pipelining allows the processor to execute more instructions per unit of time.</p>
<p id="p-0004" num="0003">In practice, instructions are often interdependent, and these dependencies often result in “pipeline hazards.” Pipeline hazards result in stalls that prevent instructions from continually entering a pipeline at a maximum possible rate. The resulting delays in pipeline flow are commonly called “bubbles.” The detection and avoidance of hazards presents a formidable challenge to designers of pipeline processors, and hardware solutions can be considerably complex.</p>
<p id="p-0005" num="0004">There are three general types of pipeline hazards: structural hazards, data hazards, and control hazards. A structural hazard occurs when instructions in a pipeline require the same hardware resource at the same time (e.g., access to a memory unit or a register file, use of a bus, etc.). In this situation, execution of one of the instructions must be delayed while the other instruction uses the resource.</p>
<p id="p-0006" num="0005">A “data dependency” is said to exist between two instructions when one of the instructions requires a value or data produced by the other. A data hazard occurs in a pipeline when a first instruction in the pipeline requires a value produced by a second instruction in the pipeline, and the value is not yet available. In this situation, the pipeline is typically stalled until the operation specified by the second instruction is completed and the needed value is produced.</p>
<p id="p-0007" num="0006">In general, a “scalar” processor issues instructions for execution one at a time, and a “superscalar” processor is capable of issuing multiple instructions for execution at the same time. A pipelined scalar processor concurrently executes multiple instructions in different pipeline stages; the executions of the multiple instructions are overlapped as described above. A pipelined superscalar processor, on the other hand, concurrently executes multiple instructions in different pipeline stages, and is also capable of concurrently executing multiple instructions in the same pipeline stage. Pipeline hazards typically have greater negative impacts on performances of pipelined superscalar processors than on performances of pipelined scalar processors. Examples of pipelined superscalar processors include the popular Intel® Pentium® processors (Intel Corporation, Santa Clara, Calif.) and IBM® PowerPC® processors (IBM Corporation, White Plains, N.Y.).</p>
<p id="p-0008" num="0007">A “control dependency” is said to exist between a non-branch/jump instruction and one or more preceding branch/jump instructions that determine whether the non-branch/jump instruction is executed. Conditional branch/jump instructions are commonly used in software programs (i.e., code) to effectuate changes in control flow. A change in control flow is necessary to execute one or more instructions dependent on a condition. Typical conditional branch/jump instructions include “branch if equal,” “jump if not equal,” “branch if greater than,” etc. A control hazard occurs in a pipeline when a next instruction to be executed is unknown, typically as a result of a conditional branch/jump instruction. When a conditional branch/jump instruction occurs, the correct one of multiple possible execution paths cannot be known with certainty until the condition is evaluated. Any incorrect prediction typically results in the need to purge partially processed instructions along an incorrect path from a pipeline, and refill the pipeline with instructions along the correct path.</p>
<p id="p-0009" num="0008">A software technique called “predication” provides an alternate method for conditionally executing instructions. Predication may be advantageously used to eliminate branch instructions from code, effectively converting control dependencies to data dependencies. If the resulting data dependencies are less constraining than the control dependencies that would otherwise exist, instruction execution performance of a pipelined processor may be substantially improved.</p>
<p id="p-0010" num="0009">In predicated execution, the results of one or more instructions are qualified dependent upon a value of a preceding predicate. The predicate typically has a value of “true” (e.g., binary ‘1’) or “false” (e.g., binary ‘0’). If the qualifying predicate is true, the results of the one or more subsequent instructions are saved (i.e., used to update a state of the processor). On the other hand, if the qualifying predicate is false, the results of the one or more instructions are not saved (i.e., are discarded).</p>
<p id="p-0011" num="0010">In some known processors, values of qualifying predicates are stored in dedicated predicate registers. In some of these processors, different predicate registers may be assigned (e.g., by a compiler) to instructions along each of multiple possible execution paths. Predicated execution may involve executing instructions along all possible execution paths of a conditional branch/jump instruction, and saving the results of only those instructions along the correct execution path. For example, assume a conditional branch/jump instruction has two possible execution paths. A first predicate register may be assigned to instructions along one of the two possible execution paths, and a second predicate register may be assigned to instructions along the second execution path. The processor attempts to execute instructions along both paths in parallel. When the processor determines the values of the predicate registers, results of instructions along the correct execution path are saved, and the results of instructions along the incorrect execution path are discarded.</p>
<p id="p-0012" num="0011">The above method of predicated execution involves associating instructions with predicate registers (i.e., “tagging” instructions along the possible execution paths with an associated predicate register). This tagging is typically performed by a compiler, and requires space (e.g., fields) in instruction formats to specify associated predicate registers. This presents a problem in reduced instruction set computer (RISC) processors typified by fixed-length and densely-packed instruction formats.</p>
<p id="p-0013" num="0012">Another example of conditional execution involves the TMS320C6x processor family (Texas Instruments Inc., Dallas, Tex.). In the ‘C6x’ processor family, all instructions are conditional. Multiple bits of a field in each instruction are allocated for specifying a condition. If no condition is specified, the instruction is executed. If an instruction specifies a condition, and the condition is true, the instruction is executed. On the other hand, if the specified condition is false, the instruction is not executed. This form of conditional execution also presents a problem in RISC processors in that multiple bits are allocated in fixed-length and densely-packed instruction formats.</p>
<p id="p-0014" num="0013">In a sequence of instructions (i.e., code) including a “previous” instruction and one or more “subsequent” instructions separated by one or more intervening instructions, it is often desirable to execute the subsequent instructions based on a state or condition of the processor resulting from execution of the previous instruction. Existence of the state or condition is typically indicated by certain values of one or more bits in one or more registers of the processor (e.g., a flag bit of a flag register, a status bit in a status register, etc.) following execution of the previous instruction.</p>
<p id="p-0015" num="0014">Current approaches to obtaining the above described conditional execution capability typically involve saving the contents of a register, including one or more bits with values indicative of the condition, following execution of the previous instruction. The contents of the register are typically saved either in a general purpose register of the processor, or in a memory system coupled to the processor. Following execution of the intervening instructions, the saved contents of the register are accessed or retrieved and tested (e.g., via one or more compare instructions) to determine if a particular state or condition existed in the processor during execution of the previous instruction. The subsequent instructions are then selectively executed (e.g., via conditional branch instructions) dependent upon whether the particular state or condition existed in the processor during execution of the previous instruction.</p>
<p id="p-0016" num="0015">A problem arises in that the above-described current approaches typically incur a performance penalty that may be considered substantial in some applications. For example, processors typically include a relatively small number of general purpose registers, and each general purpose register represents a considerable performance advantage over storing data in, and later retrieving data from, a memory system coupled to the processor. When a general purpose register is used to store the contents of a flag or status register in order to obtain the above described conditional execution capability, that general purpose register is not available for use by the intervening instructions. As a result, a value that might otherwise be stored in a general purpose register during executions of the intervening instructions may have to be stored in the memory system, and later retrieved from the memory system, incurring a substantial performance penalty. On the other hand, storing the contents of the flag or status register in the memory system following the previous instruction, and retrieving the contents from the memory system prior to executions of the subsequent instructions, expectedly incurs the same substantial performance penalty.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0017" num="0016">A processor is disclosed including an instruction unit and an execution unit. The instruction unit is configured to fetch and decode a conditional execution instruction and at least one target instruction. The conditional execution instruction specifies the at least one target instruction, a register of the processor, and a condition within the register. The execution unit is coupled to the instruction unit and configured to save a result of each of the at least one target instruction dependent upon the existence of the specified condition in the specified register during execution of the conditional execution instruction.</p>
<p id="p-0018" num="0017">In the event the conditional execution instruction specifies a first flag register, the execution unit copies a value of each of multiple flag bits in the first flag register to a corresponding flag bit in a second flag register, and saves a result of each of the at least one target instruction dependent upon the specified condition in the first flag register during execution of the conditional execution instruction. The values of the flag bits in the first flag register are thus saved in the second flag register for possible future use.</p>
<p id="p-0019" num="0018">A system (e.g., a computer system) is described including a memory system and a processor coupled to the memory system. The memory system includes the conditional execution instruction described above and the at least one target instruction. The processor includes the first flag register, the second flag register, the instruction unit, and the execution unit described above.</p>
<p id="p-0020" num="0019">A method is disclosed for conditionally executing at least one instruction. Operations of the method include inputting the conditional execution instruction described above and the at least one target instruction. The following operations are performed in the event the conditional execution instruction specifies a first flag register: (i) a value of each of multiple flag bits in the first flag register are copied to a corresponding flag bit in a second flag register, and (ii) a result of each of the at least one target instruction is saved dependent upon the specified condition in the first flag register during execution of the conditional execution instruction.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0021" num="0020">The invention may be understood by reference to the following description taken in conjunction with the accompanying drawings, in which like reference numerals identify similar elements, and in which:</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram of one embodiment of a data processing system including a processor coupled to a memory system, wherein the memory system includes software program instructions (i.e., “code”), and wherein the code includes a conditional execution instruction and a code block including one or more instructions to be conditionally executed;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram of one embodiment of the conditional execution instruction of <figref idref="DRAWINGS">FIG. 1</figref>;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram depicting an arrangement of the conditional execution instruction of <figref idref="DRAWINGS">FIG. 1</figref> and instructions of the code block of <figref idref="DRAWINGS">FIG. 1</figref> in the code of <figref idref="DRAWINGS">FIG. 1</figref>;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram of one embodiment of the processor of <figref idref="DRAWINGS">FIG. 1</figref>, wherein the processor includes an instruction unit, a load/store unit, an execution unit, a register file, and a pipeline control unit;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of one embodiment of the register file of <figref idref="DRAWINGS">FIG. 4</figref>, wherein the register file includes multiple general purpose registers, a hardware flag register, and a static hardware flag register;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 6A</figref> is a diagram of one embodiment of the hardware flag register of <figref idref="DRAWINGS">FIG. 5</figref>;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 6B</figref> is a diagram of one embodiment of the static hardware flag register of <figref idref="DRAWINGS">FIG. 5</figref>;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram illustrating an instruction execution pipeline implemented within the processor of <figref idref="DRAWINGS">FIG. 4</figref> by the pipeline control unit of <figref idref="DRAWINGS">FIG. 4</figref>;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIGS. 8A and 8B</figref> in combination form a flow chart of one embodiment of a method for conditionally executing one or more instructions; and</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram of one embodiment of the memory system of <figref idref="DRAWINGS">FIG. 1</figref> wherein the code includes a first conditional execution instruction and a first code block specified by the first conditional execution instruction, a second conditional execution instruction and a second code block specified by the second conditional execution instruction, and one or more intervening instructions located between the first code block and the second conditional execution instruction.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0032" num="0031">In the following disclosure, numerous specific details are set forth to provide a thorough understanding of the present invention. However, those skilled in the art will appreciate that the present invention may be practiced without such specific details. In other instances, well-known elements have been illustrated in schematic or block diagram form in order not to obscure the present invention in unnecessary detail. Additionally, some details, such as details concerning network communications, electromagnetic signaling techniques, and the like, have been omitted inasmuch as such details are not considered necessary to obtain a complete understanding of the present invention, and are considered to be within the understanding of persons of ordinary skill in the relevant art. It is further noted that all functions described herein may be performed in either hardware or software, or a combination thereof, unless indicated otherwise. Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate, components may be referred to by different names. This document does not intend to distinguish between components that differ in name, but not function. In the following discussion and in the claims, the terms “including” and “comprising” are used in an open-ended fashion, and thus should be interpreted to mean “including, but not limited to . . . ”. Also, the term “couple” or “couples” is intended to mean either an indirect or direct electrical or communicative connection. Thus, if a first device couples to a second device, that connection may be through a direct connection, or through an indirect connection via other devices and connections.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram of one embodiment of a data processing system <b>100</b> including a processor <b>102</b> coupled to a memory system <b>104</b>. The processor <b>102</b> executes instructions of a predefined instruction set. As illustrated in <figref idref="DRAWINGS">FIG. 1</figref>, the memory system <b>104</b> includes a software program (i.e., code) <b>106</b> including instructions from the instruction set. In general, the processor <b>102</b> fetches and executes instructions stored in the memory system <b>104</b>. In the embodiment of <figref idref="DRAWINGS">FIG. 1</figref>, the code <b>106</b> includes a conditional execution instruction <b>108</b> of the instruction set, and a code block <b>110</b> specified by the conditional execution instruction <b>108</b>. In general, the code block <b>110</b> includes one or more instructions selected from the instruction set. The conditional execution instruction <b>108</b> also specifies a condition that determines whether execution results of the one or more instructions of the code block <b>110</b> are saved in the processor <b>102</b> and/or the memory system <b>104</b>.</p>
<p id="p-0034" num="0033">The memory system <b>104</b> may include, for example, volatile memory structures (e.g., dynamic random access memory structures, static random access memory structures, etc.) and/or non-volatile memory structures (read only memory structures, electrically erasable programmable read only memory structures, flash memory structures, etc.).</p>
<p id="p-0035" num="0034">In the embodiment of <figref idref="DRAWINGS">FIG. 1</figref>, during execution of the code <b>106</b>, the processor <b>102</b> fetches the conditional execution instruction <b>108</b> from the memory system <b>104</b> and executes the conditional execution instruction <b>108</b>. As described in more detail below, the conditional execution instruction <b>108</b> specifies the code block <b>110</b> (e.g., a number of instructions making up the code block <b>110</b>) and a condition. During execution of the conditional execution instruction <b>108</b>, the processor <b>102</b> determines the code block <b>110</b> and the condition, and evaluates the condition to determine if the condition exists in the processor <b>102</b>. The processor <b>102</b> also fetches the instructions of the code block <b>110</b> from the memory system <b>104</b>, and executes each of the instructions of the code block <b>110</b>, producing corresponding execution results within the processor <b>102</b>. The execution results of the instructions of the code block <b>110</b> are saved in the processor <b>102</b> and/or the memory system <b>104</b> dependent upon the existence of the condition specified by the conditional execution instruction <b>108</b> in the processor <b>102</b>. In other words, the condition specified by the conditional execution instruction <b>108</b> qualifies the writeback of the execution results of the instructions of the code block <b>110</b>. The instructions of the code block <b>110</b> may otherwise traverse the pipeline normally. The results of the instructions of the code block <b>110</b> are used to change a state of the processor <b>102</b> and/or the memory system <b>104</b> only if the condition specified by the conditional execution instruction <b>108</b> exists in the processor <b>102</b>.</p>
<p id="p-0036" num="0035">In the embodiment of <figref idref="DRAWINGS">FIG. 1</figref>, the processor <b>102</b> implements a load-store architecture. That is, the instruction set includes load instructions used to transfer data from the memory system <b>104</b> to registers of the processor <b>102</b>, and store instructions used to transfer data from the registers of the processor <b>102</b> to the memory system <b>104</b>. Instructions other than the load and store instructions specify register operands, and register-to-register operations. In this manner, the register-to-register operations are decoupled from accesses to the memory system <b>104</b>.</p>
<p id="p-0037" num="0036">As indicated in <figref idref="DRAWINGS">FIG. 1</figref>, the processor <b>102</b> receives a CLOCK signal and executes instructions dependent upon the CLOCK signal. The data processing system <b>100</b> may include a phase-locked loop (PLL) circuit <b>112</b> that generates the CLOCK signal. The data processing system <b>100</b> may also include a direct memory access (DMA) circuit <b>114</b> for accessing the memory system <b>104</b> substantially independent of the processor <b>102</b>. The data processing system <b>100</b> may also include bus interface units (BIUs) <b>118</b>A and <b>118</b>B for coupling to external buses, and/or peripheral interface units (PIUs) <b>120</b>A and <b>120</b>B for coupling to external peripheral devices. An interface unit (IU) <b>116</b> may form an interface between the bus interface units (BIUs) <b>118</b>A and <b>118</b>B and/or the peripheral interface units (PIUs) <b>120</b>A and <b>120</b>B, the processor <b>102</b>, and the DMA circuit <b>114</b>. The data processing system <b>100</b> may also include a JTAG (Joint Test Action Group) circuit <b>122</b> including an IEEE Standard 1149.1 compatible boundary scan access port for circuit-level testing of the processor <b>102</b>. The processor <b>102</b> may also receive and respond to external interrupt signals (i.e., interrupts) as indicted in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 2</figref> depicts one embodiment of the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref>. In the embodiment of <figref idref="DRAWINGS">FIG. 2</figref>, the conditional execution instruction <b>108</b> and the one or more instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> are fixed-length instructions (e.g., 16-bit instructions), and the instructions of the code block <b>110</b> immediately follow the conditional execution instruction <b>108</b> in the code <b>106</b> of <figref idref="DRAWINGS">FIG. 1</figref>. It is noted that other embodiments of the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> are possible and contemplated.</p>
<p id="p-0039" num="0038">In the embodiment of <figref idref="DRAWINGS">FIG. 2</figref>, the conditional execution instruction <b>108</b> includes a block size specification field <b>200</b>, a select bit <b>202</b>, a condition bit <b>204</b>, a condition specification field <b>206</b>, and a root encoding field <b>208</b>. The block size specification field <b>200</b> is used to store a value indicating a number of instructions immediately following the conditional execution instruction <b>108</b> and making up the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref>. The block size specification field <b>200</b> may be, for example, a 3-bit field specifying a code block including from 1 (block size specification field=“000”) to 8 (block size specification field=“111”) instructions immediately following the conditional execution instruction <b>108</b>. Larger code blocks <b>110</b> could be specified by increasing the size or number of bits in the block size specification field <b>200</b>.</p>
<p id="p-0040" num="0039">As described in detail below, the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref> includes multiple flag registers and multiple general purpose registers. A value of the select bit <b>202</b> indicates whether the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a flag register or in a general purpose register. For example, if the select bit <b>202</b> is a ‘0,’ the select bit <b>202</b> may indicate that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a flag register. On the other hand, if the select bit <b>202</b> is a ‘1,’ the select bit <b>202</b> may indicate that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a general purpose register.</p>
<p id="p-0041" num="0040">In general, the condition bit <b>204</b> specifies a value used to qualify the execution results of the instructions in the code block <b>110</b>. For example, if the condition bit <b>204</b> is a ‘0,’ the execution results of the instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> may be qualified (i.e., stored) only if a value stored in a specified register of the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref> is equal to ‘0’ during execution of the conditional execution instruction <b>108</b>. On the other hand, if the condition bit <b>204</b> is a ‘1,’ the execution results of the instructions of the code block <b>110</b> may be stored only if the value stored in the specified register is not equal to ‘0’.</p>
<p id="p-0042" num="0041">For example, when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a flag register and the condition bit <b>204</b> is a ‘0,’ the condition specified by the conditional execution instruction <b>108</b> may be that the value of a specified flag bit in a specified flag register is ‘0.’ Similarly, when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a general purpose register and the condition bit <b>204</b> is a ‘0,’ the condition specified by the conditional execution instruction <b>108</b> may be that the value stored in the specified general purpose register is ‘0.’</p>
<p id="p-0043" num="0042">In a similar manner, when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a flag register and the condition bit <b>204</b> is a ‘1,’ the condition specified by the conditional execution instruction <b>108</b> may be that the value of the specified flag bit in the specified flag register is ‘1.’ Similarly, when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a general purpose register and the condition bit <b>204</b> is a ‘1,’ the condition specified by the conditional execution instruction <b>108</b> may be that the value stored in the specified general purpose register is non-zero, or not equal to ‘0’.</p>
<p id="p-0044" num="0043">In general, the condition specification field <b>206</b> specifies either a particular flag bit in a particular flag register, or a particular one of the multiple general purpose registers of the processor <b>102</b>. For example, when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a flag register, the condition specification field <b>206</b> specifies a particular one of the multiple flag registers of the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref>, and a particular one of several flag bits in the specified flag register. When the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a general purpose register, the condition specification field <b>206</b> specifies a particular one of the multiple general purpose registers of the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0045" num="0044">As described in more detail below, the embodiment of the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref> includes two flag registers: a hardware flag register ‘HWFLAG’ and a static hardware flag register ‘SHWFLAG.’ Both the HWFLAG and the SHWFLAG registers store the following flag bits:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0045">v=32-Bit Overflow Flag. Cleared (i.e., ‘0’) when a sign of a result of a twos-complement addition is the same as signs of 32-bit operands (where both operands have the same sign); set (i.e., ‘1’) when the sign of the result differs from the signs of the 32-bit operands.</li>
        <li id="ul0002-0002" num="0046">gv=Guard Register 40-Bit Overflow Flag. (Same as the ‘v’ flag bit described above, but for 40-bit operands.)</li>
        <li id="ul0002-0003" num="0047">sv=Sticky Overflow Flag. (Same as the ‘v’ flag bit described above, but once set, can only be cleared through software by writing a ‘0’ to the ‘sv’ bit.)</li>
        <li id="ul0002-0004" num="0048">gsv=Guard Register Sticky Overflow Flag. (Same as the ‘gv’ flag bit described above, but once set, can only be cleared through software by writing a ‘0’ to the ‘gsv’ bit.)</li>
        <li id="ul0002-0005" num="0049">c=Carry Flag. Set when a carry occurs during a twos-complement addition for 16-bit operands; cleared when no carry occurs.</li>
        <li id="ul0002-0006" num="0050">ge=Greater Than Or Equal To Flag. Set when a result is greater than or equal to zero; cleared when the result is not greater than or equal to zero.</li>
        <li id="ul0002-0007" num="0051">gt=Greater Than Flag. Set when a result is greater than zero; cleared when the result is not greater than zero.</li>
        <li id="ul0002-0008" num="0052">z=Equal to Zero Flag. Set when a result is equal to zero; cleared when the result is not equal to zero.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0046" num="0053">Table 1 below lists exemplary encoding of the condition specification field <b>206</b> vaild when the select bit <b>202</b> indiciates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a flag register:</p>
<p id="p-0047" num="0054">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 1</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Exemplary Encodings of the Condition Specification Field 206</entry>
</row>
<row>
<entry>Valid When the Select Bit 202 Indicates the Condition</entry>
</row>
<row>
<entry>Is Stored in a Flag Register.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="91pt" align="center"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="84pt" align="center"/>
<tbody valign="top">
<row>
<entry>Cond. Spec.</entry>
<entry>Specified</entry>
<entry>Specified</entry>
</row>
<row>
<entry>Field 206</entry>
<entry>Flag</entry>
<entry>Flag</entry>
</row>
<row>
<entry>Value</entry>
<entry>Register</entry>
<entry>Bit</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="91pt" align="char" char="."/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="84pt" align="center"/>
<tbody valign="top">
<row>
<entry>0000</entry>
<entry>HWFLAG</entry>
<entry>v</entry>
</row>
<row>
<entry>0001</entry>
<entry>HWFLAG</entry>
<entry>gv</entry>
</row>
<row>
<entry>0010</entry>
<entry>HWFLAG</entry>
<entry>sv</entry>
</row>
<row>
<entry>0011</entry>
<entry>HWFLAG</entry>
<entry>gsv</entry>
</row>
<row>
<entry>0100</entry>
<entry>HWFLAG</entry>
<entry>c</entry>
</row>
<row>
<entry>0101</entry>
<entry>HWFLAG</entry>
<entry>ge</entry>
</row>
<row>
<entry>0110</entry>
<entry>HWFLAG</entry>
<entry>gt</entry>
</row>
<row>
<entry>0111</entry>
<entry>HWFLAG</entry>
<entry>z</entry>
</row>
<row>
<entry>1000</entry>
<entry>SHWFLAG</entry>
<entry>v</entry>
</row>
<row>
<entry>1001</entry>
<entry>SHWFLAG</entry>
<entry>gv</entry>
</row>
<row>
<entry>1010</entry>
<entry>SHWFLAG</entry>
<entry>sv</entry>
</row>
<row>
<entry>1011</entry>
<entry>SHWFLAG</entry>
<entry>gsv</entry>
</row>
<row>
<entry>1100</entry>
<entry>SHWFLAG</entry>
<entry>c</entry>
</row>
<row>
<entry>1101</entry>
<entry>SHWFLAG</entry>
<entry>ge</entry>
</row>
<row>
<entry>1110</entry>
<entry>SHWFLAG</entry>
<entry>gt</entry>
</row>
<row>
<entry>1111</entry>
<entry>SHWFLAG</entry>
<entry>z</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0048" num="0055">For example, referring to Table 1 above, when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a flag register, a ‘0101’ encoding of the condition specification field <b>206</b> of the conditional execution instruction <b>108</b> specifies the hardware flag register and the ‘ge’ flag bit of the hardware flag register. If the condition bit <b>204</b> indicates the specified value must be a ‘1,’ and the ‘ge’ flag bit of the hardware flag register is ‘1’ during execution of the conditional execution instruction <b>108</b>, the execution results of the instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> are saved. On the other hand, if the ‘ge’ <b>108</b>, the execution results of the instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> are not saved (i.e., the execution results are discarded).</p>
<p id="p-0049" num="0056">As described in more detail below, the embodiment of the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref> also includes <b>16</b> general purpose registers (GPRs) numbered ‘0’ through ‘15.’ Table 2 below lists exemplary encodings of the condition specification field <b>206</b> valid when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a general purpose register:</p>
<p id="p-0050" num="0057">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 2</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Exemplary Encodings of the Condition Specification Field 206</entry>
</row>
<row>
<entry>Valid When the Select Bit 202 Indicates the Condition</entry>
</row>
<row>
<entry>Is Stored in a General Purpose Register.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Cond. Spec.</entry>
<entry/>
</row>
<row>
<entry/>
<entry>Field 206</entry>
<entry>Specified</entry>
</row>
<row>
<entry/>
<entry>Value</entry>
<entry>GPR</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>0000</entry>
<entry>GPR 0</entry>
</row>
<row>
<entry/>
<entry>0001</entry>
<entry>GPR 1</entry>
</row>
<row>
<entry/>
<entry>0010</entry>
<entry>GPR 2</entry>
</row>
<row>
<entry/>
<entry>0011</entry>
<entry>GPR 3</entry>
</row>
<row>
<entry/>
<entry>0100</entry>
<entry>GPR 4</entry>
</row>
<row>
<entry/>
<entry>0101</entry>
<entry>GPR 5</entry>
</row>
<row>
<entry/>
<entry>0110</entry>
<entry>GPR6</entry>
</row>
<row>
<entry/>
<entry>0111</entry>
<entry>GPR7</entry>
</row>
<row>
<entry/>
<entry>1000</entry>
<entry>GPR8</entry>
</row>
<row>
<entry/>
<entry>1001</entry>
<entry>GPR9</entry>
</row>
<row>
<entry/>
<entry>1010</entry>
<entry>GPR10</entry>
</row>
<row>
<entry/>
<entry>1011</entry>
<entry>GPR11</entry>
</row>
<row>
<entry/>
<entry>1100</entry>
<entry>GPR12</entry>
</row>
<row>
<entry/>
<entry>1101</entry>
<entry>GPR13</entry>
</row>
<row>
<entry/>
<entry>1110</entry>
<entry>GPR14</entry>
</row>
<row>
<entry/>
<entry>1111</entry>
<entry>GPR15</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0051" num="0058">For example, referring to Table 2 above, when the select bit <b>202</b> indicates that the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is stored in a general purpose register, a ‘1011’ encoding of the condition specification field <b>206</b> of the conditional execution instruction <b>108</b> specifies the GPR <b>11</b> register of the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref>. If the condition bit <b>204</b> is a ‘1,’ and the GPR <b>11</b> register does not contain a ‘0’ during execution of the conditional execution instruction <b>108</b>, the execution results of the instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> are saved. On the other hand, if the GPR <b>11</b> register contains a ‘0’ during execution of the conditional execution instruction <b>108</b>, the execution results of the instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> are not saved (i.e., the execution results are discarded).</p>
<p id="p-0052" num="0059">The root encoding field <b>208</b> identifies an operation code (opcode) of the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 2</figref>. In other embodiments of the conditional execution instruction <b>108</b>, the root encoding filed <b>208</b> may also help define the condition specified by the conditional execution instruction <b>108</b>. For example, the root encoding field <b>208</b> may also specify a particular group of registers within the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref> and/or a particular register within the processor <b>102</b>.</p>
<p id="p-0053" num="0060"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram depicting an arrangement of the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> and instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> in the code <b>106</b> of <figref idref="DRAWINGS">FIG. 1</figref>. In the embodiment of <figref idref="DRAWINGS">FIG. 3</figref>, the code block <b>110</b> includes N instruction. The conditional execution instruction <b>108</b> is instruction number M in the code <b>106</b>, and the N instructions of the code block <b>110</b> includes instructions <b>300</b>A, <b>300</b>B, and <b>300</b>C. The instruction <b>300</b>A immediately follows the conditional execution instruction <b>108</b> in the code <b>106</b>, and is instruction number M+1 of the code <b>106</b>. The instruction <b>300</b>B immediately follows the instruction <b>300</b>A in the code <b>106</b>, and is instruction number M+2 of the code <b>106</b>. The instruction <b>300</b>C is instruction number M+N of the code <b>106</b>, and is the nth (i.e., last) instruction of the code block <b>110</b>. The value of N would be set in the block size specification filed <b>200</b> of the conditional execution instruction <b>108</b> as illustrated in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0054" num="0061"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram of one embodiment of the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref>. In the embodiment of <figref idref="DRAWINGS">FIG. 4</figref>, the processor <b>102</b> includes an instruction unit <b>400</b>, a load/store unit <b>402</b>, an execution unit <b>404</b>, a register file <b>406</b>, and a pipeline control unit <b>408</b> coupled to one another as shown in <figref idref="DRAWINGS">FIG. 4</figref>. In the embodiment of <figref idref="DRAWINGS">FIG. 4</figref>, the processor <b>102</b> is a pipelined superscalar processor. That is, the processor <b>102</b> implements an instruction execution pipeline including multiple pipeline stages, concurrently executes multiple instructions in different pipeline stages, and is also capable of concurrently executing multiple instructions in the same pipeline stage.</p>
<p id="p-0055" num="0062">In general, the instruction unit <b>400</b> fetches instructions from the memory system <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref> and decodes the instructions, thereby producing decoded instructions. The load/store unit <b>402</b> is used to transfer data between the processor <b>102</b> and the memory system <b>104</b> as described above. The execution unit <b>404</b> is used to perform operations specified by instructions (and corresponding decoded instructions). The register file <b>406</b> includes multiple registers of the processor <b>102</b>, and is described in more detail below. The pipeline control unit <b>408</b> implements the instruction execution pipeline described in more detail below.</p>
<p id="p-0056" num="0063"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of one embodiment of the register file <b>406</b> of <figref idref="DRAWINGS">FIG. 4</figref>, wherein the register file <b>406</b> includes sixteen 16-bit general purpose registers <b>500</b> numbered 0 through 15, the hardware flag register described above and labeled <b>502</b> in <figref idref="DRAWINGS">FIG. 5</figref>, and the static hardware flag register described above and labeled <b>504</b> in <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0057" num="0064"><figref idref="DRAWINGS">FIG. 6A</figref> is a diagram of one embodiment of the hardware flag register <b>502</b> of <figref idref="DRAWINGS">FIG. 5</figref>. In the embodiment of <figref idref="DRAWINGS">FIG. 6A</figref>, the hardware flag register <b>502</b> includes the flag bits ‘v’, ‘gv’, ‘sv’, ‘gsv’, ‘c’, ‘ge’, ‘gt’, and ‘z’ described above. The hardware flag register <b>502</b> is updated during instruction execution such that the flag bits in the hardware flag register <b>502</b> reflect a state or condition of the processor <b>102</b> of <figref idref="DRAWINGS">FIGS. 1 and 4</figref> resulting from instruction execution.</p>
<p id="p-0058" num="0065"><figref idref="DRAWINGS">FIG. 6B</figref> is a diagram of one embodiment of the static hardware flag register <b>504</b> of <figref idref="DRAWINGS">FIG. 5</figref>. In the embodiment of <figref idref="DRAWINGS">FIG. 6B</figref>, the static hardware flag register <b>504</b> also includes the flag bits ‘v’, ‘gv’, ‘sv’, ‘gsv’, ‘c’, ‘ge’, ‘gt’, and ‘z’ described above. Unlike the hardware flag register <b>502</b> of <figref idref="DRAWINGS">FIGS. 5 and 6A</figref>, and as will be described in detail below, the static hardware flag register <b>504</b> is updated only when a conditional execution instruction in the code <b>106</b> of <figref idref="DRAWINGS">FIG. 1</figref> (e.g., the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIGS. 1 and 3</figref>) specifies the hardware flag register <b>502</b>.</p>
<p id="p-0059" num="0066">As defined hereinbelow, a “hardware flag register” is a flag register that is updated during instruction execution such that flag bits in the flag register reflect a state or condition of a processor resulting from instruction execution. A “static hardware flag register” is a flag register that is updated from a hardware flag register, and used to store persistent values of the flag bits of the hardware flag register.</p>
<p id="p-0060" num="0067"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram illustrating the instruction execution pipeline implemented within the processor <b>102</b> of <figref idref="DRAWINGS">FIG. 4</figref> by the pipeline control unit <b>408</b> of <figref idref="DRAWINGS">FIG. 4</figref>. The instruction execution pipeline (pipeline) allows overlapped execution of multiple instructions. In the example of <figref idref="DRAWINGS">FIG. 7</figref>, the pipeline includes 8 stages: a fetch/decode (FD) stage, a grouping (GR) stage, an operand read (RD) stage, an address generation (AG) stage, a memory access 0 (M0) stage, a memory access 1 (M1) stage, an execution (EX) stage, and a write back (WB) stage.</p>
<p id="p-0061" num="0068">The processor <b>102</b> of <figref idref="DRAWINGS">FIG. 4</figref> uses the CLOCK signal to generate an internal clock signal. As indicated in <figref idref="DRAWINGS">FIG. 7</figref>, operations in each of the 8 pipeline stages are completed during a single cycle of the internal clock signal.</p>
<p id="p-0062" num="0069">Referring to <figref idref="DRAWINGS">FIGS. 4 and 7</figref>, the instruction unit <b>400</b> of <figref idref="DRAWINGS">FIG. 4</figref> fetches several instructions (e.g., <b>6</b> instructions) from the memory system <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref> during the fetch/decode (FD) pipeline stage of <figref idref="DRAWINGS">FIG. 7</figref>, decodes the instructions, and provides the decoded instructions to the pipeline control unit <b>408</b>.</p>
<p id="p-0063" num="0070">During the grouping (GR) stage, the pipeline control unit <b>408</b> checks the multiple decoded instructions for grouping and dependency rules, and passes one or more of the decoded instructions conforming to the grouping and dependency rules on to the read operand (RD) stage as a group. During the read operand (RD) stage, the pipeline control unit <b>408</b> obtains any operand values, and/or values needed for operand address generation, for the group of decoded instructions from the register file <b>406</b>.</p>
<p id="p-0064" num="0071">During the address generation (AG) stage, the pipeline control unit <b>408</b> provides any values needed for operand address generation to the load/store unit <b>402</b>, and the load/store unit <b>402</b> generates internal addresses of any operands located in the memory system <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref>. During the memory address 0 (M0) stage, the load/store unit <b>402</b> translates the internal addresses to external memory addresses used within the memory system <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0065" num="0072">During the memory address 1 (M1) stage, the load/store unit <b>402</b> uses the external memory addresses to obtain any operands located in the memory system <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref>. During the execution (EX) stage, the execution unit <b>404</b> uses the operands to perform operations specified by the one or more instructions of the group. During the write back (WB) stage, valid results (including qualified results) are stored in registers of the register file <b>406</b>.</p>
<p id="p-0066" num="0073">During the write back (WB) stage, valid results (including qualified results) of store instructions, used to store data in the memory system <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref> as described above, are provided to the load/store unit <b>402</b>. Such store instructions are typically used to copy values stored in registers of the register file <b>406</b> to memory locations of the memory system <b>104</b>.</p>
<p id="p-0067" num="0074">Referring to <figref idref="DRAWINGS">FIGS. 1</figref>, <b>4</b>, <b>5</b> and <b>7</b>, the conditional execution instruction <b>108</b> is typically one of several instructions (e.g., 6 instructions) fetched from the memory system <b>104</b> by the instruction unit <b>400</b> and decoded during the fetch/decode (FD) stage. During the execution (EX) stage of the conditional execution instruction <b>108</b>, the register specified by the conditional execution instruction <b>108</b> (e.g., the flag register <b>502</b> or one of the general purpose registers <b>500</b>) is accessed. The execution unit <b>404</b> may test the specified register for the specified condition, and provide a comparison result to the pipeline control unit <b>408</b>.</p>
<p id="p-0068" num="0075">As described above, if the conditional execution instruction <b>108</b> specifies the hardware flag register <b>502</b>, the values of the flag bits in the hardware flag register <b>502</b> are copied to the corresponding flag bits in the static hardware flag register <b>504</b>. For example, if the conditional execution instruction <b>108</b> specifies the hardware flag register <b>502</b>, the pipeline control unit <b>408</b> may produce a signal that causes the values of the flag bits in the hardware flag register to be copied to the corresponding flag bits in the static hardware flag register <b>504</b>.</p>
<p id="p-0069" num="0076">During the execution (EX) stage of each of the instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref>, the pipeline control unit <b>408</b> may produce a signal dependent on whether the specified condition existed in the specified register during the execution stage of the conditional execution instruction <b>108</b>, and provides the signal to the execution unit <b>404</b>. The execution unit <b>404</b> saves results of the instructions of the code block <b>110</b> dependent upon the signal. For example, if the specified condition existed in the specified register during the execution (EX) stage of the conditional execution instruction <b>108</b>, the pipeline control unit <b>408</b> may assert the signal during the execution (EX) stage of each of the instructions of the code block <b>110</b>, and the execution unit <b>404</b> may provide the results of the instructions of the code block <b>110</b> to the register file <b>406</b> only when the signal is asserted.</p>
<p id="p-0070" num="0077">In the embodiment of <figref idref="DRAWINGS">FIG. 7</figref>, if the condition specified by the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref> is true, the results of the instructions making up the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref> are qualified, and the results are written to the register file <b>406</b> of <figref idref="DRAWINGS">FIGS. 4-5</figref> during the corresponding write back (WB) stages. If the specified condition is not true, the results of the instructions of the code block <b>110</b> are not qualified, and are not written to the register file <b>406</b> during the corresponding execution stages (i.e., are ignored).</p>
<p id="p-0071" num="0078"><figref idref="DRAWINGS">FIGS. 8A and 8B</figref> in combination form a flow chart of one embodiment of a method <b>800</b> for conditionally executing one or more instructions (e.g., instructions of the code block <b>110</b> of <figref idref="DRAWINGS">FIG. 1</figref>). The method <b>800</b> may be embodied within the processor <b>102</b> of <figref idref="DRAWINGS">FIGS. 1 and 4</figref>. During an operation <b>802</b> of the method <b>800</b>, a conditional execution instruction (e.g., the conditional execution instruction <b>108</b> of <figref idref="DRAWINGS">FIG. 1</figref>) and the one or more instructions to be conditionally executed (i.e., “target instructions”) are input (i.e., fetched or received). The conditional execution instruction specifies the one or more target instructions, a register (e.g., one of multiple flag registers or one of multiple general purpose registers), and a condition within the register (e.g., a value of a bit in a flag register or a value stored in a general purpose register).</p>
<p id="p-0072" num="0079">During a decision operation <b>804</b>, a determination is made as to whether the conditional execution instruction specifies a hardware flag register (i.e., a flag register that is updated during instruction execution such that flag bits in the flag register reflect a state or condition of a processor resulting from instruction execution such as the hardware flag register <b>502</b> of <figref idref="DRAWINGS">FIGS. 5 and 6A</figref>). In the event the conditional execution instruction specifies the hardware flag register, operations <b>806</b> and <b>808</b> are performed. On the other hand, if the conditional execution instruction does not specify the hardware flag register, a decision operation <b>810</b> is performed next.</p>
<p id="p-0073" num="0080">During the operation <b>806</b>, values of the flag bits in the hardware flag register are copied to corresponding flag bits in a static hardware flag register (e.g., the static flag register <b>504</b> of <figref idref="DRAWINGS">FIGS. 5 and 6B</figref>). The values of the flag bits existing in the hardware flag register when the conditional execution instruction is fetched or received are thus made available within the processor to subsequent instructions.</p>
<p id="p-0074" num="0081">During the operation <b>808</b>, a result of each of the one or more target instructions is saved dependent upon whether the specified condition exists in the hardware flag register during execution of the conditional execution instruction. For example, as described above, a conditional execution instruction that specifies the hardware flag register also specifies a flag bit within the hardware flag register, and a required value of the specified flag bit. During the operation <b>808</b>, the result of each of the one or more target instructions may be saved only if the specified flag bit in the hardware flag register has the specified value during execution of the conditional execution instruction.</p>
<p id="p-0075" num="0082">During the decision operation <b>810</b>, a determination is made as to whether the conditional execution instruction specifies a static hardware flag register (i.e., a flag register that is updated from a hardware flag register and used to store persistent values of the flag bits of the hardware flag register, such as the static hardware flag register <b>504</b> of <figref idref="DRAWINGS">FIGS. 5 and 6B</figref>). In the event the conditional execution instruction specifies the static hardware flag register, an operation <b>812</b> is performed.</p>
<p id="p-0076" num="0083">During the operation <b>812</b>, a result of each of the one or more target instructions is saved dependent upon whether the specified condition exists in the static hardware flag register during execution of the conditional execution instruction. For example, as described above, a conditional execution instruction that specifies the static hardware flag register also specifies a flag bit within the static hardware flag register, and a required value of the specified flag bit. During the operation <b>812</b>, the result of each of the one or more target instructions may be saved only if the specified flag bit in the static hardware flag register has the specified value during execution of the conditional execution instruction.</p>
<p id="p-0077" num="0084"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram of one embodiment of the memory system <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref> wherein the code <b>106</b> includes a first conditional execution instruction <b>108</b>A and a first code block <b>110</b>A specified by the first conditional execution instruction <b>108</b>A, a second conditional execution instruction <b>108</b>B and a second code block <b>110</b>B specified by the second conditional execution instruction <b>108</b>B, and one or more intervening instructions <b>900</b> located between the first code block <b>110</b>A and the second conditional execution instruction <b>108</b>B.</p>
<p id="p-0078" num="0085">The first conditional execution instruction <b>108</b>A may, for example, specify the hardware flag register <b>502</b> (<figref idref="DRAWINGS">FIGS. 5 and 6A</figref>) of the processor <b>102</b> (<figref idref="DRAWINGS">FIGS. 1 and 4</figref>). In this situation, when the first conditional execution instruction <b>108</b>A is input to the processor <b>102</b>, values of the flag bits in the hardware flag register <b>502</b> are copied to corresponding flag bits in the static flag register <b>504</b> (<figref idref="DRAWINGS">FIGS. 5 and 6B</figref>). The values of the flag bits existing in the hardware flag register <b>502</b> when the conditional execution instruction <b>108</b>A is fetched or received, by virtue of being stored in the static hardware flag register <b>504</b>, are advantageously made available to the intervening instructions <b>900</b> and the second conditional execution instruction <b>108</b>B.</p>
<p id="p-0079" num="0086">For example, the second conditional execution instruction <b>108</b>B may specify the static hardware flag register <b>504</b> (<figref idref="DRAWINGS">FIGS. 5 and 6B</figref>) of the processor <b>102</b> (<figref idref="DRAWINGS">FIGS. 1 and 4</figref>). In this situation, values of the flag bits of the hardware register <b>502</b> existing when the conditional execution instruction <b>108</b>A was fetched or received are advantageously made available to the second conditional execution instruction <b>108</b>B, and results of the instructions of the second code block <b>110</b>B are saved dependent upon a condition existing in the hardware register <b>502</b> when the conditional execution instruction <b>108</b>A was fetched or received.</p>
<p id="p-0080" num="0087">It is noted that by virtue of automatically storing the contents of the hardware flag register <b>502</b> (<figref idref="DRAWINGS">FIGS. 5 and 6A</figref>) in the static hardware flag register <b>504</b> (<figref idref="DRAWINGS">FIGS. 5 and 6B</figref>), the values of the flag bits existing in the hardware flag register <b>502</b> when the conditional execution instruction <b>108</b>A is fetched or received are advantageously made available to the second conditional execution instruction <b>108</b>B without having to store the contents of the hardware flag register <b>502</b> in a general purpose register or in a memory location of the memory system <b>104</b>. As a result, the intervening instructions <b>900</b> are free to use a general purpose register that may have otherwise been required to store the contents of the hardware flag register <b>502</b>. Alternately, a lengthy store operation to the memory system <b>104</b> to store the contents of the hardware flag register <b>502</b>, and a subsequent lengthy load operation to retrieve the stored contents of the hardware flag register <b>502</b> from the memory system <b>104</b>, are avoided. In either case, the performance of the processor <b>102</b> is increased.</p>
<p id="p-0081" num="0088">The particular embodiments disclosed above are illustrative only, as the invention may be modified and practiced in different but equivalent manners apparent to those skilled in the art having the benefit of the teachings herein. Furthermore, no limitations are intended to the details of construction or design herein shown, other than as described in the claims below. It is therefore evident that the particular embodiments disclosed above may be altered or modified and all such variations are considered within the scope and spirit of the invention. Accordingly, the protection sought herein is as set forth in the claims below.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What we claim as our invention is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A processor, comprising:
<claim-text>an instruction unit configured to process a conditional execution instruction and at least one target instruction, wherein the conditional execution instruction specifies the at least one target instruction, a register, and a condition within the register;</claim-text>
<claim-text>an execution unit operably coupled to the instruction unit and configured to execute the conditional execution instruction and unconditionally execute the at least one target instruction, but to save a result of the at least one target instruction only if the result of the at least one target instruction is qualified by the existence of the specified condition in the specified register during execution of the conditional execution instruction; and</claim-text>
<claim-text>wherein in the event the conditional execution instruction specifies a first flag register, the execution unit is configured to copy a value of a plurality of flag bits in the first flag register to a corresponding second plurality of flag bits in a second flag register, and to save a result of the at least one target instruction dependent upon the specified condition in the first flag register during execution of the conditional execution instruction, wherein the first flag and second flag registers are dedicated flag registers.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first flag register is configured to store a first plurality of flag bits, and wherein each of the first plurality of flag bits is indicative of a different condition existing within the processor.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The processor as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the first flag register is a hardware flag register updated during instruction execution such that the first plurality of flag bits reflect a state or condition of the processor resulting from instruction execution.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The processor as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the second flag register is configured to store the second plurality of flag bits, and wherein each of the second plurality of flag bits corresponds to a flag bit in the first plurality of flag bits.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The processor as recited in <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the second flag register is a static hardware flag register updated from the first flag register and used to store copies of the first plurality of flag bits.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The processor as recited in <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein in the event the conditional execution instruction specifies the first flag register and a value of one of the first plurality of flag bits in the first flag register, the execution unit is configured to copy a value of each of the first plurality of flag bits in the first flag register to the corresponding one of the second plurality of flag bits in the second flag register, and to save the result of each of the at least one target instruction dependent upon the value of the specified one of the first plurality of flag bits in the first flag register during execution of the conditional execution instruction.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conditional execution instruction is a fixed-length instruction.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one target instruction comprises a code block including a plurality of consecutive instructions, and wherein the conditional execution instruction specifies the code block.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The processor as recited in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the conditional execution instruction comprises a field specifying the code block.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conditional execution instruction comprises a field specifying the register.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conditional execution instruction comprises at least one bit position specifying the condition within the register.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conditional execution instruction specifies a flag register or a general purpose register within the processor.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the execution unit is configured to perform an operation specified by each of the at least one target instruction, thereby producing the result of the at least one target instruction.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a second conditional execution instruction specifying a second at least one target instruction, wherein in the event the second conditional execution instruction specifies the second flag register and a value of one of the second plurality of flag bits in the second flag register, the execution unit is configured to save the result of each of the second at least one target instruction dependent upon the value of the specified one of the second plurality of flag bits in the second flag register during execution of the second conditional execution instruction.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A system, comprising:
<claim-text>a memory system and a processor coupled to the memory system;</claim-text>
<claim-text>wherein the memory system comprises a conditional execution instruction and at least one target instruction, wherein the conditional execution instruction specifies the at least one target instruction, a register, and a condition within the register;</claim-text>
<claim-text>wherein the processor comprises:
<claim-text>a first flag register and a second flag register;</claim-text>
<claim-text>an instruction unit configured to process the conditional execution instruction and the least one target instruction from the memory system;</claim-text>
<claim-text>an execution unit operably coupled to the instruction unit and configured to execute the conditional execution instruction and unconditionally execute the at least one target instruction, but to save a result of the at least one target instruction only if the result of the at least one target instruction is qualified by the existence of the specified condition in the specified register during execution of the conditional execution instruction; and</claim-text>
<claim-text>wherein in the event the conditional execution instruction specifies the first flag register, the execution unit is configured to copy the value of the flag bit to a corresponding flag bit of the second flag register, and to save a result of the at least one target instruction dependent upon the specified condition in the first flag register during execution of the conditional execution instruction, wherein the first flag and second flag registers are dedicated flag registers.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A method for conditionally executing at least one instruction, the method comprising:
<claim-text>inputting a conditional execution instruction and an at least one target instruction, wherein the conditional execution instruction specifies the at least one target instruction, a register, and a condition within the register;</claim-text>
<claim-text>unconditionally executing the at least one target instruction;</claim-text>
<claim-text>performing the following in the event the conditional execution instruction specifies a first flag register:
<claim-text>copying a value of a plurality of flag bits in the first flag register to a corresponding plurality of flag bits in a second flag register, wherein the first flag register and the second flag register are dedicated flag registers; and</claim-text>
<claim-text>saving a result of the at least one target instruction only if the specified condition in the first flag register is met during execution of the conditional execution instruction.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising:
<claim-text>in the event the conditional execution instruction specifies the second flag register, saving a result of the at least one target instruction dependent upon the specified condition in the second flag register during execution of the conditional execution instruction.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the at least one target instruction comprises a code block including a plurality of consecutive instructions, and wherein the conditional execution instruction specifies the code block.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the conditional execution instruction comprises a field specifying the code block.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the conditional execution instruction comprises a first field specifying the at least one target instruction, a second field specifying the register, and at least one bit position specifying the condition within the register.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the inputting comprises:
<claim-text>fetching a conditional execution instruction and the at least one target instruction from a memory system, wherein the conditional execution instruction specifies the at least one target instruction, a register, and a condition within the register.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A processor, comprising:
<claim-text>means for inputting a conditional execution instruction and at least one target instruction, wherein the conditional execution instruction specifies the at least one target instruction, a register, and a condition within the register;</claim-text>
<claim-text>means for unconditionally executing the at least one target instruction;</claim-text>
<claim-text>means for performing the following in the event the conditional execution instruction specifies a first flag register:
<claim-text>copying the value of a flag bit of the first flag register to a corresponding flag bit of a second flag register, wherein the first flag register and the second flag register are dedicated flag registers; and</claim-text>
<claim-text>saving a result of the at least one target instruction only if the result is qualified by the specified condition in the first flag register during execution of the conditional execution instruction.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The processor as recited in <claim-ref idref="CLM-00022">claim 22</claim-ref>, further comprising means for saving, in the event the conditional execution instruction specifies the second flag register, a result of the at least one target instruction dependent upon the specified condition in the second flag register during execution of the conditional execution instruction.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The processor as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conditional execution instruction and the instruction block reside in sequential addresses of a program memory.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The method as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the instruction block immediately follows the conditional execution instruction in a program memory.</claim-text>
</claim>
</claims>
</us-patent-grant>
