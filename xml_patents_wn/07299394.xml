<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299394-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299394</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10400911</doc-number>
<date>20030328</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>JP</country>
<doc-number>2002-265519</doc-number>
<date>20020911</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>1138</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>01</class>
<subclass>R</subclass>
<main-group>31</main-group>
<subgroup>28</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714738</main-classification>
<further-classification>714739</further-classification>
<further-classification>714741</further-classification>
</classification-national>
<invention-title id="d0e71">Method and apparatus for determining optimum initial value for test pattern generator</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5991909</doc-number>
<kind>A</kind>
<name>Rajski et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714729</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6766473</doc-number>
<kind>B2</kind>
<name>Nozuyama</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714 33</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7162674</doc-number>
<kind>B2</kind>
<name>Nozuyama</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714741</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7178078</doc-number>
<kind>B2</kind>
<name>Hiraide et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714739</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00005">
<othercit>Kapur, Robit, et al., “Design of an Efficient Weighted Random Pattern Generation System”, International Test Conference 1994, pp. 491-500.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00006">
<othercit>Tsai, Huan-Chih, et al. “Improving the Test Quality for Scan-Based BIST Using a General Test Application Scheme”, DA Conference 1999, pp. 748-753.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>Kiefer, Gundolf, et al., “Deterministic BIST with Multiple Scan Chains”, International Test Conference 1998, pp. 1057-1064.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>Keifer, Gundolf, et al., “Application of Determinstic Logic BIST on Industrial Circuits”, International Test Conference 2000, pp. 105-114.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00009">
<othercit>Das, Debaleena, et al., “Reducing Test Data Volume Using External/LBIST Hybrid Test Patterns”, International Test Conference 2000, pp. 115-122.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00010">
<othercit>Hellebrand, Sybille, “Generation of Vector Patterns Through Reseeding of Multiple-Polynomial Linear Feedback Shift Registers”, International Test Conference 1992, pp. 120-129.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00011">
<othercit>Bayraktaroglu, Ismet, et al., “An Examination of PRPG Selection Approaches for Large, Industrial Designs”, Asia Test Symposium 1998, pp. 440-444.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00012">
<othercit>Bayraktaroglu, Ismet, et al., “Selecting PRPG: Randomness, Primitiveness, or Sheer Luck?”, Asia Test Symposium 2001, pp. 373-378.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00013">
<othercit>Fagot, C., “A Ring Architecture Strategy for BIST Test Pattern Generation”, Asia Test Symposium 1998, pp. 418-423.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00014">
<othercit>Fagot, C., “On Calculating Efficient LFSR Seeds for Built-In Self Test”, Europe Test Conference 1999, pp. 4-14.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714738</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714739</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714741</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>14</number-of-drawing-sheets>
<number-of-figures>15</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040088626</doc-number>
<kind>A1</kind>
<date>20040506</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Ichino</last-name>
<first-name>Ken-ichi</first-name>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Arai</last-name>
<first-name>Masayuki</first-name>
<address>
<city>Tama</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Fukumoto</last-name>
<first-name>Satoshi</first-name>
<address>
<city>Kawasaki</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Iwasaki</last-name>
<first-name>Kazuhiko</first-name>
<address>
<city>Yokohama</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
<applicant sequence="005" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Shoda</last-name>
<first-name>Takeshi</first-name>
<address>
<city>Kokubunji</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
<applicant sequence="006" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Sato</last-name>
<first-name>Masayuki</first-name>
<address>
<city>Takasaki</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Staas &amp; Halsey LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Semiconductor Technology Academic Research Center</orgname>
<role>03</role>
<address>
<city>Yokohama</city>
<country>JP</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kerveros</last-name>
<first-name>James C.</first-name>
<department>2138</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The purpose of the invention is to determine an optimum initial value to be input to a test pattern generator in order to achieve efficient testing of an integrated circuit. To achieve this purpose, a minimum test length is obtained by performing a fault simulation and a reverse-order fault simulation using an arbitrarily given initial value; the next initial value that is likely to yield a test length shorter than the minimum test length is computed and a fault simulation is performed using the thus computed initial value; and the next initial value that is likely to yield a test length shorter than that test length is computed and a fault simulation is performed using the thus computed initial value. By repeating this process, an initial value that yields the shortest test length is obtained.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="94.66mm" wi="151.64mm" file="US07299394-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="109.98mm" wi="153.42mm" file="US07299394-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="139.70mm" wi="161.71mm" file="US07299394-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="118.45mm" wi="146.73mm" file="US07299394-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="132.84mm" wi="140.72mm" file="US07299394-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="127.17mm" wi="161.71mm" file="US07299394-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="128.44mm" wi="166.88mm" file="US07299394-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="161.04mm" wi="107.78mm" file="US07299394-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="194.99mm" wi="142.32mm" file="US07299394-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="215.22mm" wi="144.53mm" file="US07299394-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="239.01mm" wi="148.59mm" file="US07299394-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="161.97mm" wi="98.81mm" file="US07299394-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="238.93mm" wi="154.94mm" file="US07299394-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="176.70mm" wi="152.57mm" file="US07299394-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="204.81mm" wi="136.74mm" orientation="landscape" file="US07299394-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION</heading>
<p id="p-0002" num="0001">This application claims priority from Japanese Patent Application No. 2002-265519, filed on Sep. 11, 2002.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">1. Field of the Invention</p>
<p id="p-0004" num="0003">The present invention relates to a method for determining an optimum initial value for efficient testing of an integrated circuit, including a large scale integrated circuit (VLSI), in a test pattern generator that generates a test pattern to be applied to the circuit under test.</p>
<p id="p-0005" num="0004">2. Prior Art</p>
<p id="p-0006" num="0005">With the increasing miniaturization of semiconductor processes, the costs of testing integrated circuits (including LSIs and VLSIs) have been increasing. If the operating speeds and integration levels of LSIs continue to increase at the present pace, more expensive testers than those used today would have to be used, over a long period of time, for LSI testing. To reduce test times on such expensive testers, extensive research has been conducted to find designs for easing the burden on testers by using design-for-testability techniques exemplified by scan design and built-in self-test (BIST) techniques.</p>
<p id="p-0007" num="0006">BIST implements testing by integrating a test pattern generator (TPG) and a test response compactor (TRC) on the same chip as the circuit to be tested. This serves to ease the burden on the tester connected externally to the chip. A linear feedback shift register (LFSR) and a multiple input signature register (MISR) are often used as the TPG and the TRC, respectively.</p>
<p id="p-0008" num="0007">A pseudo-random test pattern generator that uses an LFSR can apply a test pattern without using a tester, but has the shortcoming that, to achieve a high fault coverage exceeding 95%, a large number of test patterns become necessary and, as a result, the time required for testing, i.e., the test length, increases. Many attempts to overcome this shortcoming have been reported. One such attempt is a weighted pseudo-random sequence generating technique which assigns a weight to each bit in the test pattern to be applied to the circuit under test (hereinafter referred to as the CUT), and changes the probability of each bit being a 1 or a 0 in order to improve fault detection probability. (Refer, for example, to Literature 1 listed below.)</p>
<p id="p-0009" num="0008">On the other hand, a method that inserts observation points and test points is intended to improve test quality by including the observation points and test points in the circuit under test and thereby improve the observability and controllability. However, as this method inserts observation points and test points in the CUT, the shortcoming is that the circuit structure of the CUT is changed and, hence, delay characteristics, etc. change. (Refer, for example, to Literature 2 listed below.)</p>
<p id="p-0010" num="0009">With the above techniques alone, it is difficult to obtain sufficient fault coverage with limited test length. Therefore, BIST techniques that combine a random sequence with ATPG (Automatic Test-Pattern Generation) vectors are also being studied. (Refer, for example, to Literature 3, 4, and 5 listed below.)</p>
<p id="p-0011" num="0010">There is also being studied a method that encodes a testcube as a seed for an LFSR by making use of the don't cares in the test code, and that performs testing by decoding the seed with the LFSR within the chip. In this reseeding method, each testcube is encoded by using an LFSR having a bit length equal to (the number of specified bits in the testcube+20) bits.</p>
<p id="p-0012" num="0011">There is also a method called MP-LFSR which uses an LFSR having a plurality of feedback polynomials for testcube decoding. In this method, each testcube is encoded by using an MP-LFSR having a bit length equal to (the number of specified bits in the testcube+4) bits. (Refer, for example, to Literature 6 listed below.)</p>
<p id="p-0013" num="0012">Bit-flipping BIST and bit-fixing BIST are each a method that finds a test pattern closest to the testcube from among the test patterns output from an LFSR, and applies the testcube by flipping or fixing some bits. These methods require a circuit for flipping or fixing bits.</p>
<p id="p-0014" num="0013">According to the BIST techniques using the reseeding method, bit-flipping BIST, or bit-fixing BIST, first, easily detectable faults are detected using pseudo-random tests, and then reseeding of ATPG vectors is performed. These methods, first, perform pseudo-random tests using about 10,000 patterns. Then, ATPG vectors are applied to the remaining faults that have not been detected by the pseudo-random tests. To add the test vectors, the ATPG vectors must be applied from a tester or, in the case of BIST, a ROM, and if the number of undetected faults is large, the test cost increases.</p>
<p id="p-0015" num="0014">To reduce the amount of hardware in the bit-flipping BIST or bit-fixing BIST circuitry, it is desirable to improve the quality of pseudo-random testing and thereby reduce the number of undetected faults. When the number of undetected faults is reduced, the tester storage capacity required can be reduced in the case of using a tester, and the internal ROM size can be reduced in the case of BIST.</p>
<p id="p-0016" num="0015">One possible approach to improving the quality of pseudo-random testing is to improve the quality of pseudo-random testing by carefully selecting the seed. A method that makes use of a preobtained testcube is being studied. This method evaluates the test quality of the seed by the Hamming distance between the test pattern output from the LFSR and the testcube. By so doing, a seed of high test quality can be obtained with a reasonable amount of computation. (Refer, for example, to Literature 7 to 10 listed below.)</p>
<p id="p-0017" num="0016">(Literature 1)</p>
<p id="p-0018" num="0017">R. Kapur, S. Patil, T. J. Snethen, T, W. Williams, “Design of an Efficient Weighted Pattern Generation System,” Int'l Test Conf., pp. 491-500, 1994</p>
<p id="p-0019" num="0018">(Literature 2)</p>
<p id="p-0020" num="0019">H-C. Tsai, K-T. Cheng, S. Bhawmik, “Improving the Test Quality for Scan-based BIST Using a General Test Application Scheme,” DA Conf., pp. 748-753, 1999</p>
<p id="p-0021" num="0020">(Literature 3)</p>
<p id="p-0022" num="0021">G. Kiefer and H-J. Wunderlich, “Deterministic BIST with Scan Chains,” Int'l Test Conf., pp. 1057-1064,</p>
<p id="p-0023" num="0022">(Literature 4)</p>
<p id="p-0024" num="0023">G. Kiefer, H. Vranken, E. J. Marinissen, H-J. Wunderlich, “Application of Deterministic Logic BIST to Industrial Circuits,” Int'l Test Conf., pp. 105-114, 2000</p>
<p id="p-0025" num="0024">(Literature 5)</p>
<p id="p-0026" num="0025">D. Das, N. A. Touba, “Reducing Test Data Volume Using External/LBIST Hybrid Test Patterns,” Int'l Test Conf., pp. 115-122, 2000</p>
<p id="p-0027" num="0026">(Literature 6)</p>
<p id="p-0028" num="0027">S. Hellebrand, S. Tarnick, J. Rajski, B. Courtois, “Generation of Vector Patterns Through Reseeding of Multiple-Polynomial Linear Feedback Shift Registers,” Int'l Test Conf., pp. 120-129, 1992</p>
<p id="p-0029" num="0028">(Literature 7)</p>
<p id="p-0030" num="0029">I. Bayraktaroglu, K. Udawatta, A. Oraologlu, “An Examination of PRPG Selection Approaches for Large Industrial Design,” Asia Test Symposium, pp. 440-444, 1998</p>
<p id="p-0031" num="0030">(Literature 8)</p>
<p id="p-0032" num="0031">I. Bayraktaroglu and A. Oraologlu, “Selecting a PRPG, Randomness, Primitiveness, or Sheer Luck?,” Asia Test Symposium, pp. 373-379, 2001</p>
<p id="p-0033" num="0032">(Literature 9)</p>
<p id="p-0034" num="0033">C. Fagot, O. Gascuel, P. Girard, C. Landrault, “A Ring Architecture Strategy for BIST Test Pattern Generation,” Asia Test Symposium, pp. 418-423, 1998</p>
<p id="p-0035" num="0034">(Literature 10)</p>
<p id="p-0036" num="0035">C. Fagot, O. Gascuel, P. Girard, C. Landrault, “On Calculating Efficient LFSR Seeds for Built-in Self Test,” Europe Test Conf., pp. 4-14, 1999</p>
<p id="p-0037" num="0036">In the above integrated circuit testing methods using an LFSR, etc. as the test pattern generator, it is known that the test length required to achieve prescribed fault coverage differs if the initial value given to the test pattern generator differs. Accordingly, if the initial value that minimizes the test time can be selected in advance, the test time required in the mass production of integrated circuits can be reduced, and a drastic reduction in test cost can thus be achieved.</p>
<p id="p-0038" num="0037">In the prior art, however, little attention has been paid to the initial value of the pattern generator, and a suitable value, such as 111 . . . 1 (all 1s), has simply been selected. As a result, if such an initial value, selected without paying any special consideration, is an inappropriate one, there is the possibility that the test length becomes enormously long.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0039" num="0038">The present invention has been devised in view of the above problem and proposes, for a test pattern generator, a method for selecting an initial value to be given to the test pattern generator so as to achieve the target fault coverage with the shortest test length. When the method of the invention is used, the test time can be reduced without increasing the amount of chip hardware, though off-line computation time is required for the computation of the initial value.</p>
<p id="p-0040" num="0039">The invention further proposes a method for selecting a test pattern initial value that achieves a maximum fault detection count for a fixed test length. This means reducing the number of undetected faults. When the method of the invention is used, the number of undetected faults can be reduced without adding extra hardware, though off-line computation time is required. When using a bit-flipping method, the amount of hardware overhead can be reduced.</p>
<p id="p-0041" num="0040">To solve the above-described problem, the present invention provides a method for determining an optimum initial value to be input to a test pattern generator for testing an integrated circuit, comprising the steps of: a) obtaining a first test length and a first minimum test length for detecting a predetermined number, n, of faults, by performing a fault simulation and a reverse-order fault simulation using an arbitrarily given first initial value; b) computing, based on the first initial value and on the first test length and the first minimum test length, a second initial value that can yield a test length shorter than the first minimum test length; c) obtaining a second test length for detecting the number, n, of faults, by performing a second fault simulation using the computed second initial value; d) comparing the second test length with the first minimum test length, and obtaining a second minimum test length by regarding the first minimum test length as the second minimum test length when the second test length is equal to or longer than the first minimum test length, or by performing a reverse-order fault simulation against the second fault simulation when the second test length is shorter than the first minimum test length; and e) obtaining the shortest test length by repeating the steps b), c), and d) by regarding the second initial value, the second test length, and the second minimum test length as the first initial value, the first test length, and the first minimum test length, wherein an initial value that yields the shortest test length obtained in the step e) is determined as the initial value to be input to the test pattern generator when testing the integrated circuit.</p>
<p id="p-0042" num="0041">According to the method of the invention having the above-described first configuration, the value that can detect the predetermined number of faults in the shortest time can be selected as the initial value to be input to the test pattern generator. By selecting this value as the initial value for the test pattern generator when testing an integrated circuit, the test time can be greatly reduced compared with the case where no special consideration is paid to the selection of the initial value, and the invention thus offers an enormous effect in reducing the mass production cost.</p>
<p id="p-0043" num="0042">To solve the above-described problem, the present invention further provides a method for determining an optimum initial value to be input to a test pattern generator for testing an integrated circuit, comprising the steps of: a) obtaining a first number, n, of faults detected with a predetermined target test length L<sub>fix</sub>, by performing a first fault simulation using an arbitrarily given first initial value; b) obtaining a first minimum test length necessary for detecting the first number, n, of faults, by performing a reverse-order simulation against the first fault simulation; c) computing, based on the first initial value and on the target test length L<sub>fix </sub>and the first minimum test length, a second initial value that yields the first minimum test length; d) obtaining a second number, nt, of faults detected with the predetermined target test length L<sub>fix</sub>, by performing a second fault simulation using the computed second initial value; e) comparing the second number nt with the first number n, and obtaining a maximum number of detected faults by taking the first number n as the maximum number when nt≦n, or by repeating the steps b) to d) until nt≦n is achieved, when nt&gt;n; f) obtaining a test length L necessary for detecting the maximum number of detected faults, by performing a third fault simulation using an initial value, in a test pattern sequence, that immediately follows the initial value that achieves the maximum number of detected faults; g) comparing the test length L with the target test length L<sub>fix</sub>, and, if L≦L<sub>fix</sub>, then computing, based on the initial value used in the third fault simulation and on the test length L and the target test length L<sub>fix</sub>, the next initial value that is likely to yield a test length shorter than the target test length L<sub>fix</sub>; h) repeating the steps f) and g) with the initial value computed in the step g), until L&lt;L<sub>fix </sub>is achieved; and i) obtaining the largest number of faults detected with the target test length, by repeating the steps a) to h) by regarding as the first initial value the initial value that achieves L&lt;L<sub>fix </sub>in the step g) or the step h), wherein an initial value that achieves the largest number of detected faults obtained in the step i) is determined as the initial value to be input to the test pattern generator when testing the integrated circuit.</p>
<p id="p-0044" num="0043">According to the method of the invention having the above-described second configuration, the value that can detect the largest number of faults within the predetermined test length can be selected as the initial value to be input to the test pattern generator. By selecting this value as the initial value for the test pattern generator when testing an integrated circuit, the test quality can be greatly improved compared with the case where no special consideration is paid to the selection of the initial value, and the invention thus offers an enormous effect in reducing the mass production cost.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram showing a test-per-clock BIST structure;</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram showing the relationship between seed index and test length;</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram showing in simplified form the relationship between seed index and test length in <figref idref="DRAWINGS">FIG. 2</figref>;</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram for explaining a method according to one embodiment of the present invention;</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram for explaining the method according to the one embodiment of the present invention;</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 6</figref> is a diagram for explaining the method according to the one embodiment of the present invention;</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram showing one example of a program implementing the one embodiment of the present invention;</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram showing the first half of a flowchart illustrating the method steps according to the one embodiment of the present invention;</p>
<p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram showing the second half of the flowchart, which is a continuation of the flowchart shown in <figref idref="DRAWINGS">FIG. 8</figref>;</p>
<p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram showing a test-per-scan BIST structure;</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 11</figref> is a diagram showing the relationship between seed and test pattern in the test-per-scan BIST structure;</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 12</figref> is a diagram showing one example of a program implementing another embodiment of the present invention;</p>
<p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. 13</figref> is a diagram showing the first half of a flowchart illustrating the method steps according to that other embodiment of the present invention;</p>
<p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. 14</figref> is a diagram showing the second half of the flowchart, which is a continuation of the flowchart shown in <figref idref="DRAWINGS">FIG. 13</figref>; and</p>
<p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. 15</figref> is a diagram for explaining the flowchart shown in <figref idref="DRAWINGS">FIGS. 13 and 14</figref>.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0060" num="0059">The preferred embodiments of the present invention will be described below with reference to the accompanying drawings.</p>
<p id="p-0061" num="0060">A test pattern generator that uses an LFSR as a pseudo-random pattern generator generates a test pattern sequence when a clock is applied to it after its initial state has been set up. An example of BIST using such a test pattern generator is a test-per-clock structure such as shown in <figref idref="DRAWINGS">FIG. 1</figref>. In <figref idref="DRAWINGS">FIG. 1</figref>, reference numeral <b>1</b> is a test pattern generator constructed from an LFSR <b>2</b>, <b>3</b> is a circuit-under-test (CUT) to which a test pattern is input, and <b>4</b> is a test response compactor. Once the state of each flip-flop in the LFSR <b>2</b> is determined, the test pattern sequence to be output thereafter is uniquely determined. Information that determines the states of the flip-flops in the LFSR <b>2</b> is called a seed.</p>
<p id="p-0062" num="0061">In the test-per-clock BIST structure that uses an LFSR as the test pattern generator <b>1</b>, the seed that is input to the LFSR <b>2</b> is the same as the test pattern that is output from the LFSR <b>2</b> and applied to the CUT <b>3</b>.</p>
<p id="p-0063" num="0062">Consider a single stuck-at fault test using an LFSR such as shown in <figref idref="DRAWINGS">FIG. 1</figref>. The circuit to be tested for single stuck-at faults is a combinational circuit.</p>
<p id="p-0064" num="0063">The LFSR constructed with an m-degree primitive polynomial outputs (2<sup>m</sup>−1) different test patterns to the CUT. An m-bit two-element vector from the LFSR can be regarded as an element α<sup>i </sup>(0≦i≦2<sup>m−1</sup>−2) over a GF (2<sup>m</sup>). Here, i denotes an index.</p>
<p id="p-0065" num="0064">For a seed α<sup>0</sup>, the LFSR first outputs a test pattern α<sup>0</sup>, followed by a test pattern α<sup>1</sup>, and then α<sup>2</sup>, α<sup>3</sup>, and so on. For a seed α<sup>1</sup>, first the test pattern α<sup>1</sup>. is output, then α<sup>2</sup>, and so on. The j-th test pattern output in response to the seed α<sup>i </sup>is denoted by α<sup>1+j−1</sup>.</p>
<p id="p-0066" num="0065">Here, let F denote a set of detectable single stuck-at faults that can exist in the CUT. When the fault coverage of a test pattern is expressed as C %, then faults the number of which is given by
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>|F|×C/100<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
are detected. Here, ∥ indicates the number of elements in the set.
</p>
<p id="p-0067" num="0066">F<sup>a </sup>is a set of faults detected with the test pattern a from among the faults contained in F.</p>
<p id="p-0068" num="0067">The method of generating the test patterns α<sup>i−1</sup>, α<sup>i−2</sup>, . . . for the seed α<sup>i </sup>will hereinafter be referred to as reverse-order test pattern generation. L(α<sup>i</sup>, n<sub>fix</sub>) is a function that returns the test length that achieves the target fault detection count=n<sub>t </sub>for the seed α<sup>i</sup>. Ideally, n<sub>fix</sub>=|F|, but it is realistic to set a value slightly smaller than |F| as n<sub>fix</sub>.</p>
<p id="p-0069" num="0068">L<sub>R</sub>(α<sup>i+1</sup>, n<sub>fix</sub>) is a function that returns the test length that achieves the target fault detection count nt when the reverse-order test pattern generation is performed with the seed α<sup>i+1</sup>. L(α<sup>i</sup>, n<sub>fix</sub>) and L<sub>R</sub>(α<sup>i+1</sup>, n<sub>fix</sub>) can be obtained through fault simulation.</p>
<p id="p-0070" num="0069">When a CUT, its target fault detection count n<sub>fix</sub>, and an LFSR polynomial are given, the LFSR seed that minimizes the test length is called the shortest test length seed α<sub>i*</sub>. At this time, i*=arg min{L(α<sup>i</sup>, n<sub>fix</sub>)}.</p>
<p id="p-0071" num="0070">Next, the relationship between the seed and the test pattern sequence output from the LFSR will be considered.</p>
<p id="p-0072" num="0071">Consider the case where test-per-clock testing is applied to the combinational circuit portion of the s386 circuit which is one of the ISCAS 89 benchmark circuits. The input of this circuit is 13 bits wide. The results of the experiment for the test lengths that achieve 100% fault coverage for each seed are shown in <figref idref="DRAWINGS">FIG. 2</figref>. The number of detectable faults in the s386 circuit is 384. The seed number is plotted as abscissa, and the test length (clock) that achieves 100% fault coverage is plotted as ordinate. From <figref idref="DRAWINGS">FIG. 2</figref>, it can be seen that the test length L that achieves 100% fault coverage for seed α<sup>0 </sup>is L(α<sup>0</sup>, 384)=1783.</p>
<p id="p-0073" num="0072">From <figref idref="DRAWINGS">FIG. 2</figref>, the seed versus test length characteristic of the test-per-clock structure using the LFSR can be identified. That is, each time the index increases by one, the test length either
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0073">1) becomes shorter by one, or</li>
        <li id="ul0002-0002" num="0074">2) remains the same, or</li>
        <li id="ul0002-0003" num="0075">3) becomes longer.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0074" num="0076">To facilitate understanding of this characteristic, a simplified example of <figref idref="DRAWINGS">FIG. 2</figref> is shown in <figref idref="DRAWINGS">FIG. 3</figref>. In <figref idref="DRAWINGS">FIG. 3</figref>, the ordinate represents the test length L that achieves 100% fault coverage, and the abscissa represents the seed index i. For simplicity, in <figref idref="DRAWINGS">FIG. 3</figref> the number of detectable faults in the CUT is assumed to be 100.</p>
<p id="p-0075" num="0077">From <figref idref="DRAWINGS">FIG. 3</figref>, it can be seen that the test length for seed α<sup>0 </sup>is L(α<sup>0</sup>, 100)=8. Next, it is assumed that all the faults detected by α<sup>0 </sup>have been detected by the seven patterns α<sup>1 </sup>to α<sup>7 </sup>generated with the seed α<sup>1</sup>. That is,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>|F</i><sub>a</sub><sub><sup2>1</sup2></sub><i>∪F</i><sub>a</sub><sub><sup2>2</sup2></sub><i>∪ . . . ∪F</i><sub>a</sub><sub><sup2>7</sup2></sub><i>|=|F</i><sub>a</sub><sub><sup2>0</sup2></sub><i>∪F</i><sub>a</sub><sub><sup2>1</sup2></sub><i>∪ . . . ∪F</i><sub>a</sub><sub><sup2>7</sup2></sub><i>|=F|</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Then, L(α<sup>1</sup>, 100)=7.
</p>
<p id="p-0076" num="0078">Likewise, when the faults detected by six patterns α<sup>2 </sup>to α<sup>7 </sup>contain all the faults detected by α<sup>1</sup>, that is,</p>
<p id="p-0077" num="0079">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo></mo>
    <mrow>
      <msub>
        <mi>F</mi>
        <msup>
          <mi>a</mi>
          <mn>0</mn>
        </msup>
      </msub>
      <mo>⋃</mo>
      <msub>
        <mi>F</mi>
        <msup>
          <mi>a</mi>
          <mn>1</mn>
        </msup>
      </msub>
      <mo>⋃</mo>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
      <mo>⁢</mo>
      <mi>…</mi>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.6em" height="0.6ex"/>
      </mstyle>
      <mo>⋃</mo>
      <msub>
        <mi>F</mi>
        <msup>
          <mi>a</mi>
          <mn>7</mn>
        </msup>
      </msub>
    </mrow>
    <mo></mo>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mrow>
      <mo></mo>
      <mrow>
        <msub>
          <mi>F</mi>
          <msup>
            <mi>a</mi>
            <mn>1</mn>
          </msup>
        </msub>
        <mo>⋃</mo>
        <msub>
          <mi>F</mi>
          <msup>
            <mi>a</mi>
            <mn>2</mn>
          </msup>
        </msub>
        <mo>⋃</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mi>…</mi>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.6em" height="0.6ex"/>
        </mstyle>
        <mo>⋃</mo>
        <msub>
          <mi>F</mi>
          <msup>
            <mi>a</mi>
            <mn>7</mn>
          </msup>
        </msub>
      </mrow>
      <mo></mo>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mo></mo>
      <mi>F</mi>
      <mo></mo>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
then the test length for seed α<sup>2 </sup>is L(α<sup>2</sup>, 100)=6. Similarly, the test length for seed α<sup>3 </sup>is L(α<sup>3</sup>, 100)=5.
</p>
<p id="p-0078" num="0080">On the other hand, it is assumed that the faults detected by the patterns α<sup>4 </sup>to α<sup>7 </sup>generated with seed α<sup>4 </sup>are less than 100 in number and thus do not contain all the faults detected by the seed α<sup>3</sup>. That is
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>|F</i><sub>a</sub><sub><sup2>4</sup2></sub><i>∪F</i><sub>a</sub><sub><sup2>5</sup2></sub><i>∪ . . . ∪F</i><sub>a</sub><sub><sup2>7</sup2></sub><i>|&lt;|F</i><sub>a</sub><sub><sup2>3</sup2></sub><i>∪F</i><sub>a</sub><sub><sup2>4</sup2></sub><i>∪ . . . ∪F</i><sub>a</sub><sub><sup2>7</sup2></sub><i>|=|F|</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
In this case, the test length for seed α<sup>4 </sup>increases to the point where all the faults detected by the seed α<sup>3 </sup>are detected. In the example of <figref idref="DRAWINGS">FIG. 3</figref>, the test length increases from 5 to 10.
</p>
<p id="p-0079" num="0081">Here, when the relation
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>L</i>(α<sup>i</sup>, n<sub>fix</sub>)&lt;L<sub>R</sub>(α<sup>i+1</sup>, n<sub>fix</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
holds, α<sup>i </sup>is called the minimum test length seed, and L(α<sup>i</sup>, n<sub>fix</sub>) the minimum test length. Hereinafter, the seed that yields the minimum test length is expressed as the minimum test length seed α<sup>imin</sup>, and the index of the seed is denoted by i<sub>min</sub>. Of the minimum test lengths found by performing tests with all the indexes, the smallest one is taken as the shortest test length Ls.
</p>
<p id="p-0080" num="0082">In the example of <figref idref="DRAWINGS">FIG. 3</figref>, the minimum test length seed is α<sup>3 </sup>and, at this time, the minimum test length is 5. In the example of <figref idref="DRAWINGS">FIG. 2</figref>, there are 13 minimum test lengths, which are, from left to right, 1648, 2104, 1298, 1466, 2505, 2211, 2823, 2283, 2497, 1866, 1615, 2000, and 1867; thus, the shortest test length Ls is 1298.</p>
<p id="p-0081" num="0083">When the seed that yields the shortest test length L obtained as described above is selected as the initial seed for the LFSR <b>2</b> in the circuit of <figref idref="DRAWINGS">FIG. 1</figref>, the testing of the CUT <b>3</b> will be completed in the shortest time. On the other hand, in the testing of the CUT <b>3</b>, if an arbitrary seed is selected without paying any special attention to the seed selection, as in the prior art method, there is the possibility that a seed that yields a test length exceeding 3000, for example, may be selected in the example of <figref idref="DRAWINGS">FIG. 2</figref>. If such a seed is selected, the time required for testing in the mass production of VLSIs becomes enormously long, resulting in an increase in test cost. Accordingly, selecting the seed yielding the shortest test length greatly contributes to reducing the test cost during the mass production of VLSIs.</p>
<p id="p-0082" num="0084">In reality, however, obtaining the test lengths for all the seeds for test pattern sequences, as shown in <figref idref="DRAWINGS">FIG. 2</figref>, is practically impossible because the circuit scale of a VLSI is very large. There is, therefore, a need for an efficient and practicable method for selecting an optimum seed.</p>
<p id="p-0083" num="0085">Utilizing the characteristic of the seed versus test length relationship described above, the present invention provides a method for selecting an optimum initial value by using a practically feasible method.</p>
<p id="p-0084" num="0086">A procedure for selecting the initial seed for obtaining a preset number of faults, n<sub>fix</sub>, with the shortest test length according to the method of the present invention will be described below with reference to drawings. The seed selection in this case is called the shortest test length seed selection method.</p>
<p id="p-0085" num="0087">First, the selection method of the invention will be described by dividing the procedure into Step A for finding a minimum test length and Step B for checking the presence or absence of a shorter minimum test length. In the following description, i indicates the current index, and i is initialized to 0. That is, the process begins with the seed of index 0.</p>
<p id="p-0086" num="0088">[Step A]</p>
<p id="p-0087" num="0089">In Step A, the minimum test length and its seed are obtained.</p>
<p id="p-0088" num="0090">With the index i and higher, the minimum test length that appears the earliest is obtained. First, the test length Li(α<sup>i</sup>, n<sub>fix</sub>) for seed α<sup>i </sup>is obtained through fault simulation. Next, fault simulation using the reverse-order test pattern generation is performed to obtain L<sub>R</sub>i(α<sup>i+Li−1</sup>, n<sub>fix</sub>). The minimum test length Lm is thus obtained. The index im that yields the minimum test length is obtained by subtracting the minimum test length Lm from the test length Li and adding i to the difference, that is, Li−Lm+i.</p>
<p id="p-0089" num="0091"><figref idref="DRAWINGS">FIG. 4</figref> shows an example of Step A. First, in Step-A-<b>1</b>, fault simulation is performed with seed α<sup>0 </sup>to obtain the test length (α<sup>0</sup>, n<sub>fix</sub>). In the example <figref idref="DRAWINGS">FIG. 4</figref>, the test length L(α<sup>0</sup>, n<sub>fix</sub>)=8. Next, in Step-A-<b>2</b>, by using as the initial seed the seed α<sup>7 </sup>that achieved the maximum fault detection count n<sub>fix</sub>, reverse-order fault simulation is performed to obtain the test length L<sub>R</sub>(α<sup>7</sup>, n<sub>fix</sub>). This value gives the minimum test length Lm. In the example of <figref idref="DRAWINGS">FIG. 4</figref>, Lm=5.</p>
<p id="p-0090" num="0092">The index im that achieves this minimum test length Lm is L−Lm+1=8−5+0=3. This calculation step is Step-A-<b>3</b>. Thus, it can be seen that the seed α<sup>Lm−Lm+i</sup>, that is, α<sup>3</sup>, is the seed that achieves the target fault coverage with the minimum test length 5.</p>
<p id="p-0091" num="0093">[Step B]</p>
<p id="p-0092" num="0094">In Step B, it is checked whether there is a seed that achieves a minimum test length shorter than the minimum test length obtained in Step A.</p>
<p id="p-0093" num="0095">The test length for the seed of index i<sub>min+</sub>1 is longer than the minimum test length Lm.</p>
<p id="p-0094" num="0096">First, with the index set to i=i<sub>min</sub>+1, the test length l=L(α<sup>i</sup>, n<sub>fix</sub>) is obtained. From this test length L, the next index that is likely to yield a test length shorter than the minimum test length lm can be calculated. That index is i+l−l<sub>min</sub>+1. This index is set as the new index i. The test length l=L(α<sup>i</sup>, n<sub>fix</sub>) for the calculated seed α<sub>i </sub>is obtained. If the test length l is shorter than the minimum test length l<sub>min</sub>, the process returns to Step-A to obtain the minimum test length once again. Otherwise, the next index that is likely to yield a test length shorter than the minimum test length l<sub>min </sub>is calculated once again. This step is repeated until a test length shorter than the minimum test length l<sub>min </sub>appears. In the case of an m-bit LFSR, this process is repeated until the index reaches (2<sup>m</sup>−1). The minimum test length l<sub>min </sub>when i=2<sup>m</sup>−2 is the shortest test length l* that achieves the target fault coverage, and i<sub>min </sub>indicates the index i* of the seed that yields the shortest test length.</p>
<p id="p-0095" num="0097">The operation in Step B will be described with reference to <figref idref="DRAWINGS">FIGS. 5 and 6</figref>. In both <figref idref="DRAWINGS">FIGS. 5 and 6</figref>, it is assumed that the minimum test length l<sub>min</sub>=5 is already achieved with the seed <b>3</b>. That is, i<sub>min</sub>=3.</p>
<p id="p-0096" num="0098">First, a description will be given for the case of <figref idref="DRAWINGS">FIG. 5</figref>. In Step-B-<b>1</b>, the test length L(α<sup>4</sup>, n<sub>fix</sub>) for seed α<sup>4 </sup>is obtained. In the example of <figref idref="DRAWINGS">FIG. 5</figref>, the test length is 10. As the minimum test length l<sub>min</sub>=5, it follows that L(α<sup>4</sup>, n<sub>fix</sub>), . . . , L(α<sup>9</sup>, n<sub>fix</sub>)≧5. That is, α<sup>4 </sup>to α<sup>9 </sup>are not candidates for minimum test length seeds.</p>
<p id="p-0097" num="0099">In Step-B-<b>2</b>, the index of the next seed that is likely to yield a test length shorter than l<sub>min </sub>is obtained. In this case, i=4+10−5+1=10, and thus the candidate seed is α<sup>10</sup>. Then, the test length L(α<sup>10</sup>, n<sub>fix</sub>) for the seed α<sup>10 </sup>is obtained. In the example of <figref idref="DRAWINGS">FIG. 5</figref>, the test length L=4. This means that there is the possibility that, by using the seed of index <b>11</b>, the target fault detection count n<sub>fix </sub>may be achieved with a shorter test length. In this case, the process returns to Step A to obtain the minimum test length l<sub>min </sub>once again.</p>
<p id="p-0098" num="0100">Next, a description will be given for the case of <figref idref="DRAWINGS">FIG. 6</figref>. In operation, Step-B-<b>1</b> and Step-B-<b>2</b> are the same as those in <figref idref="DRAWINGS">FIG. 5</figref>. In Step-B-<b>1</b>, the test length L(α<sup>4</sup>, n<sub>fix</sub>) for the seed α<sup>4 </sup>is obtained. In the example of <figref idref="DRAWINGS">FIG. 6</figref>, the test length is 10. Next, in Step-B-<b>2</b>, the index of the seed that is likely to yield a test length shorter than the minimum test length l<sub>min </sub>obtained in the preceding Step-A is calculated. In <figref idref="DRAWINGS">FIG. 6</figref>, as in the case of <figref idref="DRAWINGS">FIG. 5</figref>, the candidate seed is α<sup>10</sup>. In Step-B-<b>3</b>, the test length L(α<sup>10</sup>, n<sub>fix</sub>) for the seed α<sup>10 </sup>is obtained. In the example of <figref idref="DRAWINGS">FIG. 6</figref>, L(α<sup>10</sup>, n<sub>fix</sub>)=7. In this case, the process returns to Step-B-<b>2</b> to repeat the step of obtaining the index of the seed that is likely to yield a test length shorter than the minimum test length l<sub>min</sub>.</p>
<p id="p-0099" num="0101"><figref idref="DRAWINGS">FIG. 7</figref> shows one example of a program for finding the shortest test length seed.</p>
<p id="p-0100" num="0102">A flowchart recapitulating the procedure for finding the shortest test length seed described above is shown in <figref idref="DRAWINGS">FIGS. 8 and 9</figref>. A description will be given below with reference to the flowchart.</p>
<p id="p-0101" num="0103">First, in step S<b>1</b>, the seed index i is set to 0. Next, in step S2, fault simulation is performed using the seed α<sup>0</sup>, to obtain the test length L that becomes necessary to detect a predetermined number, n<sub>fix</sub>, of faults. In the example of <figref idref="DRAWINGS">FIG. 4</figref>, the test length L is 8.</p>
<p id="p-0102" num="0104">In the next step S<b>3</b>, reverse-order fault simulation is performed against the fault simulation performed in step S<b>2</b>, to obtain the minimum test length Lm necessary for obtaining the number, n<sub>fix</sub>, of faults. From the example of <figref idref="DRAWINGS">FIG. 4</figref>, it can be seen that the minimum test length Lm is 5. The initial value i in the reverse-order fault simulation is i=i+L−1.</p>
<p id="p-0103" num="0105">When the minimum test length Lm is obtained in step S<b>3</b>, then the index of the seed that yields the minimum test length Lm is calculated in step S<b>4</b>. In step S<b>5</b>, the seed having the index calculated in step S<b>4</b> is selected. In step S<b>6</b>, it is determined whether the test length Lm obtained with the seed α<sup>i </sup>is a value that is good enough for an integrated circuit test. If the value of Lm is good enough, the process is terminated in step S<b>7</b>, and α<sup>i </sup>obtained in step S<b>5</b> is set as the optimum seed.</p>
<p id="p-0104" num="0106">Next, in step S<b>8</b>, it is determined whether the index i has reached the final value of the test pattern sequence S. If it has reached the final value (YES in step S<b>8</b>), the process is terminated in step S<b>9</b>, and the seed obtained in step S<b>5</b> is selected as the optimum value.</p>
<p id="p-0105" num="0107">Next, in step S<b>10</b>, the index i is incremented by 1, and after confirming in step S<b>11</b> that the index has not yet reached the final value of the test pattern sequence S, the seed having the index i is selected in step S<b>12</b>, and the same fault simulation as that in step S<b>2</b> is performed in step S<b>13</b>. In the example of <figref idref="DRAWINGS">FIG. 5</figref>, this fault simulation is performed using the seed α<sup>4</sup>. If, in step S<b>11</b>, the index i exceeds the final value of the test pattern sequence S (YES in step S<b>11</b>), the process is terminated in step S<b>14</b>, and the seed α<sup>i </sup>obtained in step S<b>5</b> is taken as the optimum value.</p>
<p id="p-0106" num="0108">With the fault simulation in step S<b>13</b>, the test length L for the seed α<sup>i+L−Lm+1 </sup>is obtained. In the example of <figref idref="DRAWINGS">FIG. 5</figref>, this test length L is 10.</p>
<p id="p-0107" num="0109">As explained in the description of Step-B-<b>2</b> in <figref idref="DRAWINGS">FIG. 5</figref>, when the new test length L is obtained in step S<b>13</b>, any seeds from the current index i to the index i=i+L−Lm cannot be candidates for seeds that are likely to yield a test length shorter than the minimum test length Lm. Accordingly, in step S<b>15</b>, the index is incremented to i=i+L−Lm+1, and after confirming in step S<b>16</b> that the index does not exceed the final value of the test pattern sequence S, the same fault simulation as that in step S<b>2</b> is performed in step S<b>17</b>. If, in step S<b>16</b>, the index i exceeds the final value of the test pattern sequence S, the process is terminated in step S<b>18</b>, and the seed α<sup>i </sup>obtained in step S<b>5</b> is taken as the optimum value.</p>
<p id="p-0108" num="0110">In the next step S<b>19</b>, it is determined whether the test length L obtained as a result of the fault simulation performed in step S<b>17</b> is shorter than the minimum test length Lm. As, actually, the test length is decreased by one clock at a time, in step S<b>19</b> it may be checked whether L=Lm−1 or not. If YES is determined in step S<b>19</b>, this corresponds to the example of <figref idref="DRAWINGS">FIG. 5</figref>; therefore, in this case, the process returns to step S<b>3</b> where the reverse-order fault simulation is performed to obtain a new minimum test length Lm.</p>
<p id="p-0109" num="0111">On the other hand, if NO is determined in step S<b>19</b>, this corresponds to the example of <figref idref="DRAWINGS">FIG. 6</figref>; therefore, the process returns to step S<b>15</b> to calculate the next index that is likely to yield a test length shorter than the minimum test length Lm and, with this index, step S<b>16</b> and its subsequent steps are repeated. These steps are repeated until the relation L&lt;Lm holds in step S<b>19</b>.</p>
<p id="p-0110" num="0112">The smallest (shortest) test length Lm is found by repeating the above process.</p>
<p id="p-0111" num="0113">Alternatively, when the test length L is obtained for the seed α<sup>4 </sup>in <figref idref="DRAWINGS">FIG. 5</figref> through fault simulation, reverse-order fault simulation up to the test pattern α<sup>10 </sup>may be performed in this fault simulation to check whether there appears any minimum test length shorter than the previously obtained minimum test length. If a shorter minimum test length is found, then the next seed index that is likely to yield an even shorter test length can be calculated using that value. Using this method, the time required to calculate the shortest test length seed can be further reduced.</p>
<p id="p-0112" num="0114">Table 1 shows a comparison between the shortest test length seed selection method of the present invention described above and the method that obtains the shortest test length seed by performing fault simulation on all the seeds. The experiment was conducted using the s386 circuit and polynomial 20033. AS can be seen from Table 1, when fault simulation was performed on all the seeds, the fault simulation had to be performed 8191 times, and the calculation time required was about 40 minutes. In contrast, when the method of the present invention was used, the fault simulation need only be performed 14 times, and the calculation time required was about four seconds.</p>
<p id="p-0113" num="0115">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 1</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>NUMBER OF TIMES OF FAULT SIMULATION AND</entry>
</row>
<row>
<entry>CALCULATION TIME IN SHORTEST TEST LENGTH SEED</entry>
</row>
<row>
<entry>SELECTION METHOD (s386/POLYNOMIAL 20033)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="77pt" align="left"/>
<colspec colname="1" colwidth="84pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>NUMBER OF TIMES OF</entry>
<entry>CALCULATION</entry>
</row>
<row>
<entry/>
<entry>FAULT SIMULATION</entry>
<entry>TIME</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="left"/>
<colspec colname="3" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry>FAULT SIMULATION</entry>
<entry>8191 TIMES</entry>
<entry>ABOUT</entry>
</row>
<row>
<entry>PERFORMED ON ALL</entry>
<entry/>
<entry>40 MINUTES</entry>
</row>
<row>
<entry>SEEDS</entry>
</row>
<row>
<entry>SHORTEST TEST</entry>
<entry> 14 TIMES</entry>
<entry>ABOUT</entry>
</row>
<row>
<entry>LENGTH SEED</entry>
<entry/>
<entry>4 SECONDS</entry>
</row>
<row>
<entry>SELECTION METHOD</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0114" num="0116">Table 2 shows the test length for the shortest test length seed obtained in the experiment of Table 1, as compared with the test lengths obtained without considering the seed selection. As is apparent from Tables 1 and 2, according to the method of the present invention, as the shortest test length seed can be obtained in a very short time, the time required for integrated circuit testing is greatly reduced.</p>
<p id="p-0115" num="0117">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 2</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>SHORTEST TEST LENGTH SEED AS COMPARED</entry>
</row>
<row>
<entry>WITH TEST LENGTHS OBTAINED WITHOUT</entry>
</row>
<row>
<entry>CONSIDERING SEED SELECTION</entry>
</row>
<row>
<entry>(s386/POLYNOMIAL 20033)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>SEED</entry>
<entry>TEST LENGTH</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry/>
<entry>SHORTEST TEST LENGTH SEED</entry>
<entry>1293</entry>
</row>
<row>
<entry/>
<entry>00 . . . 01</entry>
<entry>1783</entry>
</row>
<row>
<entry/>
<entry>All 1</entry>
<entry>2230</entry>
</row>
<row>
<entry/>
<entry>0101 . . .</entry>
<entry>1971</entry>
</row>
<row>
<entry/>
<entry>1010 . . .</entry>
<entry>2949</entry>
</row>
<row>
<entry/>
<entry>SHORTEST TEST LENGTH IN</entry>
<entry>1706</entry>
</row>
<row>
<entry/>
<entry>RANDOM 14 SELECTIONS</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0116" num="0118"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram showing a test-per-scan BIST structure which is different from the test-per-clock BIST structure shown in <figref idref="DRAWINGS">FIG. 1</figref>. The BIST shown here is characterized in that the test pattern generator <b>1</b> is constructed using an LFSR <b>2</b> in combination with a scan chain <b>5</b>. According to the structure shown here, since the number of signal inputs to the circuit-under-test (CUT) <b>3</b> and the number of bits in the LFSR <b>2</b> are independent of each other, the advantage is that a highly integrated circuit can be tested using an LFSR <b>2</b> with a smaller number of bits. For example, a circuit with a 1000-bit input can be tested using a 20-bit LFSR.</p>
<p id="p-0117" num="0119">The test-per-scan structure of <figref idref="DRAWINGS">FIG. 10</figref> can also change the output test pattern sequence by changing the seed. However, in this structure, the LFSR seed does not appear directly as the test pattern, but here also, the output test pattern sequence is determined by the seed. When the number of stages in the LFSR is m, and the length of the scan chain 5 is k bits, the PRPG outputs k-bit test patterns p<sub>0</sub>, p<sub>1</sub>, and so on.</p>
<p id="p-0118" num="0120">Let β<sub>j </sub>denote the seed that generates the test pattern p<sub>j </sub>after setting the seed in the LFSR. Here, the seed is expressed as βj=α<sup>(j×k)mod(2m−1)</sup>. That is, β<sub>0</sub>=α<sup>0</sup>, β<sub>1</sub>=α<sup>k</sup>, β<sub>2</sub>=α<sup>2k</sup>, and so on. At this time, both of k and (2<sup>m</sup>−1) must be prime numbers. If they are not prime numbers, dummy flip-flops are added to the scan chain so that they become prime numbers.</p>
<p id="p-0119" num="0121">The example of <figref idref="DRAWINGS">FIG. 11</figref> shows that the seeds β<sub>0 </sub>. . . , β<sub>4 </sub>each output 10 test patterns. For example, the seed β<sub>0 </sub>first outputs the test pattern p<sub>0</sub>. Then, it outputs p<sub>1</sub>. The 10th test pattern that the seed β<sub>0 </sub>outputs is p<sub>9</sub>. The seed β<sub>1 </sub>first outputs p<sub>1</sub>, then p<sub>2</sub>. In this way, the test-per-scan structure shown in <figref idref="DRAWINGS">FIG. 10</figref> can obtain the shortest test length that achieves the target fault coverage, by using the same technique as used in the test-per-clock structure of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0120" num="0122">A second embodiment of the present invention will be described below. This embodiment concerns an optimum seed selection method that can detect a maximum number of faults within a fixed test time. In the case of a complex circuit, it is difficult to achieve a fault coverage exceeding 95%, and it is realistic to set a certain test length and select a seed that can detect the largest number of faults with that test length l<sub>fix</sub>. This seed</p>
<p id="p-0121" num="0123">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
<mrow>
  <msub>
    <mi>β</mi>
    <mrow>
      <mi>j</mi>
      <mo>*</mo>
    </mrow>
  </msub>
  <mo>=</mo>
  <mrow>
    <mi>a</mi>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mi>r</mi>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mi>g</mi>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <munder>
        <mi>max</mi>
        <msub>
          <mi>β</mi>
          <mi>j</mi>
        </msub>
      </munder>
      <mo>⁢</mo>
      <mrow>
        <mo></mo>
        <mrow>
          <msub>
            <mi>F</mi>
            <mrow>
              <mi>β</mi>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mi>j</mi>
            </mrow>
          </msub>
          <mo>⋃</mo>
          <msub>
            <mi>F</mi>
            <mrow>
              <mrow>
                <mi>β</mi>
                <mo>⁢</mo>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
                <mo>⁢</mo>
                <mi>j</mi>
              </mrow>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>⋃</mo>
          <mstyle>
            <mspace width="0.6em" height="0.6ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mi>…</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⋃</mo>
          <msub>
            <mi>F</mi>
            <mrow>
              <mrow>
                <mi>β</mi>
                <mo>⁢</mo>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
                <mo>⁢</mo>
                <mi>j</mi>
              </mrow>
              <mo>+</mo>
              <msub>
                <mn>1</mn>
                <mrow>
                  <mi>f</mi>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mi>i</mi>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mi>x</mi>
                </mrow>
              </msub>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msub>
        </mrow>
        <mo></mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
is called the maximum fault detection count seed.
</p>
<p id="p-0122" num="0124">The maximum fault detection count seed selection method is an extension of the shortest test length seed selection method described above. The difference from the shortest test length seed selection method is that the selection method of this embodiment dynamically updates the target fault detection count each time a minimum test length is found.</p>
<p id="p-0123" num="0125">Before describing this method, the function will be defined. D(α<sup>i</sup>, 1) is a function that returns the number of faults detected with the test length l for the seed α<sup>i</sup>. Like L(α<sup>i</sup>, n<sub>fix</sub>) and L<sub>R</sub>(α<sub>i+1</sub>, n<sub>fix</sub>), D(α<sup>i</sup>, 1) can be obtained through fault simulation.</p>
<p id="p-0124" num="0126">When the test length l<sub>fix </sub>is given, the seed that achieves the largest fault detection count with that test length is selected. The process consists of two steps, Step-A* for obtaining the target fault detection count for the given test length l<sub>fix </sub>and Step-B* for predicting the presence of a seed that can detect a larger number of faults.</p>
<p id="p-0125" num="0127">The seed number of β<sub>j </sub>is denoted by j. As the selection process starts with the seed of the seed number 0, j=0.</p>
<p id="p-0126" num="0128">In Step-A*, the target fault detection count for the test length l<sub>fix </sub>is obtained.</p>
<p id="p-0127" num="0129">First, the number of faults detected with the test length l<sub>fix </sub>corresponding to the seed β<sub>j </sub>is set as the target fault detection count nt. That is, nt=D(β<sub>j</sub>, l<sub>fix</sub>). Next, the minimum test length that achieves the target fault detection count nt is obtained from
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>L<sub>R</sub>(β<sub>i+l</sub><sub><sub2>fix</sub2></sub><sub>−l</sub>, n<sub>t</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
The minimum test length l<sub>min </sub>is thus obtained. The seed number j<sub>min </sub>that yields the minimum test length is j<sub>min</sub>=j+l<sub>fix</sub>−l<sub>min</sub>. With this j<sub>min</sub>, Step-A* is repeated until the test length of seed β<sub>imin+1 </sub>becomes longer than l<sub>fix</sub>.
</p>
<p id="p-0128" num="0130">When the test length of seed β<sub>imin+1 </sub>is longer than the target test length l<sub>fix</sub>, the process proceeds to Step-B*. The seed number at which the test length l=L<sub>F</sub>(β<sub>j</sub>, n<sub>fix</sub>) that achieves the target fault detection count n<sub>fix </sub>becomes shorter than l<sub>fix </sub>is calculated. The prediction is repeated until 1 becomes equal to the calculated test length l<sub>fix</sub>−1 and, when the predicted test length is achieved, the target fault detection count n<sub>t </sub>is again set.</p>
<p id="p-0129" num="0131">In the case of an m-bit LFSR, this process is repeated until the seed number reaches 2<sup>m</sup>−2. The thus obtained target fault detection count nt is the maximum fault detection count n* for a given test length l<sub>fix</sub>, and the seed number j<sub>min </sub>is the maximum fault detection count seed number j*.</p>
<p id="p-0130" num="0132"><figref idref="DRAWINGS">FIG. 12</figref> shows one example of a program for finding the maximum fault detection count seed.</p>
<p id="p-0131" num="0133"><figref idref="DRAWINGS">FIGS. 13 and 14</figref> show a flowchart recapitulating the procedure for finding the maximum fault detection count seed described above. <figref idref="DRAWINGS">FIG. 15</figref> is a diagram for explaining the flowchart. The second embodiment of the present invention will be described below with reference to these drawings.</p>
<p id="p-0132" num="0134">First, in step P<b>1</b>, the seed number J is set to 0. Next, in step P<b>2</b>, fault simulation is performed with the seed β<b>0</b> of the seed number 0, to obtain the number of faults, n, detected with a predetermined test length L<sub>fix </sub>(in the example of <figref idref="DRAWINGS">FIG. 15</figref>, L<sub>fix</sub>=10).</p>
<p id="p-0133" num="0135">In step P<b>3</b>, it is determined whether the value of n obtained in step P<b>2</b> satisfies the condition as the maximum fault count. If the condition is satisfied, the process is terminated in step P<b>4</b>, and the seed β<b>0</b> that achieves the maximum fault count n is set as the initial value to be input to the test pattern generator.</p>
<p id="p-0134" num="0136">If NO in step P<b>3</b>, the process proceeds to step P<b>5</b> where reverse-order fault simulation is performed against the fault simulation performed in step P<b>2</b>, to obtain the minimum test length Lm necessary for detecting the number, n, of faults. In the example of <figref idref="DRAWINGS">FIG. 15</figref>, the minimum test length Lm is 7. The seed number that yields this minimum test length is calculated as J+L<sub>fix</sub>−Lm. In step P<b>6</b>, it is determined whether the seed number J+L<sub>fix</sub>−Lm exceeds the final value of the test pattern sequence S. If the determination is YES, the process is terminated in step P<b>7</b>, and the more recently obtained seed that yields the minimum test length is selected as the optimum initial value.</p>
<p id="p-0135" num="0137">If, in step P<b>6</b>, the seed number J+L<sub>fix</sub>−Lm is within the range of the test pattern sequence S (NO in step P<b>6</b>), then in step P<b>8</b> the seed number J is set to J+L<sub>fix</sub>−Lm and, in step P<b>9</b>, fault simulation is performed using this seed number, to find how many faults are detected within the target test length L<sub>fix</sub>. This is because, in the case of a seed that yields the minimum test length Lm here, unlike the case of the shortest test length seed detection method, there is the possibility that a new fault may be found between the minimum test length Lm and the target test length L<sub>fix</sub>.</p>
<p id="p-0136" num="0138">In the case of <figref idref="DRAWINGS">FIG. 15</figref>, if fault simulation is performed with the seed α<sup>3 </sup>by giving the test length 10, there is the possibility that a new fault may be found with the test patterns p<b>10</b> to p<b>12</b>.</p>
<p id="p-0137" num="0139">In the next step P<b>10</b>, the fault count nt obtained in step P<b>9</b> is compared with the fault count n obtained in step P<b>2</b>. If nt&gt;n, n is set as nt in step P<b>11</b>, after which the process returns through step P<b>3</b> to step P<b>5</b> where the reverse-order fault simulation is performed once again to obtain the minimum test length necessary for detecting the number, nt, of faults. Then, step P<b>6</b> and subsequent steps are carried out to obtain a new fault count nt; this process is repeated until nt≧t.</p>
<p id="p-0138" num="0140">When, with the above processing, the number, n, of faults detected with the target test length L<sub>fix </sub>reaches a maximum and the fault count is no longer updated, the seed number of the seed that achieves the maximum fault count is incremented by 1 in step P<b>12</b>. In the example of <figref idref="DRAWINGS">FIG. 15</figref>, when the number, nt, of faults detected with the seed β<b>3</b> is nt≦st, the next seed is β<b>4</b>. In step P<b>13</b>, it is determined whether this seed number exceeds the final value of the test pattern sequence; if it exceeds the final number, the process is terminated in step p<b>14</b>, otherwise the process proceeds to step P<b>15</b>.</p>
<p id="p-0139" num="0141">In step P<b>15</b>, fault simulation is performed with the seed of the new number to obtain the test length L necessary for achieving the so-far obtained maximum fault count n and, in step P<b>16</b>, this test length L is compared with the target test length L<sub>fix</sub>. In the case of <figref idref="DRAWINGS">FIG. 15</figref>, as the test length L of the seed β<b>4</b> is 13, L&gt;L<sub>fix</sub>. In this case, as can be seen from <figref idref="DRAWINGS">FIG. 15</figref>, there is the possibility that the seed β<b>8</b> is likely to yield a test length L shorter than L<sub>fix</sub>. In step P<b>17</b>, the next seed number that is likely to yield a test length L shorter than L<sub>fix </sub>is computed.</p>
<p id="p-0140" num="0142">In step P<b>18</b>, it is determined whether the seed number computed in step P<b>17</b> exceeds the final value of the test pattern sequence; if it does not exceed the final value, the process returns to step P<b>15</b> to perform fault simulation with the seed of the above-computed seed number. This step is repeated until the test length L becomes shorter than L<sub>fix </sub>in step P<b>16</b>. If YES in step P<b>18</b>, as in steps P<b>7</b> and P<b>13</b>, the process is terminated in step P<b>19</b>.</p>
<p id="p-0141" num="0143">When the test length L becomes shorter than L<sub>fix </sub>in step P<b>16</b>, steps P<b>2</b> and subsequent steps are carried out using the seed obtained here, to obtain a new fault count detected within the target test length L<sub>fix</sub>. In this way, the maximum fault detection count is obtained by repeating the above process until the thus obtained new fault count reaches the predetermined target fault count or until the seed number exceeds the final value of the test pattern sequence. The seed determined here is the optimum initial value for the test pattern generator.</p>
<p id="p-0142" num="0144">Alternatively, when the test length L is obtained for the seed β<b>4</b> in <figref idref="DRAWINGS">FIG. 15</figref> through fault simulation (step P<b>15</b> in <figref idref="DRAWINGS">FIG. 14</figref>), reverse-order fault simulation up to the test pattern p<b>14</b> may be performed in this fault simulation to check whether there appears any minimum test length shorter than the previously obtained minimum test length. If a shorter minimum test length is found, then the next seed number that can detect a larger number of faults within the target test length L<sub>fix </sub>can be calculated using that value. Using this method, the time required to calculate the maximum fault detection count seed can be further reduced.</p>
<p id="p-0143" num="0145">The above maximum fault detection count seed selection method has been described for the test-per-scan structure shown in <figref idref="DRAWINGS">FIGS. 10 and 11</figref>, but it will be appreciated that the above selection method can be equally applied to the test-per-clock BIST structure.</p>
<p id="p-0144" num="0146">Table 3 shows a comparison between the seed α<sub>0 </sub>and the maximum fault detection count seed obtained by the method of the present invention, for 20 polynomials in the c7552 circuit using a 20-bit primitive polynomial LFSR. The table shows the average number of detected faults, the minimum number of undetected faults, and the processing time per polynomial, for the seed α<sub>0</sub>(00 . . . 01) and the maximum fault detection count seed.</p>
<p id="p-0145" num="0147">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="308pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 3</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>AVERAGE FAULT DETECTION COUNT FOR c7552 with 20-</entry>
</row>
<row>
<entry>BIT LFSR/20 POLYNOMIALS</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="147pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="center"/>
<colspec colname="2" colwidth="49pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>MAXIMUM FAULT</entry>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="112pt" align="center"/>
<colspec colname="2" colwidth="112pt" align="center"/>
<colspec colname="3" colwidth="49pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>SEED 00 . . . 01</entry>
<entry>DETECTION COUNT SEED</entry>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="56pt" align="center"/>
<colspec colname="3" colwidth="56pt" align="center"/>
<colspec colname="4" colwidth="56pt" align="center"/>
<colspec colname="5" colwidth="56pt" align="center"/>
<colspec colname="6" colwidth="49pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>AVERAGE</entry>
<entry>MINIMUM</entry>
<entry>AVERAGE</entry>
<entry>MINIMUM</entry>
<entry/>
</row>
<row>
<entry/>
<entry>NUMBER OF</entry>
<entry>NUMBER OF</entry>
<entry>NUMBER OF</entry>
<entry>NUMBER OF</entry>
<entry>PROCESSING</entry>
</row>
<row>
<entry>TEST</entry>
<entry>UNDETECTED</entry>
<entry>UNDETECTED</entry>
<entry>UNDETECTED</entry>
<entry>UNDETECTED</entry>
<entry>TIME</entry>
</row>
<row>
<entry>LENGTH</entry>
<entry>FAULTS</entry>
<entry>FAULTS</entry>
<entry>FAULTS</entry>
<entry>FAULTS</entry>
<entry>(SECONDS)</entry>
</row>
<row>
<entry namest="1" nameend="6" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="35pt" align="char" char="."/>
<colspec colname="2" colwidth="56pt" align="char" char="."/>
<colspec colname="3" colwidth="56pt" align="char" char="."/>
<colspec colname="4" colwidth="56pt" align="char" char="."/>
<colspec colname="5" colwidth="56pt" align="char" char="."/>
<colspec colname="6" colwidth="49pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>1000</entry>
<entry>464</entry>
<entry>418</entry>
<entry>369</entry>
<entry>359</entry>
<entry>4121</entry>
</row>
<row>
<entry>5000</entry>
<entry>351</entry>
<entry>319</entry>
<entry>277</entry>
<entry>259</entry>
<entry>4262</entry>
</row>
<row>
<entry>10000</entry>
<entry>304</entry>
<entry>270</entry>
<entry>243</entry>
<entry>227</entry>
<entry>5034</entry>
</row>
<row>
<entry namest="1" nameend="6" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0146" num="0148">For the target test length 1000, when the seed α<sup>0 </sup>is used, the average number of undetected faults is 464, and the minimum number of undetected faults is 418. In the case of the maximum fault detection count seed, the average number is 369, and the minimum number of undetected faults is 359. The processing time per polynomial was 4121 seconds.</p>
<p id="p-0147" num="0149">When the test length is 10000, the number of undetected faults is 227 in the case of the polynomial having the maximum fault detection count seed that achieves the largest fault detection count among the 20 primitive polynomials. This means that 77 more faults are detected compared with the average number of undetected faults, i.e., 304, for the seed α<sup>0</sup>.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US07299394-20071120-M00001.NB">
<img id="EMI-M00001" he="4.23mm" wi="76.20mm" file="US07299394-20071120-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US07299394-20071120-M00002.NB">
<img id="EMI-M00002" he="6.35mm" wi="76.20mm" file="US07299394-20071120-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for determining an optimum initial value to be input to a test pattern generator for testing an integrated circuit, comprising the steps of:
<claim-text>a) obtaining a first test length and a first minimum test length for detecting a predetermined fault number n by performing a fault simulation and a reverse-order fault simulation using an arbitrarily given first initial value;</claim-text>
<claim-text>b) computing, based on said first initial value and on said first test length and said first minimum test length, a second initial value that can yield a test length shorter than said first minimum test length;</claim-text>
<claim-text>c) obtaining a second test length for detecting said fault number n by performing a second fault simulation using said computed second initial value;</claim-text>
<claim-text>d) comparing said second test length with said first minimum test length, and obtaining a second minimum test length by regarding said first minimum test length as said second minimum test length when said second test length is equal to or longer than said first minimum test length, or by performing a reverse-order fault simulation against said second fault simulation when said second test length is shorter than said first minimum test length; and</claim-text>
<claim-text>e) obtaining the shortest test length by repeating said steps b), c), and d) by regarding said second initial value, said second test length, and said second minimum test length as said first initial value, said first test length, and said first minimum test length, wherein
<claim-text>an initial value that yields the shortest test length obtained in said step e) is determined as the initial value to be input to said test pattern generator when testing said integrated circuit.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A method for determining an optimum initial value for testing an integrated circuit as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein in said step e), said steps b), c), and d) are repeated until said minimum test length reaches a predetermined value.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A method for determining an optimum initial value for a test pattern generator as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein in said step e), said steps b), c), and d) are repeated until said first or second initial value reaches a final value of a preselected test pattern sequence.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A method for determining an optimum initial value for a test pattern generator as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein when said first initial value is an i-th value in a test pattern sequence, said first test length is L, said first minimum test length is Lm, and said second initial value in said step b) is an i2-th value in said test pattern sequence, then i2 is calculated as
<claim-text>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>i</i>2<i>=i+L−Lm</i>+1.<?in-line-formulae description="In-line Formulae" end="tail"?>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A method for determining an optimum initial value for a test pattern generator as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said test pattern generator has a test-per-clock structure using a linear feedback shift register.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A method for determining an optimum initial value for a test pattern generator as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said test pattern generator has a test-per-scan structure using a linear feedback shift register in combination with a scan chain.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. An apparatus for testing an integrated circuit that is constructed by integrating into a single chip a circuit-under-test, a test pattern generator for generating a test pattern sequence and applying the same to said circuit-under-test, and a test response compactor for detecting a test result from said circuit-under-test, wherein said test pattern generator is provided with an initial value that yields the shortest test length, said shortest test length being determined by performing the steps of:
<claim-text>a) obtaining a first test length and a first minimum test length for detecting a predetermined fault number n by performing a fault simulation and a reverse-order fault simulation using an arbitrarily given first initial value;</claim-text>
<claim-text>b) computing, based on said first initial value and on said first test length and said first minimum test length, a second initial value that can yield a test length shorter than said first minimum test length;</claim-text>
<claim-text>c) obtaining a second test length for detecting said fault number n by performing a second fault simulation using said computed second initial value;</claim-text>
<claim-text>d) comparing said second test length with said first minimum test length, and obtaining a second minimum test length by regarding said first minimum test length as said second minimum test length when said second test length is equal to or longer than said first minimum test length, or by performing a reverse-order fault simulation against said second fault simulation when said second test length is shorter than said first minimum test length; and</claim-text>
<claim-text>e) obtaining said shortest test length by repeating said steps b), c), and d) by regarding said second initial value, said second test length, and said second minimum test length as said first initial value, said first test length, and said first minimum test length.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. An apparatus for testing an integrated circuit as claimed in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein said test pattern generator has a test-per-clock structure using a linear feedback shift register.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. An apparatus for testing an integrated circuit as claimed in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein said test pattern generator has a test-per-scan structure using a linear feedback shift register in combination with a scan chain.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method for determining an optimum initial value to be input to a test pattern generator for testing an integrated circuit, comprising the steps of:
<claim-text>a) obtaining a first fault number n detected with a predetermined target test length L<sub>fix</sub>, by performing a first fault simulation using an arbitrarily given first initial value;</claim-text>
<claim-text>b) obtaining a first minimum test length necessary for detecting said first fault number n by performing a reverse-order simulation against said first fault simulation;</claim-text>
<claim-text>c) computing, based on said first initial value and on said target test length L<sub>fix </sub>and said first minimum test length, a second initial value that yields said first minimum test length;</claim-text>
<claim-text>d) obtaining a second fault number nt detected with said predetermined target test length L<sub>fix</sub>, by performing a second fault simulation using said computed second initial value;</claim-text>
<claim-text>e) comparing said second fault number nt with said first number n, and obtaining a maximum number of detected faults by taking said first fault number n as said maximum number when nt≦n, or by repeating said steps b) to d) until nt≦n is achieved, when nt&gt;n;</claim-text>
<claim-text>f) obtaining a test length L necessary for detecting said maximum number of detected faults, by performing a third fault simulation using an initial value, in a test pattern sequence, that immediately follows the initial value that achieves said maximum number of detected faults;</claim-text>
<claim-text>g) comparing said test length L with said target test length L<sub>fix </sub>and, if L≧L<sub>fix</sub>, then computing, based on the initial value used in said third fault simulation and on said test length L and said target test length L<sub>fix</sub>, the next initial value that is likely to yield a test length shorter than said target test length L<sub>fix</sub>;</claim-text>
<claim-text>h) repeating said steps f) and g) with the initial value computed in said step g), until L&lt;L<sub>fix </sub>is achieved; and</claim-text>
<claim-text>i) obtaining the largest number of faults detected with said target test length, by repeating said steps a) to h) by regarding as said first initial value the initial value that achieves L&lt;L<sub>fix </sub>in said step g) or said step h), wherein
<claim-text>an initial value that achieves said largest number of detected faults obtained in said step i) is determined as the initial value to be input to said test pattern generator when testing said integrated circuit.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A method for determining an optimum initial value for testing an integrated circuit as claimed in <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein in said step i), said steps a) to h) are repeated until the number of faults detected reaches a predetermined desired value.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A method for determining an optimum initial value for a test pattern generator as claimed in <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein in said step i), said steps a) to h) are repeated until any one of said initial value reaches a final value of a preselected test pattern sequence.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A method for determining an optimum initial value for a test pattern generator as claimed in <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein when said first initial value is an i-th value in a test pattern sequence, said predetermined target test length is L<sub>fix</sub>, said first minimum test length is Lm, and said second initial value in said step c) is an i2-th value in said test pattern sequence, then i2 is calculated as
<claim-text>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>i</i>2<i>=i+L</i><sub>fix</sub><i>−Lm.</i><?in-line-formulae description="In-line Formulae" end="tail"?>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method for determining an optimum initial value for a test pattern generator as claimed in claim <b>10</b>, wherein said test pattern generator has a test-per-clock structure using a linear feedback shift register.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A method for determining an optimum initial value for a test pattern generator as claimed in <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein said test pattern generator has a test-per-scan structure using a linear feedback shift register in combination with a scan chain.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. An apparatus for testing an integrated circuit that is constructed by integrating into a single chip a circuit-under-test, a test pattern generator for generating a test pattern sequence and applying the same to said circuit-under-test, and a test response compactor for detecting a test result from said circuit-under-test, wherein said test pattern generator is provided with an initial value that achieves the largest number of detected faults, said largest number of detected faults being determined by performing the steps of:
<claim-text>a) obtaining a first fault number n detected with a predetermined target test length L<sub>fix</sub>, by performing a first fault simulation using an arbitrarily given first initial value;</claim-text>
<claim-text>b) obtaining a first minimum test length necessary for detecting said first fault number n by performing a reverse-order simulation against said first fault simulation;</claim-text>
<claim-text>c) computing, based on said first initial value and on said target test length L<sub>fix </sub>and said first minimum test length, a second initial value that yields said first minimum test length;</claim-text>
<claim-text>d) obtaining a second fault number nt detected with said predetermined target test length L<sub>fix</sub>, by performing a second fault simulation using said computed second initial value;</claim-text>
<claim-text>e) comparing said second fault number nt with said first fault number n, and obtaining a maximum number of detected faults by taking said first fault number n as said maximum number when nt≦n, or by repeating said steps b) to d) until nt≦n is achieved, when nt&gt;n;</claim-text>
<claim-text>f) obtaining a test length L necessary for detecting said maximum number of detected faults, by performing a third fault simulation using an initial value, in a test pattern sequence, that immediately follows the initial value that achieves said maximum number of detected faults;</claim-text>
<claim-text>g) comparing said test length L with said target test length L<sub>fix </sub>and, if L≧L<sub>fix</sub>, then computing, based on the initial value used in said third fault simulation and on said test length L and said target test length L<sub>fix</sub>, the next initial value that is likely to yield a test length shorter than said target test length L<sub>fix</sub>;</claim-text>
<claim-text>h) repeating said steps f) and g) with the initial value computed in said step g), until L&lt;L<sub>fix </sub>is achieved; and</claim-text>
<claim-text>i) obtaining said largest number of faults detected with said target test length, by repeating said steps a) to h) by regarding as said first initial value the initial value that achieves L&lt;L<sub>fix </sub>in said step g) or said step h).</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. An apparatus for testing an integrated circuit as claimed in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said test pattern generator has a test-per-clock structure using a linear feedback shift register.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. An apparatus for testing an integrated circuit as claimed in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said test pattern generator has a test-per-scan structure using a linear feedback shift register in combination with a scan chain.</claim-text>
</claim>
</claims>
</us-patent-grant>
