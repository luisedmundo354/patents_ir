<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299384-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299384</doc-number>
<kind>B1</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10920597</doc-number>
<date>20040817</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>570</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>28</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>14</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714 52</main-classification>
<further-classification>711152</further-classification>
<further-classification>711173</further-classification>
<further-classification>717124</further-classification>
<further-classification>717131</further-classification>
</classification-national>
<invention-title id="d0e53">Fixing prematurely freed objects</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6055612</doc-number>
<kind>A</kind>
<name>Spertus et al.</name>
<date>20000400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6434575</doc-number>
<kind>B1</kind>
<name>Berry et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6584478</doc-number>
<kind>B1</kind>
<name>Spertus</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6647547</doc-number>
<kind>B1</kind>
<name>Kanamaru et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2004/0215913</doc-number>
<kind>A1</kind>
<name>Fougeroux et al.</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2004/0221120</doc-number>
<kind>A1</kind>
<name>Abrashkevich et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711173</main-classification></classification-national>
</citation>
</references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711152</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711173</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 52</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 54</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717124</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717131</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Rodriguez-Rivera</last-name>
<first-name>Gustavo</first-name>
<address>
<city>West Lafayette</city>
<state>IN</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Spertus</last-name>
<first-name>Michael P.</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Fiterman</last-name>
<first-name>Charles</first-name>
<address>
<city>Deerfield</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Polubinski</last-name>
<first-name>Jim</first-name>
<address>
<city>Palos Hills</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="005" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Day</last-name>
<first-name>Brian</first-name>
<address>
<city>Hillside</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="006" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Hoyt</last-name>
<first-name>Daryl</first-name>
<address>
<city>Aurora</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="007" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Metcalf</last-name>
<first-name>Christopher D.</first-name>
<address>
<city>Wellesley</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Meyertons Hood Kivlin Kowert &amp; Goetzel, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Rankin</last-name>
<first-name>Rory D.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Symantec Operating Corporation</orgname>
<role>02</role>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Dildine</last-name>
<first-name>R. Stephen</first-name>
<department>2112</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and mechanism for managing dynamically allocated memory. Portions of memory which are available for allocation have additional information stored in association with each portion which indicates whether the portion has been previously identified as being prematurely freed. In addition, a checksum is stored with each portion of memory. In response to a request for deallocation of a portion of memory, the portion of memory is not deallocated if it is identified as having been prematurely freed. Otherwise, the a checksum is calculated for the portion and it is freed. In response to an allocation request, a candidate portion of memory is identified for allocation and a checksum is calculated for the candidate portion. If the calculated checksum does not match a checksum previously stored for the candidate portion, the portion is identified as having been prematurely freed and is not returned for allocation.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="255.61mm" wi="214.04mm" file="US07299384-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="234.53mm" wi="183.98mm" orientation="landscape" file="US07299384-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="255.61mm" wi="191.01mm" file="US07299384-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="259.42mm" wi="215.14mm" file="US07299384-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="261.28mm" wi="215.73mm" file="US07299384-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="234.95mm" wi="193.21mm" orientation="landscape" file="US07299384-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">IDENTIFICATION OF COPYRIGHT </heading>
<p id="p-0002" num="0001">A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings: Copyright® 2003, Veritas Software Corporation, All Rights Reserved.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">1. Field of the Invention</p>
<p id="p-0004" num="0003">The invention relates to computing systems and, more particularly, to detecting and fixing prematurely freed objects.</p>
<p id="p-0005" num="0004">2. Description of the Related Art</p>
<p id="p-0006" num="0005">Computer programming languages such a C and C++ allow programmers to manage memory by enabling them to explicitly allocate and free portions of memory during execution of a program. While this ability to explicitly allocate and free memory may simplify many programming tasks, it does present certain challenges as well. For example, once memory has been allocated, the programmer must ensure that it is not freed again until the program is done using it. Freeing a portion of memory before the program is done using it is sometime referred to as a “premature free”. In addition, once the program is finished using allocated memory, it should be freed and not retained in an allocated state. Otherwise, the memory which was allocated will remain unavailable for reuse by that or other programs.</p>
<p id="p-0007" num="0006">As those skilled in the art will appreciate, a variety of factors may increase the difficulty of avoiding errors in the management of memory. For example, the difficult in properly managing memory may increase as the size of a program grows. In addition, memory may be allocated in one module of a program, used in other modules of the program, and freed in still other modules. The fact that these modules may be written by different programmers can further complicate matters. Further, the difficulty in managing memory may also increase as a program ages. Most programs undergo revision in order to fix bugs or add new features. Given that the people who do the revisions may be different from those who wrote the original program, the manner in which the revised program manages memory may be different from that contemplated by the original authors of the program.</p>
<p id="p-0008" num="0007">One way of solving some of the problems posed by programs which manage their own memory is to reserve all freeing of memory to a special program called a garbage collector which frees blocks of memory that are no longer being used by a program. Generally speaking, garbage collectors work by detecting portions of memory that no longer have pointers pointing to them (i.e., are “unreachable”). In this manner, the garbage collector may identify and help resolve memory leaks. However, while the use of automated garbage collectors may ease some of the problems of managing memory, garbage collection mechanisms—when they are available—may involve a significant amount of overhead. Consequently, it may not be desirable to use automated garbage collection for a particular application.</p>
<p id="p-0009" num="0008">In addition to the above, garbage collectors generally do not address the problem of prematurely freed memory. As noted above, a premature free results when a portion of memory is freed while the portion of memory is still in use by the program. Once memory is free, it generally becomes part of the system heap and is made available for reallocation. A subsequent attempted access to memory that has already been freed may access data in an unrelated part of the program. Consequently, premature frees may result in corrupted data. In addition, locating the root cause of such data corruption can be very difficult to debug.</p>
<p id="p-0010" num="0009">Accordingly, an effective method and mechanism for managing premature frees is desired.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0011" num="0010">A method and mechanism for manage memory usage are contemplated and, in particular, for detecting and fixing premature frees.</p>
<p id="p-0012" num="0011">In one embodiment, a memory allocator/deallocator is modified to support the detection and management of premature frees in dynamically allocated memory. Contemplated is a method and mechanism in which portions or blocks of heap memory which are available for allocation have additional information stored in association with each portion which indicates whether the portion has been previously identified as having been prematurely freed. Also stored in association with each portion of memory is a checksum for the data in the allocated portion memory. In response to a request for deallocation of a particular portion of memory, the portion of memory will not be deallocated if it is identified as having been prematurely freed. If the portion to be deallocated is not identified as having been prematurely freed, a checksum is calculated for the portion and it is freed. In response to a request for the allocation of a portion of memory, a candidate portion of memory is identified for allocation and a checksum is calculated for the candidate portion. If the calculated checksum does not match the checksum which was previously stored for the candidate portion, then the portion is identified as having been prematurely freed, an indication that the portion corresponds to a prematurely freed portion is stored, and the portion is not returned for allocation.</p>
<p id="p-0013" num="0012">Also contemplated is an embodiment in which a list is maintained which identifies portions of code in an application as having been deemed unsafe. In one embodiment, when it is determined that a candidate portion of memory was prematurely freed, an identification of the calling/requesting code is stored in association with the candidate portion and the identification is added to an “unsafe list”. In one embodiment, identification of the calling/requesting code is in the form of the program counter corresponding to the requesting code. In response to a request for deallocation of a portion of memory, a check is performed to determine if the requestor of the deallocation is included on the unsafe list. If the requestor is identified as being included in the unsafe list, the portion of memory is not deallocated.</p>
<p id="p-0014" num="0013">These and other embodiments, variations, and modifications will become apparent upon consideration of the following description and associated drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> depicts one embodiment of a computing system.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> depicts one embodiment of a free list.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref> depicts one embodiment of a method for managing prematurely freed memory.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> depicts an alternative embodiment of a method for managing prematurely freed memory.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> illustrates one embodiment of a computing system configured to monitor memory usage.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0020" num="0019">While the invention is susceptible to various modifications and alternative forms, specific embodiments are shown herein by way of example. It is to be understood that the drawings and description included herein are not intended to limit the invention to the particular forms disclosed. Rather, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 1</figref> illustrates one embodiment of a computing system and illustrates one embodiment of the logical layout of memory in the system. In the example shown, the system includes a processing device <b>170</b>, memory system <b>190</b>, and persistent storage <b>180</b>. Generally speaking, the memory system <b>190</b> may include one or more caches and a system memory. Storage <b>180</b> may generally comprise a disk based system, but any suitable form of persistent storage may be utilized. Also illustrated, is a logical layout <b>100</b> of memory in the system. As shown, the memory may be divided into multiple regions, each of which is designated for a particular purpose. Included among the regions, or partitions, is a code section <b>110</b>, a data section <b>120</b>, a heap section <b>130</b>, a free section <b>140</b>, and a stack section <b>150</b>. Generally speaking, the code section <b>110</b> is used for storing executable application code and the data section <b>120</b> is used for storing application data. Stack section <b>150</b> may be used for temporarily storing data in response to procedure calls or other types of changes in context. Heap <b>130</b> is used for dynamically allocated memory during execution of a program. Finally, free section <b>140</b> represents memory which is available for use by both the heap <b>130</b> and the stack <b>150</b>. In general, the heap <b>130</b> and stack <b>150</b> grow towards each other as each of these sections increase in size.</p>
<p id="p-0022" num="0021">Unlike the stack <b>150</b>, the heap <b>130</b> is generally not maintained in a strictly ordered manner. Consequently, a contiguous region of memory within the heap <b>130</b> may include disjoint areas which are in use or are free. For example, memory blocks <b>160</b>-<b>169</b> in <figref idref="DRAWINGS">FIG. 1</figref> represent a contiguous area of memory within the heap <b>130</b>. However, as noted in the example, only blocks <b>161</b>, <b>163</b>, <b>166</b> and <b>169</b> are free. Accordingly, blocks <b>160</b>, <b>162</b>, <b>164</b>, <b>165</b>, <b>167</b>, and <b>168</b> are currently in use (i.e., have been allocated for use by the program). Because free areas of memory within the heap <b>130</b> are generally not maintained in a contiguous manner, locating a suitable area of free memory in response to an allocation request may be relatively inefficient. Consequently, various techniques are used to facilitate a more rapid and orderly identification of free blocks of memory for allocation. For example, a free list may be maintained in which blocks of memory which are free form a linked list. Some embodiments may utilize tables of free lists where each free lists corresponds to a particular size of allocated block(s). In addition, various algorithms may be used for selecting which block(s) are to be allocated in response to a request. In some embodiments, the first available free block(s) is returned. Other embodiments may search for the best fit. Numerous such alternatives are possible and are contemplated. As used herein, “block” or “blocks” of memory may refer to any allocable region of memory. For example, blocks may be measured and allocated in terms of bytes or words. An allocated region of memory may be referred to as a collection of blocks. Alternatively, the entire allocated region of memory may simply be referred to as a block. In addition, various embodiments may utilize blocks which are variable in size.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 2</figref> illustrates one embodiment of a list <b>200</b> for use in identifying those portions of the heap which are in use and those which are free. In the example shown, list <b>200</b> includes multiple blocks (<b>201</b>A, <b>202</b>B, <b>202</b>C, <b>202</b>D, and <b>202</b>E) of memory. A head pointer <b>201</b> is included which points to the first block <b>202</b> in the list. Each block in the example shown, includes a header section, data section, and a footer section. The header and footer sections of a block generally include information about the block, such as its size and whether or not it is currently free. The data section of the block is used for storing the actual data of the program. It is to be understood that the list described in <figref idref="DRAWINGS">FIG. 2</figref> is only one of many ways such lists may be configured and maintained. Those skilled in the art will appreciate numerous other ways such lists may be implemented. For example, in one embodiment, block metadata (i.e., header and/or footer data) may be maintained separately from the actual data to which it corresponds. In this manner, the metadata may be protected from overwrites or other forms of corruption during program execution. Elements referred to herein with a particular reference number followed by a letter may be collectively referred to by the reference number alone. For example, blocks <b>202</b>A-<b>202</b>E may be collectively referred to as blocks <b>202</b>.</p>
<p id="p-0024" num="0023">In one embodiment, each block <b>202</b> of memory includes pointers for use in forming a linked list. Such pointers may be maintained in either the header, footer, or both. For example, in one embodiment, free blocks of memory are configured as a linked list so as to facilitate rapid traversal of blocks of memory which are available for allocation. This list of free blocks may generally be referred to as a “free list”. When a particular block of memory is allocated for use, it is “removed” from the free list by modifying the appropriate pointer to bypass the allocated block. Similarly, when a block of memory is freed, it is inserted into the free list by modifying the appropriate pointers to include the freed block in the list.</p>
<p id="p-0025" num="0024">As discussed above, a variety of problems may arise in an application where memory is explicitly managed by the programmer(s) who write the application. One such problem that was mentioned in the that of premature frees. With respect to the discussion of the free list above, a premature free may generally refer to a situation where a program modifies a block of memory which is currently identified as being free (e.g., it is currently in the free list). As the free list is configured to maintain references to memory which are not currently in use or needed by the program, such a situation clearly denotes a problem. In order better manage the problem of premature frees, a method and mechanism described as follows may be used.</p>
<p id="p-0026" num="0025">In one embodiment, additional information is maintained for each block of memory within the heap. In the example of <figref idref="DRAWINGS">FIG. 2</figref>, each of the headers of the depicted blocks may include information such as that illustrated by block <b>220</b>. In one embodiment, a checksum (or any other suitable signature, such as CRC, Hamming code, MD5, etc.) for the block is maintained. The checksum may generally correspond to only the data stored within the data section, though other embodiments may also include the block metadata or other information as well. In addition, a “PreFreed” indication is maintained which indicates whether or not the block has previously been identified as being prematurely freed. Also illustrated is a “Size” indication which indicate the size of the block and a “Free/Allocated” indicator which indicates whether the block is currently free or in use. Not shown are the above described list pointers which may also be included in the header, along with any other information deemed suitable. It is noted that the information depicted by block <b>220</b> may be maintained in either the header, footer, or both.</p>
<p id="p-0027" num="0026">Turning now to <figref idref="DRAWINGS">FIG. 3</figref>, one embodiment of a method for managing dynamically allocated memory is shown. In one embodiment, the operations which are used by a particular program for allocating and deallocating memory are modified. For example, in a C programming language based implementation, the malloc and free operations are modified. In a C++ based implementation, the new and delete operations are modified. Modification of these operators may be accomplished via injection, relinking with a new allocation library, or otherwise. Subsequent to modification, the general operation of the allocation and deallocation of memory may be as represented by <figref idref="DRAWINGS">FIG. 3</figref> or <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0028" num="0027">In <figref idref="DRAWINGS">FIG. 3</figref>, execution of a particular program is initiated (block <b>300</b>). Subsequent to execution, memory allocations/deallocations may be detected. If a deallocation is detected (decision block <b>302</b>), such as in response to a free or delete operation, the method determines whether the block being freed has previously been identified as being PreFreed (prematurely freed) (decision block <b>312</b>). For example, as described above, the header of the block may be configured to store a PreFreed indicator. If the block is not identified as one which has previously been prematurely freed, a checksum (or other signature) is calculated for the block and stored in the block (block <b>316</b>), and the block is deallocated (block <b>318</b>). On the other hand, if the block is identified as having been prematurely freed on a prior occasion (decision block <b>312</b>), the block is not deallocated (block <b>314</b>). Consequently, blocks which have been identified as being prematurely freed are not returned to the free list. In this manner, the block cannot again be prematurely freed.</p>
<p id="p-0029" num="0028">In the event an allocation is detected (decision block <b>304</b>), the allocator identifies a candidate block for allocation (block <b>306</b>). Identification of the candidate block may be pursuant to any suitable algorithm, such as first fit, best fit, or otherwise. Subsequent to identifying a candidate block, the allocator may determine whether the identified block has previously been allocated (decision block <b>308</b>). For example, in the early stages of execution, much of the heap has not yet been allocated a first time. In one embodiment, a flag in the header may be used to indicate whether the block has previously been allocated. If the block has not been previously allocated, the block is allocated (block <b>310</b>) and the flow returns to block <b>302</b> as indicated.</p>
<p id="p-0030" num="0029">In the event that it is determined the candidate block has been previously allocated (decision block <b>308</b>), the block was previously utilized and freed by the program. As noted in the deallocation sequence of <figref idref="DRAWINGS">FIG. 3</figref>, blocks which are freed have a checksum calculated and stored prior to the deallocation. Therefore, the identified candidate block should not only be unmodified since being previously deallocated, but should also have the previously calculated checksum stored in its header (or if not stored in the header, stored in whatever manner the metadata for the block is being maintained). Therefore, in order to confirm the candidate block has not been modified since being freed, a checksum is again calculated for the block (block <b>318</b>), and compared to the checksum which was previously stored for the block (decision block <b>320</b>). If the checksums match, indicating the block has not been modified since being freed, the candidate block is allocated (block <b>326</b>). However, if the checksums do not match, then the block has been modified since being freed and a premature free has apparently occurred. Therefore, the block is marked as having been prematurely freed (e.g., by setting the PreFreed indicator) and the candidate block is not allocated (block <b>322</b>). Instead, the block is skipped and flow returns to block <b>306</b> in order to seek a new candidate block for allocation.</p>
<p id="p-0031" num="0030">In the embodiment of <figref idref="DRAWINGS">FIG. 3</figref>, both allocations and deallocations are modified to support management of prematurely freed memory. In the case of deallocations, blocks which are identified as having been prematurely freed are not deallocated and returned to the free list. Blocks to be deallocated which are not identified as having been prematurely freed have their checksum calculated and stored prior to deallocation. In the case of memory block allocations, those which are identified as having been modified after being freed are identified as having been prematurely freed. These blocks are not returned to the caller/requestor as an allocated block. Rather, these blocks are marked as having been prematurely freed and are essentially skipped by the allocator when it comes time to allocate a block. It is noted that during the search for a candidate block (block <b>306</b>), those blocks which already include an indication that they were prematurely freed on a prior occasion are not considered viable candidates for allocation and are skipped.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 4</figref> illustrates an alternative embodiment for managing dynamically allocated memory. In the embodiment of <figref idref="DRAWINGS">FIG. 4</figref>, information similar to that as described in block <b>220</b> of <figref idref="DRAWINGS">FIG. 2</figref> may be maintained. However, in addition that information, the embodiment of <figref idref="DRAWINGS">FIG. 4</figref> is also configured to maintain an identification of the “caller” or “requestor” memory allocations. For example, in one embodiment, a caller of a memory allocation (e.g., the instruction(s) corresponding to a malloc or a new operation) is identified by the Program Counter (PC) corresponding to the calling instruction. Generally speaking, once program code image is loaded into memory, the PC for a given instruction remains constant throughout execution. Therefore, each time a particular instruction is executed, as identified by its PC, it may be assumed it is the same instruction being executed each time.</p>
<p id="p-0033" num="0032">In the embodiment of <figref idref="DRAWINGS">FIG. 4</figref>, an “unsafe list” is maintained which keeps track of “callers” which have been deemed unsafe. <figref idref="DRAWINGS">FIG. 4</figref> is similar to <figref idref="DRAWINGS">FIG. 3</figref>, with the exception of blocks <b>402</b>, <b>404</b>, and <b>406</b>. With respect to allocations, if an identified candidate block has a checksum mismatch (decision block <b>320</b>), the block is marked as having been prematurely freed (block <b>400</b>)—which is similar to that of block <b>322</b> in <figref idref="DRAWINGS">FIG. 3</figref>. However, in this case, the PC of the caller is also stored with the metadata of the block (e.g., in the header) and the PC is added to a list of caller PCs which are considered unsafe (block <b>402</b>). These caller PCs are deemed unsafe in the sense that they correspond to callers which are associated with premature frees. Finally, the block is skipped (block <b>404</b>) as before, and the search for a block continues (block <b>306</b>).</p>
<p id="p-0034" num="0033">In the case of deallocations, if a block being deallocated is identified as being prematurely freed (block <b>312</b>), it is not deallocated (block <b>314</b>) as was the case in <figref idref="DRAWINGS">FIG. 3</figref>. However, if the block is not identified as having prematurely freed (block <b>312</b>), a further check is performed to determine if the block includes the identification of a caller PC which is included in the unsafe caller list (block <b>406</b>). If the block caller is included in the unsafe caller list, the block is not deallocated (block <b>314</b>). In this manner, a block associated with a caller which has been identified as being associated with unsafe practices in the past (e.g., premature frees) will not be freed. This block is not freed even if it has not itself been identified as having been prematurely freed in the past. In this manner, an added measure of protection is provided against a portion of program code which has behaved incorrectly in the past and has the potential to further corrupt or crash the program.</p>
<p id="p-0035" num="0034">It is noted that in <figref idref="DRAWINGS">FIG. 4</figref> an unsafe PC is stored for a block if the block has already been identified as corresponding to a premature free (block <b>402</b>). In such a case a deallocation check as occurs in decision block <b>406</b> may simply identify whether the block stores a valid PC. For example, blocks may be initialized with metadata which includes a null PC caller value. If the PC value is null, the deallocator does not perform a check against the unsafe caller list. In an alternative embodiment, all blocks which are allocated may have the caller PC stored (e.g., at block <b>326</b>). In such a case, the deallocator could be configured to compare all block caller IDs against the unsafe caller list. Numerous such alternatives are possible and are contemplated.</p>
<p id="p-0036" num="0035">Implementation and maintenance of the unsafe caller list may take many forms. For example, in one embodiment, a multilevel table, similar to that used for page tables, may be utilized for the unsafe caller list. In such an embodiment, a portion of the bits of the PC may be used for indexing to various levels of the table. For example, the most significant bits of the PC may index to a first level of the table, a second most significant 10 bits of the PC may index to a second level of the table, and so on. Such an embodiment may provide for a constant time indexing which may be desirable in a particular implementation.</p>
<p id="p-0037" num="0036">In addition to the above, various embodiments may be configured to store the unsafe list for a particular application in persistent storage. In such an embodiment, the list may be stored along with an identification of both the corresponding application and the version of the application at that time. When the application is reexecuted, the list is retrieved. If the current version of the application matches that which was stored with the unsafe list, the stored unsafe list may be utilized immediately instead of being reconstructed during execution. On the other hand, if the current version of the application does not match that which was stored with the unsafe list, the stored unsafe list is not used.</p>
<p id="p-0038" num="0037">Turning now to <figref idref="DRAWINGS">FIG. 5</figref>, one embodiment of a computing system which incorporates the above described methods and mechanisms is illustrated. <figref idref="DRAWINGS">FIG. 5</figref> shows one embodiment of a computing cluster, SAN, and LAN in a computer network <b>500</b>. In the example shown, servers <b>506</b>A-<b>506</b>C form a cluster <b>505</b>. Together with data storage devices <b>530</b>A-<b>530</b>C and SAN interconnect <b>540</b>, servers <b>506</b> form a SAN. Servers <b>506</b> have direct access to any of the storage devices <b>530</b> which are connected to the SAN interconnect <b>540</b>. SAN interconnect <b>540</b> is typically a high speed interconnect, such as Fibre Channel. As already noted, the servers and storage devices comprise a network in and of themselves. In the SAN, no server is dedicated to a particular storage device as in a LAN. Any server <b>506</b> may access any storage device <b>530</b> on the storage area network. Representative characteristics of a SAN may include a 200 MB/sec bandwidth, up to 526 nodes per loop, a connection distance of 50 kilometers, and a storage capacity of 9572 gigabytes. Consequently, the performance, flexibility, and scalability of a SAN may be significantly greater than that of a typical SCSI based system.</p>
<p id="p-0039" num="0038">Also included in the network <b>500</b> of <figref idref="DRAWINGS">FIG. 5</figref> are workstations <b>552</b> and LAN interconnect <b>542</b>. As shown in <figref idref="DRAWINGS">FIG. 5</figref>, LAN <b>542</b> is coupled to cluster <b>505</b>. Because each storage device <b>530</b> may be independently and directly accessed by any server <b>506</b>, overall data throughput between the LAN and SAN may be much greater than that of the traditional client-server LAN. For example, if workstations <b>552</b>A and <b>552</b>C both submit access requests to storage <b>530</b>, two of servers <b>506</b> may service these requests concurrently. Alternatively, one of servers <b>506</b> may be configured as a failover server. In the event one of the servers <b>506</b> fails, another may become active in order to prevent service interruption or downtime.</p>
<p id="p-0040" num="0039">In addition to workstations <b>552</b>, <figref idref="DRAWINGS">FIG. 5</figref> also depicts an administrator workstation <b>554</b> which may be used by a system administrator to configure and monitor operation of various hardware and software components in the network <b>500</b>. In one embodiment, as discussed above, workstation <b>554</b> is configured to monitor memory usage of applications executing on each of workstations <b>552</b>, cluster <b>505</b>, and elsewhere within the system <b>500</b>. As already noted, numerous such network configurations are possible and are contemplated.</p>
<p id="p-0041" num="0040">It is noted that the above described embodiments may comprise software. In such an embodiment, the program instructions which implement the methods and/or mechanisms may be conveyed or stored on a computer accessible medium. Numerous types of media which are configured to store program instructions are available and include hard disks, floppy disks, CD-ROM, DVD, flash memory, Programmable ROMs (PROM), random access memory (RAM), and various other forms of volatile or non-volatile storage. Still other forms of media configured to convey program instructions for access by a computing device include terrestrial and non-terrestrial communication links such as network, wireless, and satellite links on which electrical, electromagnetic, optical, or digital signals may be conveyed. Thus, various embodiments may further include receiving, sending or storing instructions and/or data implemented in accordance with the foregoing description upon a computer accessible medium.</p>
<p id="p-0042" num="0041">Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.</p>
<heading id="h-0006" level="1">APPENDIX A</heading>
<p id="p-0043" num="0042">The following listing depicts selected code fragments corresponding to one embodiment of an allocation and deallocation method and mechanism. The listing is not intended to be comprehensive or limiting in any way. Rather, the following listing is only intended to depict one possible embodiment.</p>
<p id="p-0044" num="0043">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Header Format</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>struct GCRobustlnfo {</entry>
</row>
<row>
<entry> union {</entry>
</row>
<row>
<entry>  // When object is free,_next points to the next object in the free list</entry>
</row>
<row>
<entry>  ptr_t _next;</entry>
</row>
<row>
<entry>  // When the object is allocated it stores the user-requested length of</entry>
</row>
<row>
<entry>  the object unsigned long_userLength;</entry>
</row>
<row>
<entry> };</entry>
</row>
<row>
<entry> // Store the flags and the pc together. This may reduce the accuracy of</entry>
</row>
<row>
<entry> the pc, but</entry>
</row>
<row>
<entry> // should be sufficient to identify the corresponding module.</entry>
</row>
<row>
<entry> unsigned long _flags_and_pc;</entry>
</row>
<row>
<entry> // When the object is free, _checksum has the checksum of the object</entry>
</row>
<row>
<entry> unsigned long _checksum;</entry>
</row>
<row>
<entry> char * getPC( );</entry>
</row>
<row>
<entry>};</entry>
</row>
<row>
<entry>enum {</entry>
</row>
<row>
<entry> FlagObjectAllocated = 0x1,</entry>
</row>
<row>
<entry> FlagAlreadyReportedLeak = 0x2,</entry>
</row>
<row>
<entry> FlagAlreadyReportedSmash = 0x4,</entry>
</row>
<row>
<entry> FlagChecksumAvailable = 0x8,</entry>
</row>
<row>
<entry> FlagPrematureFree = 0x10,</entry>
</row>
<row>
<entry> AllFlags = 0x1F</entry>
</row>
<row>
<entry>};</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry>Fragments of Code for Allocation</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>// This is the malloc entry point</entry>
</row>
<row>
<entry>GS_C_API_REPLACEMENT(void *)</entry>
</row>
<row>
<entry>INTERCEPT_NAME(malloc)(size_t lb)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry> gsAllocState state;</entry>
</row>
<row>
<entry> state.pc = GETPC( );</entry>
</row>
<row>
<entry> state.debugHeader = NULL;</entry>
</row>
<row>
<entry> return gcMemFunctions.mallocFunction(lb, &amp;state);</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// mallocFunction( ) will point to an instance of the GC_MALLOC<sub>—</sub></entry>
</row>
<row>
<entry>FUNCTION_NAME macro.</entry>
</row>
<row>
<entry>void *</entry>
</row>
<row>
<entry>GC_MALLOC_FUNCTION_NAME(MALLOC_PARAMETERS)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry> register ptr_t op;</entry>
</row>
<row>
<entry> extern_ptr_t_temp;</entry>
</row>
<row>
<entry> register gsFreelistHead * opp;</entry>
</row>
<row>
<entry> register word lw = 0;</entry>
</row>
<row>
<entry> register unsigned list;</entry>
</row>
<row>
<entry> gcHeap *heap;</entry>
</row>
<row>
<entry> gcDiscriminatedLock *heapLock;</entry>
</row>
<row>
<entry>. . .</entry>
</row>
<row>
<entry> if(lb &lt;= gcMaxSmallObject) {</entry>
</row>
<row>
<entry>  GET_WORDS_AND_LIST;</entry>
</row>
<row>
<entry>  heap = GET_HEAP_T( );</entry>
</row>
<row>
<entry>  if(!heap) {heap = &amp;gcDefaultHeap;}</entry>
</row>
<row>
<entry>  GET_HEAP_LOCK_S(heapLock, heap);</entry>
</row>
<row>
<entry>  opp = heap-&gt;BYTES_TO_OBJ_FREELIST[lb];</entry>
</row>
<row>
<entry>  LOCK_S(*heapLock);</entry>
</row>
<row>
<entry>  POP_LIST_HEAD(op, opp, lw, state);</entry>
</row>
<row>
<entry>  if( op == 0 ∥ CHECK_ALLOCATED(op)) {</entry>
</row>
<row>
<entry>   UNLOCK_S(*heapLock);</entry>
</row>
<row>
<entry>   temp = op;</entry>
</row>
<row>
<entry>// This do/while loop will skip blocks in the free list until we find</entry>
</row>
<row>
<entry>one that was not</entry>
</row>
<row>
<entry>// prematurely freed.</entry>
</row>
<row>
<entry>// CHECK_ALLOCATED(temp) will return TRUE if the block was</entry>
</row>
<row>
<entry>prematurely freed</entry>
</row>
<row>
<entry>   do {</entry>
</row>
<row>
<entry>    if(temp) {</entry>
</row>
<row>
<entry>     REPORT_ALLOCATED(temp);</entry>
</row>
<row>
<entry>    }</entry>
</row>
<row>
<entry>    temp = GEN_MALLOC((word)lb, heap, GC<sub>—</sub></entry>
</row>
<row>
<entry>    OBJECT_TYPE);</entry>
</row>
<row>
<entry>   } while (temp &amp;&amp; CHECK_ALLOCATED(temp));</entry>
</row>
<row>
<entry>   if (temp) {</entry>
</row>
<row>
<entry>    . . .</entry>
</row>
<row>
<entry>    ALLOCATION_SUCCESS_ACTION;</entry>
</row>
<row>
<entry>   } else {</entry>
</row>
<row>
<entry>    ALLOCATION_FAILED_ACTION;</entry>
</row>
<row>
<entry>   }</entry>
</row>
<row>
<entry>   return temp;</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry>. . .</entry>
</row>
<row>
<entry>// The macro CHECK_ALLOCATED( ) is a macro that calls</entry>
</row>
<row>
<entry>gsCheckAllocatedRobust ( ).</entry>
</row>
<row>
<entry>// The function gsCheckAllocatedRobust returns TRUE if the object</entry>
</row>
<row>
<entry>was prematurely freed.</entry>
</row>
<row>
<entry>#define CHECK_ALLOCATED_robust(op)</entry>
</row>
<row>
<entry>(gsInternalGetBooleanFeature(gsUseAfterFreeDetection) &amp;&amp;</entry>
</row>
<row>
<entry>gsCheckAllocatedRobust((ptr_t) op, lw, state))</entry>
</row>
<row>
<entry>// gsComputeCheckSum( ) is the function that computes the checksum.</entry>
</row>
<row>
<entry>inline unsigned long</entry>
</row>
<row>
<entry>gsComputeCheckSum( ptr_t p, GCRobustInfo *debugInfo, word lw)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry> // utilize suitable algorithm to generate a checksum/signature</entry>
</row>
<row>
<entry>. . .</entry>
</row>
<row>
<entry> return checksum;</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// gsCheckAllocatedRobust( )is the function called by the macro</entry>
</row>
<row>
<entry>// CHECK_ALLOCATED_robust( ).</entry>
</row>
<row>
<entry>word</entry>
</row>
<row>
<entry>gsCheckAllocatedRobust( ptr_t p, word lw, gsAllocState * state)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry> // Try first with previously saved value</entry>
</row>
<row>
<entry> GCRobustInfo * debugInfo = (GCRobustInfo *) state-&gt;debugHeader;</entry>
</row>
<row>
<entry> if( debugInfo == NULL ) {</entry>
</row>
<row>
<entry>  debugInfo = gsGetDebugInfo( p );</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> if( debugInfo == NULL ) {</entry>
</row>
<row>
<entry>  // Object is not heap object or object is not currently allocated</entry>
</row>
<row>
<entry>  return 0;</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> if ( gsInternalGetBooleanFeature(gsUseAfterFreeDetection)) {</entry>
</row>
<row>
<entry>  if ( gcRobustCheckChecksum( p, debugInfo, lw )) {</entry>
</row>
<row>
<entry>   return 1;</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> return 0;</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// gcRobustCheckChecksum compares the checksum stored in the header</entry>
</row>
<row>
<entry>with the</entry>
</row>
<row>
<entry>// computed checksum.</entry>
</row>
<row>
<entry>inline gcBool</entry>
</row>
<row>
<entry>gcRobustCheckChecksum(ptr_t p, GCRobustInfo * debugInfo, word lw )</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry> if ( debugInfo-&gt;_flags_and_pc &amp; FlagChecksumAvailable) {</entry>
</row>
<row>
<entry>  // For large objects, the lw parameter is zero. Find the</entry>
</row>
<row>
<entry>  // size directly from the hhdr.</entry>
</row>
<row>
<entry>  if(!lw) {</entry>
</row>
<row>
<entry>   hdr* hhdr = gcFindHeader(p);</entry>
</row>
<row>
<entry>   if (hhdr)</entry>
</row>
<row>
<entry>    lw = hhdr-&gt;hb_objsz;</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry>  // Check the checksum</entry>
</row>
<row>
<entry>  unsigned long checksum = gsComputeCheckSum( p, debugInfo, lw);</entry>
</row>
<row>
<entry>  if ( debugInfo-&gt;_checksum != checksum ) {</entry>
</row>
<row>
<entry>   // Object has been used since it was freed.</entry>
</row>
<row>
<entry>   // Mark object as allocated again.</entry>
</row>
<row>
<entry>   // Do not report smashing on this object</entry>
</row>
<row>
<entry>   debugInfo-&gt;_flags_and_pc |= (FlagObjectAllocated |</entry>
</row>
<row>
<entry>FlagAlreadyReportedSmash);</entry>
</row>
<row>
<entry>   return 1;</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> return 0;</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry>Free call</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>// This is the entry point for free( )</entry>
</row>
<row>
<entry>GS_C_API_REPLACEMENT(void)</entry>
</row>
<row>
<entry>INTERCEPT_NAME(free)(void *p)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry> gsAllocState state;</entry>
</row>
<row>
<entry> state.pc = GETPC( );</entry>
</row>
<row>
<entry> state.debugHeader = NULL;</entry>
</row>
<row>
<entry> gcMemFunctions.freeFunction(p, &amp;state);</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// freeFunction( ) calls an instance of the following macro</entry>
</row>
<row>
<entry>GC_FREE_FUNCTION_NAME( )</entry>
</row>
<row>
<entry>void HB_FREE_ATTR</entry>
</row>
<row>
<entry>GC_FREE_FUNCTION_NAME(void *p, hdr *hhdr, gsAllocState</entry>
</row>
<row>
<entry>* state)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry>  . . .</entry>
</row>
<row>
<entry>  if (MAY_FREE((ptr_t) p, lw, state)) {</entry>
</row>
<row>
<entry>   if(!FREEING_IS_DISABLED) {</entry>
</row>
<row>
<entry>    flh = hhdr-&gt;hb_objfreelist;</entry>
</row>
<row>
<entry>    DEFER_FREE(p, lw, state, flh, heap, heapLock);</entry>
</row>
<row>
<entry>    PROCESS_FREE(p, lw, state, flh, heap, heapLock);</entry>
</row>
<row>
<entry>   }</entry>
</row>
<row>
<entry>    // Here we compute the checksum of the free object</entry>
</row>
<row>
<entry>   AFTER_FREE(p, lw, state);</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// macro AFTER_FREE_robust is called in robust mode to compute</entry>
</row>
<row>
<entry>the checksum of the object after it has been freed and stores the</entry>
</row>
<row>
<entry>checksum value in the header.</entry>
</row>
<row>
<entry># define AFTER_FREE_robust(p, lw, state) gcRobustAfterFree((ptr_t)</entry>
</row>
<row>
<entry>p, lw, state)</entry>
</row>
<row>
<entry>void</entry>
</row>
<row>
<entry>gcRobustAfterFree( ptr_t p, word lw, gsAllocState * state)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry> GCRobustInfo * debugInfo = (GCRobustInfo *) state-&gt;debugHeader;</entry>
</row>
<row>
<entry> if ( debugInfo == NULL) { debugInfo = (GCRobustInfo *)</entry>
</row>
<row>
<entry> gsGetDebugInfo( p ); }</entry>
</row>
<row>
<entry> if ( debugInfo == NULL) { return; }</entry>
</row>
<row>
<entry> // Store pc and clear flags</entry>
</row>
<row>
<entry> debugInfo-&gt;_flags_and_pc = ((unsigned long) state-&gt;pc &amp;</entry>
</row>
<row>
<entry> ~AllFlags);</entry>
</row>
<row>
<entry> if ( gsIntemalGetBooleanFeature(gsUseAfterFreeDetection)) {</entry>
</row>
<row>
<entry>  // Compute checksum and make it available</entry>
</row>
<row>
<entry>  debugInfo-&gt;_checksum = gsComputeCheckSum( p, debugInfo, lw);</entry>
</row>
<row>
<entry>  debugInfo-&gt;_flags_and_pc |= FlagChecksumAvailable;</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for managing memory, said method comprising:
<claim-text>detecting a request to free a first block of memory;</claim-text>
<claim-text>freeing said first block of memory, in response to detecting said request and determining said first block of memory does not correspond to a prematurely freed block of memory; and</claim-text>
<claim-text>not freeing said first block of memory, in response to detecting said request and determining said first block of memory corresponds to a prematurely freed block of memory;</claim-text>
<claim-text>in response to identifying the first block corresponds to a prematurely freed block of memory:
<claim-text>storing an indication that the candidate block corresponds to a prematurely freed block of memory;</claim-text>
<claim-text>skipping said first block for purposes of allocation; and</claim-text>
<claim-text>searching for a new block for allocation.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein in response to determining said block of memory does not correspond to a prematurely freed block of memory, the method further comprises:
<claim-text>calculating a checksum corresponding to said block; and</claim-text>
<claim-text>storing said checksum in association with said block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>detecting a request for an allocation of a block of memory;</claim-text>
<claim-text>identifying a candidate block of memory for allocation;</claim-text>
<claim-text>calculating a checksum of said candidate block and comparing the calculated checksum to a previously stored checksum which is associated with the candidate block;</claim-text>
<claim-text>allocating the candidate block, in response to detecting the calculated checksum matches the previously stored checksum; and</claim-text>
<claim-text>identifying the candidate block as corresponding to a prematurely freed block of memory, in response to detecting the calculated checksum does not match the stored checksum.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising maintaining a list which identifies requesters of memory allocation which are deemed unsafe.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method as recited in <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the list identifies the requesters by a program counter corresponding the requester instruction in the program code.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method as recited in <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein freeing said first block of memory is in further response to determining the first block of memory does not correspond to a requestor which is included in the list.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method as recited in <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein in response to detecting the request for an allocation of a block of memory and identifying the candidate block as corresponding to a prematurely freed block of memory, the method further comprises storing an identification of the requester in association with the candidate block and adding the identification to the list.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A computing system comprising:
<claim-text>a memory configured to store data; and</claim-text>
<claim-text>a processing device configured to:
<claim-text>detect a request to free a first block of memory;</claim-text>
<claim-text>determine whether said first block of memory corresponds to a prematurely freed block of memory;</claim-text>
<claim-text>free said first block of memory, in response to detecting said request and determining said first block of memory does not correspond to a prematurely freed block of memory; and</claim-text>
<claim-text>not free said first block of memory, in response to detecting said request and determining said first block of memory corresponds to a prematurely freed block of memory;</claim-text>
<claim-text>in response to identifying the first block corresponds to a prematurely freed block of memory:
<claim-text>store an indication that the first block corresponds to a prematurely freed block of memory;</claim-text>
<claim-text>skip said first block for purposes of allocation; and</claim-text>
<claim-text>search for a new block for allocation.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computing system as recited in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein in response to determining said block of memory does not correspond to a prematurely freed block of memory, the processing device is further configured to:
<claim-text>calculate a checksum corresponding to said block; and</claim-text>
<claim-text>store said checksum in association with said block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computing system as recited in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the processing device is further configured to:
<claim-text>detect a request for an allocation of a block of memory;</claim-text>
<claim-text>identify a candidate block of memory for allocation;</claim-text>
<claim-text>calculate a checksum of said candidate block and comparing the calculated checksum to a previously stored checksum which is associated with the candidate block;</claim-text>
<claim-text>allocate the candidate block, in response to detecting the calculated checksum matches the previously stored checksum; and</claim-text>
<claim-text>identify the candidate block as corresponding to a prematurely freed block of memory, in response to detecting the calculated checksum does not match the stored checksum.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computing system as recited in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing device is further configured to maintain a list which identifies requestors of memory allocation which are deemed unsafe.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computing system as recited in <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the list identifies the requesters by a program counter corresponding the requestor instruction in the program code.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computing system as recited in <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein freeing said first block of memory is in further response to determining the first block of memory does not correspond to a requester which is included in the list.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computing system as recited in <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein in response to detecting the request for an allocation of a block of memory and identifying the candidate block as corresponding to a prematurely freed block of memory, the processing device is further configured to store an identification of the requester in association with the candidate block and add the identification to the list.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A computer storage medium comprising program instructions for use in monitoring memory usage in an application, wherein the program instructions are computer-executable to:
<claim-text>detect a request to free a first block of memory;</claim-text>
<claim-text>free said first block of memory, in response to detecting said request and determining said first block of memory does not correspond to a prematurely freed block of memory; and</claim-text>
<claim-text>not free said first block of memory, in response to detecting said request and determining said first block of memory corresponds to a prematurely freed block of memory;</claim-text>
<claim-text>in response to identifying the candidate block corresponds to a prematurely freed block of memory, the program instructions are further executable to:
<claim-text>store an indication that the candidate block corresponds to a prematurely freed block of memory;</claim-text>
<claim-text>skip said candidate block for purposes of allocation; and</claim-text>
<claim-text>search for a new candidate block for allocation.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer storage medium as recited in <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein in response to determining said block of memory does not correspond to a prematurely freed block of memory, the program instructions are further executable to:
<claim-text>calculate a checksum corresponding to said block; and</claim-text>
<claim-text>store said checksum in association with said block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer storage medium as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the program instructions are further executable to:
<claim-text>detect a request for an allocation of a block of memory;</claim-text>
<claim-text>identify a candidate block of memory for allocation;</claim-text>
<claim-text>calculate a checksum of said candidate block and comparing the calculated checksum to a previously stored checksum which is associated with the candidate block;</claim-text>
<claim-text>allocate the candidate block, in response to detecting the calculated checksum matches the previously stored checksum; and</claim-text>
<claim-text>identify the candidate block as corresponding to a prematurely freed block of memory, in response to detecting the calculated checksum does not match the stored checksum.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer storage medium as recited in <claim-ref idref="CLM-00015">claim 15</claim-ref>, the program instructions are further executable to maintain a list which identifies requesters of memory allocation which are deemed unsafe.</claim-text>
</claim>
</claims>
</us-patent-grant>
