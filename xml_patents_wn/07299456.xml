<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299456-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299456</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10666033</doc-number>
<date>20030918</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>811</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717129</main-classification>
<further-classification>717124</further-classification>
<further-classification>717127</further-classification>
</classification-national>
<invention-title id="d0e53">Run into function</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5050168</doc-number>
<kind>A</kind>
<name>Paterson</name>
<date>19910900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 35</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5093914</doc-number>
<kind>A</kind>
<name>Coplien et al.</name>
<date>19920300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717129</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5560009</doc-number>
<kind>A</kind>
<name>Lenkov et al.</name>
<date>19960900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717124</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5845125</doc-number>
<kind>A</kind>
<name>Nishimura et al.</name>
<date>19981200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717129</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6077312</doc-number>
<kind>A</kind>
<name>Bates et al.</name>
<date>20000600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6158045</doc-number>
<kind>A</kind>
<name>You</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717124</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6240545</doc-number>
<kind>B1</kind>
<name>Carmichael et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717128</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7047521</doc-number>
<kind>B2</kind>
<name>Bunnell</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717130</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2003/0106046</doc-number>
<kind>A1</kind>
<name>Arnold et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717129</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00010">
<othercit>U.S. Appl. No. 10/113,317, “Extended “Run To” Function”, Cary L. Bates et al., filed May 29, 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>21</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>717124</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717127</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717129</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 47</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>9</number-of-drawing-sheets>
<number-of-figures>10</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050066313</doc-number>
<kind>A1</kind>
<date>20050324</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Bates</last-name>
<first-name>Cary L.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Berestetsky</last-name>
<first-name>Vadim</first-name>
<address>
<city>North York</city>
<country>CA</country>
</address>
</addressbook>
<nationality>
<country>CA</country>
</nationality>
<residence>
<country>CA</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Buenger</last-name>
<first-name>Paul</first-name>
<address>
<city>Eau Claire</city>
<state>WI</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Halverson</last-name>
<first-name>Steven G.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Patterson &amp; Sheridan, LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>An</last-name>
<first-name>Meng-Al T.</first-name>
<department>2193</department>
</primary-examiner>
<assistant-examiner>
<last-name>Mitchell</last-name>
<first-name>Jason</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Method, apparatus and article of manufactured for debugging code. A user selects a function call (e.g., a method of object-oriented code) and a debugger parses the function call and sets breakpoints on the entry points of all instances of the method (assuming more than one). During execution, when one of the breakpoints is hit, the debugger determines whether the corresponding method is being called from the user-specified location in the code.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="131.49mm" wi="125.31mm" file="US07299456-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="247.23mm" wi="157.99mm" orientation="landscape" file="US07299456-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="229.87mm" wi="146.73mm" orientation="landscape" file="US07299456-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="248.07mm" wi="162.31mm" orientation="landscape" file="US07299456-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="171.11mm" wi="117.69mm" orientation="landscape" file="US07299456-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="154.35mm" wi="126.75mm" file="US07299456-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="144.70mm" wi="146.05mm" file="US07299456-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="202.35mm" wi="127.08mm" file="US07299456-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="225.38mm" wi="116.08mm" file="US07299456-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="78.57mm" wi="118.53mm" file="US07299456-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention generally relates to data processing and more particularly to debugging code.</p>
<p id="p-0004" num="0003">2. Description of the Related Art</p>
<p id="p-0005" num="0004">A programmer develops a software program by producing and entering source code into files using a text editor program. The computer then creates an executable program by translating the source code into machine code. The machine code is the rudimentary instructions understood by a computer. Illustratively, the foregoing software development process is accomplished by running a series of programs. These programs typically include a compiler for translating the source code into machine code and a linker to link the machine code together to form a program.</p>
<p id="p-0006" num="0005">When developing computer software, it is necessary to perform a function termed “debugging”. Simply stated, debugging is performed by a computer programmer to locate and identify errors in a program under development. Typically, a programmer uses another computer program commonly known as a “debugger” to debug a program under development. An effective debugger program is necessary for rapid and efficient development of software and typically provides functions including run-to-cursor, step into, step over, step outof, breakpoints and the like.</p>
<p id="p-0007" num="0006">One primary operation supported by conventional debuggers is a “step” function, which permits a computer programmer to process instructions (also known as “statements”) in a computer program one-by-one, and see the results upon completion of each instruction. While the step operation provides a programmer with a large amount of information about a program during its execution, stepping through hundreds or thousands of program instructions can be extremely tedious and time consuming, and may require a programmer to step through many program instructions that are known to be error-free before a set of instructions to be analyzed are executed.</p>
<p id="p-0008" num="0007">A second operation supported by conventional debuggers is a breakpoint operation, which permits a computer programmer to identify with a “breakpoint” a precise instruction for which it is desired to halt execution of a computer program during execution. As a result, when a computer program is executed by a debugger, the program executes in a normal fashion until a breakpoint is reached, and then stops execution and displays the results of the computer program to the programmer for analysis. Most breakpoints supported by conventional debuggers are unconditional, meaning that once such a breakpoint is reached, execution of the program is always halted. Some debuggers also support the use of conditional breakpoints, which only halt execution of a program when a variable used by the program is set to a predetermined value at the time such a breakpoint is reached.</p>
<p id="p-0009" num="0008">Another conventional debugging operation, the run-to-cursor function, allows a user to place a cursor on a selected statement and then execute the program from a current stopped position to the cursor. When execution reaches the line at which the cursor is located, the debugger gains control. In this way, the user may observe the effects of running the portion of code from the current stopped position to the cursor position. If unexpected results are identified, the user has successfully located the source of a problem and may then take remedial steps to correct the problem.</p>
<p id="p-0010" num="0009">Typically, step operations, breakpoints, and run-to functions are used together to simplify the debugging process. For example, a common debugging operation is to set a breakpoint at the beginning of a desired set of instructions to be analyzed, and then begin executing the program. Once the breakpoint is reached, the program is halted, and the programmer then steps through the desired set of instructions line-by-line using the step operation, or runs to a selected line number. Consequently, a programmer is able to quickly isolate and analyze a particular set of instructions without having to step through irrelevant portions of a computer program.</p>
<p id="p-0011" num="0010">While the foregoing conventional debugging tools are helpful, they are also substantially limited in certain situations. In particular, object-oriented programming and other highly modular languages present some unique debugging problems not easily handled by conventional techniques.</p>
<p id="p-0012" num="0011">With an object-oriented programming language, for example, a program is constructed from a number of “objects”, each of which includes data and/or one or more sets of instructions (often referred to as “routines” or “methods”) that define specific operations that can be performed on the data. A large number of objects may be used to build a computer program, with each object interacting with other objects in the computer program to perform desired operations.</p>
<p id="p-0013" num="0012">One characteristic of an object-oriented programming language that can make debugging problematic is that object classes can have many subclasses. As a result, it can be tedious to set breakpoints where you need them. Consider the code shown in TABLE I.</p>
<p id="p-0014" num="0013">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="168pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE I</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>25</entry>
<entry/>
<entry>while(i &lt; 40){</entry>
</row>
<row>
<entry>26</entry>
<entry/>
<entry> .</entry>
</row>
<row>
<entry>27</entry>
<entry/>
<entry> .</entry>
</row>
<row>
<entry>28</entry>
<entry/>
<entry> widget = this.getWidget(tool.foo1( ). widget.foo2( )).:</entry>
</row>
<row>
<entry>29</entry>
<entry/>
<entry> widget.run( ):</entry>
</row>
<row>
<entry>30</entry>
</row>
<row>
<entry>31</entry>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Assume that the programmer has stopped somewhere in the code prior to line <b>28</b> and wants to “step into” the method “widget.foo2()” called at this point, i.e., from the “main” function. Using conventional debugging techniques the programmer must first get to line <b>28</b> and then use the “step into” function. The problem with this approach is that it will cause the programmer to step into “tool.foo1()” before getting to the desired method. As an alternative, the user may set the cursor on the statement containing the method “widget.foo2()” and then employ the “run-to-cursor” function to arrive at the statement. Upon arriving at the statement, the user must employ the “step into” function. Accordingly, this approach is labor intensive in that it requires the user to perform multiple steps. As yet another alternative, the programmer must manually identify the portion of the source code containing the method, identify the method within the code, set a breakpoint on each entry point to that method, and then after encountering the desired breakpoint manually remove all the remaining breakpoints. Such an approach is burdensome and error prone.
</p>
<p id="p-0015" num="0014">Another problem that is especially pronounced in highly modular languages (such as object-oriented programming) results from the fact that some instructions in a computer program are executed fairly often for different purposes, and may result in many needless stoppages before a desired stoppage is encountered. More specifically, since some methods are called by many different objects, placing a conventional breakpoint on a method may result in hundreds of unwanted stoppages prior to occurrence of a desired stoppage. This may be illustrated with the following code: foo(obj1.bar(),obj2.bar()); where obj1 and obj2 are both objects of the same class. Assume the programmer desires to run into obj2.bar(). If the programmer simply examines the class hierarchy and places a breakpoint on each instance of obj2.bar(), the program will be halted even when obj1.bar() is encountered.</p>
<p id="p-0016" num="0015">Therefore, there is a need for improvements in debugging computer programs to simplify and facilitating the debugging process, particularly in object-oriented environments.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0017" num="0016">The present invention generally relates to methods, apparatus and articles of manufacture for implementing a run into function for a selected code portion.</p>
<p id="p-0018" num="0017">One embodiment provides for a computer-implemented method for debugging code comprising, while execution is halted at a first point in the code, receiving a selection of a target call site located at a second point in the code and comprising a call to a routine; and setting at least one run into breakpoint configured to halt subsequent execution only when an execution path arrives at the routine from the target call site. In one embodiment, setting the at least one run into breakpoint comprises setting the run into breakpoint on an instruction calling the routine. In this case, the function is stepped into upon encountering the breakpoint. In another embodiment, setting the at least one run into breakpoint comprises setting the run into breakpoint at each entry point to the routine. In this case, execution may be halted and a user interface returned upon encountering the breakpoint, only if it can be determined that the routine is entered from the selected target call site.</p>
<p id="p-0019" num="0018">Another embodiment provides for a computer-implemented method for debugging code comprising receiving a selection of a target call site in the code, the target call site comprising a call to a routine; establishing a breakpoint at an entry point to the selected target call site; programmatically determining call context information identifying a location of the selected target call site in the code; upon encountering the breakpoint during execution of the code, determining whether the routine is called from the selected target call site based on the stored call context information; and if so, halting execution of the code.</p>
<p id="p-0020" num="0019">Another embodiment of a computer-implemented method for debugging code comprises receiving a selection of a target call site in the code, the target call site comprising a routine having a plurality of entry points; establishing a breakpoint at each of the plurality of entry points; and programmatically determining call context information uniquely identifying the selected target call site. For each of the breakpoints encountered during execution of the code, the method further comprises determining whether the routine is called from the selected target call site based on the call context information; and if so, halting execution of the code.</p>
<p id="p-0021" num="0020">Yet another embodiment of a computer-implemented method for debugging object-oriented code comprises receiving a selection of a target call site in the code, the target call site comprising a method; identifying a plurality of entry points for the method; establishing a breakpoint at each of the plurality of entry points; determining call context information uniquely identifying the selected target call site. For each of the breakpoints encountered during execution of the code, the method further comprises determining whether the routine is called from the selected target call site based on the call context information; and if so, halting execution of the code.</p>
<p id="p-0022" num="0021">Yet another embodiment provides a computer comprising a memory; code under debug resident in the memory, the code comprising as least one target call site selected by a user and comprising a call to a routine; a breakpoint data structure resident in the memory and configured for storing at least context information indicating a location of the call within the code; and a debugger program resident in the memory. The debugger program is configured to interrupt execution of the code under debug in response to encountering a breakpoint and determining that the routine is called from the target call site as determined with reference to the context information.</p>
<p id="p-0023" num="0022">Still other embodiments include computer-readable mediums containing instructions which, when executed, perform the above methods.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0024" num="0023">So that the manner in which the above recited features, advantages and objects of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments thereof which are illustrated in the appended drawings.</p>
<p id="p-0025" num="0024">It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 1</figref> is a high-level diagram of a computer, according to one embodiment of the present invention.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating the operation of a debugger, according to one embodiment of the present invention.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 3</figref> is one embodiment of a user interface screen illustrating a user-implemented run into function for a selected method, according to one embodiment of the present invention.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 4</figref> is a breakpoint table, according to one embodiment of the present invention.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIGS. 5A-B</figref> show a flow chart illustrating the operation of a debugger program during a run into operation, according to one embodiment of the present invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 6</figref> shows a flow chart illustrating one embodiment of setting context sensitive breakpoints.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 7</figref> shows a flow chart illustrating one embodiment of setting instruction specific breakpoints.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 8</figref> shows a flow chart illustrating one embodiment of handling context sensitive breakpoints.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 9</figref> shows a flow chart illustrating one embodiment of handling instruction specific breakpoints.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0035" num="0034">The present invention provides methods, apparatus and articles of manufacture for implementing a “run into” function for a selected function of some code under debug. In particular, the user selects a function with respect to a particular target call site (i.e., the location from which the function of interest is called). The function is generally selected by a user through a user-interface screen. In one embodiment, by invoking the run into function, the debugger places a temporary breakpoint(s) at the entry point(s) to the selected function. When one of these breakpoints is encountered during execution, the debugger determines whether the function was called from the specified place in the code (i.e., the target call site) and, if so, fires the breakpoint, halting execution, and removing all related temporary breakpoints. Because the breakpoint(s) only causes execution to halt if the function is called from a particular place in the code, the breakpoint may be referred to as a “context sensitive breakpoint” or “conditional breakpoint”. In another embodiment, a single breakpoint is set at the exact location of the call instruction for the selected function. Upon encountering the breakpoint, the debugger halts execution and then performs a step into operation to step into the function. In the latter embodiment, the breakpoints are referred to herein as “instruction specific breakpoints”. In each of the embodiments, the inventive breakpoint being set is generically referred to as a “run into breakpoint”.</p>
<p id="p-0036" num="0035">One embodiment of the invention is implemented as a program product for use with a computer system such as, for example, the computer <b>110</b> shown in <figref idref="DRAWINGS">FIG. 1</figref> and described below. The program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of signal-bearing media. Illustrative signal-bearing media include, but are not limited to: (i) information permanently stored on non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive); (ii) alterable information stored on writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive); and (iii) information conveyed to a computer by a communications medium, such as through a computer or telephone network, including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal-bearing media, when carrying computer-readable instructions that direct the functions of the present invention, represent embodiments of the present invention.</p>
<p id="p-0037" num="0036">In general, the routines executed to implement the embodiments of the invention, may be part of an operating system or a specific application, component, program, module, object, or sequence of instructions. The computer program of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions. Also, programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition, various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However, it should be appreciated that any particular program nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and/or implied by such nomenclature.</p>
<p id="p-0038" num="0037">In one aspect, the invention is particularly advantageous in the context of highly modular languages such as object-oriented programming languages including Java and C++. Accordingly, reference is made throughout the present application to well-known object-oriented programming constructs such as classes, objects and methods. Again, the use of particular terminology is merely for convenience or illustration, and not limiting of the invention. In some cases, different terms are used for the same or similar aspects of the invention. For example, in the claims appended below, the term “routine” or “function” may be used as a generic substitute for the term “method” to avoid any suggestion of that the invention is limited to particular object-oriented programming languages.</p>
<p id="p-0039" num="0038">Referring now to <figref idref="DRAWINGS">FIG. 1</figref>, a computing environment <b>100</b> is shown. In general, the distributed environment <b>100</b> includes a computer system <b>110</b> and a plurality of networked devices <b>146</b>. For simplicity, only the details of the computer system <b>110</b> are shown. However, it is understood that the computer system <b>110</b> may be representative of one or more of the networked devices <b>146</b>. In general, computer system <b>110</b> and the networked devices <b>146</b> could be any type of computer, computer system or other programmable electronic device, including desktop or PC-based computers, workstations, network terminals, a client computer, a server computer, a portable computer, an embedded controller, etc.</p>
<p id="p-0040" num="0039">Although shown networked into a larger system, the computer system <b>110</b> may be a standalone device. Moreover, those skilled in the art will appreciate that embodiments may be practiced with other computer system configurations including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers and the like. The embodiment may also be practiced in distributed computing environments in which tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices. In this regard, the computer system <b>110</b> and one or more of the networked devices <b>146</b> may be thin clients which perform little or no processing. In a particular embodiment, the computer system <b>110</b> is an eServer® iSeries® 400 computer available from International Business Machines, Corporation of Armonk, N.Y.</p>
<p id="p-0041" num="0040">The computer system <b>110</b> could include a number of operators and peripheral systems as shown, for example, by a mass storage interface <b>137</b> operably connected to a direct access storage device <b>138</b>, by a terminal interface <b>140</b> operably connected to a terminal <b>142</b>, and by a network interface <b>144</b> operably connected to the plurality of networked devices <b>146</b>. The terminal <b>142</b> may be any video output device for outputting viewable information.</p>
<p id="p-0042" num="0041">Computer system <b>110</b> is shown comprising at least one processor <b>112</b>, which obtains instructions, or operation codes, (also known as opcodes), and data via a bus <b>114</b> from a main memory <b>116</b>. The processor <b>112</b> could be any processor adapted to support the debugging methods, apparatus and article of manufacture of the invention. In particular, the computer processor <b>112</b> is selected to support the debugging features of the present invention. Illustratively, the processor is a PowerPC® processor available from International Business Machines Corporation of Armonk, N.Y.</p>
<p id="p-0043" num="0042">The main memory <b>116</b> is any memory sufficiently large to hold the necessary programs and data structures. Main memory <b>116</b> could be one or a combination of memory devices, including Random Access Memory, nonvolatile or backup memory, (e.g., programmable or Flash memories, read-only memories, etc.). In addition, memory <b>116</b> may be considered to include memory physically located elsewhere in a computer system <b>110</b>, for example, any storage capacity used as virtual memory or stored on a mass storage device or on another computer coupled to the computer system <b>110</b> via bus <b>114</b>.</p>
<p id="p-0044" num="0043">As shown, the main memory <b>116</b> generally includes an operating system <b>118</b>, a computer program <b>119</b>, a call stack <b>120</b>, a compiler <b>121</b>, and a debugger program (the debugger) <b>123</b>. The operating system may be any suitable operating system such as the OS/400® operating system. The computer program <b>119</b> represents any code that is to be examined, edited, compiled and/or debugged. The call stack <b>120</b> is associated with the computer program <b>119</b> and utilized by the operating system <b>118</b> during the execution of the program <b>119</b>. The call stack <b>120</b> is a data structure that maintains information regarding the sequence of routines that are called during the execution of the computer program. Routines, which are often referred to as methods, procedures, and functions, are typically sequences of instructions or statements in a computer program that may be invoked to perform predetermined operations on a computer.</p>
<p id="p-0045" num="0044">In one embodiment, the debugger <b>123</b> is a graphical user interface system debugger for the eServer iSeries computer. The OS/400 operating system and the eServer iSeries computer are available from International Business Machines, Corporation of Armonk, N.Y. Although the software constructs, such as the computer program <b>119</b> and the debugger <b>123</b>, are shown residing on the same computer, a distributed environment is also contemplated. Thus, for example, the debugger <b>123</b> may be located on a networked device <b>146</b>, while the computer program <b>119</b> to be debugged is on the computer system <b>110</b>.</p>
<p id="p-0046" num="0045">In a specific embodiment, the debugger <b>123</b> comprises a debug user interface <b>124</b>, expression evaluator <b>126</b>, Dcode interpreter <b>128</b> (also referred to herein as the debug interpreter <b>128</b>), debugger hook (also known as a stop handler) <b>134</b>, a breakpoint manager <b>135</b>, a results buffer <b>136</b> and a breakpoint table <b>150</b>. Although treated herein as integral parts of the debugger <b>123</b>, one or more of the foregoing components may exist separately in the computer system <b>110</b>. Further, the debugger may include additional components not shown.</p>
<p id="p-0047" num="0046">An illustrative debugging process is now described with reference to <figref idref="DRAWINGS">FIG. 2</figref>. A debugging process is initiated by the debug user interface <b>124</b>. The user interface <b>124</b> presents the program under debugging and highlights the current line of the program on which a stop or error occurs. The user interface <b>124</b> allows the user to set control points (e.g., breakpoints and watches), display and change variable values, and activate other inventive features described herein by inputting the appropriate commands. In the embodiments of the invention, the debug user interface <b>124</b> also allows a user to select a method and implement a run into function with respect to the selected method. An Illustrative embodiment of the user interface <b>124</b> for setting a run into function is described with reference to <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0048" num="0047">The expression evaluator <b>126</b> parses the debugger command passed from the user interface <b>124</b> and uses a data structure (e.g., a table) generated by the compiler <b>121</b> to map the line number in the debugger command to the physical memory address in memory <b>116</b>. In addition, the expression evaluator <b>126</b> generates a Dcode program for the command. The Dcode program is machine executable language that emulates the commands. Some embodiments of the invention include Dcodes which, when executed, activate control features described in more detail below.</p>
<p id="p-0049" num="0048">The Dcode generated by the expression evaluator <b>126</b> is executed by the Dcode interpreter <b>128</b>. Additionally, the Dcode interpreter <b>128</b> passes a replacement op code (i.e., bad operation code) for breakpoints to the program <b>119</b> to trigger processing of the breakpoint when the replacement op code is reached during execution of program <b>119</b>. As is well known in the art, a breakpoint may be detected during execution of a program by placing a known invalid instruction in the program at a desired point so that an error results when the program reaches that instruction and causes an interrupt that is then processed by the debugger. Results from Dcode interpreter <b>128</b> are returned to the user interface <b>124</b> through the expression evaluator <b>126</b>. In addition, the Dcode interpreter <b>128</b> passes on information to the debug hook <b>134</b>, which takes steps described below.</p>
<p id="p-0050" num="0049">After the commands are entered, the user provides an input that resumes execution of the program <b>119</b>. During execution, control is returned to the debugger <b>123</b> via the debug hook <b>134</b>. The debug hook <b>134</b> is a code segment that returns control to the appropriate user interface. In some implementations, execution of the program eventually results in an event causing a trap to fire (e.g., a breakpoint or watchpoint is encountered). Inserting and managing special op codes that cause these traps to fire is the responsibility of the breakpoint manager <b>135</b>. When a trap fires, control is then returned to the debugger by the debug hook <b>134</b> and program execution is halted. The debug hook <b>134</b> then invokes the debug user interface <b>124</b> and may pass the results to the user interface <b>124</b>. Alternatively, the results may be passed to the results buffer <b>136</b> to cache data for the user interface <b>124</b>.</p>
<p id="p-0051" num="0050">The call stack <b>120</b> may be utilized during the execution of the program <b>119</b>. A call stack is a last in-first out (LIFO) data structure. In response to a routine call from a first routine to a second routine, an operating system will generally “push” onto the top of the call stack an entry that identifies both the first routine, as well as the specific instruction or statement in that routine from which the routine call was made (or alternatively, the instruction or statement in that routine to which control should be returned upon completion of the second routine). The second routine is then executed, and if that routine calls an additional routine, an entry relating to that routine call is also added to the stack. As routines terminate in execution, entries from the call stack are then “popped” from the top of the stack and the information therein analyzed to determine the routine and instruction therein where control should be returned.</p>
<p id="p-0052" num="0051">Referring now to <figref idref="DRAWINGS">FIG. 3</figref>, one embodiment of the user interface <b>124</b> for setting run into functions is shown. In general, a run into function may be implemented for any method in the code. Illustratively, a user interface screen <b>300</b> of the user interface <b>124</b> is shown in which a user has selected a method <b>304</b> shown in a source code panel <b>302</b>. A menu <b>308</b> is then invoked from which a “Run Into” menu item <b>306</b> is selected to implement a run into function. The menu <b>308</b> may be accessed in any variety of ways, including right-clicking a mouse after the method <b>304</b> has been selected.</p>
<p id="p-0053" num="0052">In the present example the user has selected the method “foo2()” for the object “widget”. This may be done, for example, highlighting the method or placing the cursor on the method (e.g., in the middle of “foo2()” or “widget.foo2()”) and letting the debugger parse the method name. In any case, the intention of the user is to halt execution of the program only when the particular selected method “foo2()” is encountered. That is, execution is halted only when “foo2()” is called from the selected call site, i.e., from line 28 of the “main” routine. One embodiment of the present invention facilitates this objective by examining the context of the breakpoint and halting execution only when specified context criteria is met, as will be described in more detail below. Another embodiment facilitates this objective by executing to the call site of the method, stepping into it and then returning control to a user via a user interface.</p>
<p id="p-0054" num="0053">In one embodiment, the inventive run into function is implemented by setting breakpoints whose location is recorded in the breakpoint table <b>150</b> (<figref idref="DRAWINGS">FIG. 1</figref>). One embodiment of the breakpoint table <b>150</b> is shown in <figref idref="DRAWINGS">FIG. 4</figref>. In general, the breakpoint table <b>150</b> provides some aspects which are well-known in the art in combination with some inventive features. For example, as is well-known, an op code (operation code) column <b>404</b> and an address column <b>406</b> are shown. The information contained under the address column <b>406</b> specifies a memory address of a breakpoint. The information contained under the op code column <b>404</b> specifies the original operation code of the program which has been replaced with some “bad” operation code at the corresponding address in the address column <b>402</b>. A statement column <b>402</b> contains information regarding the statement at which a method is selected for setting a breakpoint.</p>
<p id="p-0055" num="0054">In one embodiment, a user may elect to invoke the run into function with respect to multiple function calls. Further, a given invocation of the run into function results in multiple breakpoints being set. Accordingly, two or more run into breakpoints may be set for each invocation of the run into function (i.e., one breakpoint for each instance of a selected method). Accordingly, a technique is needed to identify a set of breakpoints related to a given invocation of the run into function (i.e., for a given selection of a function call to run into). To this end, the run into column <b>408</b> stores a run into function number used in one embodiment of the invention. For example, the first and fourth record of the table <b>150</b> contain the same run into number, 11, indicating that these two records are for the same selected method. In one embodiment, the run into number is generated by a number generation code portion. The information contained in the stack position column <b>410</b> specifies the function (i.e., routine) in which the breakpoint is set and from which the selected method is called. Upon encountering a breakpoint during execution of the computer program under debug, a test may be performed to determine whether a function stored in the stack position column <b>410</b> is the function in which the encountered breakpoint is set.</p>
<p id="p-0056" num="0055">Referring now to <figref idref="DRAWINGS">FIG. 5</figref>, a method <b>500</b> of operating the debugger <b>123</b> in a manner consistent with embodiments of the present invention is shown. Referring first to <figref idref="DRAWINGS">FIG. 5A</figref>, an illustrative operation for setting run into breakpoints is shown. Upon receiving an event for processing (step <b>504</b>) the debugger <b>123</b> determines whether the event is a run into function request (step <b>506</b>). That is, a determination is made as to whether the user is setting a run into breakpoint for a selected method. If so, the debugger <b>123</b> resolves (i.e., parses) the function call (step <b>508</b>) to facilitate classification. Then, the necessary run into breakpoints are set (step <b>510</b>). The debugger <b>123</b> then resumes executing the program (step <b>512</b>) until the next event (step <b>504</b>). Embodiments for setting run into breakpoints (at step <b>510</b>) are described with respect to <figref idref="DRAWINGS">FIG. 6</figref> and <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0057" num="0056">Referring first to <figref idref="DRAWINGS">FIG. 6</figref>, a method for setting context sensitive breakpoints is shown. That is, a user specifies a method call at which to halt execution, on the condition that the method call is made from a selected target site. To this end, the debugger obtains a run into number for subsequently storing it in the breakpoint table in later steps (step <b>602</b>).</p>
<p id="p-0058" num="0057">Having resolved the function call at step <b>508</b> (<figref idref="DRAWINGS">FIG. 5A</figref>), the debugger can then determine whether the selected call involves an object (step <b>604</b>). In one embodiment, this step generally distinguishes non-object oriented languages from object oriented languages; although even an object oriented language may include a method that does not involve an object. If the selected call does not involve an object, the debugger may simply set breakpoints on each entry point to the method (step <b>606</b>); that is, the fields of the first three columns of the breakpoint table <b>150</b> are populated. Otherwise, the debugger obtains the object type of the object involved with the selected function (at step <b>608</b>) to identify cases where the function may have been overridden. Persons skilled in the art will appreciate that a fundamental feature of object-oriented programming is that classes can be related to one another by inheritance. The properties, behaviors, data and operations of a parent, or “base”, class may be inherited without modification by some child, or “derived”, class, or the behavior, properties and operations may be selectively refined under the control of the programmer in the derived class. The latter function is generally referred to as overriding. The function name remains the same, but the changed or overridden function operates on a different type. When defining a derived class, one may start by building on an existing base class which is similar to the one to be created. The derived class inherits the implementation and behavior of the base class, including its functions, except as modified by overriding amendments detailed in the derived class definition. For example, there may be an object type 2 which is derived from and inherited properties of an object type 1. Some functions in object type 1 may be overridden (modified). Illustratively, if object type 1 has a size method that was overridden in object type 2, there now exist two size methods that relate to an object type 1. To ensure breakpoints are set for both methods, the debugger obtains the object type for a function and then traverses the class hierarchy searching for those objects that are based from this object type and override this same function. Accordingly it may be necessary to get the object type (step <b>608</b>) and then insert breakpoints for each matching function within the class hierarchy of the object (step <b>610</b>). Techniques for resolving object type are well known in the art and are not further described here.</p>
<p id="p-0059" num="0058">After the run into breakpoints are set, the call site of the selected method is identified (step <b>612</b>). The call site refers to the location or context of the selected method; i.e., where the method is being called from. The information identifying the call site is referred to herein as “calling context information”. It is contemplated that the level of granularity of the “calling context information” is selectable according to the particular implementation, but preferably the “calling context information” uniquely (i.e., unambiguously) identifies the call site. Unambiguous identification of the call site may be necessary, for example, where two or more objects are objects of the same class. Consider the following code: foo(obj1.bar(), obj2.bar()), where obj1 and obj2 are of the same class. Now assume the user desires to run into obj2.bar(). Without unique identification of the call site, execution may halt at obj1.bar().</p>
<p id="p-0060" num="0059">The particular technique for unambiguously identifying the call site may vary depending on the particular implementation. In one embodiment, the line number of the call site is known and is mapped to information (i.e., the “calling context information”) that will appear on the call stack <b>120</b>, e.g., a statement number or address. This information is then stored in the breakpoint table <b>150</b> in the appropriate record(s) set for each breakpoint at steps <b>606</b> or <b>610</b> (step <b>614</b>). The debugger <b>123</b> then resumes executing the program (step <b>512</b>) until the next event (step <b>504</b>), as shown in <figref idref="DRAWINGS">FIG. 5A</figref>.</p>
<p id="p-0061" num="0060">Referring now to <figref idref="DRAWINGS">FIG. 7</figref>, a method for setting instruction specific breakpoints is shown. In particular, the exact location of the call instruction for the selected function is determined (step <b>702</b>). This may the same processing as is performed at step <b>612</b> described above with reference to <figref idref="DRAWINGS">FIG. 6</figref>. A run into breakpoint is then set at the determined instruction location (step <b>704</b>).</p>
<p id="p-0062" num="0061">Returning to step <b>506</b> of <figref idref="DRAWINGS">FIG. 5A</figref>, if the debug event is not a run into request, the debugger <b>123</b> determines (at step <b>526</b>) whether the event is an encountered breakpoint. If step <b>526</b> is answered negatively, the event is handled in an appropriate way (step <b>528</b>). If, however, the event is a breakpoint hit, then the debugger determines whether the breakpoint is a run into breakpoint (<b>530</b>).</p>
<p id="p-0063" num="0062">If the breakpoint is not a run into breakpoint, then the debugger determines whether a run into skipping operation is active (step <b>532</b>). In one embodiment, the run into skipping operation may be utilized to provide added flexibility for processing non-run-into breakpoints prior to completing a run into operation. When the skipping operation is active, non-run-into breakpoints may be ignored and program execution may be resumed. If the process is not active, then all other breakpoints are processed as normal (step <b>534</b>). Of course, other features and functionality may be added to the debugger <b>123</b>. For example, other conditions may be placed on a run into breakpoint. Illustrative conditions include a value on a certain parameter or some instance variable. Persons skilled in the art will recognize other embodiments.</p>
<p id="p-0064" num="0063">Referring back to step <b>530</b>, when the breakpoint is a run into breakpoint, the debugger takes appropriate action depending on whether the breakpoint is a context sensitive breakpoint or an instruction specific breakpoint (step <b>532</b>). In particular, a determination is made whether the breakpoint encountered results halting execution (step <b>534</b>). Embodiments of step <b>532</b> are described in <figref idref="DRAWINGS">FIGS. 8 and 9</figref>.</p>
<p id="p-0065" num="0064">Referring first to <figref idref="DRAWINGS">FIG. 8</figref>, a flow chart is shown illustrating an operation performed when the breakpoint encountered is a context sensitive run into breakpoint. The debugger compares the call stack with the saved information in the stack position column of the breakpoint table <b>150</b> to determine whether the breakpoint was called from the desired function (step <b>802</b>). If the contents do not match, the function is not called from the desired location and, therefore, program execution is resumed with no other action (i.e., processing proceeds to step <b>512</b> of <figref idref="DRAWINGS">FIG. 5A</figref>). If the statement number and the function name match with the contents of the call stack, however, then all run into breakpoints associated with the same run into number are removed (step <b>804</b>) and program execution is halted (steps <b>534</b> and <b>540</b> of <figref idref="DRAWINGS">FIG. 5B</figref>).</p>
<p id="p-0066" num="0065">Referring now to <figref idref="DRAWINGS">FIG. 9</figref>, a flow chart is shown illustrating an operation performed when the breakpoint encountered is an instruction specific run into breakpoint. If so, execution is currently at the instruction call to the selected function. Accordingly, the debugger performs a conventional step into operation to advance the debugger's stopped position into the function of interest (step <b>902</b>). The debugger then halts (steps <b>534</b> and <b>540</b> of <figref idref="DRAWINGS">FIG. 5B</figref>).</p>
<p id="p-0067" num="0066">While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for debugging code, comprising:
<claim-text>while execution is halted at a first point in the code, receiving a user selection of a target call site of the code, the user selection being made through a graphical user interface, and the target call site comprising a call to any one of a plurality of overriding methods;</claim-text>
<claim-text>wherein the code is object-oriented;</claim-text>
<claim-text>in response to the user selection, setting a run-into breakpoint at each respective entry point of the plurality of overriding methods, wherein the run-into breakpoint is configured to halt subsequent execution only when the target call site calls one of the plurality of overriding methods;</claim-text>
<claim-text>while the code is under debug:
<claim-text>encountering one of the plurality of run-into breakpoints, during execution of the code under debug; and</claim-text>
<claim-text>determining whether the target call site called the one of the plurality of overriding methods;</claim-text>
<claim-text>if the target call site called the one of the plurality of overriding methods:</claim-text>
<claim-text>halting execution of the code.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A computer-implemented method for debugging code, comprising:
<claim-text>(a) while execution is halted at a first point in the code, receiving a user selection of a target call site of the code, the user selection being made through a graphical user interface, and the target call site comprising a call to any one of a plurality of overriding methods</claim-text>
<claim-text>(b) in response to receiving the user selection, setting a run-into breakpoint at each respective entry point of the plurality of overriding methods;</claim-text>
<claim-text>(c) determining call context information identifying a location of the target call site in the code;</claim-text>
<claim-text>(d) encountering the run-into breakpoint; and</claim-text>
<claim-text>(e) for each of the run-into breakpoints encountered during execution of the code:</claim-text>
<claim-text>determining whether the target call site called one of the plurality of overriding methods, based on the call context information; and
<claim-text>if so:</claim-text>
<claim-text>halting execution of the code.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>repeating each of the steps (a)-(e) for a plurality of target call sites, wherein each target call site has an associated method of an associated plurality of overriding methods, an associated breakpoint at each respective associated entry point of the associated plurality of overriding methods, and associated call context information; and</claim-text>
<claim-text>automatically removing at least one of the associated breakpoints upon determining that one of the plurality of target call sites has called the associated method based on the associated call context information.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein determining whether the target call site called the one of the plurality of overriding methods comprises comparing the call context information to selected content of a call stack.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the target call site is determined to have called the one of the plurality of overriding methods if stored call context information matches the selected content of the call stack.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the selected content of the call stack is a call to the one of the plurality of overriding methods, and wherein the target call site is determined to have called the one of the plurality of methods if the stored call context information matches the selected content of the call stack.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the code is object-oriented, and the method further comprises identifying the plurality of overriding methods.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising, prior to identifying the plurality of overriding methods, determining that the method is associated with an object.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein identifying the plurality of overriding methods comprises traversing a class hierarchy, and locating each matching member method according to the selected target call site.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A computer readable storage medium containing a program which, when executed, performs an operation for debugging code, comprising:
<claim-text>(a) while execution is halted at a first point in the code, receiving a user selection of a target call site of the code, the user selection being made through a graphical user interface, and the target call site comprising a call to any one of a plurality of overriding methods;</claim-text>
<claim-text>(b) in response to receiving the user selection, setting a run-into breakpoint at each respective entry point of the plurality of overriding methods;</claim-text>
<claim-text>(c) determining call context information identifying a location of the target call site in the code;</claim-text>
<claim-text>(d) encountering the run-into breakpoint; and</claim-text>
<claim-text>(e) for each of the run-into breakpoints encountered during execution of the code:</claim-text>
<claim-text>determining whether the target call site called one of the plurality of overriding methods, based on the call context information; and
<claim-text>if so:</claim-text>
<claim-text>halting execution of the code at.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer readable storage medium of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:
<claim-text>repeating each of the steps (a)-(e) for a plurality of target call sites, wherein each target call site has an associated method of an associated plurality of overriding methods, an associated breakpoint at each respective associated entry point of the associated plurality of methods, and associated call context information; and</claim-text>
<claim-text>automatically removing at least one of the associated breakpoints upon determining that one of the plurality of target call sites has called the associated method based on the associated call context information.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer readable storage medium of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein determining whether the target call site called the one of the plurality of overriding methods comprises comparing the call context information to selected content of a call stack.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computer readable storage medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the target call site is determined to have called the one of the plurality of overriding methods if stored call context information matches the selected content of the call stack.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer readable storage medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the selected content of the call stack is a call to the one of the plurality of overriding methods, and wherein the target call site is determined to have called the one of the plurality of overriding methods if the stored call context information matches the selected content of the call stack.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer readable storage medium of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the code is object-oriented, and the method further comprises identifying the plurality of overriding methods.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer readable storage medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising, prior to identifying the plurality of overriding methods, determining that the method is associated with an object.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer readable storage medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein identifying the plurality of overriding methods comprises traversing a class hierarchy, and locating each matching member method according to the selected target call site.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A computer, comprising:
<claim-text>a memory;</claim-text>
<claim-text>a processor;</claim-text>
<claim-text>code under debug resident in the memory, the code comprising at least one target call site comprising a call to any one of a plurality of overriding methods, the target call site being selected by the user through a graphical user interface while execution is halted at a first point in the code;</claim-text>
<claim-text>a breakpoint data structure resident in the memory and configured for storing at least context information indicating a location of the target call site within the code; and</claim-text>
<claim-text>a debugger program resident in the memory and which, when executed by the processor, is configured to place a run-into breakpoint at each respective entry point of the plurality of overriding methods in response to the target call site being selected by the user, and is further configured to interrupt execution of the code under debug in response to encountering a breakpoint set on one of the plurality of overriding methods if the selected target call site called the one of the plurality of overriding methods with reference to the context information.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising a caller data structure resident in the memory and configured for storing at least callers of overriding methods in the code as encountered during an execution path; and wherein the debugger program is configured to determine whether the routine is called from the target call site by comparing the context information to a caller stored in the caller data structure.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the code under debug is object-oriented.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, where the call context information unambiguously identifies the location of the target call site in the code.</claim-text>
</claim>
</claims>
</us-patent-grant>
