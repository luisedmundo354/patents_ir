<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299220-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299220</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10815061</doc-number>
<date>20040331</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>519</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707  2</main-classification>
<further-classification>707  4</further-classification>
<further-classification>707  5</further-classification>
</classification-national>
<invention-title id="d0e53">Constructing database object workload summaries</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5960423</doc-number>
<kind>A</kind>
<name>Chaudhuri et al.</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6223171</doc-number>
<kind>B1</kind>
<name>Chaudhuri et al.</name>
<date>20010400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6598038</doc-number>
<kind>B1</kind>
<name>Guay et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7120623</doc-number>
<kind>B2</kind>
<name>Ganesan et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2005/0192978</doc-number>
<kind>A1</kind>
<name>Lightstone et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00006">
<othercit>Index Filtering and View Materialization in ROLAP Environment By Shi Guang Qiu et al, Nov. 5-10, 2001, Atlanta, Georgia, USA. Copyright 2001 ACM I-581 13-436-Mar. 1, 2001.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>Aboulnaga, A. and Chaudhuri, S. Self-Tuning Histograms: Building Histograms Without Looking at Data, Processings of ACM SIGMOD, Philadelphia, 1999.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>Acharya S., Gibbons P.B., and Poosala V. Congressional Samples for Approximate Answering of Group-By Queries, Proceedings of ACM SIGMOD, 2000.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00009">
<othercit>Agrawal, S., Chaudhuri, S., and Narasayya, V. Automated Selection of Materialized Views and Indexes for SQL Databases, Proceedings of VLDB 2000.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00010">
<othercit>Agrawal S., Chaudhuri S., Kollar L., and Narasayya V. Index Tuning Wizard for Microsoft SQL Server 2000, Aug. 2000.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00011">
<othercit>Borzsonyi S, Stocker K., Kossmann D. The Skyline Operator, Proceedings of ICDE 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00012">
<othercit>Calzarossa M., and Serazzi G. Workload Characterization: A Survey, Proceedings of IEEE, 81(8), Aug. 1993.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00013">
<othercit>Chandra, A. K., Hirschberg, D. S., and Wong, C. K. Approximate Algorithms For Some Generalized Knapsack Problems, Theoretical Computer, Science, 3, 293-304, 1976.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00014">
<othercit>Chatziantoniou D. and Ross, K. A. Groupwise Processing of Relational Queries, Proceedings of VLDB 1997.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00015">
<othercit>Chaudhuri S., Das G., Datar M., Motwani R., and Narasayya V. Overcoming Limitations of Sampling for Aggregation Queries, Proceedings of ICDE 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00016">
<othercit>Chaudhuri S., Das G., and Narasayya V. A Robust, Optimization-Based Approach for Approximate Answering of Aggregate Queries, Proceedings of ACM SIGMOD 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>Chaudhuri S., Gupta A, and Narasayya V. Compressing SQL Workloads (Workload Compression), Proceedings of ACM SIGMOD 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>Chaudhuri S., Kaushiki R., and Naughton J.F. on Relational Support for XML Publishing: Beyond Sorting and Tagging, Proceedings of ACM SIGMOD 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>Chaudhuri S., and Narasayya, V. AutoAdmin “What-If” Index Analysis Utility, Proceedings of SIGMOD 1998.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00020">
<othercit>Elnaffar S. A Methodology for Auto-Recognizing DBMS Workloads, Proceedings of CASCON'02, 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00021">
<othercit>Elnaffar S., Martin P., and Horman R. Automatically Classifying Database Workloads, In Proceedings of CIKM'02, 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00022">
<othercit>Fagin R. Combining fuzzy information from multiple systems, Proceedings of ACM PODS 1996.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00023">
<othercit>Fagin R. Fuzzy Queries in Multimedia Database Systems, Proceedings of ACM PODS 1998.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00024">
<othercit>Ganti V., Lee M.L., and Ramakrishnan R. ICICLES: Self-tuning Samples for Approximate Query Answering, Proceedings of VLDB 2000.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00025">
<othercit>Johnson, D.S. Approximation Algorithms for Combinatorial Problems, Journal of Computer and System Sciences, 9, 1974, pp. 256-278.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00026">
<othercit>Legaria, C.G., and Joshi, M. M. Orthogonal Optimization of Subqueries and Aggregation. Proceedings of SIGMOD 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00027">
<othercit>Lovasz, L. “On the ratio of optimal integral and fractional covers”, Journal: Discrete mathematics, vol. 13, 1975, pp. 383-390.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00028">
<othercit>Papadias D., Tao Y., Fu G., Seeger B.: An Optimal and Progressive Algorithm for Skyline Queries. Proceedings of ACM SIGMOD 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00029">
<othercit>Srinivasan, A. Improved Approximations of Packing and Covering Problems. Proc. 27th Ann. ACM Symposium. on Theory of Comp., pp. 278-276, 1995.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00030">
<othercit>Stillger M., Lohman C., and Markl V. LEO-DB2's Learning Optimizer. In Proceedings of VLDB 2001, 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00031">
<othercit>Tan K., Eng P., Ooi B.C.: Efficient Progressive Skyline Computation. Proceedings of VLDB 2001, 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00032">
<othercit>Valentin, G., Zuliani, M., Zilio, D., and Lohman, G. DB2 Advisor: An Optimizer Smart Enough to Recommend Its Own Indexes. Proceedings of ICDE 2000, 200.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00033">
<othercit>Yu P., Chen M., Heiss H., and Lee S. On Workload Characterization of Relational Database Enviorments. IEEE Transactions of Software Engineering, vol. 18, Apr. '92, 1992.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00034">
<othercit>ILOG CPLEX: CPLEX algorithms, retrieved from the Internet on Feb. 21, 2005.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>67</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>9</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050223026</doc-number>
<kind>A1</kind>
<date>20051006</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Chaudhuri</last-name>
<first-name>Surajit</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Narasayya</last-name>
<first-name>Vivek</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Ganesan</last-name>
<first-name>Prasanna</first-name>
<address>
<city>Menlo Park</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Pham</last-name>
<first-name>Khanh B.</first-name>
<department>2166</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A database object summarization tool is provided that selects a subset of database objects subject to filtering constraints such as a partial order or optimization of some attribute. A dominance primitive filters out tuples that are dominated according to a partial order constraint by another tuple. A representation primitive selects a representative subset of tuples such than an optimization criteria is met.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="101.18mm" wi="214.12mm" file="US07299220-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="222.33mm" wi="139.95mm" orientation="landscape" file="US07299220-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="235.97mm" wi="168.49mm" file="US07299220-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="216.75mm" wi="120.06mm" orientation="landscape" file="US07299220-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="196.34mm" wi="174.92mm" file="US07299220-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="226.82mm" wi="161.04mm" file="US07299220-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="113.20mm" wi="156.13mm" file="US07299220-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="243.59mm" wi="172.89mm" orientation="landscape" file="US07299220-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">TECHNICAL FIELD</heading>
<p id="p-0002" num="0001">The invention pertains generally to the field of database management and more particularly to operators for use in constructing a summary of database statements or objects.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">The past few years have seen the emergence of a large class of tasks that benefit from analysis of SQL workload information. Some examples of such tasks are database administration and understanding user/application behavior. The problem of collecting a SQL workload is facilitated by profiling tools provided by commercial database vendors that log SQL activity on the server over a representative period of time. However, little attention has been paid to understanding the requirements for analysis of the collected workload.</p>
<p id="p-0004" num="0003">In analyzing workloads, it is helpful to identify a small representative subset that captures the essence of the large workload that has been logged using automated tools. There are multiple reasons why picking such a small representative subset is necessary. First, the resources needed to accomplish tasks such as index tuning grows with increasing sizes of workloads. There is a significant benefit to be gained by “filtering” the workload before it is fed to these tasks, while not compromising its characteristics. A second motivation for identifying a small representative subset is the necessity of having to meaningfully summarize data for viewing by DBAs or analysts. It is important to be able to offer relatively small representative synopses of the workload, before “drilling down” to identify the queries of interest.</p>
<p id="p-0005" num="0004">A simple way to obtain a representative subset is to pick a uniform random sample of the workload. While sampling is conceptually simple, and, in fact, useful in many situations, a DBA may like to obtain a representative subset that has additional constraints, e.g., pick a representative workload with the 100 most expensive queries while ensuring that every table in the database occurs in at least 5 queries. Thus, the specification for picking a representative subset for a workload (henceforth called a “summary”) depends on the task at hand and, more often than not, sampling in itself is not adequate.</p>
<p id="p-0006" num="0005">Recently, several tools have emerged that exploit knowledge of the database workload for a variety of tasks such as physical design tuning, feedback based optimization, and approximate query processing. There has also been work on classifying database workloads, such as OLTP vs DSS, so as to enable automatic tuning and configuration of database system parameters based on workload type. Typically, workloads collected by today's database profiling tools can be very large (millions of statements), whereas most of the above tools work efficiently for relatively small workload sizes.</p>
<p id="p-0007" num="0006">The concept of workload compression has been introduced to find a smaller workload whose use results in the same application quality as when the original workload is used. Workload compression requires applications to specify custom distance functions that quantify how close two statements in the workload are. Providing such distance functions may not be easy for all applications. REDWAR allows simple aggregations over the structure and complexity of SQL statements and transaction run-time behavior. A variety of techniques for producing a workload model have also been presented. However, the “representativeness” of these workload models varies.</p>
<heading id="h-0003" level="1">SUMMARY </heading>
<p id="p-0008" num="0007">A database object summarization tool is provided that selects a subset of database objects subject to constraints such as a partial order or optimization of some aggregate over one or more attributes. The subset is a summary of the database objects that can be useful for better understanding the database without the need for examining the entire set of database objects.</p>
<p id="p-0009" num="0008">The object selection criterion can be a partial order criterion for an attribute, such one or more transitive inequality conditions, whereby a master database object dominates an associated slave database object. An operator with this type of object selection criterion can include a dominance aggregation module that, for a master database object, aggregates information about slave database objects that the master database object dominates.</p>
<p id="p-0010" num="0009">The object selection criterion can be an optimization criterion that is an aggregate over a database object attribute. The optimization criterion can be the minimization or maximization of an aggregate over one or more attributes. A global constraint can be input to the operator on the attributes of the database objects in the subset. A local constraint be input on the attributes of the database objects in the subset for each partition. A filter constraint can be imposed with respect to any database object in the subset. In one embodiment, the operator includes a database object ranking module that specifies an order, based on attribute values, in which database objects are accessed by the operator for possible selection to the subset.</p>
<p id="p-0011" num="0010">The database objects can be database statements from a database workload presented according to a workload schema. The partitioning module can hash database objects on the partitioning attribute.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 1</figref> is a functional block diagram of a query processing system that features a workload summarization tool constructed in accordance with an embodiment of the present invention;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 2</figref> is table representation of a workload schema that can be used in practice of an embodiment of the present invention;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 3</figref> is a graphical illustration of a dominance operator in accordance with an embodiment of the present invention;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 4</figref> is a functional block diagram of the workload summarization tool of <figref idref="DRAWINGS">FIG. 1</figref>;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart outlining a method for implementing a dominance operator in accordance with an embodiment of the present invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart outlining a method for implementing a representation operator in accordance with an embodiment of the present invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIGS. 7-8</figref> are block diagrams of dominance and representation operators, respectively according to an embodiment of the present invention; and</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 9</figref> is an exemplary operating environment for practicing an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0020" num="0019">A natural approach to summarizing workload information is to express the specification for a summary workload as a SQL statement over the entire workload represented in a relational database. However, today's SQL provides limited support for conveniently specifying such summary workloads. Two primitive operators will be described herein that support workload analysis. As with traditional filtering, both these primitives take as input a set of statements and output a subset of those statements. The first primitive, “dominance”, allows filtering based on a partial order among the statements in the workload. Thus, statements that are “dominated” by other statements in the workload (as determined by the partial order) are filtered out. For example, when considering workload summarization for the index-selection task, whenever two queries Q<sub>1 </sub>and Q<sub>2 </sub>are identical in all respects except in their GROUP BY clause, and if Q<sub>1 </sub>contains a superset of the GROUP BY columns of Q<sub>2</sub>, it could be determined that Q<sub>1 </sub>dominates Q<sub>2 </sub>since the indexes chosen for Q<sub>1 </sub>are likely to be adequate for Q<sub>2 </sub>as well.</p>
<p id="p-0021" num="0020">The second primitive, called “representation”, is a form of combinatorial optimization. It allows specification of a subset of the workload such that a certain objective function ( any aggregate expression over an attribute) is maximized or minimized, subject to a set of constraints. For example, in the index selection task, it may be advantageous to constrain the output to no more than 1000 statements in the workload, while trying to maximize “coverage” (such as total execution time of all statements in the output) of the workload. It should also be noted that both the dominance and representation primitives need to be able to provide aggregate information as well. For example, the count of the total number statements a dominating statement in the workload has dominated would be advantageous.</p>
<p id="p-0022" num="0021">The primitives of dominance and representation, while described herein in the context of workload summarization are useful in a variety of other scenarios. The dominance primitive is a generalization of the Skyline operator that has been proposed, but not yet included, in SQL and implementation of the dominance primitive can leverage algorithms that have been proposed for implementing the Skyline operator, as will be described in more detail below. Implementing the representation primitive in SQL requires consideration of trade-offs between functionality and complexity. While the representation primitive can potentially have wide usage, in its full generality requires solution of the Integer Programming problem that is known to be NP-hard. While several algorithms are known for solving the IP problem, their integration into SQL directly can result in a very heavyweight operator whose usefulness on large data sets may be rather limited. Thus, an alternative, simpler, implementation in SQL is described that allows efficient and scalable implementation. This simple extension appears to be adequate for many common summarization tasks.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 1</figref> is a functional block diagram of a query processing system <b>100</b> that includes a workload summarization tool <b>120</b> that implements the primitive operators dominance and representation. Queries are presented to a query processor <b>110</b> for selecting a given set of tuples from a database <b>150</b> or to otherwise act upon the database <b>150</b>, such as inserting or deleting tuples from the database. The query processor <b>110</b> takes advantage of a set of physical design structures <b>160</b>, such as indexes and/or materialized views, to more efficiently locate tuples in the database.</p>
<p id="p-0024" num="0023">The queries that are presented to the database are logged as the query processing system's workload <b>115</b>. It is expected that the workload is stored according to a workload schema like the one depicted in <figref idref="DRAWINGS">FIG. 2</figref>. Each query statement is an object in the schema with one or more attributes corresponding to a property of the query statement. The schema shown in <figref idref="DRAWINGS">FIG. 2</figref> contains attributes of the following types: (1) atomic valued attributes such as the execution cost of the statement or the number of tables referenced by the statement; (2) set-valued attributes such as the set of tables referenced by the query; and (3) sequence attributes such as the sequence of ORDER BY columns. According to the schema, the attributes of a statement in the workload are broadly categorized into three categories: (1) syntactice and structural statements that describe the syntax or structure of the statement; (2) plan information; and (3) execution information.</p>
<p id="p-0025" num="0024">A workload summarization tool <b>120</b> inputs the set of queries in the workload which are expressed according to the workload schema to construct a subset of the queries that makes up a workload summary <b>130</b>. The workload summary <b>130</b> is intended to include queries that in some way subsume or represent other queries in the workload which are not included in the workload summary. To select these queries, the workload summarization tool provides a set of operators to a user for acting upon the queries in the workload to select a satisfactory subset. One database component that could advantageously use the workload summary <b>130</b> is the physical design tool <b>140</b>. The physical design tool <b>140</b> enumerates candidate physical design structures based on queries in the workload and can benefit from a workload summary as described below.</p>
<heading id="h-0006" level="1">EXAMPLE 1 </heading>
<p id="p-0026" num="0025">Workloads often consist of different templates that are invoked repeatedly with different parameters. Within each template, relationships between the queries can be leveraged to filter out some of the queries before inputting them to the physical design tool <b>140</b>. For example, whenever two queries Q<sub>i </sub>and Q<sub>j </sub>are identical in all respects except their GROUP BY clause, and if Q<sub>i</sub>.GroupBy Cols ⊂ Q<sub>j</sub>.GroupByCols and Qi. OrderByCols is a prefix of Qj. OrderByCols, Q<sub>i </sub>could be filtered from the workload prior to inputting it to the physical design tool <b>140</b>, since indexes that are beneficial for Qj are likely to be adequate for Qi as well. After this filtering step, a summary workload could be selected such that each template receives adequate representation that is proportional to the number of statements in each template. Finally, the workload summary could be limited to nom more than 1000 queries such that the sum of the Weight attribute is maximized, i.e., as much of the total weight of the original workload as possible is captured.</p>
<heading id="h-0007" level="1">EXAMPLE 2 </heading>
<p id="p-0027" num="0026">Another application for workload summarization is in finding queries that are potential resource bottlenecks. Queries that are responsible for consuming the most CPU, I/O, or memory resources are often of interest to DBAs. It would be helpful then to find the smallest subset of queries that covers at least 50% of CPUTotal, IOTotal, and MemoryTotal.</p>
<heading id="h-0008" level="1">EXAMPLE 3 </heading>
<p id="p-0028" num="0027">Workload summarization can also be used to identify columns for potential building or updating of statistics. For this task, queries with a large discrepancy between the optimizer's estimated time and the actual execution time or having large errors in cardinality estimation are sought. Statements could be filtered out that do not have at least 50% error in cardinality estimation or take less than one second to execution. The remaining statements could be partitioned based on the tables referenced (FromTables attribute) and join conditions down the columns that could benefit from the creation/update of statistics by eliminating statements which have a super set of the columns involved in some other statement. Five or less statements could be selected per partition such that no more than a total of 100 statements in contained in the summary, while maximizing the total value of CostRatio (defined as ExecutionCost/EstimatedCost) over the statements in the summary.</p>
<p id="p-0029" num="0028">A workload summarization tool <b>120</b> that can achieve the above objectives can be implemented with three primitive operators: filtering, dominance, and representation. Filtering is a traditional operator that eliminates any statement in the workload that does not satisfy a given Boolean Expression. An atomic condition in the filter is any predicate on an attribute of the workload schema. For example, the filtering operator can be used to filter out statements with low errors in cardinality estimation or with low execution times.</p>
<p id="p-0030" num="0029">The dominance primitive can be used to specify a partial order among statements in the workload. Moreover, this partial order is used also as a filtering and aggregation operator (as will described below). In particular, for any pair of statements S<sub>1 </sub>and S<sub>2 </sub>in the workload, if per the partial order S<sub>1 </sub>is “dominated by” S<sub>2</sub>, then S<sub>1 </sub>must be filtered from the output of the dominance operator, with the exception of the case when S<sub>1 </sub>dominates S<sub>2 </sub>and S<sub>2 </sub>dominates S<sub>1</sub>. In the latter case, S<sub>1 </sub>and S<sub>2 </sub>are considered equivalent, and it is acceptable to include either one (but not both) in the output. Thus, the semantics of dominance is that it outputs a smallest subset such that every statement not included in the output is dominated by some statement in the output.</p>
<p id="p-0031" num="0030">The specification of the partial order, or equivalently the test for whether a statement is dominated by another statement, is expressed by a conjunction of conditions on the attributes of the statements. In general, some of the conditions will be strict equality conditions, and the rest will be partial order conditions. The attributes mentioned in the strict equality conditions are referred to as partitioning attributes associated with the dominance primitive. The strict equality conditions in the first example above are that FromTables, JoinConds, and WhereCols of both statements are identical, and the partial order conditions are: (1) GroupByCols of the first statement is a subset of GroupByCols of the second statement: (2) OrderByCols of the first statement is a prefix of OrderByCols of the second statement. The strict equality conditions imply a partitioning of the statements. Note also, that if in this example, two statements in the workload have the same group by and order by columns, then either of them (but not both) may be included in the output.</p>
<p id="p-0032" num="0031">The dominance relationship is illustrated graphically in <figref idref="DRAWINGS">FIG. 3</figref>. Each node in the graph denotes a statement and an edge from node X to node Y denotes that X dominates Y. In <figref idref="DRAWINGS">FIG. 3</figref>, the output set of statements is {A,B,C}. Dominance is advantageous for certain workload summarization tasks. For example, an index that is appropriate for statement S<sub>2 </sub>may also be appropriate for S<sub>1</sub>, but not necessarily the other way around. In the described embodiment of the dominance operator the comparison operators of the inequality conditions are restricted to transitive operators, such as &lt;, &gt;, ≧, and ≦ for atomic-valued attributes, ⊂, ⊃, <u style="single">⊂</u>, and <u style="single">⊂</u> for set-valued attributes, and prefix-of, subsequence-of, and supersequence-of for sequence-valued attributes. In addition, for the described embodiment, an attribute of a statement must be compared with the same attribute of the other statements. Since the dominance relationship imposes a partial order, it is transitive. Transitivity is useful in enabling an efficient implementation of dominance.</p>
<p id="p-0033" num="0032">As noted above, the dominance primitive also represents aggregation. With every statement S in the output of the dominance operator, aggregation information over the statements that were dominated by S could be included. Each such specified aggregate becomes a new attribute, which will be referred to as a dominance-based aggregate attribute of each statement output by the dominance primitive. A dominance-based aggregate attribute corresponding to an output statement S is the SUM or COUNT function (or, in principle, any other aggregate function) applied to any attribute, over all the statements that were eliminated by S, and including S itself. Note that such a statement can be dominated by two different statements, neither of which dominates the other. In <figref idref="DRAWINGS">FIG. 3</figref> H is dominated by E and F, but neither E nor F dominates the other. One way to handle this case is to establish a convention that H's value will contribute to the aggregate of either E or F but not both.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 7</figref> is a simple functional block diagram of the dominance operator. Workload queries, a partitioning attribute, and a partial order criteria are input to the dominance operator <b>210</b>. The dominance operator includes a partial order specification module <b>211</b> that inputs the partial order criteria and a subset selection and aggregation module <b>212</b> selects queries that dominate other queries based on the partial order criteria and aggregates the values of statements that are eliminated by other statements and associates the aggregate value with each statement that passes to the output <b>220</b>.</p>
<p id="p-0035" num="0034">Referring now to <figref idref="DRAWINGS">FIG. 8</figref>, a block diagram of the representation primitive <b>260</b> is shown. The representation primitive allows specification to a specification module <b>261</b> of a subset of the workload such that a certain object function (an aggregate expression offer an attribute) is maximized or minimized, subject to a set of constraints. Thus, the representation primitive specifies an optimization problem. Criteria upon which representation can sort and filter queries, as described herein, include, as shown as input in <figref idref="DRAWINGS">FIG. 8</figref> to the representation operator <b>260</b>: (1) partitioning attributes; (2) optimization criterion; (3) global constraints; (4) local constraints; and (5) filtering constraints. A criteria solver <b>262</b> resolves those constraints and selects the subset of representative queries.</p>
<p id="p-0036" num="0035">Representation can specify a partitioning of the input to be used, so that constraints can be specified at a per-partition level. Partitioning is similar to a GROUP BY, in that each partition corresponds to all statements that have the same values for all the partitioning attributes.</p>
<p id="p-0037" num="0036">The optimization criteria can be specified in one of the following forms: (1) Minimize an aggregate over an attribute, e.g., the number of statements in the output, subject to the constraints; or (2) Maximize an aggregate over an attribute, e.g., maximize the sum of ExecutionCost subject to the constraints.</p>
<p id="p-0038" num="0037">Global constraints are constraints on an aggregate computed over the entire output set of statements. Any condition expression involving aggregates over any of the attributes of the input can be used as a global constraint. Referring to the first example above, the requirement that the chosen statements should cover at least 75% of the total ExecutionCost of statements in the input workload is a global constraint.</p>
<p id="p-0039" num="0038">Local constraints are identical to global constraints, except that the constraint applies to each individual partition. For example, it could be specified that every partition should contain enough output statements to cover at lest 75% of the total statements in that partition.</p>
<p id="p-0040" num="0039">Filter constraints are constraints that apply to each individual statement chosen by the representation process. A statement not satisfying the filter constraint may not be a part of the output. A filter constraint may involve aggregate expressions computed over partitions for the entire input workload. For example, a filter constraint could require that every statement chosen has an execution cost at least 30% higher that the average execution cost for its partition.</p>
<p id="p-0041" num="0040">A workload summarization tool can be implemented with an extension of SQL that allows a user to declaratively specify workload summarization tasks. The proposed extension of SQL is referred to herein as WAL (Workload Analysis Language). The overall structure of a query in WAL is shown below:</p>
<p id="p-0042" num="0041">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SELECT &lt;select clause&gt;</entry>
</row>
<row>
<entry/>
<entry>FROM &lt;from clause&gt;</entry>
</row>
<row>
<entry/>
<entry>WHERE &lt;filter condition&gt;</entry>
</row>
<row>
<entry/>
<entry>DOMINATE &lt;dominate clause&gt;</entry>
</row>
<row>
<entry/>
<entry>REPRESENT &lt;representation clause&gt;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0043" num="0042">The SELECT clause is similar to that of any SQL query. It permits the specification of a subset of the attributes in the workload schema, together with other aggregates. In addition, dominance-based aggregate attributes can be defined in this clause. Dominance-based aggregates are similar to aggregates computed for each group specified by the GROUP BY clause of a traditional SQL query. The difference is that, for each output statement S, the aggregate is computed over the set of all statements dominated by S. These aggregates are defined by prefixing DOM to the traditional keywords for computing aggregates. For example, DOMSUM(ExecutionCost) returns, for each statement S output by the dominance primitive, the sum of the ExecutionCost of all statements dominated by S, including S itself. Thus for each aggregate function (e.g., SUM, COUNT) in SQL, there is a corresponding dominance-based aggregate function. The scope of such an attribute is the block defined by the SELECT clause. Thus this attribute can be referenced in the REPRESENT clause in a constraint.</p>
<p id="p-0044" num="0043">The FROM clause simply specifies a single table or view. In the context of workload summarization, it is implicit that this table or view conforms to the workload schema. The view may itself be an arbitrary SQL query whose result conforms to the workload schema. For example, traditional SQL operators such as UNION, DIFFERENCE etc., could be used to combine two or more workloads. In SQL, the WHERE clause is permitted to be an arbitrary Boolean condition applicable to each tuple of the table or view specified in the FROM clause.</p>
<p id="p-0045" num="0044">The syntax of the DOMINATE clause is:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>DOMINATE WITH (PARTITIONING BY &lt;attr-list&gt;) (SLAVE.Attr Op MASTER.Attr)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0046" num="0045">Thus, the strict equality dominance conditions are specified by the shorthand PARTITIONING BY (&lt;attr-list&gt;). This is followed by the conditions that define the partial order. All conditions are implicitly ANDed. Logically, each condition for the partial order is specified by a comparison operator (e.g., &lt;) and an attribute over which the comparison condition is applied. It should be noted that SLAVE.Attr Op MASTER.Attr is a syntactic redundancy to make the query examples herein more readable. For the purposes of this description, MASTER and SLAVE are keywords and Op is restricted to any comparison operator that is transitive.</p>
<p id="p-0047" num="0046">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, one method for implementation of the dominance operator <b>500</b> is shown. This implementation based on a block nested loop technique described in Borzonyi S, Kossmann K, and Stoker D The Skyline Operator. Proceedings of ICDE 2001. The interested reader is referred to this paper for alternative techniques that would be helpful in implementing the dominance primitive. In general, this algorithm keeps a window of incomparable “master” tuples in main memory. Each new tuple that is read is compared to the tuples in the window and either added to the window to replace dominated tuples or discarded as follows. At <b>510</b> a window for holding “master” tuples is initialized, as well as a counter p. At <b>520</b> and <b>530</b> a next tuple p is obtained. At <b>540</b> it is determined whether tuple p is dominated by any tuple in the window. If so, at <b>545</b> the tuple is discarded. If the tuple is not dominated by any tuple in the window but rather dominates one or more tuples in the window (<b>550</b>), the aggregate score of the dominated tuples is calculated and the dominated tuples are discarded at <b>555</b> and the tuple p is added to the window at <b>558</b>. If the tuple p neither dominates nor is dominated by any tuple in the window, tuple p is added to the window at <b>570</b>. At the end of each pass through the tuples, tuples in the window can be output as masters if they have been compared to all tuples (were present at the in the window before any tuples were discarded). Later added tuples can be output only at later passes through the tuples to ensure that they have been compared to all the tuples.</p>
<p id="p-0048" num="0047">The REPRESENT clause allows specification of the representation primitive. In particular, it allows specification of the partitioning attributes, the objective function to be maximized or minimized, and the constraints the output must satisfy.</p>
<p id="p-0049" num="0048">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>REPRESENT WITH (PARTITIONING BY &lt;attr-list&gt;)</entry>
</row>
<row>
<entry/>
<entry>[MAXIMIZING|MINIMIZING] &lt;aggr-expr&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(GLOBAL CONSTRAINT &lt;global-constraint&gt;)*</entry>
</row>
<row>
<entry/>
<entry>(FILTER CONSTRAINT &lt;filter-constraint&gt;)*</entry>
</row>
<row>
<entry/>
<entry>(LOCAL CONSTRAINT &lt;local-constraint&gt;)*</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0050" num="0049">The optional PARTITIONING BY specifies a set of attributes on which to partition the statements in the workload. It should be noted that LOCAL CONSTRAINTs are meant to be used only if PARTITIONING BY is specified.</p>
<p id="p-0051" num="0050">&lt;aggr-expr&gt; is an aggregate expression of the form Aggregate(Attribute) that is to be maximized (or minimized) subject to specified constraints, and can be referred to as the optimization criterion. Aggregate can be the SUM or COUNT aggregate function.</p>
<p id="p-0052" num="0051">&lt;filter-constraint&gt; is a condition of the form (Attr Op Expression). &lt;global-constraint&gt; and &lt;local-constraint&gt; are both conditions of theform (Aggregate(Attr) Op Expression). In all these constraints, Expression can involve constants, aggregates on an attribute computed over the entire set of statements in put to the representation primitive (obtained by prefixing the aggregate by the keyword GLBOAL), or aggregates computed over the set of tuples within a partition (obtain by prefixing the aggregate with the keyword (LOCAL). LOCAL can only be used in a filter or local constraint, and not in a global constraint.</p>
<p id="p-0053" num="0052">The following examples illustrate several workload summarization tasks expressed as queries WAL. These examples highlight the expressiveness and usefulness of the primitives exposed in a declarative interface. The first three examples correspond to the three examples discussed above. For purposes of the examples, WorkladTable is the name of the table containing the workload statements according to the schema in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<heading id="h-0009" level="1">EXAMPLE 1 </heading>
<p id="p-0054" num="0053">The following sequence of commands prepares a workload for input to an index selection tool like the physical design tool <b>140</b> in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0055" num="0054">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SELECT*, DOMSUM(Weight) AS Dom_Weight</entry>
</row>
<row>
<entry/>
<entry>FROM WorkloadTable</entry>
</row>
<row>
<entry/>
<entry>DOMINATE WITH PARTITIONING BY</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>FromTables, JoinConds, WhereCols</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>SLAVE.GroupByCols SUBSET MASTER.GroupByCols</entry>
</row>
<row>
<entry/>
<entry>SLAVE.OrderByCols PREFIX MASTER.OrderByCols</entry>
</row>
<row>
<entry/>
<entry>REPRESENT WITH PARTITIONING BY</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>FromTables, JoinConds, WhereCols</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>MAXIMIZING Sum(DOM_Weight)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>GLOBAL CONSTRAINT Count(*) ≦ 200</entry>
</row>
<row>
<entry/>
<entry>LOCAL CONSTRAINT Count(*) ≧</entry>
</row>
<row>
<entry/>
<entry>int(200*LOCAL.Count(*)/GLOBAL.Count(*))</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0010" level="1">EXAMPLE 2 </heading>
<p id="p-0056" num="0055">The following series of commands finds queries that are potential performance bottlenecks.</p>
<p id="p-0057" num="0056">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SELECT * FROM WorkloadTable</entry>
</row>
<row>
<entry/>
<entry>REPRESENT WITH</entry>
</row>
<row>
<entry/>
<entry>MINIMIZING COUNT(*)</entry>
</row>
<row>
<entry/>
<entry>GLOBAL CONSTRAINT SUM(CPUTime) &gt; 0.50 *</entry>
</row>
<row>
<entry/>
<entry>GLOBAL.SUM(CPUTime)</entry>
</row>
<row>
<entry/>
<entry>GLOBAL CONSTRAINT SUM(IOTime) &gt; 0.50 *</entry>
</row>
<row>
<entry/>
<entry>GLOBAL.SUM(IOTime)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
GLOBAL CONSTRAINT SUM(Memory) &gt;0.50* GLOBAL.SUM(Memory)
</p>
<heading id="h-0011" level="1">EXAMPLE 3 </heading>
<p id="p-0058" num="0057">The following series of commands identifies columns for potential building or updating of statistics.</p>
<p id="p-0059" num="0058">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SELECT * FROM WorkloadTable</entry>
</row>
<row>
<entry/>
<entry>WHERE ABS(CardEst − CardActual)/CardActual &gt; 0.5</entry>
</row>
<row>
<entry/>
<entry> AND (ExecutionCost &gt; 1.0)</entry>
</row>
<row>
<entry/>
<entry>DOMINATE WITH PARTITIONING BY FromTables, JoinConds</entry>
</row>
<row>
<entry/>
<entry> SLAVE.SelectCols SUBSET MASTER.SelectCols</entry>
</row>
<row>
<entry/>
<entry> SLAVE.WhereCols SUBSET MASTER.WhereCols</entry>
</row>
<row>
<entry/>
<entry>REPRESENT WITH PARTITIONING BY FromTables, JoinConds</entry>
</row>
<row>
<entry/>
<entry>MAXIMIZING SUM(CostRatio)</entry>
</row>
<row>
<entry/>
<entry>GLOBAL CONSTRAINT Count(*)≦ 100</entry>
</row>
<row>
<entry/>
<entry>LOCAL CONSTRAINT Count(*)≦ 5</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0012" level="1">EXAMPLE 4 </heading>
<p id="p-0060" num="0059">The following series of commands obtains a summary of the workload for use in building samples of the database for approximate processing of aggregation queries. In this example, among all queries in each partition specified in the representation clause, at most 10 queries are requested. The total number of queries cannot exceed 500, while maximizing the total weight of all queries that are selected.</p>
<p id="p-0061" num="0060">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SELECT * FROM WorkloadTable</entry>
</row>
<row>
<entry/>
<entry>REPRESENT WITH PARTITIONING BY FromTables,</entry>
</row>
<row>
<entry/>
<entry>JoinConds, GroupByCols,</entry>
</row>
<row>
<entry/>
<entry>WhereCols</entry>
</row>
<row>
<entry/>
<entry>MAXIMIZING SUM(Weight)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>GLOBAL CONSTRAINT Count(*)≦ 500</entry>
</row>
<row>
<entry/>
<entry>LOCAL CONSTRAINT Count(*) ≦ 10</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0013" level="1">EXAMPLE 5 </heading>
<p id="p-0062" num="0061">The following sequence of commands finds queries in each application with a low relative index usage. A subset is sought of at most 100 queries in the workload maximizing total execution cost suttee that, for each application, a subset of queries is selected that has a lower-than-average index usage despite having a higher-than-average number of tables references compared to other queries from the application.</p>
<p id="p-0063" num="0062">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SELECT * FROM WorkloadTable</entry>
</row>
<row>
<entry/>
<entry>REPRESENT WITH PARTITIONING BY Application</entry>
</row>
<row>
<entry/>
<entry>MAXIMIZING Sum(ExecutionCost)</entry>
</row>
<row>
<entry/>
<entry>GLOBAL CONSTRAINT COUNT(*)≦ 1000</entry>
</row>
<row>
<entry/>
<entry>LOCAL CONSTRAINT AVG(NumIndexesUsed) &lt; 0.75 *</entry>
</row>
<row>
<entry/>
<entry>LOCAL.AVG(NumIndexesUsed)</entry>
</row>
<row>
<entry/>
<entry>LOCAL CONSTRAINT AVG(NumTables) &gt; 1.25 *</entry>
</row>
<row>
<entry/>
<entry>LOCAL.AVG(NumTables)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0064" num="0063">Although the dominance and representation primitives present in this description are described in the context of workload summarization, the applicability of these operators is not limited to workload summarization. The following examples illustrate other domains where these operators could be useful in complementing existing analysis techniques in the respective domains.</p>
<p id="h-0014" num="0000">Scenario 1</p>
<p id="p-0065" num="0064">A company mails product catalogs to its customers. The company has a fixed budget for mailing costs. The concept of dominance can help in the scenario as follows: to avoid sending multiple catalogs to a single address, the company considers all customers with the same address as equivalent, and will pick one customer at that address, for example, the person in the household with the highest income. To maximize the expected benefit from the mailing, the company may like to select a subset of customers with the largest total “importance”, which could be measured by the amount of money spent in the past. Representation is useful for specifying such a subset while not exceeding the mailing-cost budget (a global constraint), and ensuring that one customer is picked from each address (a local constraint).</p>
<p id="h-0015" num="0000">Scenario 2</p>
<p id="p-0066" num="0065">Web pages are often personalized based on user profiles. When a user requests a web page, only a fixed number k of targeted ads can typically be displayed on that page. The concept of partitioning and local constraints can be useful to specify that at most two ads from each category (such as food, jewelry, books, etc.) should be chosen. Dominance can be useful in specifying whether, within a category (based on the user's profile), the expensive items or the inexpensive items should dominate. Representation is necessary since the company running the web site wishes to pick a subset of ads such that a certain objective function (e.g., the likelihood of click-throughs) is maximized, while not exceeding the global constraint of k ads.</p>
<p id="h-0016" num="0000">Scenario 3</p>
<p id="p-0067" num="0066">In a web community scenario an incoming question needs to be answered by locating a certain set of “experts” on the subject. The goal is to provide a timely response from as highly rated an expert as possible. For cost effectiveness, no more than n experts should be requested for any given question. Dominance can be useful to partition experts according to different time zones in order to improve the probability of providing a quick response. Within each zone, a person having a higher expertise rating and lower average response time as “dominating” any other expert with a lower rating and higher average response time. Representation can be useful for specifying that the subset of at most n experts is selected while the sum of expertise is maximized, subject to having at least one expert from each partition.</p>
<p id="p-0068" num="0067">The following description will detail a possible implementation of the primitives dominance and representation in SQL, assuming that the syntax for exposing dominance and representation is as described above. <figref idref="DRAWINGS">FIG. 4</figref> gives a general overview of the workload summarization tool <b>120</b> that utilizes dominance and representation as part of a collection of operators to construct a workload summary <b>130</b> given a query workload <b>115</b> and some selection criteria.</p>
<p id="p-0069" num="0068">A partitioning module <b>122</b> partitions the workload queries on a partitioning attribute that is part of the selection criteria. Partitioning is significant because both dominance and representation are specified with partitioning attributes. The partitioning of the input can be achieved either by hashing or by sort-based methods, which can exploit indexes or existing orders on the input. Once the input is partition, dominance and representation may need to be invoked within each partition <b>124</b>. Techniques from group-wise processing can be leveraged for implementation of the dominance and special forms of representation. The result of the overall query is the union over the results of the sub-query over each partition, which is applied as a filter <b>125</b> on the queries in each partition.</p>
<p id="p-0070" num="0069">The physical operator necessary for the dominance primitive is a generalization of the Skyline operator as discussed above in conjunction with <figref idref="DRAWINGS">FIG. 5</figref>. The specification of the attributes in the PARTITIONING BY induces a partitioning of the input. Thus the checking of dominance conditions is limited to tuples within a partition. The Skyline operator is implemented as above with the generalization that any transitive dominance condition can be specified. The addition of dominance-based aggregate attributes or “scores” for dominating tuples is not part of the Skyline operator and must be implemented separately.</p>
<p id="p-0071" num="0070">In order to implement the representation operator inside a SQL engine to support the REPRESENT clause in it full generality requires the ability to implement solvers for the Integer Programming problem. Several such industrial strength solvers can provide exact of approximate answers to mathematical optimization problem. While incorporating such a solver into the SQL query engine may be possible and indeed useful for a class of applications, the resulting operator will be very expensive to execute, particularly on large data sets that are typical in today's databases. Thus, a less expensive representation physical operator that provides a user-guided search may be advantageous in some instances.</p>
<p id="p-0072" num="0071">A user-guided search is efficient and accessible to developers. A simply greedy heuristic is used that examines one statement or tuple at a time in a single pass over the input. To achieve to user-guided search, the syntax of the REPREESNT clause is extended with an optional RANKING BY &lt;Expression-List&gt;. The full syntax of the extended REPRESENT clause is shown below.</p>
<p id="p-0073" num="0072">
<tables id="TABLE-US-00008" num="00008">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>REPRESENT WITH (PARTITIONING BY &lt;attr-list&gt;)</entry>
</row>
<row>
<entry/>
<entry>[MAXIMIZING|MINIMIZING]&lt;aggr-expr&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(GLOBAL CONSTRAINT &lt;global-constraint&gt;)*</entry>
</row>
<row>
<entry/>
<entry>(FILTER CONSTRAINT &lt;filter-constraint)*</entry>
</row>
<row>
<entry/>
<entry>(LOCAL CONSTRAINT &lt;local-constraint&gt;)*</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(RANKING BY &lt;Expression-List&gt;)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0074" num="0073">When the RANKING BY clause is specified, &lt;aggr-expr&gt; is limited to being COUNT(*). The RANKING BY specifies the order in which the input tuples should be accessed. <figref idref="DRAWINGS">FIG. 6</figref> is a flowchart representation of a method <b>600</b> that can be used to implement representation with RANKING BY. At <b>610</b> the constraints and optimization function are input. A counter N is initiated at <b>620</b>. At <b>630</b>-<b>645</b> the input tuples are scanned in the order specified by the &lt;Expression-List&gt; in RANKING BY. For example, RANKING BY (A+B) DESC means that the tuples must be considered for inclusion in the output in descending order of the expression (A+B) evaluated on each tuple. When the RANKING BY clause is not specified, the implementation for the general case of IP is invoked.</p>
<p id="p-0075" num="0074">Despite the restriction of only allowing &lt;aggr-expr&gt; to be COUNT(*), it may be possible for the application developer to map a query that requires maximizing/minimizing a SUM(attr) aggregate to a query that only maximizes/minimizes COUNT(*) but using RANKING BY. While the two queries are not equivalent, the quality and performance trade-off may be acceptable for the application. For example, if SUM(Attr) is to be maximized subject to Count(*) ≦k, this could be mapped e.g., to a maximizing COUNT(*) query with the constraint Count(*) ≦k and RANKING BY Attr DESC.</p>
<p id="p-0076" num="0075">The semantics of a query with RANKING BY can be procedurally described a follows. For the MINIMIZING case, before the input is scanned, all ≦ constraints are trivially satisfied. If the addition of the next tuple would violate any ≦ constraint (<b>650</b>), then the tuple is discarded. Otherwise, the tuple is added at <b>640</b> to the output. The method terminates as soon as all ≧ constraints are satisfied or the end of the input is reached at <b>650</b>, <b>660</b>. A final check is performed to see if all ≧ constraints are satisfied, and not, it is reported that a feasible solution was not found. The procedure for the MAXIMIZING case is identical except that the termination condition is only when the end of the input is reached. An alternative solution may be to use known algorithms for Top-K query processing.</p>
<p id="p-0077" num="0076">RANKING BY provides a particular way to specify how the general mathematical optimization problem should be solved. Another such approach is uniform random sampling or stratified sampling. It is possible to expose stratified sampling by combining PARTITIONING BY with a local equality constraint on Count(*). Likewise uniform random sampling exposed using a single global equality constraint. In these cases an aggregate is not maximized or minimized, but rather a random subset with the specified count is found.</p>
<p id="p-0078" num="0077">A specialized representation operator can be advantageous for a special class of queries. A query MAXIMIZING an aggregate over some attribute A subject to arbitrary filter constraints, together with a local constraint on Count(*), and a global constraint on Count(*) is proposed for consideration. Intuitively, such queries require selecting some set of tuples to maximize an objective, while being constrained by the total number of tuples to be selected, as well as having constraints on how these chosen tuples are distributed across the different partitions. There are many interesting queries that fall into this class, including for of the five example queries described above.</p>
<p id="p-0079" num="0078">An efficient operator to solve this special case exactly is as follows. When both the global and local constraints are of the form Count(*)≧c<sub>1</sub>, the solution is trivially the entire input. When the global constraint is Count(*)≧c<sub>1 </sub>and the local constraint is Count(*)≦c<sub>2</sub>, the global constraint is ignored and within each partition tuples are added to the output in descending order of attribute A until no more tuples can be added without violating the constraint. This approach takes advantage of the group-wise processing operator as discussed earlier to repeatedly execute this operation within each partition. The global constraint is checked at the end. When the global constraint is Count(*)≦c<sub>1 </sub>and the local constraint is Count(*)≧c<sub>2</sub>, each local constraint is minimally satisfied separately, i.e., exactly c<sub>2 </sub>tuples are selected from each partition in descending order of A. If the global constraint has already been violated, then no solution exists. Otherwise, the remaining tuples are picked form the input in descending order of A and added to the output as long as the global constraint is not violated. The final case when the global constraint is Count(*)≦c<sub>1 </sub>and the local constraint is Count(*)≦c<sub>2 </sub>(c<sub>2 </sub>must be ≦c<sub>1</sub>). In this case, the input is accessed in descending order of A and tuples are added as long as the local constraint of the partition is not violated. Tuples are no longer added when c<sub>1 </sub>tuples have been added to the output of the end of input is reached.</p>
<p id="p-0080" num="0079">Another class of queries for which optimal solutions can be implemented efficiently are queries that minimize Count(*). An exact solution can be obtained for the case when there are arbitrary filter conditions and at most one other constraint, either global or local. The input tuples are scanned in decreasing order of the attribute involved in the constraint, and are added to the output until the constraint is satisfied. If the constraint is a local constraint, the group-wise operator is used to execute this operation within each partition. Finally, when there are global and local constraints on the same attribute and in the same direction, an optimal solution can be similarly obtained.</p>
<p id="p-0081" num="0080">When there are a multiple number c global/local constraints, all of which are c “≧” constraints, the same ideas can be applied in a multi-pass fashion to achieve an approximate solution. The constraints are satisfied one by one. In the i<sup>th </sup>pass, tuples are scanned in descending order of the attribute in the i<sup>th </sup>constraint, and added to the output until that constraint is satisfied. Proceeding in this fashion until all the constraints are satisfied leads to a solution with an approximation ration of c, where c is the total number of constraints. An optimization that can lead to a better approximation ratio in practice is to perform the i<sup>th </sup>pass only over tuples that are not already in the output (and adjust the constraints to take into account the contribution from tuples that are already part of the output. Finally, it may be possible to get a better approximation ratio by ordering the constraints in an intelligent manner.</p>
<p id="h-0017" num="0000">Exemplary Operating Environment</p>
<p id="p-0082" num="0081">The query processing system <b>100</b> described above includes a workload summarization tool constructed in accordance with one exemplary embodiment of the invention. Most typically, the query processing system <b>100</b> is constructed in software executing on a computer system <b>20</b> (<figref idref="DRAWINGS">FIG. 9</figref>) such as a server computer which in turn is coupled to other servers or computers on a network. A computer system <b>20</b> that can serve as a server or query processing computer is depicted in <figref idref="DRAWINGS">FIG. 9</figref> and described in greater detail below.</p>
<p id="p-0083" num="0082"><figref idref="DRAWINGS">FIG. 9</figref> and the following discussion are intended to provide a brief, general description of a suitable computing environment in which the invention can be implemented. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer. Generally, program modules include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.</p>
<p id="p-0084" num="0083">With reference to <figref idref="DRAWINGS">FIG. 9</figref>, an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer <b>20</b>, including a processing unit <b>21</b>, a system memory <b>22</b>, and a system bus <b>23</b> that couples various system components including system memory <b>22</b> to processing unit <b>21</b>. System bus <b>23</b> may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. System memory <b>22</b> includes read only memory (ROM) <b>24</b> and random access memory (RAM) <b>25</b>. A basic input/output system (BIOS) <b>26</b>, containing the basic routines that help to transfer information between elements within personal computer <b>20</b>, such as during start-up, is stored in ROM <b>24</b>. Personal computer <b>20</b> further includes a hard disk drive <b>27</b> for reading from and writing to a hard disk, a magnetic disk drive <b>28</b> for reading from or writing to a removable magnetic disk <b>29</b> and an optical disc drive <b>30</b> for reading from or writing to a removable optical disc <b>31</b> such as a CD ROM or other optical media. Hard disk drive <b>27</b>, magnetic disk drive <b>28</b>, and optical disc drive <b>30</b> are connected to system bus <b>23</b> by a hard disk drive interface <b>32</b>, a magnetic disk drive interface <b>33</b>, and an optical drive interface <b>34</b>, respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for personal computer <b>20</b>. Although the exemplary environment described herein employs a hard disk, a removable magnetic disk <b>29</b> and a removable optical disc <b>31</b>, it should be appreciated by those skilled in the art that other types of computer-readable media which can store data that is accessible by computer, such as random access memories (RAMs), read only memories (ROMs), and the like may also be used in the exemplary operating environment.</p>
<p id="p-0085" num="0084">A number of program modules may be stored on the hard disk, magnetic disk <b>129</b>, optical disc <b>31</b>, ROM <b>24</b> or RAM <b>25</b>, including an operating system <b>35</b>, one or more application programs <b>36</b>, other program modules <b>37</b>, and program data <b>38</b>. A database system <b>55</b> may also be stored on the hard disk, magnetic disk <b>29</b>, optical disc <b>31</b>, ROM <b>24</b> or RAM <b>25</b>. A user may enter commands and information into personal computer <b>20</b> through input devices such as a keyboard <b>40</b> and pointing device <b>42</b>. Other input devices may include a microphone, stylus, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to processing unit <b>21</b> through a serial port interface <b>46</b> that is coupled to system bus <b>23</b>, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor <b>47</b> or other type of display device is also connected to system bus <b>23</b> via an interface, such as a video adapter <b>48</b>. In addition to the monitor, personal computers typically include other peripheral output devices such as speakers and printers.</p>
<p id="p-0086" num="0085">Personal computer <b>20</b> may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer <b>49</b>. Remote computer <b>49</b> may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to personal computer <b>20</b>, although only a memory storage device <b>50</b> has been illustrated in <figref idref="DRAWINGS">FIG. 9</figref>. The logical connections depicted in <figref idref="DRAWINGS">FIG. 9</figref> include local area network (LAN) <b>51</b> and a wide area network (WAN) <b>52</b>. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.</p>
<p id="p-0087" num="0086">When using a LAN networking environment, personal computer <b>20</b> is connected to local network <b>51</b> through a network interface or adapter <b>53</b>. When used in a WAN networking environment, personal computer <b>20</b> typically includes a modem <b>54</b> or other means for establishing communication over a wide area network <b>52</b>, such as the Internet. Modem <b>54</b>, which may be internal or external, is connected to system bus <b>23</b> via serial port interface <b>46</b> or a broadband connection. In a networked environment, program modules depicted relative to personal computer <b>20</b>, or portions thereof, may be stored in remote memory storage device <b>50</b>. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.</p>
<p id="p-0088" num="0087">It can be seen from the foregoing description that dominance and representation primitives can facilitate database object summarization, such as workload summarization. Although the present invention has been described with a degree of particularity, it is the intent that the invention include all modifications and alterations from the disclosed design falling within the spirit or scope of the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. At least one computer-readable media having instructions stored thereon for generating a database operator that selects a subset of a plurality of database objects having associated attributes, the database operator comprising:
<claim-text>a partial order specification module that receives a workload, the workload including a plurality of database objects, wherein the partial order specification module determines a first subset of database objects and a second subset of database objects in the plurality of database objects of the workload, the first subset of database objects comprising database objects that dominate at least one database object in the second subset of database objects; and</claim-text>
<claim-text>a database object subset selection module that generates a summarized workload by:
<claim-text>determining a third subset of database objects within the second subset of database objects that dominate at least one database object in the first subset of database objects;</claim-text>
<claim-text>combining the first subset of database objects and the third subset of database objects to generate the summarized workload;</claim-text>
</claim-text>
<claim-text>outputting the summarized workload.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The computer-readable media of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database operator further comprises a partitioning module that partitions the database objects into partitions based on a partitioning attribute; wherein database objects in the partition have equivalent values for the partitioning attribute and wherein the subset selection module applies the partial order separately for each partition.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The computer-readable media of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database operator further comprises a dominance aggregation module that, for a master database object, aggregates information about slave database objects that the master database object dominates.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The computer-readable media of <claim-ref idref="CLM-00003">claim 3</claim-ref> wherein information about a slave database object is distributed between two master database objects that dominate the slave object.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The computer-readable media of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database objects are database statements from a database workload presented according to a workload schema.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computer-readable media of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein when a database object in the second subset dominates the associated database object in the first subset, one of either the database object in the first subset or the database object in the second subset is eliminated from the corresponding subset.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The computer-readable media of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the partial order specification module inputs a partial order criterion comprising a conjunction of one or more transitive inequality conditions.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The computer-readable media of <claim-ref idref="CLM-00002">claim 2</claim-ref> wherein the partitioning module hashes database objects on the partitioning attribute.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer-readable media of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the plurality of database objects includes queries.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer-readable media of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the first subset of database objects includes a first query associated with a first condition and a second condition and the second subset of database objects includes a second query associated with the first condition.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer-readable media of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein the second query is not associated with the second condition.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer-readable media of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein attributes of the database objects are associated with at least one partial order condition.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computer-readable media of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein a partial order condition of a database object in the first plurality of database objects is a subset of a partial order condition of a database object in the second plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer-readable media of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the partial order condition of the database object in the first plurality of database objects and the database object in the second plurality of database objects include a grouping of attributes.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer-readable media of <claim-ref idref="CLM-00014">claim 14</claim-ref> wherein each of the attributes in the grouping of attributes of the database object in the second plurality of database objects is included in the grouping of attributes of the database object in the first plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer-readable media of <claim-ref idref="CLM-00015">claim 15</claim-ref> wherein at least one attribute in the grouping of attributes of the database object in the first plurality of database objects is not included in the attributes in the grouping of attributes of database object in the second plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer-readable media of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein a partial order condition of a database object in the first plurality of database objects is a prefix of a partial order condition of a database object in the second plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer-readable media of <claim-ref idref="CLM-00017">claim 17</claim-ref> the partial order condition associated with the database object in the first plurality of database objects includes an ordering of statements based on attributes associated with the database object in the first plurality of database objects and the partial order condition associated with database object in the second plurality of database objects includes an ordering of statements based on attributes associated with the database object in the second plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer-readable media of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein each of the partial order conditions includes an ordering of statements based on attributes associated with the corresponding database object.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer-readable media of <claim-ref idref="CLM-00019">claim 19</claim-ref> wherein each of the attributes associated with the database object in the second plurality of database objects is included in the attributes associated with the database object in the first plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The computer-readable media of <claim-ref idref="CLM-00020">claim 20</claim-ref> wherein at least one attribute associated with the database object in the first plurality of database objects is not included in the attributes associated with the database object in the second plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A method that selects a subset of database objects from a plurality of database objects having associated attributes comprising:
<claim-text>accessing two or more database objects from the plurality of database objects, wherein the database objects comprise database statements from a database workload;</claim-text>
<claim-text>inputting a partial order criterion for at least one attribute associated with the two or more database objects;</claim-text>
<claim-text>applying the partial order criteria to the two or more database objects to identify at least one master database object, the at least one master database object dominating at least one other database object in the plurality of database objects;</claim-text>
<claim-text>identifying a subset of master database objects that are dominated by at least one other database object in the plurality of database objects;</claim-text>
<claim-text>generating a subset of database objects including the identified master database objects dominating at least one other database object in the plurality of database objects minus the subset of master database objects that are dominated by at least one other database object in the plurality of database objects; and</claim-text>
<claim-text>outputting the generated subset of database objects.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> comprising partitioning the plurality of database objects into partitions based on a partitioning attribute such that database objects in the partition have equivalent values for the partitioning attribute and wherein the partial order criteria is applied separately to database objects in each partition.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> comprising aggregating information about slave database objects that are dominated by an associated master database object and are not included in the subset.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> comprising selecting one of two database objects for inclusion in the subset if each of the two database objects dominates the other.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The method of <claim-ref idref="CLM-00023">claim 23</claim-ref> comprising hashing the database objects on the partitioning attribute.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. One or more computer-readable media comprising computer executable instructions for performing the method of <claim-ref idref="CLM-00022">claim 22</claim-ref>.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein the step of applying comprises:
<claim-text>identifying the at least one master database object based on a condition based on attributes of the at least one master database object; and</claim-text>
<claim-text>identifying the at least one other database object in the plurality of database objects, wherein the at least one other database object in the plurality of database objects includes a condition based on at least one attribute.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The method of <claim-ref idref="CLM-00028">claim 28</claim-ref> wherein the condition associated with the at least one master database object comprises a subset of the condition associated with the at least one other database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The method of <claim-ref idref="CLM-00028">claim 28</claim-ref> wherein each of the at least one attributes associated with the condition of the at least one other database object is included in the attributes of the at least one master database object.</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The method of <claim-ref idref="CLM-00030">claim 30</claim-ref> wherein at least one attribute of the at least one master database object is not included in the at least one attribute associated with the condition of the at least one other database object.</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The method of <claim-ref idref="CLM-00028">claim 28</claim-ref> wherein the condition associated with the at least one master database object is a prefix of the condition associated with the at least one other database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00033" num="00033">
<claim-text>33. The method of <claim-ref idref="CLM-00031">claim 31</claim-ref> wherein the condition includes an ordering of the database objects.</claim-text>
</claim>
<claim id="CLM-00034" num="00034">
<claim-text>34. The method of <claim-ref idref="CLM-00033">claim 33</claim-ref> wherein ordering of the master database object is based on a first plurality of attributes and ordering of the at least one other database object is based on at least one attribute.</claim-text>
</claim>
<claim id="CLM-00035" num="00035">
<claim-text>35. The method of <claim-ref idref="CLM-00033">claim 33</claim-ref> wherein a subset of the plurality of attributes of the master database object includes each of the at least one attribute of the at least one other database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00036" num="00036">
<claim-text>36. The method of <claim-ref idref="CLM-00035">claim 35</claim-ref> wherein at least one attribute in the plurality of attributes of the master database object is not included in the at least one attribute of the at least one other database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00037" num="00037">
<claim-text>37. One or more computer readable media having computer-executable instructions stored thereon for selecting a subset of a plurality of database objects having associated attributes, the instructions comprising:
<claim-text>inputting a partial order criterion for an attribute to determine a master database object in the plurality of database objects that dominates at least one aassociated slave database object in the plurality of database objects, wherein the database objects comprise database statements from a database workload; and</claim-text>
<claim-text>applying the partial order criterion to the database object attributes to identify a first subset of database objects and a second subset of database objects in the plurality of database objects, the first subset including master database objects and the second subset including associated slave database objects;</claim-text>
<claim-text>eliminating all slave database objects that do not dominate their associated master database object from the second subset to obtain a modified second subset of database objects;</claim-text>
<claim-text>generating a third subset of the plurality of database objects including the first subset of database objects and the modified second subset of database objects; and</claim-text>
<claim-text>outputting the third subset of the plurality of database objects.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00038" num="00038">
<claim-text>38. The computer readable media of <claim-ref idref="CLM-00037">claim 37</claim-ref> wherein the instructions comprise partitioning the database objects into partitions based on a partitioning attribute; wherein database objects in the partition have equivalent values for the partitioning attribute and wherein the filtering module applies the partial order separately for each partition.</claim-text>
</claim>
<claim id="CLM-00039" num="00039">
<claim-text>39. The computer readable media of <claim-ref idref="CLM-00037">claim 37</claim-ref> wherein the instructions comprise aggregating information about slave database objects that the master database object dominates.</claim-text>
</claim>
<claim id="CLM-00040" num="00040">
<claim-text>40. The computer readable media of <claim-ref idref="CLM-00039">claim 39</claim-ref> wherein the information about a slave database object is distributed between two master database objects that dominate the slave object.</claim-text>
</claim>
<claim id="CLM-00041" num="00041">
<claim-text>41. The computer readable media of <claim-ref idref="CLM-00037">claim 37</claim-ref> wherein the database objects are database statements from a database workload presented according to a workload schema.</claim-text>
</claim>
<claim id="CLM-00042" num="00042">
<claim-text>42. The computer readable media of <claim-ref idref="CLM-00037">claim 37</claim-ref> wherein when a slave database object dominates the associated master database object, one of either the slave or master database objects is eliminated from the subset.</claim-text>
</claim>
<claim id="CLM-00043" num="00043">
<claim-text>43. The computer readable media of <claim-ref idref="CLM-00037">claim 37</claim-ref> wherein the partial order criterion comprises a conjunction of one or more transitive inequality conditions.</claim-text>
</claim>
<claim id="CLM-00044" num="00044">
<claim-text>44. The computer readable media of <claim-ref idref="CLM-00038">claim 38</claim-ref> wherein the instructions comprise hashing the database objects on the partitioning attribute.</claim-text>
</claim>
<claim id="CLM-00045" num="00045">
<claim-text>45. The computer readable media of <claim-ref idref="CLM-00037">claim 37</claim-ref> wherein the step of applying comprises:
<claim-text>identifying the at least one master database object based on a condition based on attributes of the at least one master database object; and</claim-text>
<claim-text>identifying the at least one associated slave database object in the plurality of database objects, wherein the at least one associated slave database object in the plurality of database objects includes a condition based on at least one attribute.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00046" num="00046">
<claim-text>46. The method of <claim-ref idref="CLM-00045">claim 45</claim-ref> wherein the condition associated with the at least one master database object comprises a subset of the condition associated with the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00047" num="00047">
<claim-text>47. The method of <claim-ref idref="CLM-00045">claim 45</claim-ref> wherein the condition associated with the at least one master database object is a prefix of the condition associated with the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00048" num="00048">
<claim-text>48. The method of <claim-ref idref="CLM-00045">claim 45</claim-ref> wherein each of the at least one attributes associated with the condition of the at least one associated slave database object is included in the attributes of the at least one master database object.</claim-text>
</claim>
<claim id="CLM-00049" num="00049">
<claim-text>49. The method of <claim-ref idref="CLM-00048">claim 48</claim-ref> wherein at least one attribute of the at least one master database object is not included in the at least one attribute associated with the condition of the at least one associated slave database object.</claim-text>
</claim>
<claim id="CLM-00050" num="00050">
<claim-text>50. The method of <claim-ref idref="CLM-00049">claim 49</claim-ref> wherein the condition includes an ordering of the database objects.</claim-text>
</claim>
<claim id="CLM-00051" num="00051">
<claim-text>51. The method of <claim-ref idref="CLM-00050">claim 50</claim-ref> wherein ordering of the master database object is based on a first plurality of attributes and ordering of the at least one associated slave database object is based on at least one attribute.</claim-text>
</claim>
<claim id="CLM-00052" num="00052">
<claim-text>52. The method of <claim-ref idref="CLM-00050">claim 50</claim-ref> wherein a subset of the plurality of attributes of the master database object includes each of the at least one attribute of the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00053" num="00053">
<claim-text>53. The method of <claim-ref idref="CLM-00052">claim 52</claim-ref> wherein at least one attribute in the plurality of attributes of the master database object is not included in the at least one attribute of the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00054" num="00054">
<claim-text>54. An apparatus for selecting a subset of database objects from a plurality of database objects having associated attributes comprising:
<claim-text>at least one processor;</claim-text>
<claim-text>a component for accessing two or more database objects from the plurality of database objects;</claim-text>
<claim-text>a component for inputting a partial order criterion for at least one attribute associated with the two or more database objects;</claim-text>
<claim-text>a component for applying the partial order criteria to the two or more database objects to identify at least one master database object, the at least one master database object dominating at least one other database object in the plurality of database objects, wherein the database objects comprise database statements from a database workload;</claim-text>
<claim-text>a component for identifying a subset of master database objects that are dominated by at least one other database object in the plurality of database objects;</claim-text>
<claim-text>a component for generating a subset of database objects including the identified master database objects dominating at least one other database object in the plurality of database objects minus the subset of master database objects that are dominated by at least one other database object in the plurality of database objects; and</claim-text>
<claim-text>a component for outputting the generated subset of database objects.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00055" num="00055">
<claim-text>55. The apparatus of <claim-ref idref="CLM-00054">claim 54</claim-ref> comprising a component for partitioning the plurality of database objects into partitions based on a partitioning attribute such that database objects in the partition have equivalent values for the partitioning attribute and wherein the means for applying the partial order criteria applies the criteria separately to database objects in each partition.</claim-text>
</claim>
<claim id="CLM-00056" num="00056">
<claim-text>56. The apparatus of <claim-ref idref="CLM-00054">claim 54</claim-ref> comprising a component for aggregating information about slave database objects that are dominated by an associated master database object and are not included in the subset.</claim-text>
</claim>
<claim id="CLM-00057" num="00057">
<claim-text>57. The apparatus of <claim-ref idref="CLM-00054">claim 54</claim-ref> comprising a component for selecting one of two database objects for inclusion in the subset if each of the two database objects dominates the other.</claim-text>
</claim>
<claim id="CLM-00058" num="00058">
<claim-text>58. The apparatus of <claim-ref idref="CLM-00055">claim 55</claim-ref> comprising a component for hashing the database objects on the partitioning attribute.</claim-text>
</claim>
<claim id="CLM-00059" num="00059">
<claim-text>59. The apparatus of <claim-ref idref="CLM-00054">claim 54</claim-ref> wherein the component for applying further identifies the at least one master database object based on a condition based on attributes of the at least one master database object and identifies the at least one associated slave database object in the plurality of database objects, and wherein the at least one associated slave database object in the plurality of database objects includes a condition based on at least one attribute.</claim-text>
</claim>
<claim id="CLM-00060" num="00060">
<claim-text>60. The apparatus of <claim-ref idref="CLM-00059">claim 59</claim-ref> wherein the condition associated with the at least one master database object comprises a subset of the condition associated with the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00061" num="00061">
<claim-text>61. The apparatus of <claim-ref idref="CLM-00059">claim 59</claim-ref> wherein the condition associated with the at least one master database object is a prefix of the condition associated with the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00062" num="00062">
<claim-text>62. The apparatus of <claim-ref idref="CLM-00059">claim 59</claim-ref> wherein each of the at least one attribute associated with the condition of the at least one associated slave database object is included in the attributes of the at least one master database object.</claim-text>
</claim>
<claim id="CLM-00063" num="00063">
<claim-text>63. The apparatus of <claim-ref idref="CLM-00062">claim 62</claim-ref> wherein at least one attribute of the at least one master database object is not included in the at least one attribute associated with the condition of the at least one associated slave database object.</claim-text>
</claim>
<claim id="CLM-00064" num="00064">
<claim-text>64. The apparatus of <claim-ref idref="CLM-00063">claim 63</claim-ref> wherein the condition includes an ordering of the database objects.</claim-text>
</claim>
<claim id="CLM-00065" num="00065">
<claim-text>65. The apparatus of <claim-ref idref="CLM-00064">claim 64</claim-ref> wherein ordering of the master database object is based on a first plurality of attributes and ordering of the at least one associated slave database object is based on at least one attribute.</claim-text>
</claim>
<claim id="CLM-00066" num="00066">
<claim-text>66. The apparatus of <claim-ref idref="CLM-00064">claim 64</claim-ref> wherein a subset of the plurality of attributes of the master database object includes each of the at least one attribute of the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
<claim id="CLM-00067" num="00067">
<claim-text>67. The apparatus of <claim-ref idref="CLM-00066">claim 66</claim-ref> wherein at least one attribute in the plurality of attributes of the master database object is not included in the at least one attribute of the at least one associated slave database object in the plurality of database objects.</claim-text>
</claim>
</claims>
</us-patent-grant>
