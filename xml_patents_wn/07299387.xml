<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299387-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299387</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10971619</doc-number>
<date>20041021</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>TW</country>
<doc-number>92131507 A</doc-number>
<date>20031111</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>618</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>11</class>
<subclass>C</subclass>
<main-group>29</main-group>
<subgroup>18</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>11</class>
<subclass>C</subclass>
<main-group>29</main-group>
<subgroup>40</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714702</main-classification>
<further-classification>714701</further-classification>
</classification-national>
<invention-title id="d0e71">Address generator for block interleaving</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6691261</doc-number>
<kind>B1</kind>
<name>Ovalekar</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714701</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6748561</doc-number>
<kind>B2</kind>
<name>Prasad</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714702</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6986081</doc-number>
<kind>B1</kind>
<name>Furutani</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714701</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>JP</country>
<doc-number>01293074</doc-number>
<kind>A</kind>
<date>19891100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00005">
<othercit>Mathew et al., Algorithmic Foundations for a Parallel Vector Access Memory System, Jul. 2000, Proceedings of the twelfth annual ACM symposium on Parallel algorithms and architectures SPAA'00, ACM Press, pp. 156-165.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
</references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050102599</doc-number>
<kind>A1</kind>
<date>20050512</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Yang</last-name>
<first-name>Ping-Chung</first-name>
<address>
<city>Jiji Township, Nantou County</city>
<country>TW</country>
</address>
</addressbook>
<nationality>
<country>TW</country>
</nationality>
<residence>
<country>TW</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Thomas, Kayden, Horstemeyer &amp; Risley</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Benq Corporation</orgname>
<role>03</role>
<address>
<city>Taoyuan</city>
<country>TW</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Britt</last-name>
<first-name>Cynthia</first-name>
<department>2117</department>
</primary-examiner>
<assistant-examiner>
<last-name>Gandhi</last-name>
<first-name>Dipakkumar</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A block interleaving/de-interleaving method and address generator thereof. The block interleaver segments the coded symbols into blocks according to a predetermined column value (C). The interleaver reads the coded symbols of each block by jumping according to the corresponding values (T<sub>0</sub>:T<sub>C-1</sub>) of a sequence matching table and the column value, and writes the values in sequence. The block de-interleaver reads the coded symbols sequentially, and re-assembles the coded symbols in the original order according to the same column value (C) and sequence matching table as the interleaver.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="103.80mm" wi="245.96mm" file="US07299387-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="228.09mm" wi="120.31mm" file="US07299387-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="237.57mm" wi="128.19mm" file="US07299387-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="247.06mm" wi="118.79mm" orientation="landscape" file="US07299387-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="245.36mm" wi="172.80mm" orientation="landscape" file="US07299387-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">The present invention relates to an interleaving and de-interleaving method of a communication system, and more specifically, to a block interleaving and de-interleaving method and address generator thereof.</p>
<p id="p-0003" num="0002">The main function of channel coding is to detect and correct errors induced by random noise occurring in transmission in the wireless communication system. Transmission errors happen randomly and are thus usually distributed evenly in the data. Burst error, however sometimes occurs during transmission, and is likely to exceed the error detection or error correction abilities of the encoder/decoder, requiring retransmission if the errors cannot be corrected. Interleaving is a method of improving burst error correction ability. The interleaving process re-orders data (i.e. the coded symbols) before transmission. When a burst error occurs during transmission, errors are dispersed by performing the corresponding de-interleaving process. The encoder is able to improve the error correction ability by reducing the likelihood of long consecutive errors. The address generator for interleaving, or the interleaver, is an apparatus that changes the order of the coded symbols in the transmitter, whereas the address generator for de-interleaving, or the de-interleaver, is a corresponding apparatus assembling the coded symbols into their original order.</p>
<p id="p-0004" num="0003">Block interleaving is one of the most common and easily performed interleaving methods. The block interleaving method permutes the coded symbols in blocks from the encoder, and rearranges the coded symbols. Permutation is normally performed by filling a matrix with coded sequences by row, then outputting to the modulator by column. As shown in <figref idref="DRAWINGS">FIGS. 1A and 1B</figref>, block interleaving is explained using a matrix with C columns and R rows. <figref idref="DRAWINGS">FIG. 1A</figref> shows the filling order of the matrix at the transmitter, wherein the coded symbols {0, 1, 2, 3, 4, 5, . . . , M-3,M-2,M-1} are filled into the matrix by row. The total number of coded symbols (M) is 26, and the column value (C) is 4 in this example. The row value (R) is thus 6, the whole number obtained from dividing 26 by 4, and the remainder (W) is 2. As shown in <figref idref="DRAWINGS">FIG. 1A</figref>, there are R complete rows and an incomplete row, which is the (R+1)<sup>st </sup>row with only W coded symbols. As shown in <figref idref="DRAWINGS">FIG. 1B</figref>, the sequence of columns is then permuted before input to the modulator. In this example, the block interleaver swaps the second and the third columns. The interleaving operation is accomplished by outputting the coded symbols {0, 4, 8, . . . , 2, 6, 10, . . . 1, 5, 9, . . . 3, 7, 11, . . . } from the matrix by column. At the receiver, the de-interleaver performs the inverse operation.</p>
<p id="p-0005" num="0004">In a typical case, both the interleaver and de-interleaver read the coded symbols from the memory cells, and then write the coded symbols after performing interleaving or de-interleaving into other memory cells. This kind of interleaving or de-interleaving operation requires accessing the memory twice for each coded symbol. Since the M coded symbols must be filled before they can be read out, twice as many memory cells as coded symbols (<b>2</b>M) are required. Furthermore, since the interleaver writes the coded symbols by row and reads the coded symbols by column, a complete column can only be obtained for input to the modulator when the first coded symbol of the last row is filled in the matrix. In other words, C(R−1)+1 memory cells must be filled before the interleaver begins input of the coded symbols to the modulator. A minimum delay time is therefore the time required to access the memory C(R−1)+1 times.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">An interleaving/de-interleaving method that computes some of the initial output addresses while reading the coded symbols, to ensure that the block interleaving/de-interleaving is accomplished with the shortest delay is provided. The interleaver of the present invention reads a coded symbol once and immediately computes the address for output without waiting until the coded symbols in the last row of the matrix have been read. At the transmitter, the interleaver reads the coded symbols by jumping, and writes the initial output addresses in order. The interleaving operations which fill and are read out from the matrix are replaced with jumping input access. The jumping operation is computed according to the provided algorithm. At the receiver, the de-interleaver performs the inverse operation of reading the coded symbols in order, but writes the initial output addresses by jumping. The de-interleaving operation for filling and reading out from the matrix is replaced with a jumping output sequence. As a result, the block interleaving/de-interleaving method requires only one read/write operation per coded symbol, eliminating the (R−1)+1 delay caused by accessing memory. The memory cells for storing the input coded symbols can be overlap with the memory cells for storing the output coded symbols. Furthermore, the interleaving and de-interleaving method is easily implemented, and the provided address generator can perform both interleaving and de-interleaving.</p>
<p id="p-0007" num="0006">An embodiment of the block interleaving method performs interleaving for M coded symbols in a memory with two blocks, one for reading and another for writing. The write memory block has memory cells starting with an initial output address, and the read memory block has memory cells starting with an initial input address. The first coded symbol is stored in the initial input address, and the remaining coded symbols are stored successively in the memory cells after the initial input address. Both ends, performing interleaving and de-interleaving agree on a column value C for segmenting the M coded symbols, and a sequence matching table [T<sub>0</sub>, T<sub>1</sub>, . . . , T<sub>C-1</sub>] comprising C corresponding values for appointing the permutation sequence. Each of the corresponding values in the sequence matching table is treated as a reference value successively, and the coded symbols in the read memory block are read out from the reference value with a fixed spacing C. For example, if the current reference value is T<sub>1</sub>, the coded symbols {T<sub>1</sub>, T<sub>1</sub>+C, T<sub>1</sub>+2C, . . . } are read out. The coded symbols are then written to the memory cells of the write memory block starting from the initial output address according to the read order. The above reading and writing processes are repeated until all the corresponding values [T<sub>0</sub>, T<sub>1</sub>, . . . , T<sub>C-1</sub>] have been selected as the reference value.</p>
<p id="p-0008" num="0007">The column value C is used to segment the M coded symbols into R blocks with W coded symbols as remainder, wherein each block includes C coded symbols and a (R+1)<sup>st </sup>block includes W coded symbols. Normally only R corresponding coded symbols are read out according to each reference value, however if the reference value is less than the remainder W, an extra corresponding coded symbol in the (R+1)<sup>st </sup>block is also read out.</p>
<p id="p-0009" num="0008">An embodiment of the block de-interleaving method performs de-interleaving for M coded symbols in a memory with two blocks, one for reading and another for writing. The write memory block has memory cells starting with an initial output address, and the read memory block has memory cells starting with an initial input address. The first coded symbol is stored in the initial input address, and the rest of the coded symbols are stored successively in the memory cells after the initial input address. The column value C and the sequence matching table are the same as on the side performing the interleaving operation. The M coded symbols are read out from the read memory block sequentially, and segmented into C blocks, and each block corresponding to each corresponding value of the sequence matching table [T<sub>0</sub>, T<sub>1</sub>, . . . , T<sub>C-1</sub>]. The value corresponding to each block is selected as a reference value sequentially, and from the reference value, the coded symbols to be read are chosen by jumping according to the sequence matching table.</p>
<p id="p-0010" num="0009">The de-interleaving method also comprises comparing the value corresponding to each block with the remainder (W) to determine the number of coded symbols in the block. If the corresponding value of the block is less than the remainder (W), the block has R+1 coded symbols, otherwise the block has R coded symbols. Both interleaving and de-interleaving methods allow the read memory block to overlap up to R memory cells with the write memory block.</p>
<p id="p-0011" num="0010">An address generator to perform interleaving and de-interleaving on M coded symbols is also provided. The address generator comprises an input block, a memory overlap block, a computing block, and an output block. The input block receives input parameters such as initial input address, total number of coded symbols (M), column number (C), clock signal, and reset signal. The memory overlap block coupled to the input block computes an initial output address according to the initial input addresses, M, and C. The computing block coupled to the input block and the memory overlap block computes read and write addresses for each of the M coded symbols. The output block coupled to the computing block outputs a read address array and a write address array. The computing block computes an input address index and an output address index for each of the M coded symbols in two loops, combining the initial input address, the initial output address, and a sequence matching table to obtain the read and write addresses for each of the M coded symbols.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011">The invention can be more fully understood by reading the subsequent detailed description in conjunction with the examples and references made to the accompanying drawings, wherein:</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1A</figref> illustrates an example of coded symbols arranged in a matrix before performance of the block interleaving operation.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 1B</figref> illustrates an example of coded symbols arranged in a matrix after performance of the block interleaving operation.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 2</figref> illustrates an example of reading and writing the coded symbols according to an embodiment of the interleaving method.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram illustrating an embodiment of the address generator.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 4</figref> is a logic circuit diagram illustrating an embodiment of the address generator.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIGS. 1A</figref>, <b>1</b>B and <b>2</b> illustrate an embodiment of a simple example of block interleaving and de-interleaving operations. The concept of block interleaving is based on M coded symbols arrayed in a matrix in C columns and R rows, and then swapping the columns according to a sequence matching table. <figref idref="DRAWINGS">FIGS. 1A and 1B</figref> represent a sequence of 26 coded symbols (<b>0</b>˜<b>25</b>) which are filled into a matrix with 4 columns. The total number of coded symbols <b>26</b> is not a multiple of the column value <b>4</b>, thus the whole number R obtained from dividing 26 by 4 is 6 (R=M/C), and the remainder W is 2 (W=M%C). As shown in <figref idref="DRAWINGS">FIGS. 1A and 1B</figref>, the coded symbols do not fill the matrix completely as there are W tail elements in the last row. The sequence matching table [T<sub>0</sub>, T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>] is (0, 2, 1, 3) in this example, and the new order of the coded symbols in the matrix after interleaving is shown in <figref idref="DRAWINGS">FIG. 1B</figref>. The sequences of the first (column <b>0</b>) and the last (column <b>3</b>) columns remain the same, whereas the sequences of the second (column <b>1</b>) and third (column <b>2</b>) columns are swapped. After column permutation, the coded symbols are output by column, so the coded symbols in the first column of the new order are output first, followed by the second column, and so on. The output sequence thus becomes {0, 4, . . . , 2, 6, . . . 1, 5, . . . 3, 7, . . . 19, 23}. Both the column value C and the permutation sequence of column (i.e. the sequence matching table) correspond in both the interleaver and de-interleaver.</p>
<p id="p-0019" num="0018">The de-interleaver recovers the order of the coded symbols. The received coded symbols are first filled in the matrix by row as shown in <figref idref="DRAWINGS">FIG. 1B</figref>, and then the sequence of columns is rearranged according to the sequence matching table to recover the matrix shown in <figref idref="DRAWINGS">FIG. 1A</figref>. The coded symbols are read by row, from the first row to the last row.</p>
<p id="p-0020" num="0019">After clarifying the desired effects of block interleaving and de-interleaving operations, <figref idref="DRAWINGS">FIG. 2</figref> illustrates an embodiment of the interleaving and de-interleaving method. The same example comprising 26 encoded symbols (M=26) and 4 columns (C=4) is used here, and the relative row value and the remainder are 6 and 2 respectively (R=6, W=2). A total of 26+26−6=46 (M+M−R) memory cells are required to store the coded symbols during this interleaving/de-interleaving operation. The memory with 46 memory cells is divided into two blocks, each comprising 26 memory cells, read memory block <b>220</b> and write memory block <b>200</b>, wherein 6 (R) memory cells from Address <b>20</b> to Address <b>25</b> overlap. The overlapping memory cells indicate that some memory cells are reusable.</p>
<p id="p-0021" num="0020">As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the four steps (Step A˜Step D) describe the interleaving method. In Step A, the 26 coded symbols are stored in the read memory block <b>220</b> sequentially, the first coded symbol stored in Address <b>20</b> and the last coded symbol in Address <b>45</b>. In some embodiments, the coded symbols are read out by jumping according to a predetermined pattern, and then written to the write memory block sequentially. When a coded symbol is written in the write memory block, it is immediately output without waiting for the block interleaving to be completed.</p>
<p id="p-0022" num="0021">Step B describes the process of reading and writing the coded symbols related to the first corresponding value in the sequence matching table. Each corresponding value in the sequence matching table is individually selected as the reference value. When reading the coded symbols related to a reference value from the read memory block <b>220</b>, the coded symbol corresponding to the reference value is read, and then jumps C memory cells to read the subsequent coded symbols until the end of the coded sequence. In this example, the first corresponding value T<sub>0 </sub>is 0, the column value C is 4, and the start address of the read memory block <b>220</b> is 20. Accordingly, the first coded symbol corresponding to T<sub>0 </sub>is stored in Address T<sub>0</sub>+20, Address <b>20</b> in this case. The coded symbols stored in Address {T<sub>0</sub>+20+4, T<sub>0</sub>+20+4*2, T<sub>0</sub>+20+4*3, . . . } are read thereafter, {24, 28, 32, 36, 40, 44} in this example. The coded symbols are written in the write memory block in the reading order. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, Step B, the first 7 coded symbols read out are stored in Address <b>0</b> to <b>6</b>.</p>
<p id="p-0023" num="0022">The second corresponding value T<sub>1 </sub>becomes the next reference value, and T<sub>1 </sub>is 2 in this example, such that coded symbol <b>2</b> is read from Address T<sub>1</sub>+20 (<b>22</b>) and the coded symbols following the same rule of jumping to read the fourth coded symbol after the previous coded symbol until the end of the coded sequence. As shown in Step C, before performing the reading and writing processes for the last corresponding value, the non-overlapping part of the write memory block <b>200</b> is filled completely. The last corresponding value T<sub>3 </sub>indicates the read coded symbol <b>3</b> in Address <b>23</b>, and the overlapping memory cells become empty after the coded symbol <b>3</b> is read out. This ensures that all the data in the overlapping memory is read out before rewriting. Step D illustrates successful block interleaving as all the coded symbols are stored in the write memory block <b>200</b> in the desired order according to the sequence matching table.</p>
<p id="p-0024" num="0023">As shown in the matrix of <figref idref="DRAWINGS">FIG. 1A</figref>, however, it is possible to have either 6 (R) or 7 (R+1) coded symbols in a column. In order to consider the tail elements in the (R+1)<sup>st </sup>row, determination of the existence of a coded symbol in the (R+1)<sup>st </sup>row is necessary for each corresponding value of the sequence matching table. A simple determination method is to compare each of the corresponding values with the remainder W, and if the corresponding value is less than the remainder, the (R+1)<sup>st </sup>coded symbol must be read, otherwise each corresponding value only corresponds to R coded symbols.</p>
<p id="p-0025" num="0024">For example, since the second corresponding value <b>2</b> is not less than the remainder 2 in this case, it only reads 6 coded symbols, whereas the third corresponding value <b>1</b> is less than the remainder 2, so 7 coded symbols are read out. The maximum number of overlapping memory cells is the row value (R) calculated by dividing the total number of coded symbols by the column value. The initial output address (Address <b>0</b>), the starting address of the write memory block, is calculated by subtracting the total number of coded symbols (M) from the initial input address (Address <b>20</b>), then adding the row value (R).</p>
<p id="p-0026" num="0025">Similarly, the coded symbols for de-interleaving are stored in the read memory block <b>220</b>, and are read out sequentially from the initial input address (Address <b>20</b>). The writing operation for the de-interleaver is similar to the reading operation for the interleaver. Each corresponding value of the sequence matching table is individually selected as the reference value. The de-interleaver writes the coded symbols corresponding to each corresponding value into the write memory block <b>200</b> by jumping every R address. For example, if the first corresponding value is 0, the initial output address (the starting address of the write memory block) is also 0. There are seven corresponding coded symbols because the first corresponding value (T<sub>0</sub>) 0 is less than the remainder (W) 2. The first seven coded symbols are therefore stored in Address 0 (T<sub>0</sub>), 4 (T<sub>0</sub>+R), 8 (T<sub>0</sub>+2R), 12 (T<sub>0</sub>+3R), 16 (T<sub>0</sub>+4R), 20 (T<sub>0</sub>+5R), 24 (T<sub>0</sub>+6R). The second corresponding value (T<sub>1</sub>) 2 is not less than the remainder, thus the next six coded symbols are stored in Address 2 (T<sub>1</sub>), 6 (T<sub>0</sub>+R), 10 (T<sub>0</sub>+2R), 14 (T<sub>0</sub>+3R), 18 (T<sub>0</sub>+4R), 22 (T<sub>0</sub>+5R). Subsequent to the reading and writing operations for all the corresponding values in the sequence matching table, the write memory block stores the coded symbols in the original sequence {0, 1, 2, . . . , 24, 25}.</p>
<p id="p-0027" num="0026">An address generator performing the above interleaving and de-interleaving operations is also provided. <figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of the address generator in the present embodiment. An input block <b>300</b> of the address generator receives parameters comprising initial input address <b>308</b>, total number of coded symbols (M) <b>310</b>, column value (C) <b>312</b>, clock signal <b>314</b>, and reset signal <b>316</b>. The input block <b>300</b> divides the total number of coded symbols <b>310</b> by the column value <b>312</b> to obtain a whole number R (M/C) and a remainder W (M%C). A memory overlap block <b>304</b> receives an initial input address <b>308</b>, total number of coded symbols <b>310</b>, and the remainder W for calculating an initial output address.</p>
<p id="p-0028" num="0027">A computing block <b>302</b> in the address generator comprises two loops and a sequence matching table, and the computing block <b>302</b> calculates an input address index and an output address index for each coded symbol according to the corresponding value of the sequence matching table. The initial input address <b>308</b> acts as a reference to the input address index of each coded symbol, and a corresponding read address is obtained by adding the initial input address. <b>308</b> and the input address index. Similarly, the initial output address acts as the reference to the output address index of each coded symbol, and a corresponding write address is the sum of the initial output address and the output address index. The computing block <b>302</b> further comprises an offset block for address correction. The offset block detects if the corresponding value is less than the remainder (W), in order to determine whether it requires reading of an extra coded symbol, and the offset block accumulates the offset to ensure the tail elements are correctly considered in the calculation. An output block <b>306</b> outputs the calculated addresses in a read address array <b>320</b> and a write address array <b>318</b>.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 4</figref> illustrates an example of the logic circuit diagram for realizing the address generator shown in <figref idref="DRAWINGS">FIG. 3</figref>. Calculation block <b>400</b> divides total number of coded number <b>410</b> by column value <b>412</b> to obtain a whole number R and a remainder W. Loops <b>402</b> and <b>404</b> combine the offset block <b>406</b> to compute read address <b>420</b> and write address <b>418</b> for each coded symbol. A reset signal <b>416</b> sets all logic units such as registers, delay flip-flop (d flip-flop), and loops at the start of every interleaving/de-interleaving operation.</p>
<p id="p-0030" num="0029">In some embodiments, the block interleaving/de-interleaving method can be implemented using a simple program, and the address generator can also be constructed according to the program. An example of such program is shown below, where C is the predetermined column value, R is the whole number obtained from dividing the total number of coded symbols by the column value C, and W is the remainder of the division. Z is an offsetting accumulation of address for correcting the output/input address index, and T_table is the sequence matching table comprising C corresponding values.</p>
<p id="p-0031" num="0030">At the transmitter, a possible program performing the block interleaving method is represented below:</p>
<p id="p-0032" num="0031">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>Z=0;</entry>
</row>
<row>
<entry/>
<entry>for(y=0;y&lt;C;y++)</entry>
</row>
<row>
<entry/>
<entry>{</entry>
</row>
<row>
<entry/>
<entry>  T=T_table[y];</entry>
</row>
<row>
<entry/>
<entry>  for(x=0;x&lt;R;x++)</entry>
</row>
<row>
<entry/>
<entry>  {</entry>
</row>
<row>
<entry/>
<entry>    out[y*R+x+Z]=in[x*C+T];</entry>
</row>
<row>
<entry/>
<entry>  }</entry>
</row>
<row>
<entry/>
<entry>  if(T&lt;W)</entry>
</row>
<row>
<entry/>
<entry>  {</entry>
</row>
<row>
<entry/>
<entry>    Z++;</entry>
</row>
<row>
<entry/>
<entry>    out[y*R+x+Z]=in[x*C+T];</entry>
</row>
<row>
<entry/>
<entry>  }</entry>
</row>
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0033" num="0032">At the receiver, a possible program performing the block de-interleaving method is represented below:</p>
<p id="p-0034" num="0033">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>Z=0;</entry>
</row>
<row>
<entry/>
<entry>for(y=0;y&lt;C;y++)</entry>
</row>
<row>
<entry/>
<entry>{</entry>
</row>
<row>
<entry/>
<entry>  T=T_table[y];</entry>
</row>
<row>
<entry/>
<entry>  for(x=0;x&lt;R;x++)</entry>
</row>
<row>
<entry/>
<entry>  {</entry>
</row>
<row>
<entry/>
<entry>    out[x*C+T]=in[y*R+x+Z];</entry>
</row>
<row>
<entry/>
<entry>  }</entry>
</row>
<row>
<entry/>
<entry>  if(T&lt;W)</entry>
</row>
<row>
<entry/>
<entry>  {</entry>
</row>
<row>
<entry/>
<entry>    Z++;</entry>
</row>
<row>
<entry/>
<entry>    out[x*C+T]=in[y*R+x+Z];</entry>
</row>
<row>
<entry/>
<entry>  }</entry>
</row>
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0035" num="0034">Finally, while the invention has been described by way of example and in terms of the above, it is to be understood that the invention is not limited to the disclosed embodiment. On the contrary, it is intended to cover various modifications and similar arrangements as would be apparent to those skilled in the art. Therefore, the scope of the appended claims should be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A block interleaving encoding method for generating addresses, comprising the steps of:
<claim-text>providing M coded symbols to perform block interleaving on a memory, the memory comprises a write memory block and a read memory block, the write memory block having memory cells starting with an initial output address, and the read memory block has memory cells starting with an initial input address;</claim-text>
<claim-text>storing the M coded symbols in the M memory cells following the initial input address successively;</claim-text>
<claim-text>determining a column value (C) for segmenting the M coded symbols;</claim-text>
<claim-text>determining a sequence matching table comprising C corresponding values for appointing the interleaving order;</claim-text>
<claim-text>obtaining one of the C corresponding values in the sequence matching table as a reference value successively;</claim-text>
<claim-text>reading out the coded symbols from the read memory block starting from the reference value with a fixed spacing C;</claim-text>
<claim-text>writing the read coded symbols to the corresponding memory cells of the write memory block successively; and</claim-text>
<claim-text>repeating the above reading and writing processes until all the C corresponding values have been selected.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The block interleaving encoding method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising dividing the total number of coded symbols (M) by the column value (C) to obtain a whole number (R) and a remainder (W).</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The block interleaving encoding method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising segmenting the M coded symbols into R blocks with W remainder coded symbols, wherein each block includes C coded symbols and a (R+1)<sup>st </sup>block includes W coded symbols.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The block interleaving encoding method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising reading a coded symbol in the (R+1)<sup>st </sup>block corresponding to the reference value if the reference value is less than the remainder W.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The block interleaving encoding method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the initial output address is computed by subtracting the initial input address from the total number of coded symbols (M), and adding the whole number (R) obtained by dividing M with column value C.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The block interleaving encoding method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the read memory block overlaps the write memory block by R memory cells from the initial input address.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The block interleaving encoding method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the sequence matching table and the column value (C) correspond in both interleaving and de-interleaving.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A block de-interleaving encoding method for generating addresses, comprising the steps of:
<claim-text>providing M coded symbols to perform block de-interleaving on a memory, wherein the memory comprises a write memory block and a read memory block, the write memory block has memory cells starting with an initial output address, and the read memory block has memory cells starting with an initial input address;</claim-text>
<claim-text>storing the M coded symbols in the M memory cells following the initial input address successively;</claim-text>
<claim-text>determining a column value (C) for segmenting the M coded symbols;</claim-text>
<claim-text>determining a sequence matching table comprising C corresponding values for appointing the interleaving order;</claim-text>
<claim-text>segmenting the M coded symbols into C blocks, wherein each block corresponds to each corresponding value of the sequence matching table;</claim-text>
<claim-text>reading out the coded symbols of the read memory block sequentially; and</claim-text>
<claim-text>writing the coded symbols obtained from each block in the order according to the sequence matching table until all coded symbols are written into the write memory block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The block de-interleaving encoding method according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising dividing the total number of coded symbols (M) by the column value (C) to obtain a whole number (R) and a remainder (W).</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The block de-interleaving encoding method according to <claim-ref idref="CLM-00009">claim 9</claim-ref>, dividing the M coded symbol into C blocks corresponding to the C corresponding values further comprising comparing the corresponding value of each block with the remainder (W) to determine whether there are R or R+1 coded symbols in the block, and if the corresponding value of the block is less than the remainder (W), the block has R+1 coded symbols, otherwise the block has R coded symbols.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The block de-interleaving encoding method according to <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the memory cells of the write memory block overlap with the memory cells of the read memory block by R memory cells.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The block de-interleaving encoding method according to <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the initial output address is computed by subtracting the initial input address from the total number of coded symbols (M), and adding the whole number (R) obtained by dividing M with column value C.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. An address generator for block interleaving and de-interleaving performing interleaving and de-interleaving on M coded symbols, comprising:
<claim-text>an input block, receiving input parameters comprising an initial input address, a total number of coded symbols (M), a column value (C), a clock signal, and a reset signal;</claim-text>
<claim-text>a memory overlap block, coupling to the input block and computing an initial output address according to the input parameters;</claim-text>
<claim-text>a computing block, coupling to the input block and the memory overlap block and calculating read and write addresses for each of the M coded symbols; and</claim-text>
<claim-text>an output block, coupling to the computing block and outputting a read address array and a write address array;</claim-text>
<claim-text>wherein the computing block computes an input address index and an output address index for each of the M coded symbols in two loops, combined with the initial input address, the initial output address, and a sequence matching table corresponding to both sides, performing interleaving and de-interleaving to compute the read and write addresses for each of the M coded symbols.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The address generator for performing interleaving and de-interleaving according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the computing block further comprises an address offset block for offsetting the output address index according to a remainder (W) calculated by dividing the total number of the coded symbols (M) by the column value (C).</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The address generator for performing interleaving and de-interleaving according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the computing block computes the addresses for the M coded symbols using a two-dimensional concept of arranging the addresses in a matrix of C columns and R rows.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The address generator for performing interleaving and de-interleaving according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the read address array comprises M addresses corresponding to M addresses of a read memory block.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The address generator for performing interleaving and de-interleaving according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the write address array comprises M addresses corresponding to M addresses of a write memory block.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The address generator for performing interleaving and de-interleaving according to <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the read address array overlaps the write address array by R addresses.</claim-text>
</claim>
</claims>
</us-patent-grant>
