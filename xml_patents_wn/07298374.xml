<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298374-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298374</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11195474</doc-number>
<date>20050802</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>184</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>T</subclass>
<main-group>15</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>345473</main-classification>
<further-classification>345589</further-classification>
<further-classification>345606</further-classification>
<further-classification>382 11</further-classification>
</classification-national>
<invention-title id="d0e53">Scheme for providing wrinkled look in computer simulation of materials</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5504845</doc-number>
<kind>A</kind>
<name>Vecchione</name>
<date>19960400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345419</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6532014</doc-number>
<kind>B1</kind>
<name>Xu et al.</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>345673</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6909431</doc-number>
<kind>B1</kind>
<name>Anderson et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345473</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6970171</doc-number>
<kind>B2</kind>
<name>Baraff et al.</name>
<date>20051100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345473</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7091977</doc-number>
<kind>B2</kind>
<name>Jeong et al.</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345473</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00006">
<othercit>Jakobsen, Thomas; “Advanced Character Physics;” Gama Network Presents: Gamasutra.com; CMP Media Inc.; Jan. 21, 2003; pp. 1-17; (http://www.gamasutra.com/resource<sub>—</sub>guide/20030121/jacobson<sub>—</sub>01.shtml).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>Malzbender, Tom et al.; “Polynomial Texture Maps;” presented at the Siggraph 2001 proceedings; May 15, 2001; pp. 1-10; (http://www.hpl.hp.com/research/ptm/papers/ptm.pdf).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>Malzbender; Tom et al.; “Polynomial Texture Mapping (PTM);” Hewlett-Packard Laboratories; Research; pp. 1-2; 2001; http://www.hpl.hp.com/cgi-bin/printer-friendly.cgi.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>345473-475</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345589</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345606</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345582</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345588</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>382111</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>356429</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>703  6</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>700141</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20070030266</doc-number>
<kind>A1</kind>
<date>20070208</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Styles</last-name>
<first-name>Andrew Graham</first-name>
<address>
<city>San Diego</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fitch, Even, Tabin &amp; Flannery</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Sony Computer Entertainment America Inc.</orgname>
<role>02</role>
<address>
<city>Foster City</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Nguyen</last-name>
<first-name>Phu K.</first-name>
<department>2628</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Scheme for use in cloth simulation that provides a good dynamic “wrinkled” look to the cloth as it moves. The simulated area of each of the triangles in the triangle mesh is compared with the original area of the triangle to determine how much it got compressed or stretched during animation. This comparison is then used as a basis for altering the lighting of the pixels representing the triangles in order to improve the appearance of the wrinkles in the cloth. The lighting of each pixel is altered by altering a surface normal of the pixel using a value obtained from each of one or more normal maps. Normal maps are selected by using wrinkle ratios that are calculated based on the above mentioned comparisons.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="171.28mm" wi="162.64mm" file="US07298374-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="170.43mm" wi="140.80mm" file="US07298374-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="192.87mm" wi="146.64mm" file="US07298374-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="240.28mm" wi="145.20mm" file="US07298374-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="176.61mm" wi="135.64mm" file="US07298374-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="236.30mm" wi="175.51mm" file="US07298374-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">REFERENCE TO COMPUTER PROGRAM LISTING APPENDIX</heading>
<p id="p-0002" num="0001">The following computer program listing files are submitted on one compact disc and are incorporated herein by reference in their entirety; a duplicate copy of the compact disc is also submitted herewith:</p>
<p id="p-0003" num="0002">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="63pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>NAME</entry>
<entry>CREATION DATE</entry>
<entry>SIZE (bytes)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="63pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry/>
<entry>AxialConstraint.ccp</entry>
<entry>May 11, 2005</entry>
<entry>2,817</entry>
</row>
<row>
<entry/>
<entry>AxialConstraint.h</entry>
<entry>May 11, 2005</entry>
<entry>928</entry>
</row>
<row>
<entry/>
<entry>BondConstraint.ccp</entry>
<entry>May 11, 2005</entry>
<entry>2,583</entry>
</row>
<row>
<entry/>
<entry>BondConstraint.h</entry>
<entry>May 11, 2005</entry>
<entry>1,044</entry>
</row>
<row>
<entry/>
<entry>ClothInstance.cpp</entry>
<entry>May 27, 2005</entry>
<entry>13,690</entry>
</row>
<row>
<entry/>
<entry>ClothInstance.h</entry>
<entry>May 11, 2005</entry>
<entry>2,839</entry>
</row>
<row>
<entry/>
<entry>cloth-shaders.xml</entry>
<entry>May 31, 2005</entry>
<entry>5,705</entry>
</row>
<row>
<entry/>
<entry>ClothTemplate.cpp</entry>
<entry>May 31, 2005</entry>
<entry>12,567</entry>
</row>
<row>
<entry/>
<entry>ClothTemplate.h</entry>
<entry>May 27, 2005</entry>
<entry>3,109</entry>
</row>
<row>
<entry/>
<entry>CollisionBody.cpp</entry>
<entry>May 11, 2005</entry>
<entry>5,410</entry>
</row>
<row>
<entry/>
<entry>CollisionBody.h</entry>
<entry>May 11, 2005</entry>
<entry>2,231</entry>
</row>
<row>
<entry/>
<entry>CylinderConstraint.cpp</entry>
<entry>Apr. 21, 2005</entry>
<entry>1,282</entry>
</row>
<row>
<entry/>
<entry>CylinderConstraint.h</entry>
<entry>May 11, 2005</entry>
<entry>915</entry>
</row>
<row>
<entry/>
<entry>JerseyInstance.cpp</entry>
<entry>May 11, 2005</entry>
<entry>303</entry>
</row>
<row>
<entry/>
<entry>JerseyInstance.h</entry>
<entry>May 11, 2005</entry>
<entry>447</entry>
</row>
<row>
<entry/>
<entry>JerseyTemplate.cpp</entry>
<entry>May 27, 2005</entry>
<entry>1,651</entry>
</row>
<row>
<entry/>
<entry>JerseyTemplate.h</entry>
<entry>May 27, 2005</entry>
<entry>642</entry>
</row>
<row>
<entry/>
<entry>PtxSystem.cpp</entry>
<entry>May 13, 2005</entry>
<entry>3,759</entry>
</row>
<row>
<entry/>
<entry>PtxSystem.h</entry>
<entry>May 11, 2005</entry>
<entry>3,245</entry>
</row>
<row>
<entry/>
<entry>ShortsInstance.cpp</entry>
<entry>May 11, 2005</entry>
<entry>1,732</entry>
</row>
<row>
<entry/>
<entry>ShortsInstance.h</entry>
<entry>May 11, 2005</entry>
<entry>909</entry>
</row>
<row>
<entry/>
<entry>ShortsTemplate.cpp</entry>
<entry>May 27, 2005</entry>
<entry>3,152</entry>
</row>
<row>
<entry/>
<entry>ShortsTemplate.h</entry>
<entry>May 27, 2005</entry>
<entry>858</entry>
</row>
<row>
<entry/>
<entry>Skeleton.cpp</entry>
<entry>Apr. 14, 2005</entry>
<entry>4,124</entry>
</row>
<row>
<entry/>
<entry>Skeleton.h</entry>
<entry>May 11, 2005</entry>
<entry>2,184</entry>
</row>
<row>
<entry/>
<entry>Vec3Array.cpp</entry>
<entry>May 13, 2005</entry>
<entry>525</entry>
</row>
<row>
<entry/>
<entry>Vec3Array.h</entry>
<entry>May 11, 2005</entry>
<entry>1,697</entry>
</row>
<row>
<entry/>
<entry>VertexConstraint.cpp</entry>
<entry>May 11, 2005</entry>
<entry>7,101</entry>
</row>
<row>
<entry/>
<entry>VertexConstraint.h</entry>
<entry>May 11, 2005</entry>
<entry>3,475</entry>
</row>
<row>
<entry/>
<entry>VertexProgram.txt</entry>
<entry>Jul. 21, 2005</entry>
<entry>10,333</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">1. Field of the Invention</p>
<p id="p-0005" num="0004">The present invention relates generally to computer graphics and animation, and more specifically to techniques for computer simulation of cloth, skin and other materials.</p>
<p id="p-0006" num="0005">2. Discussion of the Related Art</p>
<p id="p-0007" num="0006">Computer animation, such as is used in computer entertainment video game systems, is becoming more and more realistic. While the simulation and modeling of rigid bodies is fairly advanced, the simulation and modeling of non-rigid bodies such as cloth and clothing is still developing. Cloth is generally more difficult to simulate than rigid bodies because cloth reacts differently to forces such as wind, gravity, collisions with rigid bodies, etc.</p>
<p id="p-0008" num="0007">The paper “Advanced Character Physics” by Thomas Jakobsen, dated Jan. 21, 2003 (http://www.gamasutra.com/resource_guide/20030121/jacobso n<sub>—</sub>01.shtml), which is incorporated by reference herein in its entirety, describes a Verlet integration scheme for cloth simulation. Verlet integration is a method of calculating classical physics in a way suitable to real-time simulations on computers. It is a method with more stability with larger steps in time than the equations usually used in Newtonian physics. It is most often used for molecular dynamics and real-time computer simulation of objects. A very similar method is often used as an optimized method of water ripple simulation.</p>
<p id="p-0009" num="0008">It is with respect to these and other background information factors that the present invention has evolved.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0010" num="0009">The present invention advantageously addresses the needs above as well as other needs by providing a method for use in simulation of a material. The method comprises the steps of: establishing a polygon mesh for the material with each polygon in the polygon mesh having a first area equal to its area in a resting position; animating the polygon mesh, the animation resulting in each polygon in the polygon mesh having a second area; for each polygon in the polygon mesh, calculating a polygon wrinkle ratio by dividing the second area by the first area; for each vertex in the polygon mesh, calculating a vertex wrinkle ratio as an average of the polygon wrinkle ratios for each polygon attached to the vertex; and using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh.</p>
<p id="p-0011" num="0010">Another embodiment of the present invention provides a system for use in simulation of a material. The system comprises: means for establishing a polygon mesh for the material with each polygon in the polygon mesh having a first area equal to its area in a resting position; means for animating the polygon mesh, the animation resulting in each polygon in the polygon mesh having a second area; means for calculating a polygon wrinkle ratio for each polygon in the polygon mesh by dividing the second area by the first area; means for calculating a vertex wrinkle ratio for each vertex in the polygon mesh as an average of the polygon wrinkle ratios for each polygon attached to the vertex; and means for using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh.</p>
<p id="p-0012" num="0011">Another embodiment of the present invention provides a computer program product comprising a medium for embodying a computer program for input to a computer. A computer program is embodied in the medium for causing the computer to perform steps of: establishing a polygon mesh for a material with each polygon in the polygon mesh having a first area equal to its area in a resting position; animating the polygon mesh, the animation resulting in each polygon in the polygon mesh having a second area; for each polygon in the polygon mesh, calculating a polygon wrinkle ratio by dividing the second area by the first area; for each vertex in the polygon mesh, calculating a vertex wrinkle ratio as an average of the polygon wrinkle ratios for each polygon attached to the vertex; and using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh.</p>
<p id="p-0013" num="0012">A better understanding of the features and advantages of the present invention will be obtained by reference to the following detailed description of the invention and accompanying drawings which set forth an illustrative embodiment in which the principles of the invention are utilized.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The above and other aspects, features and advantages of the present invention will be more apparent from the following more particular description thereof, presented in conjunction with the following drawings wherein:</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is a flow diagram illustrating a method for use in the simulation of a material in accordance with an embodiment of the present invention;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram illustrating an example of a method that may be used with the method shown in <figref idref="DRAWINGS">FIG. 1</figref> in accordance with an embodiment of the present invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIGS. 3A and 3B</figref> are pictorial diagrams illustrating an example application of the method shown in <figref idref="DRAWINGS">FIG. 1</figref> in accordance with an embodiment of the present invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> is a pictorial diagram illustrating an enlarged view of a portion of the subject matter shown in <figref idref="DRAWINGS">FIG. 3B</figref>;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> is a pictorial diagram illustrating normal maps that may be used with the method shown in <figref idref="DRAWINGS">FIG. 2</figref> in accordance with an embodiment of the present invention; and</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram illustrating a system that may be used to run and execute the methods shown in <figref idref="DRAWINGS">FIGS. 1 and 2</figref> in accordance with embodiments of the present invention.</p>
<p id="p-0021" num="0020">Corresponding reference characters indicate corresponding components throughout the several views of the drawings.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0022" num="0021">It has been found by the inventor hereof that the above-mentioned Verlet integration scheme for cloth simulation, which may also be referred to herein as the Verlet cloth simulator, has a number of disadvantages. Such disadvantages become apparent when the Verlet integration scheme is used for simulating clothing on an animated character.</p>
<p id="p-0023" num="0022">One such disadvantage is that in order for the Verlet cloth simulator (or any other cloth simulation scheme) to provide a good “wrinkled” look to the simulated cloth it would require many, many vertices and would be impractical on modern graphics hardware in real-time. The numerous number of vertices are required in order to provide enough fine detail for the wrinkles that are in the cloth, especially for tight wrinkles.</p>
<p id="p-0024" num="0023">Embodiments of the present invention help to overcome these and other disadvantages by providing techniques that may be used in the simulation and/or movement of cloth, skin and/or other materials. Such techniques can be used in many different types of computer graphics and animation applications, such as for example graphics workstations and video game applications of the type executed by video game consoles and similar devices.</p>
<p id="p-0025" num="0024">The techniques and schemes described herein improve the quality of cloth simulation by providing a good dynamic “wrinkled” look to the cloth or skin as it moves. The techniques described may be used in the real-time simulation and/or movement of materials such as for example cloth, clothing (e.g. shirts, jerseys, shorts, other garments, etc.), skin (e.g. for frowns, etc.), hair, fur, flags, etc. The techniques can be used with any existing or forthcoming material simulation technique, such as the Verlet integration scheme mentioned above, or the techniques may be used separately. The techniques and schemes are useable on today's hardware and provide very good results.</p>
<p id="p-0026" num="0025">Furthermore, the techniques may be run on graphics systems which may not have random-access to main memory. Thus, once the graphics system is preloaded with the data needed, the techniques can be applied, and persistent data saved out. And the simulation may be run concurrently with other graphics tasks. On a multi processing core, the simulation can be executed on a separate processor.</p>
<p id="p-0027" num="0026">The techniques described herein may be used in connection with video games having one or more animated players, such as for example a basketball video game. The clothing that a player in the basketball game typically wears comprises a shirt or jersey and a pair of shorts. Cloth simulation techniques are preferably used to make the player's clothing look as realistic as possible. The techniques described herein may be used to improve the wrinkled appearance of the player's clothing. It should be well understood that there are numerous other types of games and animations to which embodiments of the present invention may be used and applied, such as for example other types of video games, movies, videos, animations, cartoons, etc.</p>
<p id="p-0028" num="0027">By way of example, the systems described herein may be built using a number of spheres to represent a player body. The spheres may be enveloped with simulated skin using any known skin simulation technique, which is sometimes referred to as skinning. The spheres then move with the movement of the player skin. Clothing may be simulated using well-known triangle mesh techniques.</p>
<p id="p-0029" num="0028">A discussion of texture mapping and bump mapping will aid in the understanding of the techniques described herein. Specifically, texture mapping is the process of applying a texture, i.e. an image, to a triangle during rendering wherein the texture gets mapped onto the triangle. The surface normal of the triangle is used along with the color value in the texture to calculate the lighting equation and thus the direction of the light. A surface normal is like an arrow that points in the direction that the surface is facing in. As it angles away from a light source, the color of the pixel gets darker (and vice versa).</p>
<p id="p-0030" num="0029">Bump mapping is a method wherein the flat image of a texture map is altered to give the impression of being non-smooth but without changing the physical shape of the surface. Bump mapping uses another texture map, which is sometimes called a bump map or a normal map, to change the brightness of the pixel in the main texture on the surface. Specifically, the normal map texture contains values that alter the surface normals of the original pixels. This is done by multiplying the normal from the normal map by the normal of the triangle. This gives the illusion of a bumpy surface. The surface is not really bumpy but it appears bumpy because of the changes in the lighting equation due to the change in the normal direction of the surface. It should be noted that bump mapping does not alter the position or amount of vertices in the surface.</p>
<p id="p-0031" num="0030">Referring to <figref idref="DRAWINGS">FIG. 1</figref>, there is illustrated a method <b>20</b> that operates in accordance with an embodiment of the present invention. The method <b>20</b>, which may be referred to herein as wrinkle mapping, may be used in the simulation of a material, such as clothing or any of the other materials mentioned above. In general, the method <b>20</b> takes into consideration that a cloth simulator typically distorts the area of the triangles in a triangle mesh. That is, when cloth is simulated the area of the triangles in the triangle mesh can change. The method <b>20</b> compares the current simulated area of each of the triangles with the original area of the triangle to determine how much it got compressed or stretched. This comparison is then used as a basis for altering the lighting of the pixels representing the triangles in order to improve the appearance of the wrinkles in the cloth.</p>
<p id="p-0032" num="0031">Turning to the specific steps of the method <b>20</b>, in step <b>22</b> a polygon mesh for a material is established with each polygon in the polygon mesh having a first area A<sub>R </sub>equal to its area in a resting position. The polygons may comprise triangles, as are typically used in cloth simulation, or any other polygon shape. In step <b>24</b> the polygon mesh is animated. The animation results in each polygon in the polygon mesh having a second area A<sub>A</sub>.</p>
<p id="p-0033" num="0032">The cloth mesh may be animated using any method, such as for example character skinning or cloth simulation. Any type of cloth simulation technique may be used, such as the Verlet integration scheme mentioned above, and any type of skin simulation technique may be used, many of which are known in the art. If cloth simulation is used, the polygon edges will typically compress, resulting in the area of each polygon becoming smaller as the cloth “bunches up.”</p>
<p id="p-0034" num="0033">An example of steps <b>22</b> and <b>24</b> is illustrated in <figref idref="DRAWINGS">FIGS. 3A and 3B</figref>, which illustrates an example application of the method <b>20</b>. Specifically, <figref idref="DRAWINGS">FIG. 3A</figref> illustrates a polygon mesh <b>60</b> in the resting position. In this example the polygons comprise triangles, but it should be well understood that the polygons may comprise any shape. The area of polygons P<b>1</b>, P<b>2</b>, P<b>3</b>, P<b>4</b>, P<b>5</b>, P<b>6</b>, P<b>7</b>, P<b>8</b> and P<b>9</b> in the resting position are indicated as A<sub>RP1</sub>, A<sub>RP2</sub>, A<sub>RP3</sub>, A<sub>RP4</sub>, A<sub>RP5</sub>, A<sub>RP6</sub>, A<sub>RP7</sub>, A<sub>RP8</sub>, and A<sub>RP9</sub>. A few of the vertices are labeled as V<b>1</b>, V<b>2</b>, and V<b>3</b>.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 3B</figref> illustrates the polygon mesh <b>60</b> after it has been animated. The area of the polygons after the animation are indicated as A<sub>AP1</sub>, A<sub>AP2</sub>, A<sub>AP3</sub>, A<sub>AP4</sub>, A<sub>AP5</sub>, A<sub>AP6</sub>, A<sub>AP7</sub>, A<sub>AP8</sub>, and A<sub>AP9</sub>. As illustrated some of the polygons have become compressed which has reduced their area, such as polygons P<b>1</b>, P<b>2</b>, P<b>4</b>, P<b>6</b> and P<b>7</b>. Some of the polygons have stayed about the same size, such as polygons P<b>3</b> and P<b>8</b>. And other polygons have been stretched which has increased their area, such as polygons P<b>5</b> and P<b>9</b>.</p>
<p id="p-0036" num="0035">As mentioned above the area of the polygons in the resting position are compared with the area of the polygons after animation. This is illustrated in the next steps of the method <b>20</b> (<figref idref="DRAWINGS">FIG. 1</figref>). Namely, in step <b>26</b> a polygon wrinkle ratio WR<sub>p </sub>is calculated for each polygon in the mesh by dividing the area of each polygon after animation by the area of the respective polygon in the resting pose, i.e. by dividing the second area A<sub>A </sub>by the first area A<sub>R</sub>. That is:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>WR</i><sub>Pn</sub><i>=A</i><sub>APn</sub><i>/A</i><sub>RPn</sub>  (1)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0037" num="0036">If the polygon wrinkle ratio is equal to 1.0, then this indicates that the area of the polygon has not changed due to the animation step, e.g. polygons P<b>3</b> and P<b>8</b>. That is, the area of the polygon has neither been compressed nor stretched during the animation step. If the polygon wrinkle ratio is about equal to 0.5, then this indicates that the area of the polygon has been compressed due to the animation step and will be wrinkled, e.g. polygons P<b>2</b>, P<b>4</b> and P<b>7</b>. If the polygon wrinkle ratio is less than 0.5, then this indicates that the area of the polygon has been very compressed due to the animation step and will have many tight wrinkles, e.g. polygons P<b>1</b> and P<b>6</b>. Finally, if the polygon wrinkle ratio is greater than 1.0, then this indicates that the area of the polygon has been stretched due to the animation step and will be smooth with few or no wrinkles, e.g. polygons P<b>5</b> and P<b>9</b>.</p>
<p id="p-0038" num="0037">In step <b>28</b> a vertex wrinkle ratio WR<sub>v </sub>is calculated for each vertex in the mesh as the average of the polygon wrinkle ratios for each polygon attached to the vertex. For example, for vertex V<b>2</b> the vertex wrinkle ratio WR<sub>V2 </sub>is calculated as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>WR</i><sub>V2</sub>=(<i>WR</i><sub>P2</sub><i>+WR</i><sub>P3</sub><i>+WR</i><sub>P4</sub>)/3  (2)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
This calculation is repeated for each vertex in the mesh to obtain the vertex wrinkle ratio for each vertex.
</p>
<p id="p-0039" num="0038">In accordance with embodiments of the present invention, the above calculations are taken into consideration when lighting the pixels that represent the material in order to improve the appearance of the wrinkles in the material. Specifically, in step <b>30</b> the vertex wrinkle ratios are used in a process of altering the lighting of the pixels representing the polygons in the polygon mesh. Changing the brightness of the pixels that represent the material can give the illusion of an improved wrinkled appearance.</p>
<p id="p-0040" num="0039">One example process of altering the lighting of the pixels representing the polygons that may be used in accordance with embodiments of the present invention involves using the above-described comparison as the basis for interpolating the values of two or more different normal maps. The different normal maps will typically have different degrees of wrinkled appearance. For example, one of the different normal maps might be very loose and have only a few or a medium amount of wrinkles, the next normal map may have many very tight wrinkles, and another normal map may have a stretched appearance so that it is smooth with no wrinkles. Depending on how much the polygons get compressed, the method uses different normal maps and interpolates between them to pull different surface normals from the different maps. This results in more wrinkles appearing in the texture as the cloth compresses with a smooth transition, which provides a good dynamic “wrinkled” appearance.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 2</figref> illustrates a method <b>40</b> in accordance with an embodiment of the present invention that may be used for implementing step <b>30</b> in <figref idref="DRAWINGS">FIG. 1</figref>. In this example process the vertex wrinkle ratios are used to select from among normal maps. Specifically, in step <b>42</b> each polygon in the polygon mesh is rasterized to form screen pixels. Then in step <b>44</b> the wrinkle ratio for each pixel is interpolated based on the vertex wrinkle ratios for the polygon. The vertex wrinkle ratios may be interpolated across each polygon by the graphics processing unit (GPU) and digital differential analysis (DDA) hardware.</p>
<p id="p-0042" num="0041">An example of steps <b>42</b> and <b>44</b> is illustrated in <figref idref="DRAWINGS">FIG. 4</figref>, which shows an enlarged and simplified view of polygon P<b>2</b> after the animating step. As shown the rasterization step results in a number of screen pixels <b>100</b>, <b>102</b>, <b>104</b>, <b>106</b>, <b>108</b>, <b>110</b>, <b>112</b>, <b>114</b>, <b>116</b>, <b>118</b>, <b>120</b>, <b>122</b>, <b>124</b> being formed. It should be well understood that only a small number of the pixels are shown in order to simplify the explanation herein and that in an actual implementation many, many more pixels will be formed.</p>
<p id="p-0043" num="0042">The vertex wrinkle ratios WR<sub>V1</sub>, WR<sub>V2</sub>, and WR<sub>V3</sub>, which are known, are used to interpolate the wrinkle ratios of the rasterized pixels <b>100</b>, <b>102</b>, <b>104</b>, <b>106</b>, <b>108</b>, <b>110</b>, <b>112</b>, <b>114</b>, <b>116</b>, <b>118</b>, <b>120</b>, <b>122</b>, <b>124</b>. The computer graphics hardware interpolates between the vertex wrinkle ratios when it draws the polygon. This ultimately results in a very smooth transition from areas of the cloth with no wrinkles to areas with many wrinkles. The smooth transition is due to the vertex wrinkle ratios being based on an average of the polygon wrinkle ratios of the polygons attached to the vertex.</p>
<p id="p-0044" num="0043">Returning to the method <b>40</b> (<figref idref="DRAWINGS">FIG. 2</figref>), in step <b>46</b> the interpolated wrinkle ratio for each rasterized pixel in the polygon mesh is used to select one or more normal maps. One or more normal maps are selected by the pixel program for each pixel in order to obtain a value from each selected normal map for altering the surface normal of that pixel. An example of selecting two normal maps for each pixel will be described below.</p>
<p id="p-0045" num="0044">Two or more normal maps may be used to provide varying degrees of wrinkles. For example, if two normal maps are used the first normal map may indicate the normal map of the cloth in a resting, unwrinkled position, and the second normal map may indicate a wrinkled up version of the cloth. If three normal maps are used the first normal map may be a flat, regular normal of the surface, which is not really a normal map. The second normal map may be a slightly wrinkled texture, and the third normal map may be a very wrinkled texture. In another embodiment more than three normal maps may be used.</p>
<p id="p-0046" num="0045">By way of example, if the wrinkle ratio of a particular pixel is equal to 1.0, then the area of the surrounding polygons has generally not changed in the animation step. Therefore, a normal map is not really needed and the regular normal of the surface may be used instead. If the wrinkle ratio is less than 1.0, then the area of the surrounding polygons has been compressed in the animation step and a normal map having preformed wrinkles on the cloth may be used. If the wrinkle ratio is much less than 1.0, then a different normal map having many tight preformed wrinkles on the cloth may be used. And if the wrinkle ratio is greater than 1.0, then the area of the surrounding polygons has been stretched in the animation step and a normal map that is smooth with no wrinkles on the cloth may be used. The use of the different normal maps combined with the smooth transition mentioned above helps to provide a good dynamic wrinkled looked to the cloth as it moves.</p>
<p id="p-0047" num="0046">There are many different ways that the interpolated wrinkle ratios of the rasterized pixels may be used to select normal maps. In one example the normal maps may be selected based on the interpolated wrinkle ratios falling within predetermined ranges. In another example each of the interpolated wrinkle ratios may be put through a function to calculate adjusted wrinkle ratios WR<sub>adj</sub>. By way of example, if two normal maps are used the adjusted wrinkle ratios may be one of two different values, such as 0 or 1, if three normal maps are used the adjusted wrinkle ratios may be one of three different values, such as 0, 1 or 2, etc.</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an example of the different normal maps to which the adjusted wrinkle ratios WR<sub>adj </sub>may correspond for a scenario where three normal maps are used. Namely, an adjusted wrinkle ratio WR<sub>adj </sub>equal to 1 may correspond to just the resting texture in a normal position having only a few wrinkles, an adjusted wrinkle ratio WR<sub>adj </sub>equal to 0 may correspond to a normal map having the most wrinkled texture, and an adjusted wrinkle ratio WR<sub>adj </sub>equal to 2 may correspond to a plain normal map having no wrinkles so that the cloth appears smooth and stretched.</p>
<p id="p-0049" num="0048">An example of a function for calculating adjusted wrinkle ratios WR<sub>adj </sub>that may be used for the scenario shown in <figref idref="DRAWINGS">FIG. 5</figref> is as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>If <i>WR</i>&lt;0.5, then <i>WR</i><sub>adj</sub>=0;<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>If <i>WR</i>&gt;1.3, then <i>WR</i><sub>adj</sub>=2;  (3)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Else, then <i>WR</i><sub>adj</sub>=1;<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
It should be well understood that this is just one example and that many variations may be used in accordance with embodiments of the invention.
</p>
<p id="p-0050" num="0049">For example, the following portion of code provides another example of a function that may be used for calculating adjusted wrinkle ratios:</p>
<p id="p-0051" num="0050">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>if (wrinkleRatio &lt; 1)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>wrinkleRatioResult = (wrinkleRatio − wrinkleAreaMin) /</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(wrinkleAreaMiddle − wrinkleAreaMin)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>wrinkleRatioResult = 1 + (wrinkleRatio −</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>wrinkleAreaMiddle) / (wrinkleAreaMax − wrinkleAreaMiddle)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
In this function the value “wrinkleRatio” is equal to the interpolated wrinkle ratio and “wrinkleRatioResult” is equal to the adjusted wrinkle ratio WR<sub>adj</sub>. Furthermore, by way of example the following values for the other variables may be used: wrinkleAreaMin=0.5; wrinkleAreaMiddle=1.0; wrinkleAreaMax=1.5. Again, it should be well understood that this is just one example and that there are many different ways the adjusted vertex wrinkle ratios WR<sub>adj </sub>may be calculated in accordance with the present invention.
</p>
<p id="p-0052" num="0051">Returning to the method <b>40</b> (<figref idref="DRAWINGS">FIG. 2</figref>), after one or more normal maps are selected for a particular pixel, then in step <b>48</b> a value is obtained from each selected normal map for the pixel. The obtained value(s) are used for altering a surface normal of that pixel in step <b>50</b>. The surface normal may be altered by, for example, replacing or modifying the surface normal of the pixel by the value obtained from the selected normal map. These steps are repeated for each rasterized pixel in the polygon mesh.</p>
<p id="p-0053" num="0052">Altering the surface normal of each pixel using the value obtained from each selected normal map changes the brightness of the pixel. This can have the result of making the surface appear either more wrinkled or less wrinkled depending upon which normal map was selected for the pixel.</p>
<p id="p-0054" num="0053">In accordance with an embodiment of the present invention, the value that is obtained from each selected normal map may comprise a surface normal that is used to replace the surface normal of the particular pixel. In this scenario the surface normal that is obtained will typically comprise a “tangent space lighting normal”. To perform lighting, this “tangent space lighting normal” will generally need to be transformed to “world space”.</p>
<p id="p-0055" num="0054">This transformation may be done by storing tangent space vectors per vertex, which essentially comprises a tangent-space-to-world matrix. These matrices are then interpolated per-pixel and are used to transform the “tangent space lighting normal” into a world space normal. Once this transformation is completed the obtained surface normal can then be used to replace the surface normal of the pixel.</p>
<p id="p-0056" num="0055">In accordance with various embodiments of the present invention, two normal maps may be selected for each pixel based on the wrinkle ratio and then an average calculated between the values obtained from the two selected normal maps. For example, if the wrinkle ratio is 0.7, the normal may be calculated as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Normal=normalize(normal1*0.7+normal2*(0.3))<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Where normal<b>1</b> is the normal from normal map <b>1</b> and normal<b>2</b> is the normal from normal map <b>2</b>. If the wrinkle Ratio is 1.4, the normal may be calculated as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Normal=normalize(normal2*0.4+normal3*(0.6))<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Where normal<b>3</b> is the normal from normal map <b>3</b>. The use of two normal maps for each pixel gives a smooth transition between each pixel, rather than jumping from one normal map to the next. By way of example, in one embodiment only two normal maps are used for normal maps <b>2</b> and <b>3</b>. Normal map <b>1</b> is implicitly (0,0,1), i.e. flat, for each pixel in the normal map.
</p>
<p id="p-0057" num="0056">The method <b>40</b> concludes in step <b>52</b> where the altered surface normal for each rasterized pixel in the polygon mesh is used for lighting the pixel.</p>
<p id="p-0058" num="0057">As mentioned above, the methods and techniques described herein may be utilized and run on many different types of computers, graphics workstations, video game systems and consoles, and the like. Referring to <figref idref="DRAWINGS">FIG. 6</figref> there is illustrated such a system <b>200</b> that may be used to run the methods and techniques described herein. The system <b>200</b> includes a central processing unit (CPU) <b>202</b>, a graphics processing unit (GPU) <b>204</b>, digital differential analysis (DDA) hardware <b>206</b>, a random access memory (RAM) <b>208</b>, a mass storage unit <b>210</b>, such as a disk drive, and a display monitor <b>212</b>.</p>
<p id="p-0059" num="0058">The CPU <b>202</b> and/or GPU <b>204</b> can be used to execute the steps of the methods and techniques described herein, and the materials that are simulated can be rendered on the display monitor <b>212</b>. Removable storage media <b>214</b> may optionally be used with the mass storage unit <b>210</b>, which may be used for storing code that implements the methods and techniques described herein. Either all or a portion of the system <b>200</b> may be embodied in a device <b>216</b>, such as for example a computer or video game console or system. And as mentioned above, the simulations may be run concurrently with other graphics tasks. On a multi processing core, the simulations can be executed on a separate processor.</p>
<p id="p-0060" num="0059">While the invention herein disclosed has been described by means of specific embodiments and applications thereof, numerous modifications and variations could be made thereto by those skilled in the art without departing from the scope of the invention set forth in the claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for use in simulation of a material, comprising the steps of:
<claim-text>establishing a polygon mesh for the material with each polygon in the polygon mesh having a first area equal to its area in a resting position;</claim-text>
<claim-text>animating the polygon mesh, the animation resulting in each polygon in the polygon mesh having a second area;</claim-text>
<claim-text>for each polygon in the polygon mesh, calculating a polygon wrinkle ratio by dividing the second area by the first area;</claim-text>
<claim-text>for each vertex in the polygon mesh, calculating a vertex wrinkle ratio as an average of the polygon wrinkle ratios for each polygon attached to the vertex; and</claim-text>
<claim-text>using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A method in accordance with <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh comprises the steps of:
<claim-text>for each polygon in the polygon mesh, rasterizing the polygon to form screen pixels;</claim-text>
<claim-text>for each rasterized pixel in the polygon mesh, interpolating the wrinkle ratio per pixel based on the vertex wrinkle ratios; and</claim-text>
<claim-text>for each rasterized pixel in the polygon mesh, altering a surface normal of the pixel using a value obtained from each of one or more normal maps.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A method in accordance with <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the step of using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh further comprises the step of:
<claim-text>for each rasterized pixel in the polygon mesh, using the interpolated wrinkle ratio to select the one or more normal maps.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A method in accordance with <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the step of using the interpolated wrinkle ratio to select the one or more normal maps for each rasterized pixel in the polygon mesh comprises the step of:
<claim-text>for each rasterized pixel in the polygon mesh, calculating an adjusted wrinkle ratio by processing the interpolated wrinkle ratio with a function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A method in accordance with <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the step of using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh further comprises the step of:
<claim-text>for each rasterized pixel in the polygon mesh, using the altered surface normal for lighting the pixel.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A method in accordance with <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the value obtained from each of the one or more normal maps comprises a surface normal.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A method in accordance with <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of animating the polygon mesh comprises the step of:
<claim-text>animating the polygon mesh using a cloth simulation technique.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A method in accordance with <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the material comprises clothing.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A system for use in simulation of a material, comprising:
<claim-text>means for establishing a polygon mesh for the material with each polygon in the polygon mesh having a first area equal to its area in a resting position;</claim-text>
<claim-text>means for animating the polygon mesh, the animation resulting in each polygon in the polygon mesh having a second area;</claim-text>
<claim-text>means for calculating a polygon wrinkle ratio for each polygon in the polygon mesh by dividing the second area by the first area;</claim-text>
<claim-text>means for calculating a vertex wrinkle ratio for each vertex in the polygon mesh as an average of the polygon wrinkle ratios for each polygon attached to the vertex; and</claim-text>
<claim-text>means for using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A system in accordance with <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the means for using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh comprises:
<claim-text>means for rasterizing each polygon in the polygon mesh to form screen pixels;</claim-text>
<claim-text>means for interpolating the wrinkle ratio per pixel for each rasterized pixel in the polygon mesh based on the vertex wrinkle ratios; and</claim-text>
<claim-text>means for altering a surface normal of each rasterized pixel in the polygon mesh using a value obtained from each of one or more normal maps.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A system in accordance with <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the means for using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh further comprises:
<claim-text>means for using the interpolated wrinkle ratio for each rasterized pixel in the polygon mesh to select the one or more normal maps.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A system in accordance with <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the means for using the interpolated wrinkle ratio for each rasterized pixel in the polygon mesh to select the one or more normal maps comprises:
<claim-text>means for calculating an adjusted wrinkle ratio for each rasterized pixel in the polygon mesh by processing the interpolated wrinkle ratio with a function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A system in accordance with <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the means for using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh further comprises:
<claim-text>means for using the altered surface normal for each rasterized pixel in the polygon mesh for lighting the pixel.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A system in accordance with <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the value obtained from each of the one or more normal maps comprises a surface normal.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A computer program product comprising a computer storage medium for embodying a computer program for input to a computer and a computer program embodied in the computer storage medium for causing the computer to perform steps of:
<claim-text>establishing a polygon mesh for a material with each polygon in the polygon mesh having a first area equal to its area in a resting position;</claim-text>
<claim-text>animating the polygon mesh, the animation resulting in each polygon in the polygon mesh having a second area;</claim-text>
<claim-text>for each polygon in the polygon mesh, calculating a polygon wrinkle ratio by dividing the second area by the first area;</claim-text>
<claim-text>for each vertex in the polygon mesh, calculating a vertex wrinkle ratio as an average of the polygon wrinkle ratios for each polygon attached to the vertex; and</claim-text>
<claim-text>using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A computer program product in accordance with <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the step of using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh comprises the steps of:
<claim-text>for each polygon in the polygon mesh, rasterizing the polygon to form screen pixels;</claim-text>
<claim-text>for each rasterized pixel in the polygon mesh, interpolating the wrinkle ratio per pixel based on the vertex wrinkle ratios; and</claim-text>
<claim-text>for each rasterized pixel in the polygon mesh, altering a surface normal of the pixel using a value obtained from each of one or more normal maps.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A computer program product in accordance with <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the step of using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh further comprises the step of:
<claim-text>for each rasterized pixel in the polygon mesh, using the interpolated wrinkle ratio to select the one or more normal maps.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A computer program product in accordance with <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the step of using the interpolated wrinkle ratio to select the one or more normal maps for each rasterized pixel in the polygon mesh comprises the step of:
<claim-text>for each rasterized pixel in the polygon mesh, calculating an adjusted wrinkle ratio by processing the interpolated wrinkle ratio with a function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A computer program product in accordance with <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the step of using the vertex wrinkle ratios in a process of altering lighting of pixels representing polygons in the polygon mesh further comprises the step of:
<claim-text>for each rasterized pixel in the polygon mesh, using the altered surface normal for lighting the pixel.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A computer program product in accordance with <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the step of animating the polygon mesh comprises the step of:
<claim-text>animating the polygon mesh using a cloth simulation technique.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
