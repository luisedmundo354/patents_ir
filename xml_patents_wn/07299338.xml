<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299338-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299338</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10722100</doc-number>
<date>20031125</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>442</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>04</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711220</main-classification>
<further-classification>711221</further-classification>
</classification-national>
<invention-title id="d0e53">Vector indexed memory unit and method</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4128880</doc-number>
<kind>A</kind>
<name>Cray, Jr.</name>
<date>19781200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  4</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>4677547</doc-number>
<kind>A</kind>
<name>Omoda et al.</name>
<date>19870600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  6</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>4760518</doc-number>
<kind>A</kind>
<name>Potash et al.</name>
<date>19880700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710107</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>4811213</doc-number>
<kind>A</kind>
<name>Takamine et al.</name>
<date>19890300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  4</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>4825361</doc-number>
<kind>A</kind>
<name>Omoda et al.</name>
<date>19890400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  6</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>4910667</doc-number>
<kind>A</kind>
<name>Tanaka et al.</name>
<date>19900300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711168</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>4991083</doc-number>
<kind>A</kind>
<name>Aoyama et al.</name>
<date>19910200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711207</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>5010483</doc-number>
<kind>A</kind>
<name>Mishina et al.</name>
<date>19910400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  6</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>5136699</doc-number>
<kind>A</kind>
<name>Yokoyama</name>
<date>19920800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711220</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>5247695</doc-number>
<kind>A</kind>
<name>Kashiyama et al.</name>
<date>19930900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  6</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>5437043</doc-number>
<kind>A</kind>
<name>Fujii et al.</name>
<date>19950700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  1</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>5649142</doc-number>
<kind>A</kind>
<name>Lavelle et al.</name>
<date>19970700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711209</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>5887182</doc-number>
<kind>A</kind>
<name>Kinoshita</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>5929928</doc-number>
<kind>A</kind>
<name>Matsugami et al.</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>348563</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6349380</doc-number>
<kind>B1</kind>
<name>Shahidzadeh et al.</name>
<date>20020200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712211</main-classification></classification-national>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>6745315</doc-number>
<kind>B2</kind>
<name>Gurney et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711217</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00017">
<othercit>R. Espasa, M. Valero, J. Smith, Vector Architectures: Past, Present and Future, International Conference on Supercomputing (ICS'1998), pp. 425-432, Jul. 1998.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>Pages downloaded from home.ecn.ab.ca/˜jsavard/other/arcint.htm,ar02.htm,ar0201.htm,ar0202.htm,ar020201.htm,ar0302htm,ar0304.htm; downloaded on Nov. 24, 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>P. Koopman, Vector Architecture, Carnegie Mellon 18-548/15-548 Memory System Architecture, Nov. 4, 1998, downloaded from www.ece.cmu.edu/˜ece548/handouts/16v<sub>—</sub>arch.pdf on Nov. 24, 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00020">
<othercit>W. Buchholz, The IBM System/370 vector architecture, IBM Systems Journal, vol. 25, No. 1, 1986, pp. 51-62.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00021">
<othercit>M. Mittal, A. Peleg, U. Weiser, MMX Technology Architecture Overview, Intel Technololgy Journal, 3rd Quarter 1997, www.intel.com/technology/itj/q31997/pdf/archite.pdf.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00022">
<othercit>A. Peleg, U. Weiser, MMX Technology Extension to the Intel Architecture, IEEE Micro, 1996, pp. 42-50.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00023">
<othercit>Motorola, AltiVec Technology At-a-Glance, 2002, downloaded from http://e-www.motorola.com/files/32bit/doc/fact<sub>—</sub>sheet/ALTIVECGLANCE.pdf.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00024">
<othercit>S. Fuller, Motorola's AltiVec Technology, 1998, downloaded from http://e-www.motorola.com/files/32bit/doc/fact<sub>—</sub>sheet/ALTIVECWP.pdf.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00025">
<othercit>Motorola, AltiVec Execution Unit and Instruction Set Overview, downloaded from http://e-www.motorola.com/webapp/sps/site/overview.jsp?nodeId=03C1TR0467mKqW5Nf2hG12 Nov. 24, 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00026">
<othercit>V. Fischer, M. Drutarovsky, Scalable RSA Processor in Reconfigurable Hardware—a SoC Building Block, Conf. on Design of Circuits and Integrated Sys., Nov. 20-23, 2001, Portugal.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00027">
<othercit>Hewlett Packard, Vax Macro and Instruction Set Reference Manual, sections 10. Apr. 10-12, 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00028">
<othercit>R. Buchty, Cryptonite—A Programmable Crypto Processor Architecture for High-Bandwidth Applications, Thesis, Technische Universitat Munchen, Jan. 10, 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>16</number-of-claims>
<us-exemplary-claim>10</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711221</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711220</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>6</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60430749</doc-number>
<kind>00</kind>
<date>20021204</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040153623</doc-number>
<kind>A1</kind>
<date>20040805</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Buchty</last-name>
<first-name>Rainer</first-name>
<address>
<city>Neuershausen</city>
<country>DE</country>
</address>
</addressbook>
<nationality>
<country>DE</country>
</nationality>
<residence>
<country>DE</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Heintze</last-name>
<first-name>Nevin</first-name>
<address>
<city>Morristown</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Oliva</last-name>
<first-name>Dino P.</first-name>
<address>
<city>Maplewood</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Agere Systems Inc.</orgname>
<role>02</role>
<address>
<city>Allentown</city>
<state>PA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kim</last-name>
<first-name>Matthew</first-name>
<department>2186</department>
</primary-examiner>
<assistant-examiner>
<last-name>Tsai</last-name>
<first-name>Sheng-Jen</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Disclosed is a vector indexed memory unit and method of operation. In one embodiment a plurality of values are stored in segments of a vector index register. Individual ones of the values are provided to an associated operator (e.g., adder or bit replacement). Individual ones of the operators operates on its associated vector index value and a base value to generate a memory address. These memory addresses are then concurrently accessed in one or more memory units. If the data in the memory units are organized as data tables, the apparatus allows for multiple concurrent table lookups. In an alternate embodiment, in addition to the above described operators generating multiple memory addresses, an adder is provided to add the base value to the value represented by the concatenation of the bits in the vector index register to generate a single memory address. Multiplexers controlled by a programmable mode select signal are used to provide either the multiple memory addresses or the single memory address to the memory units. This alternate embodiment provides an apparatus that can programmably function in either an vector indexed memory mode or a conventional memory addressing mode.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="138.60mm" wi="198.04mm" file="US07299338-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="253.49mm" wi="165.44mm" file="US07299338-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="245.11mm" wi="151.72mm" file="US07299338-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="250.87mm" wi="149.86mm" file="US07299338-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="127.34mm" wi="172.64mm" file="US07299338-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="237.49mm" wi="156.89mm" file="US07299338-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="202.52mm" wi="155.28mm" orientation="landscape" file="US07299338-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Application No. 60/430,749, filed Dec. 4, 2002.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">This invention relates generally to memory units and more particularly to techniques for accessing memory addresses within such memory units.</p>
<p id="p-0004" num="0003">The use of electronic memory units is prevalent in many different types of devices. For example, memory is used in general purpose computers where programs and user data are stored in the memory and accessed as necessary by the computer processor. Although general purpose computers may be the most commonly thought of device which uses such memory, many other devices use electronic memory for storing data. For example, mobile telephones, household electronics and handheld entertainment units are just a few of the devices that utilize electronic memory to store data.</p>
<p id="p-0005" num="0004">As is well known in the art, traditional memory is accessed by providing a memory address to the memory unit and either reading data from or writing data to the particular memory address. One traditional type of memory addressing is base-index addressing in which memory is accessed using a base address b and an index value x. The index x is added to the base address b to calculate the memory address a to be accessed. Such conventional memory addressing is shown in <figref idref="DRAWINGS">FIG. 1</figref> which illustrates a logical memory <b>100</b> which is 64 bits (8 bytes) wide and has capacity to store 256 64-bit data words. Assume for the present illustration that the base value points to the first memory location <b>102</b> of logical memory <b>100</b>. By adding the index value to the base value, the index value acts as an offset and identifies the memory location <b>104</b> which has an address of a=b+x. In accordance with conventional memory addressing techniques, the hardware will return the 64 bit data word starting at location <b>104</b> to a memory register <b>106</b>.</p>
<p id="p-0006" num="0005">Another known technique for accessing memory, as illustrated in <figref idref="DRAWINGS">FIG. 2</figref>, is a block access. In accordance with this technique, rather than accessing a single data word from the memory unit, a contiguous block of data is read starting at the memory location identified using base-index addressing as described above. With reference to <figref idref="DRAWINGS">FIG. 2</figref>, assume that the base plus index calculation (a=b+x) results in an identification of memory address <b>202</b>. Rather than accessing the 64 bit data word starting at address <b>202</b>, the block access technique will access a contiguous block of data starting at location <b>202</b>. The amount of data that will be accessed depends on the particular implementation. For purposes of illustrations, assume that the block access returns three 64 bit data words. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the block memory access will return the three 64 bit data words starting at memory location <b>202</b>. Assuming a read operation, the resulting data will be stored either in a register or another memory location, illustrated in <figref idref="DRAWINGS">FIG. 2</figref> as <b>206</b>.</p>
<p id="p-0007" num="0006">One well known type of memory access is a table lookup, in which data to be accessed is stored in memory as a logical table. The table data structure is particularly well suited for base-index addressing, in which the base address represents the starting location of the table and the index represents the particular entry in the table. Table lookups are often used to implement data transformations in cryptographic algorithms in order to save computation time. Rather than calculate such data transformations in real-time, the data transformations are calculated in advance and the results are stored in a memory table. When a transformation is needed, a table lookup is performed and the result is retrieved from the table. While these table lookups substantially improve the efficiency of cryptographic algorithms, the table lookups remain one of the more time consuming tasks. When many data transformations are necessary, there are a large number of table lookups.</p>
<p id="p-0008" num="0007">One known technique for simplifying multiple table lookups is the use of a technique in which a memory register (e.g., 64 bits) is considered as containing a number of segments each representing table indices. For example, the memory word may be considered as containing eight 8-bit segments each representing a table index. Each segment is considered as a memory index and is added to a base address to identify a memory location. Each memory address is accessed (e.g., read) and the data at each of the accessed memory addresses is then stored, either in a register or in main memory. It is noted that while this technique may be implemented using one processor instruction, each memory access is performed sequentially, with one memory access at a time. Thus, in the illustrative case in which a 64 bit memory word is considered as containing eight 8 bit segments, there would be eight sequential memory accesses.</p>
<p id="p-0009" num="0008">Table lookups are an important technique in various computer processing tasks. However, main memory table lookups are expensive in terms of processing time and represent a significant amount of processing time for those algorithms (e.g., cryptographic algorithms) which require a large number of table lookups.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0010" num="0009">The present invention provides an improved method and apparatus for accessing memory, and is especially useful in applications which require a large number of table lookups in memory.</p>
<p id="p-0011" num="0010">In accordance with one embodiment of the invention, multiple memory locations are accessed concurrently using the values stored in an index vector to identify the memory locations to be accessed. The index vector contains a plurality of segments, individual ones of which contains a value. Individual ones of a plurality of operator circuits which are coupled to the index vector concurrently perform an operation on individual ones of the index vector values and a base value to generate a plurality of memory addresses. The operation may be, for example, the addition operation or bit substitution. The operator circuits are coupled to one or more memory units and the memory addresses output from the operator circuits are concurrently accessed in the memory units.</p>
<p id="p-0012" num="0011">In one advantageous embodiment, the memory units store identical data tables such that multiple table lookups may be performed concurrently using the values in the index vector as indices into the data tables. This embodiment is particularly useful in conjunction with table lookup intensive algorithms, such as cryptographic algorithms which make use of data table lookups to perform data transformations.</p>
<p id="p-0013" num="0012">In another embodiment of the invention, the memory access apparatus is programmable such that it may operate as a vector indexed memory unit or as a conventionally addressed memory unit. In such an embodiment, individual ones of a plurality of operator circuits which are coupled to segments of the index vector concurrently perform an operation on individual ones of the index vector values and a base value to generate a plurality of memory addresses. At the same time, an adder adds the base value to the value represented by the concatenation of all segments of the index vector to generate a single memory address. Using a plurality of multiplexers controlled by a mode select signal, either the plurality of memory addresses, or the single memory address, is provided to the memory units. In this manner, the apparatus may be used as either a vector indexed memory unit or as a conventionally addressed memory unit, and the mode of operation is programmably controlled.</p>
<p id="p-0014" num="0013">These and other advantages of the invention will be apparent to those of ordinary skill in the art by reference to the following detailed description and the accompanying drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> illustrates the prior art base plus index memory addressing;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> illustrates the prior art base plus index block memory addressing;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref> illustrates vector index memory addressing in accordance with the principles of the present invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> is a block diagram of an embodiment of a vector indexed memory apparatus;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5A</figref> illustrates the binary addition operation in conjunction with base plus index memory addressing;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 5B</figref> illustrates bit slicing which may be used in accordance with one embodiment of the present invention; and</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram of an embodiment of a memory apparatus which is programmable to operate in a vector indexed memory mode or conventional memory addressing mode.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0022" num="0021">While details of various embodiments of the invention will be described below, we will first provide a high level description of the principles of the present invention in conjunction with <figref idref="DRAWINGS">FIG. 3</figref>. <figref idref="DRAWINGS">FIG. 3</figref> shows a logical memory <b>304</b> and an index vector <b>302</b>. For purposes of this discussion, the particular size or layout of the logical memory <b>304</b> or of the index vector <b>302</b> is unimportant. The logical memory <b>304</b> contains various memory locations for storing data. As described above, the logical memory <b>304</b> is accessed using base plus index addressing. As such, the base value contains the memory address of the first memory location <b>306</b>. In accordance with the principles of the present invention, the index vector contains a plurality of values which are used as indices to access memory unit <b>304</b>. Thus, each of the index vector <b>302</b> values is used as an offset from the base value and thus represents a location in memory unit <b>304</b>. In accordance with one aspect of the invention, the memory locations identified by the indices in the index vector <b>302</b> are accessed concurrently and the resulting data is stored in results register <b>312</b>. As shown in <figref idref="DRAWINGS">FIG. 3</figref>, the index i<sub>7 </sub>stored in segment <b>308</b> of index vector <b>302</b> identifies memory location <b>310</b> (i.e., i<sub>7</sub>+Base=memory location <b>310</b>). Thus, in the case of a read operation, the contents of memory location <b>310</b> are retrieved and stored in result register <b>312</b> location <b>314</b>. Similarly, the index stored in segment <b>316</b> of index vector <b>302</b> identifies memory location <b>318</b> and the contents of memory location <b>318</b> are retrieved and stored in result register <b>312</b> location <b>320</b>. In this manner, each of the memory locations within memory unit <b>304</b> identified by the indices in index vector <b>302</b> are accessed and stored in the result register <b>312</b>. In accordance with one aspect of the present invention, the memory accesses occur concurrently, rather than sequentially as in the prior art. In the example of <figref idref="DRAWINGS">FIG. 3</figref>, eight data items are retrieved from eight different memory locations during one memory access cycle. Using prior art techniques, the retrieval of the same eight data items from the eight different memory locations would require eight memory access cycles. Thus, the present invention provides for multiple memory accesses (e.g., multiple table lookups) in memory access cycle and is especially useful for memory intensive computing algorithms.</p>
<p id="p-0023" num="0022">A block diagram of a first embodiment of the present invention is shown in <figref idref="DRAWINGS">FIG. 4</figref>. One skilled in the art will recognize that <figref idref="DRAWINGS">FIG. 4</figref> is a high level functional block diagram. As such, and for clarity of description, certain well known required elements are not shown but would be readily apparent to one skilled in the art when implementing the present invention. <figref idref="DRAWINGS">FIG. 4</figref> shows an index vector register <b>402</b> which stores a plurality of table indices in a plurality of segments. In the embodiment shown in <figref idref="DRAWINGS">FIG. 4</figref>, the index vector register is 64 bits wide, with each segment (e.g., segment <b>412</b>) containing 8 bits. Thus, using base plus index addressing, each segment of the index vector register may address one of 256 memory locations. Each of the index vector register segments is connected to one of a plurality of adders <b>406</b>. Each of the adders has as one input a base value (stored, for example, in a memory register) for use in the base plus indexing addressing technique, and as its other input an associated one of the segments of the index vector register. Thus, for example, adder <b>414</b> has as one of its inputs the base value and as its other input segment <b>412</b> of the index vector register <b>402</b>. The output of the adders <b>406</b> are connected to associated memory units <b>408</b>. Thus, for example, the output of adder <b>414</b> is connected to memory unit <b>416</b>. It is the output of adder <b>416</b> that is used to access the memory unit <b>416</b>. In the embodiment shown in <figref idref="DRAWINGS">FIG. 4</figref>, the memory units <b>408</b> are each 8 bits wide and contain 65,536 8-bit data words. This is appropriate assuming a base value having 16 bits. The output of the memory units <b>416</b> are connected to associated segments of a result register <b>410</b>. Thus, for example, the output of memory unit <b>416</b> is connected to segment <b>418</b> of result register <b>410</b>. Assuming a read operation, the data read from the memory units <b>408</b> are stored in appropriate segments of the result register <b>410</b>.</p>
<p id="p-0024" num="0023">We will now describe the operation of the apparatus shown in <figref idref="DRAWINGS">FIG. 4</figref> by describing the memory access with respect to one of the indices in the index vector register <b>402</b>. As shown in the figure, segment <b>412</b> of index vector register <b>402</b> contains the index i<sub>0</sub>. Adder <b>414</b> adds index i<sub>0 </sub>with the base value and provides the resulting address to memory <b>416</b>. The base value represents the first address of a table stored in memory <b>416</b> and the index i<sub>0 </sub>is the index into the table. Assuming the memory access in this case was a read operation, the data stored at the memory location output by adder <b>414</b> is stored in segment <b>418</b> of result register <b>410</b>. The above described memory access is concurrently carried out for each of the indices stored in the segments of index vector register <b>402</b>. As such, in a single memory access cycle, the result register <b>410</b> is loaded with the values identified by the indices stored in the index vector register <b>402</b>.</p>
<p id="p-0025" num="0024">The memory units <b>408</b> of <figref idref="DRAWINGS">FIG. 4</figref> may be implemented in various ways. For example, each of the memory units may be a separate physical memory unit. Alternatively, the various memory units shown in <figref idref="DRAWINGS">FIG. 4</figref> may be implemented using one or more multiport memory units which are well known in the art. In a multiport memory embodiment, the outputs of the adders <b>406</b> would be connected to individual ports of the multiport memory.</p>
<p id="p-0026" num="0025">In certain embodiments, the data stored in each of the memory units <b>408</b> will be identical. For example, consider an implementation of the present invention which will be used to optimize a particular algorithm in which many table lookups are required in a data table which has 256 8-bit entries. In such an embodiment, each of the memory units <b>408</b> could be stored with the same data table, and in accordance with the embodiment shown in <figref idref="DRAWINGS">FIG. 4</figref>, 8 table lookups could be performed simultaneously by storing 8 indices in the index vector <b>402</b>. In accordance with this embodiment of the invention, the 8 table items associated with the 8 indices will be concurrently loaded into the result register <b>410</b> as described above. Of course, in various other embodiments, the memory units <b>408</b> may store different data, or some memory units may store the same data while other memory units store different data.</p>
<p id="p-0027" num="0026">In another embodiment of the invention, the adders <b>414</b> of <figref idref="DRAWINGS">FIG. 4</figref> are replaced with bit replacement operators to further improve the speed of operation. Prior to describing this embodiment, we will first describe in further detail the addition operation performed by the adders in <figref idref="DRAWINGS">FIG. 4</figref>. <figref idref="DRAWINGS">FIG. 5A</figref> shows the addition operation performed by the adders <b>406</b>. As described above, the embodiments described herein utilize the base plus index addressing technique wherein the physical memory address a is calculated by adding an index value i to a base value b such that a=b+x. Assume for purposes of discussion a base address of 16 bits, an index address of 8 bits and a physical address of 16 bits. Thus, as shown in <figref idref="DRAWINGS">FIG. 5A</figref>, the base address <b>502</b> is added to the index <b>504</b> to obtain the physical address <b>506</b>. This addition operation of <figref idref="DRAWINGS">FIG. 5A</figref> is a standard binary addition which is well known in the art. While not an overly complex operation, memory access in accordance with the present invention may be further improved by replacing the addition operator with a bit replacement operator. Referring now to <figref idref="DRAWINGS">FIG. 5B</figref>, if we assume that the low order bits <b>508</b> of the base address <b>510</b> are all 0 (or unused), then the index address <b>512</b> can be effectively added to the base address <b>510</b> by merely replacing the low order bits <b>508</b> of the base address <b>510</b> with the bits of the index address <b>512</b> to obtain the physical address <b>514</b>. This bit replacement could be implemented in various ways. For example, in one embodiment, the high order bits <b>516</b> of the base address <b>510</b> could be concatenated with the bits of the index address <b>512</b>. One of ordinary skill in the art of binary logic would understand that the bit replacement operation may also be implemented using a logical OR operation so long as the assumption holds that the low order bits <b>508</b> of the base address <b>510</b> are all 0.</p>
<p id="p-0028" num="0027">One skilled in the art would recognize that the use of bit replacement as described in conjunction with <figref idref="DRAWINGS">FIG. 5B</figref> requires certain assumptions to be met and the data in the memory units to be organized in a particular manner. For example, in the embodiment described in conjunction with <figref idref="DRAWINGS">FIG. 5B</figref>, it is assumed that the low order 8 bits <b>508</b> of the 16 bit base address <b>510</b> are all zero or unused. This means that any tables stored in the memory units must begin on 256 byte page boundaries.</p>
<p id="p-0029" num="0028">Thus, in an alternate embodiments, the adders <b>406</b> of <figref idref="DRAWINGS">FIG. 4</figref> would be replaced with bit replacement operators (e.g., logical OR operators or an operator which performs concatenation of appropriate bits).</p>
<p id="p-0030" num="0029">Another embodiment of the invention is shown in <figref idref="DRAWINGS">FIG. 6</figref>. In this embodiment, the apparatus is programmable to act as either a vector indexed memory or as a convention memory. <figref idref="DRAWINGS">FIG. 6</figref> shows an index vector register <b>602</b> which stores either a plurality of table indices in a plurality of segments in the manner described above in conjunction with <figref idref="DRAWINGS">FIG. 4</figref>, or a single index as described in further detail below. In the embodiment shown in <figref idref="DRAWINGS">FIG. 6</figref>, we will again assume that the index vector register is 64 bits wide, with each segment (e.g., segment <b>604</b>) containing 8 bits. Thus, using base plus index addressing, each segment of the index vector register may address one of 256 memory locations. Each of the index vector register segments is connected to one of a plurality of adders <b>606</b>. Each of the adders has as one input a base value for use in the base plus indexing addressing technique, and as its other input an associated one of the segments of the index vector register <b>602</b>. Thus, for example, adder <b>608</b> has as one of its inputs the base value and as its other input segment <b>604</b> of the index vector register <b>602</b>.</p>
<p id="p-0031" num="0030">The apparatus shown in <figref idref="DRAWINGS">FIG. 6</figref> also contains adder <b>614</b> which has as one input the base value. The other input of adder <b>614</b> is the 64-bits of the index vector register <b>602</b>. However, unlike the adders <b>606</b> which each have as an input a particular segment of the index vector register <b>602</b>, adder <b>614</b> has as an input the entire index vector register <b>602</b>. Thus, the adder <b>614</b> receives all 64-bits of the index vector register <b>602</b> via 64-bit line <b>622</b>. Another way to view this input of the adder <b>614</b> is that the adder receives the concatenated bits of the individual segments of the index vector register <b>602</b>. In operation, the adder <b>614</b> adds the single value represented by the 64-bits of the index vector register <b>602</b> and the value represented by the 16 bits of the base value to produce a single memory address as its output.</p>
<p id="p-0032" num="0031">The outputs of each of the adders <b>606</b> are each provided as an input to an associated one of the multiplexers <b>610</b> as shown in <figref idref="DRAWINGS">FIG. 6</figref>. The output of adder <b>614</b> is also provided as an input to each of the multiplexers <b>610</b>. Each of the multiplexers also has as an input a mode select signal which determines which of the multiplexer inputs is output from the multiplexer. Thus, for example, multiplexer <b>612</b> has as one input the output of adder <b>608</b> and as another input the output of adder <b>614</b>. The mode select signal <b>616</b> to multiplexer <b>612</b> will determine which of its two inputs is output from the multiplexer. The output of each for the multiplexers <b>610</b> is an input to an associated one of the memory units <b>618</b>. The output of the memory units <b>618</b> are connected to associated segments of a result register <b>620</b>.</p>
<p id="p-0033" num="0032">We will now describe the operation of the apparatus shown in <figref idref="DRAWINGS">FIG. 6</figref>. As shown in the figure, segment <b>604</b> of index vector register <b>602</b> contains the index i<sub>0</sub>. Adder <b>608</b> adds index i<sub>0 </sub>with the base value and provides the resulting address to multiplexer <b>612</b>. Each of the adders <b>606</b> operates in a similar manner concurrently adding one of the indices in one of the segments of the index vector register <b>602</b> with the base value and provides the result to an associated one of the multiplexers. At the same time, the adder <b>614</b> adds the entire index vector register <b>602</b> to the base value. That is, the adder <b>614</b> concatenates the bits in all of the segments and adds the value represented by the concatenated bits to the base value. Thus, the adder <b>614</b> performs the operation: base value+i<sub>7 </sub>i<sub>6 </sub>i<sub>5 </sub>i<sub>4 </sub>i<sub>3 </sub>i<sub>2 </sub>i<sub>1 </sub>i<sub>0</sub>. The output of the adder <b>614</b> is provided to each of the multiplexers <b>610</b>. The operation of the memory units <b>618</b> and result register <b>620</b> are as described above in connection with <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0034" num="0033">The mode select signal, which is an input to each of the multiplexers <b>610</b>, determines which of the multiplexer inputs is output from the multiplexer. For example, the presence of a 0 on the mode select signal could indicate that the multiplexer will pass the output of adders <b>606</b> as an output, while the presence of a 1 on the mode select signal could indicate that the multiplexer will pass the output of adder <b>614</b> as an output. The mode select signal is programmable, and thus determines whether the apparatus will operate in a standard memory addressing mode or in a vector indexed addressing mode. If the mode select signal is 0, then the multiplexers pass the output of adders <b>606</b> as an output and thus the apparatus operates in a vector indexed addressing mode as described above in connection with <figref idref="DRAWINGS">FIG. 4</figref>. If the mode select signal is 1, then the multiplexers pass the output of adder <b>614</b> as an output and thus the apparatus operates in a standard memory addressing mode. In this standard memory addressing mode, the vector index register <b>602</b> contains a single index which is used as an offset from the base value in order to address the memory units <b>618</b>. Each of the memory units <b>618</b> is addressed using the same base plus index value. In this standard mode, although the memory units <b>618</b> may be separate logical memories, they will appear as a single memory during the standard memory addressing mode of operation. Assuming a read operation in the standard addressing mode, an 8-bit value will be read from each memory unit <b>618</b> and stored in an associated segment of the result register <b>620</b>. At the end of the operation, the result register <b>620</b> will contain a 64-bit value which, to the user, represents the single value returned as a result of the conventional memory access.</p>
<p id="p-0035" num="0034">In vector indexed memory mode, the index vector register <b>602</b> stores a vector of multiple values which are used as indices for memory access. However, in the standard memory access mode, the value stored in the index vector register <b>602</b> is not a vector of values, but a single value stored in the entire concatenated 64-bits. We note here that we identify the register <b>602</b> as a vector indexed register in both modes for clarity of description, even though in standard mode the register does not store a vector of index values. This is pointed out to make clear that in the embodiment shown in <figref idref="DRAWINGS">FIG. 6</figref>, the register <b>602</b> may store either a vector of values or a single value, and the use of the term vector indexed register to identify this register should not be taken to limit the contents of the register to a vector of values.</p>
<p id="p-0036" num="0035">In an alternate embodiment, the adders <b>606</b> of <figref idref="DRAWINGS">FIG. 6</figref> may be replaced with bit replacement operators (e.g., logical OR operators or concatenation operators) in order to implement the bit replacement embodiment as described above.</p>
<p id="p-0037" num="0036">The foregoing Detailed Description is to be understood as being in every respect illustrative and exemplary, but not restrictive, and the scope of the invention disclosed herein is not to be determined from the Detailed Description, but rather from the claims as interpreted according to the full breadth permitted by the patent laws. It is to be understood that the embodiments shown and described herein are only illustrative of the principles of the present invention and that various modifications may be implemented by those skilled in the art without departing from the scope and spirit of the invention. For example, the embodiments described above show various components having particular size (e.g., number of bits in a data word, number or memory units, or memory size), but it is to be understood that these are particular embodiments only, and the invention may be implemented using various components having different configurations. One skilled in the art would readily recognize that the principles of the present invention may be implemented using components of various sizes and configurations. Also, the embodiments described herein have for the most part been described using the read operation as an example of a memory access. However, the memory access techniques of the present invention are not limited to read operations. The principles of the present invention also apply to accessing memory for write operations.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for accessing at least one memory unit based on an index vector comprising a plurality of segments, said method comprising the steps of:
<claim-text>concurrently performing an operation on a value stored in individual ones of said index vector segments with a same base value to generate a first plurality of memory addresses;</claim-text>
<claim-text>adding said base value to a value represented by the concatenation of said plurality of segments of said index vector to generate a single memory address; and</claim-text>
<claim-text>concurrently accessing in said at least one memory unit either said first plurality of memory addresses or said single memory address.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein whether said first plurality of memory addresses or said single memory address is accessed is based on a mode select signal.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref> wherein said mode select signal is programmable.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said operation is addition.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said operation is bit replacement.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref> wherein said bit replacement operation is implemented with logical OR and a plurality of least significant bits of said base address are 0.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref> wherein said bit replacement operation is implemented with bit concatenation.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said at least one memory unit comprises one multiport memory unit and wherein said step of concurrently accessing comprises the step of accessing either i) individual ones of said first plurality of memory addresses in a corresponding port of said multiport memory unit or ii) said single memory address in individual ones of said ports of said multiport memory unit.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said at least one memory unit comprises a plurality of memory units and wherein said step of concurrently accessing comprises the step of accessing either i) individual ones of said first plurality of memory addresses in a corresponding one of said plurality of memory units or ii) said single memory address in individual ones of said plurality of memory units.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. Apparatus comprising:
<claim-text>a first storage register for storing an index vector comprising a plurality of segments;</claim-text>
<claim-text>a second storage register for storing a base value;</claim-text>
<claim-text>a plurality of operator circuits, individual ones of said plurality of operator circuits having a first input coupled to at least a portion of said first storage register and a second input coupled to said second storage register, said plurality of operator circuits for performing an operation on a value stored in individual ones of said index vector segments with said base value to generate a first plurality of memory addresses on outputs of said operator circuits;</claim-text>
<claim-text>an adder circuit having a first input coupled to said second storage register and a second input coupled to said first storage register for adding said base value to a value represented by the concatenation of said plurality of segments of said index vector to generate a single memory address;</claim-text>
<claim-text>a plurality of multiplexers, individual ones of said plurality of multiplexers having as a first input one of said first plurality of memory addresses generated by said operator circuits and as a second input said single memory address and as a third input a mode select signal such that said plurality of multiplexers outputs either said one of said first plurality of memory addresses or said single memory address on an output port depending on said mode select signal; and</claim-text>
<claim-text>at least one memory unit coupled to said output port of said multiplexers such that either said plurality of memory addresses or said single memory address is accessible in said at least one memory unit.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The apparatus of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein said operator circuits are adders.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The apparatus of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein said operator circuits are bit replacement circuits.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The apparatus of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein said bit replacement circuits are logical OR circuits and a plurality of least significant bits of said base address are 0.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The apparatus of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein said bit replacement circuits are bit concatenation circuits.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The apparatus of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein said at least one memory unit is a multiport memory unit and wherein individual ones of said ports of said multiport memory unit are coupled to an output port of a corresponding multiplexer.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The apparatus of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein said at least one memory unit comprises a plurality of memory units and wherein individual ones of said plurality of memory units is coupled to an output of a corresponding multiplexer.</claim-text>
</claim>
</claims>
</us-patent-grant>
