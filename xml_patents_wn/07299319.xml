<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299319-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299319</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10807094</doc-number>
<date>20040322</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>341</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711125</main-classification>
<further-classification>711163</further-classification>
<further-classification>711156</further-classification>
</classification-national>
<invention-title id="d0e53">Method and apparatus for providing hardware assistance for code coverage</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4291371</doc-number>
<kind>A</kind>
<name>Holtey</name>
<date>19810900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>364200</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>4316245</doc-number>
<kind>A</kind>
<name>Luu et al.</name>
<date>19820200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5103394</doc-number>
<kind>A</kind>
<name>Blasciak</name>
<date>19920400</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>395575</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5113507</doc-number>
<kind>A</kind>
<name>Jaeckel</name>
<date>19920500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5212794</doc-number>
<kind>A</kind>
<name>Pettis et al.</name>
<date>19930500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5276833</doc-number>
<kind>A</kind>
<name>Auvinen et al.</name>
<date>19940100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>5287481</doc-number>
<kind>A</kind>
<name>Lin</name>
<date>19940200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>5394529</doc-number>
<kind>A</kind>
<name>Brown, III et al.</name>
<date>19950200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>5537572</doc-number>
<kind>A</kind>
<name>Michelsen et al.</name>
<date>19960700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>5581778</doc-number>
<kind>A</kind>
<name>Chin et al.</name>
<date>19961200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>5652858</doc-number>
<kind>A</kind>
<name>Okada et al.</name>
<date>19970700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>5659679</doc-number>
<kind>A</kind>
<name>Alpert et al.</name>
<date>19970800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>5691920</doc-number>
<kind>A</kind>
<name>Levine et al.</name>
<date>19971100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>36455101</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>5710881</doc-number>
<kind>A</kind>
<name>Gupta et al.</name>
<date>19980100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>5752062</doc-number>
<kind>A</kind>
<name>Gover et al.</name>
<date>19980500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>5768500</doc-number>
<kind>A</kind>
<name>Agrawal et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>5774724</doc-number>
<kind>A</kind>
<name>Heisch</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>395704</main-classification></classification-national>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>5794028</doc-number>
<kind>A</kind>
<name>Tran</name>
<date>19980800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>5797019</doc-number>
<kind>A</kind>
<name>Levine et al.</name>
<date>19980800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>5805879</doc-number>
<kind>A</kind>
<name>Hervin et al.</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>5822763</doc-number>
<kind>A</kind>
<name>Baylor et al.</name>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>5822790</doc-number>
<kind>A</kind>
<name>Mehrotra</name>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>5887159</doc-number>
<kind>A</kind>
<name>Burrows</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>5928334</doc-number>
<kind>A</kind>
<name>Mandyam et al.</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>5930508</doc-number>
<kind>A</kind>
<name>Faraboschi et al.</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>395706</main-classification></classification-national>
</citation>
<citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>5937437</doc-number>
<kind>A</kind>
<name>Roth et al.</name>
<date>19990800</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>711202</main-classification></classification-national>
</citation>
<citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>5938760</doc-number>
<kind>A</kind>
<name>Levine et al.</name>
<date>19990800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>5938778</doc-number>
<kind>A</kind>
<name>John, Jr. et al.</name>
<date>19990800</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714 45</main-classification></classification-national>
</citation>
<citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>5940618</doc-number>
<kind>A</kind>
<name>Blandy et al.</name>
<date>19990800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>5950003</doc-number>
<kind>A</kind>
<name>Kaneshiro et al.</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>5950009</doc-number>
<kind>A</kind>
<name>Bortnikov et al.</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>5966537</doc-number>
<kind>A</kind>
<name>Ravichandran</name>
<date>19991000</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>395709</main-classification></classification-national>
</citation>
<citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>5966538</doc-number>
<kind>A</kind>
<name>Granston et al.</name>
<date>19991000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>5970439</doc-number>
<kind>A</kind>
<name>Levine et al.</name>
<date>19991000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>5987250</doc-number>
<kind>A</kind>
<name>Subrahmanyam</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>395704</main-classification></classification-national>
</citation>
<citation>
<patcit num="00036">
<document-id>
<country>US</country>
<doc-number>6006033</doc-number>
<kind>A</kind>
<name>Heisch</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00037">
<document-id>
<country>US</country>
<doc-number>6026235</doc-number>
<kind>A</kind>
<name>Shaughnessy</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00038">
<document-id>
<country>US</country>
<doc-number>6070009</doc-number>
<kind>A</kind>
<name>Dean et al.</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>395704</main-classification></classification-national>
</citation>
<citation>
<patcit num="00039">
<document-id>
<country>US</country>
<doc-number>6094709</doc-number>
<kind>A</kind>
<name>Baylor et al.</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00040">
<document-id>
<country>US</country>
<doc-number>6101524</doc-number>
<kind>A</kind>
<name>Choi et al.</name>
<date>20000800</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>709102</main-classification></classification-national>
</citation>
<citation>
<patcit num="00041">
<document-id>
<country>US</country>
<doc-number>6119075</doc-number>
<kind>A</kind>
<name>Dean et al.</name>
<date>20000900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00042">
<document-id>
<country>US</country>
<doc-number>6134676</doc-number>
<kind>A</kind>
<name>VanHuben et al.</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714 39</main-classification></classification-national>
</citation>
<citation>
<patcit num="00043">
<document-id>
<country>US</country>
<doc-number>6189072</doc-number>
<kind>B1</kind>
<name>Levine et al.</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00044">
<document-id>
<country>US</country>
<doc-number>6189141</doc-number>
<kind>B1</kind>
<name>Benitez et al.</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717  4</main-classification></classification-national>
</citation>
<citation>
<patcit num="00045">
<document-id>
<country>US</country>
<doc-number>6189142</doc-number>
<kind>B1</kind>
<name>Johnston et al.</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00046">
<document-id>
<country>US</country>
<doc-number>6192513</doc-number>
<kind>B1</kind>
<name>Subrahmanyam</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717  5</main-classification></classification-national>
</citation>
<citation>
<patcit num="00047">
<document-id>
<country>US</country>
<doc-number>6206584</doc-number>
<kind>B1</kind>
<name>Hastings</name>
<date>20010300</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>39518311</main-classification></classification-national>
</citation>
<citation>
<patcit num="00048">
<document-id>
<country>US</country>
<doc-number>6223338</doc-number>
<kind>B1</kind>
<name>Smolders</name>
<date>20010400</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717  4</main-classification></classification-national>
</citation>
<citation>
<patcit num="00049">
<document-id>
<country>US</country>
<doc-number>6233679</doc-number>
<kind>B1</kind>
<name>Holmberg</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00050">
<document-id>
<country>US</country>
<doc-number>6237141</doc-number>
<kind>B1</kind>
<name>Holzle et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00051">
<document-id>
<country>US</country>
<doc-number>6243804</doc-number>
<kind>B1</kind>
<name>Cheng</name>
<date>20010600</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>712228</main-classification></classification-national>
</citation>
<citation>
<patcit num="00052">
<document-id>
<country>US</country>
<doc-number>6256775</doc-number>
<kind>B1</kind>
<name>Flynn</name>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717  4</main-classification></classification-national>
</citation>
<citation>
<patcit num="00053">
<document-id>
<country>US</country>
<doc-number>6285974</doc-number>
<kind>B1</kind>
<name>Mandyam et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00054">
<document-id>
<country>US</country>
<doc-number>6286132</doc-number>
<kind>B1</kind>
<name>Tanaka et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717  4</main-classification></classification-national>
</citation>
<citation>
<patcit num="00055">
<document-id>
<country>US</country>
<doc-number>6324689</doc-number>
<kind>B1</kind>
<name>Lowney et al.</name>
<date>20011100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717  9</main-classification></classification-national>
</citation>
<citation>
<patcit num="00056">
<document-id>
<country>US</country>
<doc-number>6330662</doc-number>
<kind>B1</kind>
<name>Patel et al.</name>
<date>20011200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>712236</main-classification></classification-national>
</citation>
<citation>
<patcit num="00057">
<document-id>
<country>US</country>
<doc-number>6351844</doc-number>
<kind>B1</kind>
<name>Bala</name>
<date>20020200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717  4</main-classification></classification-national>
</citation>
<citation>
<patcit num="00058">
<document-id>
<country>US</country>
<doc-number>6374364</doc-number>
<kind>B1</kind>
<name>McElroy et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714 10</main-classification></classification-national>
</citation>
<citation>
<patcit num="00059">
<document-id>
<country>US</country>
<doc-number>6381679</doc-number>
<kind>B1</kind>
<name>Matsubara et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00060">
<document-id>
<country>US</country>
<doc-number>6430741</doc-number>
<kind>B1</kind>
<name>Mattson, Jr. et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717154</main-classification></classification-national>
</citation>
<citation>
<patcit num="00061">
<document-id>
<country>US</country>
<doc-number>6442585</doc-number>
<kind>B1</kind>
<name>Dean et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>709108</main-classification></classification-national>
</citation>
<citation>
<patcit num="00062">
<document-id>
<country>US</country>
<doc-number>6446029</doc-number>
<kind>B1</kind>
<name>Davidson et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>702186</main-classification></classification-national>
</citation>
<citation>
<patcit num="00063">
<document-id>
<country>US</country>
<doc-number>6480938</doc-number>
<kind>B2</kind>
<name>Vondran, Jr.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>711125</main-classification></classification-national>
</citation>
<citation>
<patcit num="00064">
<document-id>
<country>US</country>
<doc-number>6505292</doc-number>
<kind>B1</kind>
<name>Witt</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00065">
<document-id>
<country>US</country>
<doc-number>6539458</doc-number>
<kind>B2</kind>
<name>Holmberg</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00066">
<document-id>
<country>US</country>
<doc-number>6542985</doc-number>
<kind>B1</kind>
<name>Johnson et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00067">
<document-id>
<country>US</country>
<doc-number>6549959</doc-number>
<kind>B1</kind>
<name>Yates et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00068">
<document-id>
<country>US</country>
<doc-number>6549998</doc-number>
<kind>B1</kind>
<name>Pekarich et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00069">
<document-id>
<country>US</country>
<doc-number>6594820</doc-number>
<kind>B1</kind>
<name>Ungar</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00070">
<document-id>
<country>US</country>
<doc-number>6631514</doc-number>
<kind>B1</kind>
<name>Le</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00071">
<document-id>
<country>US</country>
<doc-number>6636950</doc-number>
<kind>B1</kind>
<name>Mithal et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00072">
<document-id>
<country>US</country>
<doc-number>6647301</doc-number>
<kind>B1</kind>
<name>Sederlund et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00073">
<document-id>
<country>US</country>
<doc-number>6662295</doc-number>
<kind>B2</kind>
<name>Yamaura</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00074">
<document-id>
<country>US</country>
<doc-number>6681387</doc-number>
<kind>B1</kind>
<name>Hwu et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00075">
<document-id>
<country>US</country>
<doc-number>6687794</doc-number>
<kind>B2</kind>
<name>Malik</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00076">
<document-id>
<country>US</country>
<doc-number>6721875</doc-number>
<kind>B1</kind>
<name>McCormick et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712233</main-classification></classification-national>
</citation>
<citation>
<patcit num="00077">
<document-id>
<country>US</country>
<doc-number>6735666</doc-number>
<kind>B1</kind>
<name>Koning</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00078">
<document-id>
<country>US</country>
<doc-number>6772322</doc-number>
<kind>B1</kind>
<name>Merchant et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00079">
<document-id>
<country>US</country>
<doc-number>6782454</doc-number>
<kind>B1</kind>
<name>Damron</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00080">
<document-id>
<country>US</country>
<doc-number>6848029</doc-number>
<kind>B2</kind>
<name>Coldewey</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00081">
<document-id>
<country>US</country>
<doc-number>6925424</doc-number>
<kind>B2</kind>
<name>Jones et al.</name>
<date>20050800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00082">
<document-id>
<country>US</country>
<doc-number>6961925</doc-number>
<kind>B2</kind>
<name>Callahan, II et al.</name>
<date>20051100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00083">
<document-id>
<country>US</country>
<doc-number>6973417</doc-number>
<kind>B1</kind>
<name>Maxwell et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00084">
<document-id>
<country>US</country>
<doc-number>6973542</doc-number>
<kind>B1</kind>
<name>Schmuck et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00085">
<document-id>
<country>US</country>
<doc-number>7181723</doc-number>
<kind>B2</kind>
<name>Luk et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00086">
<document-id>
<country>US</country>
<doc-number>2001/0032305</doc-number>
<kind>A1</kind>
<name>Barry</name>
<date>20011000</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>712 34</main-classification></classification-national>
</citation>
<citation>
<patcit num="00087">
<document-id>
<country>US</country>
<doc-number>2002/0019976</doc-number>
<kind>A1</kind>
<name>Patel et al.</name>
<date>20020200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717137</main-classification></classification-national>
</citation>
<citation>
<patcit num="00088">
<document-id>
<country>US</country>
<doc-number>2002/0073406</doc-number>
<kind>A1</kind>
<name>Gove</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00089">
<document-id>
<country>US</country>
<doc-number>2002/0124237</doc-number>
<kind>A1</kind>
<name>Sprunt et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717127</main-classification></classification-national>
</citation>
<citation>
<patcit num="00090">
<document-id>
<country>US</country>
<doc-number>2002/0129309</doc-number>
<kind>A1</kind>
<name>Floyd et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>714724</main-classification></classification-national>
</citation>
<citation>
<patcit num="00091">
<document-id>
<country>US</country>
<doc-number>2002/0147965</doc-number>
<kind>A1</kind>
<name>Swaine et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717124</main-classification></classification-national>
</citation>
<citation>
<patcit num="00092">
<document-id>
<country>US</country>
<doc-number>2002/0157086</doc-number>
<kind>A1</kind>
<name>Lewis et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00093">
<document-id>
<country>US</country>
<doc-number>2002/0199179</doc-number>
<kind>A1</kind>
<name>Lavery et al.</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>717158</main-classification></classification-national>
</citation>
<citation>
<patcit num="00094">
<document-id>
<country>US</country>
<doc-number>2003/0014741</doc-number>
<kind>A1</kind>
<name>Megiddo et al.</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00095">
<document-id>
<country>US</country>
<doc-number>2003/0040955</doc-number>
<kind>A1</kind>
<name>Anaya et al.</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00096">
<document-id>
<country>US</country>
<doc-number>2003/0066055</doc-number>
<kind>A1</kind>
<name>Spivey</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00097">
<document-id>
<country>US</country>
<doc-number>2003/0101367</doc-number>
<kind>A1</kind>
<name>Bartfai et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00098">
<document-id>
<country>US</country>
<doc-number>2003/0131343</doc-number>
<kind>A1</kind>
<name>French et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00099">
<document-id>
<country>US</country>
<doc-number>2003/0135719</doc-number>
<kind>A1</kind>
<name>DeWitt et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712227</main-classification></classification-national>
</citation>
<citation>
<patcit num="00100">
<document-id>
<country>US</country>
<doc-number>2004/0049712</doc-number>
<kind>A1</kind>
<name>Betker et al.</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 35</main-classification></classification-national>
</citation>
<citation>
<patcit num="00101">
<document-id>
<country>US</country>
<doc-number>2004/0153612</doc-number>
<kind>A1</kind>
<name>Mutz et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00102">
<document-id>
<country>US</country>
<doc-number>2004/0194076</doc-number>
<kind>A1</kind>
<name>Comp et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00103">
<document-id>
<country>US</country>
<doc-number>2004/0205302</doc-number>
<kind>A1</kind>
<name>Cantrill</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00104">
<document-id>
<country>US</country>
<doc-number>2004/0268316</doc-number>
<kind>A1</kind>
<name>Fisher et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00105">
<document-id>
<country>US</country>
<doc-number>2005/0091456</doc-number>
<kind>A1</kind>
<name>Huck</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00106">
<document-id>
<country>US</country>
<doc-number>2005/0108483</doc-number>
<kind>A1</kind>
<name>Bungo</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00107">
<document-id>
<country>JP</country>
<doc-number>2000029731</doc-number>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00108">
<document-id>
<country>JP</country>
<doc-number>2000347863</doc-number>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00109">
<othercit>Tanenbaum, “Structured Computer Organization”, 1984, Prentice-Hall, Inc., 2<sup>nd </sup>Edition, pp. 10-12.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00110">
<othercit>Torrellas et al., “False Sharing and Spatial Locality in Multiprocessor Caches”, Jun. 1994, IEEE Transactions on Computers, vol. 43, No. 6, pp. 651-663.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00111">
<othercit>Rothman et al., “Analysis of Shared Memory Misses and Reference Patterns”, 2000, IEEE, pp. 187-198.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00112">
<othercit>Wikipedia “JavaServer Pages” downloaded Jan. 24, 2006 http://en.wikipedia.org/wiki/JavaServer<sub>—</sub>Pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00113">
<othercit>“Hardware Cycle Based memory Residency”, IBM, May 22, 2003, ip.com, IPCOM000012728D, pp. 1-2.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00114">
<othercit>Hyde, “The Art of Assembly Language”, 2001, Linux Edition, pp. 247-248, retrieved Mar. 1, 2005 from http://webster.cs.ucr.edu/AoA/Linux/PDFs/0<sub>—</sub>PDFindexLinux.html.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00115">
<othercit>Jeong et al., “Cost Sensitive Cache Replacement Algorithms”, Jun. 2002, Second Workshop on Cashing, Coherence and Consistency, NY, pp. 1-14.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00116">
<othercit>Kikuchi, “Parallelization Assist System”, Joho Shori, vol. 34, No. 9, Sep. 1993, pp. 1158-1169.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00117">
<othercit>Cohen et al., “Hardware-Assisted Characterization of NAS Benchmarks”, Cluster Computing, vol. 4, No. 3, Jul. 2001, pp. 189-196.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00118">
<othercit>Talla et al., “Evaluating Signal Processing and Multimedia Applications on SIMD, VLIW and Super Scalar Architectures”, International Conference on Computer Design, Austin, Sep. 17-20, 2000, pp. 163-172.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00119">
<othercit>Iwasawa et al., “Parallelization Method of Fortran DO Loops by Parallelizing Assist System”, Transactions of Information Processings Society of Japan, vol. 36, No. 8, Aug. 1995, pp. 1995-2006.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00120">
<othercit>Talla et al., “Execution Characteristics of Multimedia Applications on a Pentium II Processor”, IEEE International Performance, Computing, and Communications Conference, 19<sup>th</sup>, Phoenix, Feb. 20-22, 2000, pp. 516-524.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00121">
<othercit>IBM Research Disclosure Bulletin 444188, “Enable Debuggers as an Objective Performance Measurement Tool for Software Development Cost Reduction”, Apr. 2001, pp. 686-688.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00122">
<othercit>U.S. Appl. No. 09/435,069, filed Nov. 4, 1999, Davidson et al. Method and Apparatus for Instruction Sampling for Performance Monitoring and Debug.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00123">
<othercit>U.S. Appl. No. 08/538,071, filed Oct. 2, 1995, Gover et al. Method and System for Selecting and Distinguishing an Event Sequence using an Effective Address in a Processing System.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00124">
<othercit>U.S. Appl. No. 10/675,777, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Instruction Execution and Data Accesses.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00125">
<othercit>U.S. Appl. No. 10/674,604, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Selectively Counting Instructions and Data Accesses,</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00126">
<othercit>U.S. Appl. No. 10/675,831, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Generating Interrupts Upon Execution of Marked Instructions and Upon Access to Marked Memory Locations.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00127">
<othercit>U.S. Appl. No. 10/675,778, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Data Accesses and Instruction Executions that Exceed a Threshold.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00128">
<othercit>U.S. Appl. No. 10/675,776, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Execution of Specific Instructions and Accesses to Specific Data Locations.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00129">
<othercit>U.S. Appl. No. 10/675,751, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Debug Support for Individual Instructions and Memory Locations.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00130">
<othercit>U.S. Appl. No. 10/675,721, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Select Instructions for Selective Counting.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00131">
<othercit>U.S. Appl. No. 10/674,642, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Count Instruction Execution for Applications.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00132">
<othercit>U.S. Appl. No. 10/674,606, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Take an Execution on Specified Instructions.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00133">
<othercit>U.S. Appl. No. 10/675,783, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Profile Applications.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00134">
<othercit>U.S. Appl. No. 10/675,872, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Instruction and Memory Location Ranges.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00135">
<othercit>U.S. Appl. No. 10/757,250, filed Jan. 14, 2004, Levine et al. Method and Apparatus for Maintaining Performance Monitoring Structures in a Page Table for use in Monitoring Performance of a Computer Program.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00136">
<othercit>U.S. Appl. No. 10/757,192, filed Jan. 14, 2004, DeWitt, Jr. et al. Method and Apparatus for Providing Pre and Post Handlers for Recording Events.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00137">
<othercit>U.S. Appl. No. 10/757,192, filed Mar. 18, 2004, DeWitt, Jr. et al. Method and Apparatus for Determining Computer Program Flows Autonomically Using Hardware Assisted Thread Stack Tracking and Cataloged Symbolic Data.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00138">
<othercit>U.S. Appl. No. 10/757,227, filed Jan. 14, 2004, DeWitt, Jr. et al. Method and Apparatus for Autonomically Moving Cache Entries to Dedicated Storage when False Cache Line Sharing is Detected.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00139">
<othercit>U.S. Appl. No. 10/757,197, filed Jan. 14, 2004, DeWitt, Jr. et al. Method and Apparatus for Optimizing Code Execution Using Annotated Trace Information having Performance Indicator and Counter Information.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00140">
<othercit>U.S. Appl. No. 10/808,716, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Autonomic Test Case Feedback Using Hardware Assistance for Code Coverage.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00141">
<othercit>U.S. Appl. No. 10/806,576, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Hardware Assistance for Data Access Coverage.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00142">
<othercit>U.S. Appl. No. 10/806,633, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Providing Hardware Assistance for Data Access Coverage on Dynamically Allocated Data.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00143">
<othercit>U.S. Appl. No. 10/806,917, filed Mar. 22. 2004, Dimpsey et al. Method and Apparatus for Automatic Test Case Feedback Using Hardware Assistance for Data Coverage.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00144">
<othercit>U.S. Appl. No. 10/806,871, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Hardware Assistance for Prefetching Data.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00145">
<othercit>U.S. Appl. No. 10/806,866, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Prefetching Data from a Data Structure.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00146">
<othercit>Ramirez et al., “The Effect of Code Reordering on Branch Prediction”, Proceedings of the International Conference on Parallel Architectures and Compilation Techniques, Oct. 2000, pp. 189-198.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00147">
<othercit>Yang et al., “Improving Performance by Branch Reordering”, Proceedings of the ACM SIGPLAN 1998 Conference onProgramming Language Design and Implementation, Montreal Canada, 1008, pp. 130-141.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00148">
<othercit>Conte et al., “Accurate and Practical Profile-Driven Compilation Using the Profile Buffer”, Proceedings of the 29th Annual ACM/IEEE International Symposium on Microarchitecture, Paris, France, 1996, pp. 36-45.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00149">
<othercit>Conte et al., “Using Branch Handling Hardware to Support Profile-Driven Optimization”, Proceedings of the 27th Annual International Symposium on Microarchitecture, San Jose CA, 1994, pp. 12-21.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00150">
<othercit>Fisher, “Trace Scheduling: A Technique for Global Microcode Compaction”, IEEE Transactions on Computers, vol. C30, No. 7, Jul. 1981, pp. 478-490.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00151">
<othercit>Chang et al., “Using Profile Information to Assist Classic Code Optimizations”, Software Pract. Exper. Dec. 21, 1991, pp. 1301-1321.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00152">
<othercit>Schmidt et al., “Profile-Directed Restructuring of Operating System Code”, IBM Systems Journal, 1998, vol. 37, No. 2, pp. 270-297.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00153">
<othercit>Aho et al., “Compilers: Principles, Techniques, and Tools”, Addison-Wesley, 1988, pp. 488-497.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00154">
<othercit>INTEL. “Intel IA-64 Architecture Software Developer's Manual”, Revision 1.1, vol. 4, No. 245320.002, Jul. 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00155">
<othercit>“Method for the dynamic prediction of nonsequential memory accesses”, Sep. 25, 2002, pp. 1-4, ip.com IPCOM000009888D.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00156">
<othercit>“Cache Miss Director—A Means of Prefetching Cache Missed Lines”, Aug. 1, 1982, IBM Technical Disclosure Bulletin, vol. 25, Issue 3A, pp. 1286.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>9</number-of-drawing-sheets>
<number-of-figures>25</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050210452</doc-number>
<kind>A1</kind>
<date>20050922</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Dimpsey</last-name>
<first-name>Robert Tod</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Levine</last-name>
<first-name>Frank Eliot</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Urquhart</last-name>
<first-name>Robert John</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Yee</last-name>
<first-name>Duke W.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Rodriguez</last-name>
<first-name>Herman</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="03" rep-type="attorney">
<addressbook>
<last-name>Bailey</last-name>
<first-name>Wayne P.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Peugh</last-name>
<first-name>Brian R.</first-name>
<department>2189</department>
</primary-examiner>
<assistant-examiner>
<last-name>Flournoy</last-name>
<first-name>Horace L</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method, apparatus, and computer instructions for generating coverage data during execution of code in the data processing system. During execution of the code, a determination is made as to whether an access indicator is associated with an instruction in response to executing the instruction in the code by a processor in the data processing system. If the access indicator is associated with the instruction, a state of the access indicator is changed, by the processor, when the instruction is executed. In this manner, coverage data for executed instructions is generated by the processor during execution of the code.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="166.54mm" wi="214.63mm" file="US07299319-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="223.27mm" wi="160.10mm" file="US07299319-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="213.53mm" wi="165.27mm" orientation="landscape" file="US07299319-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="229.28mm" wi="163.07mm" file="US07299319-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="234.53mm" wi="163.32mm" file="US07299319-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="233.17mm" wi="164.68mm" file="US07299319-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="220.47mm" wi="160.36mm" file="US07299319-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="232.83mm" wi="152.23mm" file="US07299319-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="234.61mm" wi="158.16mm" file="US07299319-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="233.17mm" wi="165.35mm" file="US07299319-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">The present invention is related to the following applications entitled “Method and Apparatus for Counting Instruction Execution and Data Accesses”, Ser. No. 10/675,777, filed on Sep. 30, 2003; “Method and Apparatus for Selectively Counting Instructions and Data Accesses”, Ser. No. 10/674,604, filed on Sep. 30, 2003; “Method and Apparatus for Generating Interrupts Upon Execution of Marked Instructions and Upon Access to Marked Memory Locations”, Ser. No. 10/675,831, filed on Sep. 30, 2003; “Method and Apparatus for Counting Data Accesses and Instruction Executions that Exceed a Threshold”, Ser. No. 10/675,778, filed on Sep. 30, 2003; “Method and Apparatus for Counting Execution of Specific Instructions and Accesses to Specific Data Locations”, Ser. No. 10/675,776, filed on Sep. 30, 2003; “Method and Apparatus for Debug Support for Individual Instructions and Memory Locations”, Ser. No. 10/675,751, filed on Sep. 30, 2003; “Method and Apparatus to Autonomically Select Instructions for Selective Counting”, Ser. No. 10/675,721, filed on Sep. 30, 2003; “Method and Apparatus to Autonomically Count Instruction Execution for Applications”, Ser. No. 10/674,642, filed on Sep. 30, 2003; “Method and Apparatus to Autonomically Take an Exception on Specified Instructions”, Ser. No. 10/674,606, filed on Sep. 30, 2003; “Method and Apparatus to Autonomically Profile Applications”, Ser. No. 10/675,783, filed on Sep. 30, 2003; “Method and Apparatus for Counting Instruction and Memory Location Ranges”, Ser. No. 10/675,872, filed on Sep. 30, 2003; “Method and Apparatus for Maintaining Performance Monitoring Structures in a Page Table for Use in Monitoring Performance of a Computer Program”, Ser. No. 10/757,250, filed on Jan. 14, 2004; “Method and Apparatus for Providing Pre and Post Handlers for Recording Events”, Ser. No. 10/757,192, filed on Jan. 14, 2004; “Method and Apparatus for Determining Computer Program Flows Autonomically Using Hardware Assisted Thread Stack Tracking and Cataloged Symbolic Data”, Ser. No. 10/803,663, filed on Mar. 18, 2004; “Method and Apparatus for Autonomically Moving Cache Entries to Dedicated Storage When False Cache Line Sharing is Detected”, Ser. No. 10/757,227, filed on Jan. 14, 2004; “Method and Apparatus for Optimizing Code Execution Using Annotated Trace Information Having Performance Indicator and Counter Information”, Ser. No. 10/757,197, filed on Jan. 14, 2004; “Method and Apparatus for Autonomic Test Case Feedback Using Hardware Assistance for Code Coverage”, Ser. No. 10/808,716, filed on Mar. 22, 2004; “Method and Apparatus for Hardware Assistance for Data Access Coverage”, Ser. No. 10/806,576, filed on Mar. 22, 2004; “Method and Apparatus for Providing Hardware Assistance for Data Access Coverage on Dynamically Allocated Data”, Ser. No. 10/806,603, filed on Mar. 22, 2004; “Method and Apparatus for Autonomic Test Case Feedback Using Hardware Assistance for Data Coverage”, Ser. No. 10/806,917, filed on Mar. 22, 2004; “Method and Apparatus for Hardware Assistance for Prefetching Data”, Ser. No. 10/806,871, filed on Mar. 22, 2004; and “Method and Apparatus for Prefetching Data from a Data Structure”, Ser. No. 10/806,866, filed on Mar. 22, 2004. All of the above related applications are assigned to the same assignee, and incorporated herein by reference.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">1. Technical Field</p>
<p id="p-0004" num="0003">The present invention relates generally to an improved data processing system. In particular, the present invention provides a method and apparatus for obtaining performance data in a data processing system. Still more particularly, the present invention provides a method and apparatus for hardware assistance to software tools in obtaining code coverage data in a data processing system.</p>
<p id="p-0005" num="0004">2. Description of Related Art</p>
<p id="p-0006" num="0005">In analyzing and enhancing performance of a data processing system and the applications executing within the data processing system, it is helpful to know which software modules within a data processing system are using system resources. Effective management and enhancement of data processing systems requires knowing how and when various system resources are being used. Performance tools are used to monitor and examine a data processing system to determine resource consumption as various software applications are executing within the data processing system. For example, a performance tool may identify the most frequently executed modules and instructions in a data processing system, or may identify those modules which allocate the largest amount of memory or perform the most I/O requests. Hardware performance tools may be built into the system or added at a later point in time.</p>
<p id="p-0007" num="0006">One known software performance tool is a trace tool. A trace tool may use more than one technique to provide trace information that indicates execution flows for an executing program. One technique keeps track of particular sequences of instructions by logging certain events as they occur. This technique is called a event-based profiling technique. For example, a trace tool may log every entry into, and every exit from, a module, subroutine, method, function, or system component. Alternately, a trace tool may log the requester and the amounts of memory allocated for each memory allocation request. Typically, a time-stamped record is produced for each such event. Corresponding pairs of records similar to entry-exit records also are used to trace execution of arbitrary code segments, starting and completing I/O or data transmission, and for many other events of interest.</p>
<p id="p-0008" num="0007">In order to improve performance of code generated by various families of computers, it is often necessary to determine where time is being spent by the processor in executing code, such efforts being commonly known in the computer processing arts as locating “hot spots.” Ideally, one would like to isolate such hot spots at the instruction and/or source line of code level in order to focus attention on areas which might benefit most from improvements to the code.</p>
<p id="p-0009" num="0008">Another trace technique involves periodically sampling a program's execution flows to identify certain locations in the program in which the program appears to spend large amounts of time. This technique is based on the idea of periodically interrupting the application or data processing system execution at regular intervals. This technique is referred to as a sample-based profiling technique. At each interruption, information is recorded for a predetermined length of time or for a predetermined number of events of interest. For example, the program counter of the currently executing thread, which is an executable portion of the larger program being profiled, may be recorded at each interval. These values may be resolved against a load map and symbol table information for the data processing system at post-processing time and a profile of where the time is being spent may be obtained from this analysis.</p>
<p id="p-0010" num="0009">Determining testing coverage is a difficult problem with currently available software tools. When testing code for programs, no easy mechanism is present to determine what code is executed and what code is not executed. This type of identification is also referred to as code coverage. Software techniques and tools are present for identifying code coverage. These techniques and tools, however, usually involve changing the code that is being tested. Having to change or instrument code is undesirable because such a process may be tedious and time consuming. Other types of techniques and tools are based on generating test cases from static analysis of the program. This type of methodology cannot guarantee full coverage in testing.</p>
<p id="p-0011" num="0010">Creating tools such as these to find answers related to specific situations or problems can take much effort and can be very difficult to calibrate as the software tools themselves affect the system under test. The present invention recognizes that hardware assistance for tool development and problem analysis can significantly ease the amount of effort needed to develop software performance tools. Further, with the increasing density of processors, hardware assistance can be included to provide additional debug and analysis features.</p>
<p id="p-0012" num="0011">Therefore, it would be advantageous to have an improved method, apparatus, and computer instructions for providing hardware assistance for performance tools analyzing the code coverage of code executed in data processing systems.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0013" num="0012">The present invention provides a method, apparatus, and computer instructions for generating coverage data during execution of code in the data processing system. During execution of the code, a determination is made as to whether an access indicator is associated with an instruction in response to executing the instruction in the code by a processor in the data processing system. If the access indicator is associated with the instruction, a state of the access indicator is changed, by the processor, when the instruction is executed. In this manner, coverage data for executed instructions is generated by the processor during execution of the code.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a data processing system in which the present invention may be implemented;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a processor system for processing information in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram illustrating components used in processing instructions associated with indicators in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating data flow for signals used to set indicators identifying memory locations that have been accessed in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram illustrating one mechanism for associating an access indicator with an instruction or memory location in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> is a diagram illustrating a bundle in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram illustrating components used for generating metadata, such as indicators, in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 8</figref> is an exemplary block diagram of data flow in which a page table is used to translate the memory address specified by the program into a physical address in accordance with an exemplary embodiment of the present invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 9</figref> is an exemplary page table entry in accordance with an exemplary embodiment of the present invention;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart of a process for marking access to instructions in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart of a process for illustrating a process followed by an instruction cache to set instruction access indicators in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart of a process for illustrating marking access to a subroutine in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 13</figref> is a flowchart of a process for identifying access to code segments in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 14</figref> is a block diagram illustrating components used to analyze code coverage data in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 15</figref> is a flowchart of a process for collecting code coverage data and displaying paths that are covered and not covered within a program in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 16</figref> is a flowchart of a process for marking access to memory locations containing data in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 17</figref> is a flowchart of a process for illustrating a process followed by a data cache in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 18</figref> is a flowchart of a process for obtaining call stack information when a dynamic memory allocation occurs during runtime in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 19</figref> is a flowchart of a process for sending information regarding data access that occurs during execution of a program when memory is deallocated in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 20</figref> is a flowchart of a process for generating a call flow tree to identify areas that have not been initialized or accessed in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 21</figref> is a diagram illustrating a graphical report showing coverage of data areas in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 22</figref> is a flowchart of a process for generating the display information in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 23</figref> is a flowchart of a process for prefetching of data into a cache using metadata in accordance with the preferred embodiment of the present invention;</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 24</figref> is a flowchart of a process for illustrating metadata including an identification of what data is to be prefetched from the starting point in accordance with the preferred embodiment of the present invention; and</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 25</figref> is a flowchart of a process for illustrating metadata including an identification of what data is to be prefetched from the starting point in accordance with the preferred embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
<p id="p-0040" num="0039">With reference now to <figref idref="DRAWINGS">FIG. 1</figref>, a block diagram of a data processing system is shown in which the present invention may be implemented. Client <b>100</b> is an example of a computer, in which code or instructions implementing the processes of the present invention may be located. Client <b>100</b> employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Accelerated Graphics Port (AGP) and Industry Standard Architecture (ISA) may be used. Processor <b>102</b> and main memory <b>104</b> are connected to PCI local bus <b>106</b> through PCI bridge <b>108</b>. PCI bridge <b>108</b> also may include an integrated memory controller and cache memory for processor <b>102</b>. Additional connections to PCI local bus <b>106</b> may be made through direct component interconnection or through add-in boards.</p>
<p id="p-0041" num="0040">In the depicted example, local area network (LAN) adapter <b>110</b>, small computer system interface SCSI host bus adapter <b>112</b>, and expansion bus interface <b>114</b> are connected to PCI local bus <b>106</b> by direct component connection. In contrast, audio adapter <b>116</b>, graphics adapter <b>118</b>, and audio/video adapter <b>119</b> are connected to PCI local bus <b>106</b> by add-in boards inserted into expansion slots. Expansion bus interface <b>114</b> provides a connection for a keyboard and mouse adapter <b>120</b>, modem <b>122</b>, and additional memory <b>124</b>. SCSI host bus adapter <b>112</b> provides a connection for hard disk drive <b>126</b>, tape drive <b>128</b>, and CD-ROM drive <b>130</b>. Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.</p>
<p id="p-0042" num="0041">An operating system runs on processor <b>102</b> and is used to coordinate and provide control of various components within data processing system <b>100</b> in <figref idref="DRAWINGS">FIG. 1</figref>. The operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on client <b>100</b>. “Java” is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive <b>126</b>, and may be loaded into main memory <b>104</b> for execution by processor <b>102</b>.</p>
<p id="p-0043" num="0042">Those of ordinary skill in the art will appreciate that the hardware in <figref idref="DRAWINGS">FIG. 1</figref> may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in <figref idref="DRAWINGS">FIG. 1</figref>. Also, the processes of the present invention may be applied to a multiprocessor data processing system.</p>
<p id="p-0044" num="0043">For example, client <b>100</b>, if optionally configured as a network computer, may not include SCSI host bus adapter <b>112</b>, hard disk drive <b>126</b>, tape drive <b>128</b>, and CD-ROM <b>130</b>. In that case, the computer, to be properly called a client computer, includes some type of network communication interface, such as LAN adapter <b>110</b>, modem <b>122</b>, or the like. As another example, client <b>100</b> may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not client <b>100</b> comprises some type of network communication interface. As a further example, client <b>100</b> may be a personal digital assistant (PDA), which is configured with ROM and/or flash ROM to provide non-volatile memory for storing operating system files and/or user-generated data. The depicted example in <figref idref="DRAWINGS">FIG. 1</figref> and above-described examples are not meant to imply architectural limitations.</p>
<p id="p-0045" num="0044">The processes of the present invention are performed by processor <b>102</b> using computer implemented instructions, which may be located in a memory such as, for example, main memory <b>104</b>, memory <b>124</b>, or in one or more peripheral devices <b>126</b>-<b>130</b>.</p>
<p id="p-0046" num="0045">Turning next to <figref idref="DRAWINGS">FIG. 2</figref>, a block diagram of a processor system for processing information is depicted in accordance with a preferred embodiment of the present invention. Processor <b>210</b> may be implemented as processor <b>102</b> in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0047" num="0046">In a preferred embodiment, processor <b>210</b> is a single integrated circuit superscalar microprocessor. Accordingly, as discussed further herein below, processor <b>210</b> includes various units, registers, buffers, memories, and other sections, all of which are formed by integrated circuitry. Also, in the preferred embodiment, processor <b>210</b> operates according to reduced instruction set computer (“RISC”) techniques. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, system bus <b>211</b> is connected to a bus interface unit (“BIU”) <b>212</b> of processor <b>210</b>. BIU <b>212</b> controls the transfer of information between processor <b>210</b> and system bus <b>211</b>.</p>
<p id="p-0048" num="0047">BIU <b>212</b> is connected to an instruction cache <b>214</b> and to data cache <b>216</b> of processor <b>210</b>. Instruction cache <b>214</b> outputs instructions to sequencer unit <b>218</b>. In response to such instructions from instruction cache <b>214</b>, sequencer unit <b>218</b> selectively outputs instructions to other execution circuitry of processor <b>210</b>.</p>
<p id="p-0049" num="0048">In addition to sequencer unit <b>218</b>, in a preferred embodiment, the execution circuitry of processor <b>210</b> includes a number of processor units that are used to execute instructions. These processor units are also called execution units. The execution units include, for example, a branch unit <b>220</b>, a fixed-point unit A (“FXUA”) <b>222</b>, a fixed-point unit B (“FXUB”) <b>224</b>, a complex fixed-point unit (“CFXU”) <b>226</b>, a load/store unit (“LSU”) <b>228</b>, and a floating-point unit (“FPU”) <b>230</b>. FXUA <b>222</b>, FXUB <b>224</b>, CFXU <b>226</b>, and LSU <b>228</b> input their source operand information from general-purpose architectural registers (“GPRs”) <b>232</b> and fixed-point rename buffers <b>234</b>. Moreover, FXUA <b>222</b> and FXUB <b>224</b> input a “carry bit” from a carry bit (“CA”) register <b>242</b>. FXUA <b>222</b>, FXUB <b>224</b>, CFXU <b>226</b>, and LSU <b>228</b> output results (destination operand information) of their operations for storage at selected entries in fixed-point rename buffers <b>234</b>. Also, CFXU <b>226</b> inputs and outputs source operand information and destination operand information to and from special-purpose register processing unit (“SPR unit”) <b>240</b>.</p>
<p id="p-0050" num="0049">FPU <b>230</b> inputs its source operand information from floating-point architectural registers (“FPRs”) <b>236</b> and floating-point rename buffers <b>238</b>. FPU <b>230</b> outputs results (destination operand information) of its operation for storage at selected entries in floating-point rename buffers <b>238</b>.</p>
<p id="p-0051" num="0050">In response to a Load instruction, LSU <b>228</b> inputs information from data cache <b>216</b> and copies such information to selected ones of rename buffers <b>234</b> and <b>238</b>. If such information is not stored in data cache <b>216</b>, then data cache <b>216</b> inputs (through BIU <b>212</b> and system bus <b>211</b>) such information from a system memory <b>260</b> connected to system bus <b>211</b>. Moreover, data cache <b>216</b> is able to output (through BIU <b>212</b> and system bus <b>211</b>) information from data cache <b>216</b> to system memory <b>260</b> connected to system bus <b>211</b>. In response to a Store instruction, LSU <b>228</b> inputs information from a selected one of GPRs <b>232</b> and FPRs <b>236</b> and copies such information to data cache <b>216</b>.</p>
<p id="p-0052" num="0051">Sequencer unit <b>218</b> inputs and outputs information to and from GPRs <b>232</b> and FPRs <b>236</b>. From sequencer unit <b>218</b>, branch unit <b>220</b> inputs instructions and signals indicating a present state of processor <b>210</b>. In response to such instructions and signals, branch unit <b>220</b> outputs (to sequencer unit <b>218</b>) signals indicating suitable memory addresses storing a sequence of instructions for execution by processor <b>210</b>. In response to such signals from branch unit <b>220</b>, sequencer unit <b>218</b> inputs the indicated sequence of instructions from instruction cache <b>214</b>. If one or more of the sequence of instructions is not stored in instruction cache <b>214</b>, then instruction cache <b>214</b> inputs (through BIU <b>212</b> and system bus <b>211</b>) such instructions from system memory <b>260</b> connected to system bus <b>211</b>.</p>
<p id="p-0053" num="0052">In response to the instructions input from instruction cache <b>214</b>, sequencer unit <b>218</b> selectively dispatches the instructions to selected ones of execution units <b>220</b>, <b>222</b>, <b>224</b>, <b>226</b>, <b>228</b>, and <b>230</b>. Each execution unit executes one or more instructions of a particular class of instructions. For example, FXUA <b>222</b> and FXUB <b>224</b> execute a first class of fixed-point mathematical operations on source operands, such as addition, subtraction, ANDing, ORing and XORing. CFXU <b>226</b> executes a second class of fixed-point operations on source operands, such as fixed-point multiplication and division. FPU <b>230</b> executes floating-point operations on source operands, such as floating-point multiplication and division.</p>
<p id="p-0054" num="0053">As information is stored at a selected one of rename buffers <b>234</b>, such information is associated with a storage location (e.g. one of GPRs <b>232</b> or CA register <b>242</b>) as specified by the instruction for which the selected rename buffer is allocated. Information stored at a selected one of rename buffers <b>234</b> is copied to its associated one of GPRs <b>232</b> (or CA register <b>242</b>) in response to signals from sequencer unit <b>218</b>. Sequencer unit <b>218</b> directs such copying of information stored at a selected one of rename buffers <b>234</b> in response to “completing” the instruction that generated the information. Such copying is called “writeback”.</p>
<p id="p-0055" num="0054">As information is stored at a selected one of rename buffers <b>238</b>, such information is associated with one of FPRs <b>236</b>. Information stored at a selected one of rename buffers <b>238</b> is copied to its associated one of FPRs <b>236</b> in response to signals from sequencer unit <b>218</b>. Sequencer unit <b>218</b> directs such copying of information stored at a selected one of rename buffers <b>238</b> in response to “completing” the instruction that generated the information.</p>
<p id="p-0056" num="0055">Processor <b>210</b> achieves high performance by processing multiple instructions simultaneously at various ones of execution units <b>220</b>, <b>222</b>, <b>224</b>, <b>226</b>, <b>228</b>, and <b>230</b>. Accordingly, each instruction is processed as a sequence of stages, each being executable in parallel with stages of other instructions. Such a technique is called “pipelining.” In a significant aspect of the illustrative embodiment, an instruction is normally processed as six stages, namely fetch, decode, dispatch, execute, completion, and writeback.</p>
<p id="p-0057" num="0056">In the fetch stage, sequencer unit <b>218</b> selectively inputs (from instruction cache <b>214</b>) one or more instructions from one or more memory addresses storing the sequence of instructions discussed further hereinabove in connection with branch unit <b>220</b>, and sequencer unit <b>218</b>. In the decode stage, sequencer unit <b>218</b> decodes up to four fetched instructions.</p>
<p id="p-0058" num="0057">In the dispatch stage, sequencer unit <b>218</b> selectively dispatches up to four decoded instructions to selected (in response to the decoding in the decode stage) ones of execution units <b>220</b>, <b>222</b>, <b>224</b>, <b>226</b>, <b>228</b>, and <b>230</b> after reserving rename buffer entries for the dispatched instructions' results (destination operand information). In the dispatch stage, operand information is supplied to the selected execution units for dispatched instructions. Processor <b>210</b> dispatches instructions in order of their programmed sequence.</p>
<p id="p-0059" num="0058">In the execute stage, execution units execute their dispatched instructions and output results (destination operand information) of their operations for storage at selected entries in rename buffers <b>234</b> and rename buffers <b>238</b> as discussed further hereinabove. In this manner, processor <b>210</b> is able to execute instructions out-of-order relative to their programmed sequence.</p>
<p id="p-0060" num="0059">In the completion stage, sequencer unit <b>218</b> indicates an instruction is “complete.” Processor <b>210</b> “completes” instructions in order of their programmed sequence.</p>
<p id="p-0061" num="0060">In the writeback stage, sequencer <b>218</b> directs the copying of information from rename buffers <b>234</b> and <b>238</b> to GPRs <b>232</b> and FPRs <b>236</b>, respectively. Sequencer unit <b>218</b> directs such copying of information stored at a selected rename buffer. Likewise, in the writeback stage of a particular instruction, processor <b>210</b> updates its architectural states in response to the particular instruction. Processor <b>210</b> processes the respective “writeback” stages of instructions in order of their programmed sequence. Processor <b>210</b> advantageously merges an instruction's completion stage and writeback stage in specified situations.</p>
<p id="p-0062" num="0061">In the illustrative embodiment, each instruction requires one machine cycle to complete each of the stages of instruction processing. Nevertheless, some instructions (e.g., complex fixed-point instructions executed by CFXU <b>226</b>) may require more than one cycle. Accordingly, a variable delay may occur between a particular instruction's execution and completion stages in response to the variation in time required for completion of preceding instructions.</p>
<p id="p-0063" num="0062">A completion buffer <b>248</b> is provided within sequencer <b>218</b> to track the completion of the multiple instructions which are being executed within the execution units. Upon an indication that an instruction or a group of instructions have been completed successfully, in an application specified sequential order, completion buffer <b>248</b> may be utilized to initiate the transfer of the results of those completed instructions to the associated general-purpose registers.</p>
<p id="p-0064" num="0063">In addition, processor <b>210</b> also includes processor monitoring unit <b>240</b>, which is connected to instruction cache <b>214</b> as well as other units in processor <b>210</b>. Operation of processor <b>210</b> can be monitored utilizing performance monitor unit <b>240</b>, which in this illustrative embodiment is a software-accessible mechanism capable of providing detailed information descriptive of the utilization of instruction execution resources and storage control. Although not illustrated in <figref idref="DRAWINGS">FIG. 2</figref>, performance monitor unit <b>240</b> is coupled to each functional unit of processor <b>210</b> to permit the monitoring of all aspects of the operation of processor <b>210</b>, including, for example, reconstructing the relationship between events, identifying false triggering, identifying performance bottlenecks, monitoring pipeline stalls, monitoring idle processor cycles, determining dispatch efficiency, determining branch efficiency, determining the performance penalty of misaligned data accesses, identifying the frequency of execution of serialization instructions, identifying inhibited interrupts, and determining performance efficiency.</p>
<p id="p-0065" num="0064">Performance monitor unit <b>240</b> includes an implementation-dependent number (e.g., 2-8) of counters <b>241</b>-<b>242</b>, labeled PMC<b>1</b> and PMC<b>2</b>, which are utilized to count occurrences of selected events. Performance monitor unit <b>240</b> further includes at least one monitor mode control register (MMCR). In this example, two control registers, MMCRs <b>243</b> and <b>244</b> are present that specify the function of counters <b>241</b>-<b>242</b>. Counters <b>241</b>-<b>242</b> and MMCRs <b>243</b>-<b>244</b> are preferably implemented as SPRs that are accessible for read or write via MFSPR (move from SPR) and MTSPR (move to SPR) instructions executable by CFXU <b>26</b>. However, in one alternative embodiment, counters <b>241</b>-<b>242</b> and MMCRs <b>243</b>-<b>244</b> may be implemented simply as addresses in I/O space. In another alternative embodiment, the control registers and counters may be accessed indirectly via an index register. This embodiment is implemented in the IA-64 architecture in processors from Intel Corporation.</p>
<p id="p-0066" num="0065">Additionally, processor <b>210</b> also includes interrupt unit <b>250</b>, which is connected to instruction cache <b>214</b>. Additionally, although not shown in <figref idref="DRAWINGS">FIG. 2</figref>, interrupt unit <b>250</b> is connected to other processor units within processor <b>210</b>. Interrupt unit <b>250</b> may receive signals from other processor units and initiate an action, such as starting an error handling or trap process. In these examples, interrupt unit <b>250</b> is employed to generate interrupts and exceptions that may occur during execution of a program.</p>
<p id="p-0067" num="0066">The present invention provides an ability to monitor the execution of specific instructions, as well as, the access of specific memory locations during the execution of a program. This type of determination also is referred to as code coverage. Specifically, a spare field may be used to hold an indicator that is associated with a specific instruction or memory location. This indicator may be set in response to execution of the instruction or access to the memory location. Examination of these indicators may be used to determine what code has been executed and what code has not been executed. A similar identification may be made as to what memory locations have or have not been accessed during execution of the code. Alternatively, the indicator may be stored in another location in association with the instruction or memory location.</p>
<p id="p-0068" num="0067">In the case in which the indicator is placed in the instruction, a spare field is typically used, but in some cases the instruction may be extended to include the space needed for the indicator. With this case, the architecture of the processor may require changes. For example, a 64 bit architecture may be changed to a 65 bit architecture to accommodate the indicator. With respect to accesses of data, an indicator may be associated with the data or memory locations in which the data is located.</p>
<p id="p-0069" num="0068">These indicators also are referred to as access indicators in these illustrative examples. Data access indicators are associated with memory locations, while instruction access indicators are associated with instructions. These indicators are typically initialized as being unset prior to execution of a program.</p>
<p id="p-0070" num="0069">When the processor executes an instruction, the instruction access indicator associated with that instruction is set. Access to a memory location results in an indicator associated with that memory location being set. By examining indicators that have been set and not set, an identification of code coverage may be made. This examination may take place using processes implemented in a software tool designed to test code coverage. In this manner, code coverage, with respect to instructions and data access to memory locations, may be made without requiring statistical analysis or instrumentation of code.</p>
<p id="p-0071" num="0070">Turning now to <figref idref="DRAWINGS">FIG. 3</figref>, a diagram illustrating components used in processing instructions associated with indicators is depicted in accordance with a preferred embodiment of the present invention. Instruction cache <b>300</b> receives bundles <b>302</b>. Instruction cache <b>300</b> is an example of instruction cache <b>214</b> in <figref idref="DRAWINGS">FIG. 2</figref>. A bundle is a grouping of instructions. This type of grouping of instructions is typically found in an IA-64 processor, which is available from Intel Corporation. Instruction cache <b>300</b> processes instructions for execution.</p>
<p id="p-0072" num="0071">As part of this processing of instructions, instruction cache <b>300</b> dispatches instructions to different execution units for execution. Signal <b>304</b> is received from completion buffer <b>306</b> when execution of the instruction has occurred. Completion buffer <b>306</b> is an example of a completion buffer, such as completion buffer <b>248</b> in <figref idref="DRAWINGS">FIG. 2</figref>. Signal <b>304</b> identifies the instruction for which execution has completed. This identification may take different forms. For example, entry numbers corresponding to entries in completion buffer <b>306</b> may be used to identify the instruction for which execution has completed. With this approach, instruction cache <b>300</b> knows where the specified instruction resides in its cache. Depending upon the processor implementation, other indicators may be used to identify which instruction has completed, such as, the position in cache <b>300</b>.</p>
<p id="p-0073" num="0072">When signal <b>304</b> is received, instruction cache <b>300</b> sets the instruction access indicator associated with the instruction that has been executed. In response to receiving signal <b>304</b>, instruction cache <b>300</b> marks or sets instruction access indicator <b>308</b>, which is associated with the instruction that has completed execution. This indicator may be in various locations, depending on the particular implementation. For example, instruction access indicator <b>308</b> may be located in a spare bit or field in the instruction, in a shadow memory, or in a page table.</p>
<p id="p-0074" num="0073">With respect to the accessing of data in memory locations, the data and indicators are processed by a data cache, such as data cache <b>216</b> in <figref idref="DRAWINGS">FIG. 2</figref>, rather than by an instruction cache. Alternatively, the processor may have a combined data and instruction cache in which case, the indicators set as appropriate.</p>
<p id="p-0075" num="0074">Although the illustrative examples show the generation of a signal indicating the completion of instruction execution being generated by completion buffer <b>306</b>, this signal may be generated by other processor units depending on the particular processor architecture and configuration. For example, this unit may be the processing unit actually processing the instruction. Further, if the hardware does not support out-of-order operations, then the dispatching of an instruction to a processor unit for execution may be an acceptable point in time to indicate that the instruction has been executed. In other words, if an instruction is not speculatively executed, a dispatcher in the processor may mark the instruction as executed.</p>
<p id="p-0076" num="0075">Turning to <figref idref="DRAWINGS">FIG. 4</figref>, a diagram illustrating data flow for signals used to set indicators identifying memory locations that have been accessed is depicted in accordance with a preferred embodiment of the present invention. Data cache <b>400</b> receives signal <b>402</b> from completion buffer <b>404</b> when an instruction has been executed. Signal <b>402</b> also includes an indication that data in a memory location has been accessed by the executed instruction.</p>
<p id="p-0077" num="0076">In response to receiving signal <b>402</b>, data access indicator <b>406</b> is set. This data access indicator is associated with the memory location accessed by the completed instruction. Metadata is used to map the association of indicators to memory locations in the case in which the data access indicators are not included in the memory locations themselves. The position of the instruction/data in the cache unit identifies the location in physical memory of the instruction/data. All currently available cache units have this capability. The cache unit also knows the location of the where to update the access indicators.</p>
<p id="p-0078" num="0077">Turning next to <figref idref="DRAWINGS">FIG. 5</figref>, a diagram illustrating one mechanism for associating an access indicator with an instruction or memory location is depicted in accordance with a preferred embodiment of the present invention. Processor <b>500</b> receives instructions from cache <b>502</b>. In this example, the indicators are not stored with the instructions or in the memory locations in which data is found. Instead, the indicators are stored in a separate area of storage, access indicator shadow cache <b>504</b>. The storage may be any storage device, such as for example, a system memory, a flash memory, a cache, or a disk.</p>
<p id="p-0079" num="0078">When processor <b>500</b> receives and then executes an instruction from cache <b>502</b>, processor <b>500</b> sets an instruction access indicator in access indicator shadow cache <b>504</b>, corresponding to the instruction from cache <b>502</b>. A similar process is performed with respect to accesses of memory locations containing data. In one embodiment, a full shadow word is provided for each corresponding word that does not affect the actual data segments. In other words, processor <b>500</b> allows for the architecture or configuration of cache <b>502</b> to remain unchanged. In these examples, the mapping described is word for word. However, some other type of mapping may be used, such as a shadow bit per data word in which a bit in access indicator shadow cache <b>504</b> corresponds to one word of data.</p>
<p id="p-0080" num="0079">With respect to this type of architecture, the compilers, using this feature, create the debug information in a separate work area from the data area themselves in a manner similar to debug symbols. When a module is loaded, the extra information, access indicators, is prepared by the loader so that it will be available to incorporate into access indicator shadow cache <b>504</b> when instructions are loaded into cache <b>502</b>. These cache areas may be intermingled and either marked as such or understood by the mode of operation. Processor <b>500</b> sets the access indicators when related data accesses and instruction executions occur. In these examples, the process is programmed by a debugger or an analysis program to know whether to use the shadow information while the process is executing instructions.</p>
<p id="p-0081" num="0080">Turning next to <figref idref="DRAWINGS">FIG. 6</figref>, a diagram illustrating a bundle is depicted in accordance with a preferred embodiment of the present invention. Bundle <b>600</b> contains instruction slot <b>602</b>, instruction <b>604</b>, instruction slot <b>606</b> and template <b>608</b>. As illustrated, bundle <b>600</b> contains 128 bits. Each instructions slot contains 41 bits, and template <b>608</b> contains 5 bits. Template <b>608</b> is used to identify stops within the current bundle and to map instructions within the slots to different types of execution units.</p>
<p id="p-0082" num="0081">Spare bits within bundle <b>600</b> are used to hold indicators of the present invention. For example, indicators <b>610</b>, <b>612</b>, and <b>614</b> are located within instruction slots <b>602</b>, <b>604</b>, and <b>606</b>, respectively. These indicators may take various forms and may take various sizes depending on the particular implementation. Indicators may use a single bit or may use multiple bits. In these illustrative examples, a single bit may be used to indicate that an instruction has been executed. A similar use of fields may be used for indicators that mark data or memory locations. When execution always starts at the first instruction in a bundle, as in the IA64 architecture, two bits may be used to indicate the last instruction executed. This is only needed for templates that have branch instructions. If basic blocks are being flagged, then only branch instructions and the instruction following a branch need be marked.</p>
<p id="p-0083" num="0082">Turning to <figref idref="DRAWINGS">FIG. 7</figref>, a block diagram illustrating components used for generating metadata and access indicators is depicted in accordance with a preferred embodiment of the present invention. The compiler supports directives embedded in the source that indicate the metadata to be generated. The metadata is used to indicate what operation is to be performed, such as identifying which instructions or memory locations are to be associated with particular access indicators. In other words, the metadata defines the mapping of access indicators to individual instructions, groups of instructions, and memory locations. With respect to memory locations, the metadata may map access indicators to individual memory locations or to different groupings of memory locations with different sizes depending on the particular implementation. These access indicators are used by the hardware components in the processor to reflect updates made by these components when a memory location is accessed or an instruction is executed.</p>
<p id="p-0084" num="0083">Compiler <b>700</b> may generate instructions <b>702</b> for execution and metadata and access indicators <b>704</b> for monitoring code coverage. As instruction or data cache pages are loaded into memory, the operating system program loader/linker and/or the performance monitoring program, reads metadata and access indicators <b>704</b> generated by compiler <b>700</b> and loads metadata and access indicators <b>704</b> into memory. Processor <b>708</b> may accept metadata and access indicators <b>704</b> in the format as generated by compiler <b>700</b> and populate shadow memory <b>705</b> with metadata and access indicators <b>704</b>.</p>
<p id="p-0085" num="0084">In an alternative embodiment, instead of the compiler, the performance monitoring program generates the metadata and access indicators.</p>
<p id="p-0086" num="0085">In one embodiment the format simply has a metadata and/or an access indicator shadow cache entry for each of its block or sector references and moves metadata and access indicators <b>704</b> to its corresponding shadow entry or entries. Instead of having a shadow cache, the internal format of the cache itself may be modified to contain metadata and access indicators <b>704</b>. In embodiments where the instruction stream itself is modified to contain the metadata, then either the loader updates the instruction stream to contain the appropriate metadata and/or access indicators and work areas or compiler <b>700</b> has generated the code to contain metadata and access indicators <b>704</b>. In either case, after the code is loaded, the processor receives metadata and access indicators <b>704</b>.</p>
<p id="p-0087" num="0086">In addition, metadata and access indicators <b>704</b> may be placed into shadow memory <b>705</b> in association with instructions <b>702</b>. Compiler <b>700</b> produces information in a table or debug data section. The performance monitoring program loads this information into shadow data areas in shadow memory <b>705</b>. Alternatively, the debug areas may be automatically populated by the operating system or performance monitoring program and the processor working together.</p>
<p id="p-0088" num="0087">Instructions <b>702</b> may then be executed by processor <b>708</b>. Compiler <b>700</b> may set a register such as mode register <b>710</b> in processor <b>708</b>. When this register is set, processor <b>708</b> looks at metadata and access indicators <b>704</b> in shadow memory <b>705</b> when executing instructions <b>702</b> to determine whether metadata and access indicators <b>704</b> are associated with instructions that are being executed in instructions <b>702</b>.</p>
<p id="p-0089" num="0088">If mode register <b>710</b> is not set, then metadata and access indicators <b>704</b> are ignored when instructions <b>702</b> are executed. Mode register <b>710</b> is used to turn on and off the feature of marking access to instructions in these illustrative embodiments.</p>
<p id="p-0090" num="0089">The metadata within metadata and access indicator <b>704</b> may be used to set mode register <b>710</b> in addition to defining instructions or groups of instructions that are to be associated with access indicators. When an access indicator is associated on an instruction level basis, each instruction associated with an access indicator has its associated access indicator set when that instruction is executed. When an access indicator is associated with a group of instructions, this access indicator is set when any instruction in the group is executed in these illustrative examples.</p>
<p id="p-0091" num="0090">A similar process may be performed with respect to data in memory locations <b>712</b>. Depending on the particular implementation, metadata and access indicators <b>704</b> may be placed within the instruction or within the data, rather than in shadow memory <b>705</b>. However, by placing metadata and access indicators <b>704</b> in shadow memory <b>705</b>, the generation of metadata and access indicators <b>704</b> may be performed dynamically when metadata and access indicators <b>704</b> are placed in shadow memory <b>705</b>.</p>
<p id="p-0092" num="0091">This feature allows for selection and identification of instructions for code coverage monitoring to occur without having to modify the program. In other words, compiler <b>700</b> may generate metadata and access indicators <b>704</b> after instructions <b>702</b> have been compiled for execution by processor <b>708</b>. Setting mode register <b>710</b> causes processor <b>708</b> to look for metadata and access indicators <b>704</b> in performance instrumentation shadow memory <b>705</b> without having to modify instructions <b>702</b>. In these examples, the presence of an access indicator associated with an instruction or memory location causes processor <b>708</b> to set the access indicator when the execution of the instruction in instructions <b>702</b> occurs and/or data is accessed to the memory location in memory locations <b>712</b>.</p>
<p id="p-0093" num="0092"><figref idref="DRAWINGS">FIG. 8</figref> illustrates an exemplary block diagram of data flow in which a page table is used to translate the memory address specified by the program into a physical address in accordance with an exemplary embodiment of the present invention. As shown in <figref idref="DRAWINGS">FIG. 8</figref>, a program address <b>810</b> (for data or instruction) is translated to a virtual address by way of the address space register <b>820</b> using one of the various means of specifying the active address space. The resultant virtual address is used by the processor to search page table <b>830</b> for a page descriptor in page table <b>830</b> that matches the virtual address. The contents of the matching page descriptor commonly contain the physical address and attributes associated with the virtual page. These contents are used to translate the virtual address to a physical address and to determine the attributes of the page (e.g., access rights).</p>
<p id="p-0094" num="0093">In a further embodiment of the present invention, the page table is expanded to include additional fields for each entry for storing access indicators, such as instruction access indicators and data access indicators. When a process accesses the page table to perform virtual to physical page address mapping, these additional fields may be queried, values from these fields retrieved, and values in these fields updated based on the particular event causing the access to the page table.</p>
<p id="p-0095" num="0094">Alternatively, to avoid any degradation of performance, the access indicator information in these fields may be cached in processor resources similar to a Translation Look-aside Buffer (TLB) or an Effective to Real Address Translation Buffer (ERAT). For example, a Performance Indicator Look-Aside Buffer (PILAB) may be provided in which the virtual to real address translation information and the performance indicator information provided in the above fields of the page table may be cached. When an instruction or data address access request is received, a lookup of the program or virtual address may be performed in the PILAB to obtain both the address translation information and the access indicator information. If the program or virtual address is not present in the PILAB, the page table may be consulted to obtain this information.</p>
<p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. 9</figref> illustrates an exemplary page table entry in accordance with an exemplary embodiment of the present invention. As shown in <figref idref="DRAWINGS">FIG. 9</figref>, the page table entry <b>900</b> includes field <b>910</b> for storing a virtual page address, field <b>920</b> for storing a physical page address, and code coverage fields <b>930</b>-<b>950</b> for storing data relating to determining code coverage. These fields are ones used by testing or performance monitoring applications for determining the code coverage of a computer application that is being tested. These code coverage fields may include, for example, an instruction access indicator, a data access indicator, or prefetch information. The values of these additional fields <b>930</b>-<b>950</b> may be set by different components in a processor based on information provided to these units by a testing or performance monitoring application.</p>
<p id="p-0097" num="0096">For example, in a similar manner that access indicators are associated with instructions and/or portions of data as described above, the access indicators may be associated with these instructions and/or data portions within the page table. Thus, when determining whether an instruction or data portion has an associated access indicator, the virtual address of the instruction or data portion may be used to identify an entry in the page table and the values stored in additional fields <b>930</b> and <b>940</b> may be checked to see if an access indicator is associated with the physical page or a portion of the physical page. That is, if the offset associated with the virtual address falls within an offset range identified in field <b>930</b> has an access indicator stored therein, then the instruction corresponding to the virtual address has an associated access indicator. This indicator is set in the event that the instruction is executed.</p>
<p id="p-0098" num="0097">Access type field <b>940</b> is used to identify the type of access that has occurred with respect to accesses to a memory location. Prefetch information field <b>950</b> may include information, such as pointers, offsets, and addresses. Thus, for example, when an instruction or portion of data must be retrieved from physical storage, the page table is consulted to identify the physical storage location of the instruction or portion of data. At the same time, fields <b>930</b>-<b>950</b> may be queried and the indicator in access field <b>930</b> may be set to indicate that the page has been fetched from physical storage and loaded into the memory or cache.</p>
<p id="p-0099" num="0098">It should be appreciated that while <figref idref="DRAWINGS">FIG. 9</figref> shows only a single field for storing an access indicator, a single field for identifying an access type, and a single field for storing prefetch information, the present invention is not limited to such. Rather, any number of fields for storing a plurality of access indicators, and the like, associated with the physical page may be used without departing from the spirit and scope of the present invention.</p>
<p id="p-0100" num="0099">With reference now to <figref idref="DRAWINGS">FIG. 10</figref>, a flowchart of a process for marking access to instructions is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 10</figref> may be implemented into an instruction cache, such as instruction cache <b>214</b> in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0101" num="0100">The process begins by receiving a bundle (step <b>1000</b>). Next, an instruction in the bundle for execution is identified (step <b>1002</b>). Next, the instruction is executed (step <b>1004</b>). In these illustrative examples, part of processing the instruction in step <b>1004</b> includes executing the instruction. Then, an indicator associated with the instruction is set to indicate execution of the instruction (step <b>1006</b>). Then, a determination is made as to whether more unprocessed instructions are present in the bundle (step <b>1008</b>).</p>
<p id="p-0102" num="0101">If more unprocessed instructions are present in the bundle, then the process proceeds to step <b>1002</b> as described above. If additional unprocessed instructions are not present in the bundle, then the process terminates. In an alternative embodiment, one bit is set if the bundle does not have a branch and the bit indicates the last instruction executed when a branch is taken.</p>
<p id="p-0103" num="0102">In this example, the instruction cache contains all of the information and has direct access to areas containing instruction access indicators to be updated to reflect changes when instructions are executed. Information regarding completed execution is provided by a completion buffer or processor units accessing the completion buffer.</p>
<p id="p-0104" num="0103">Turning now to <figref idref="DRAWINGS">FIG. 11</figref>, a flowchart of a process for illustrating a process followed by an instruction cache to set instruction access indicators is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 11</figref> may be implemented into an instruction cache, such as instruction cache <b>214</b> in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0105" num="0104">The process begins by receiving a signal indicating instruction execution has completed (step <b>1100</b>). In these examples, a signal is received from a completion buffer, such as completion buffer <b>248</b> in <figref idref="DRAWINGS">FIG. 2</figref>. This completion buffer includes information identifying the instruction for which execution has completed. Next, update information in storage is saved (step <b>1102</b>), with the process terminating thereafter. In response to receiving this signal, an entry in the instruction cache may be saved into storage. The entry is identified using information received in the signal from the completion buffer. For example, the signal may indicate that the instruction corresponding to item number seven has completed execution. The information for this instruction may be located in a register created in the instruction cache to provide a fast path for performing operations. In saving information in the cache, this information is placed in another location, such as a page table or a shadow memory. This update also includes the setting of an instruction access indicator if such an indicator is associated with the instruction.</p>
<p id="p-0106" num="0105">In this manner, code coverage with respect to instructions may be identified through the assistance of hardware components in a processor. This hardware assistance allows for instructions that have been executed to be identified through instruction access indicators that are set when instructions are executed. The example described above provides a fine granularity in which each executed instruction is marked. If a coarser granularity is desired, this process may be applied to portions of code, such as code segments or subroutines.</p>
<p id="p-0107" num="0106">Turning now to <figref idref="DRAWINGS">FIG. 12</figref>, a flowchart of a process for illustrating marking access to a subroutine is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in FIG. <b>12</b> may be implemented into an instruction cache, such as instruction cache <b>214</b> in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0108" num="0107">The process begins by identifying an executed instruction (step <b>1200</b>). Next, a determination is made as to whether the instruction is located at a start address of a subroutine selected for monitoring (step <b>1202</b>). If the instruction is not the start of a subroutine, then a determination is made as to whether an instruction access indicator for an instruction at a start address for the subroutine was previously set (step <b>1204</b>). If a determination is made that the instruction access indicator for the instruction at the start address was previously set, then a determination is made as to whether the identified instruction is one for a return address for the subroutine (step <b>1206</b>). If the instruction is for a return address, then the instruction access indicator for that return instruction is set in metadata associated with the subroutine (step <b>1208</b>), with the process terminating thereafter.</p>
<p id="p-0109" num="0108">Referring back to steps <b>1206</b> and <b>1204</b> as described above, if the determination is no, then the process returns to step <b>1200</b>. In step <b>1202</b>, if the identified instruction is for the start of a subroutine, then the process proceeds to step <b>1208</b> as described above.</p>
<p id="p-0110" num="0109">With reference now to <figref idref="DRAWINGS">FIG. 13</figref>, a flowchart of a process for identifying access to code segments is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 13</figref> may be implemented into an instruction cache, such as instruction cache <b>214</b> in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0111" num="0110">The process begins by identifying instruction that is to be executed (step <b>1300</b>). Next, a determination is made as to whether the identified instruction is a branch instruction (step <b>1302</b>). If the instruction is a branch instruction, then the instruction access indicator associated with that instruction is set (step <b>1304</b>) with the process terminating thereafter. As described above, this indicator may be implemented in a number of different ways. For example, the indicator may be located in an extra field or an unused field in the instruction, in a shadow memory, or a page table.</p>
<p id="p-0112" num="0111">Referring back to step <b>1302</b>, if the instruction is not a branch instruction, then a determination is made as to whether the previous instruction is a branch instruction (step <b>1306</b>). If the previous instruction is a branch instruction, then the process proceeds to step <b>1304</b> to mark an instruction access indicator as described above. In step <b>1306</b>, if the previous instruction is not a branch instruction then the process terminates. In essence, step <b>1306</b> in conjunction with step <b>1304</b> marks an instruction subsequent to a branch instruction when a branch does occur.</p>
<p id="p-0113" num="0112">In this manner, the mechanism of the present invention provides hardware assistance for marking code segments that have been executed. By examining the instruction access indicators that have been marked, execution of code segments may be identified in determining code coverage.</p>
<p id="p-0114" num="0113">With reference now to <figref idref="DRAWINGS">FIG. 14</figref>, a block diagram illustrating components used to analyze code coverage data is depicted in accordance with a preferred embodiment of the present invention. With code coverage information generated by the hardware assistance mechanism of the present invention, software tools may be employed to produce a report or graphical presentation to identify areas of code that have not been executed in contrast to those that have been executed. This code coverage information also may include access to memory locations that occur during execution of the code. With this information, new testing of the code may be initiated to generate updated reports or presentations to show changes in code coverage.</p>
<p id="p-0115" num="0114">In this illustrative example, code coverage application <b>1400</b> obtains access indicator data <b>1402</b> generated by the execution of code <b>1404</b>. This code may be, for example, a program, an application, or code for a portion of a program or application. Access indicator data includes instruction access indicators and/or data access indicators.</p>
<p id="p-0116" num="0115">These indicators are initially unset when the execution of code <b>1404</b> begins. The indicators are set when instructions are executed or data in memory locations are accessed during the execution of instructions. The execution of an instruction may cause both the instruction access indicator and the data access indicator for a memory location to be set. After execution of code <b>1404</b>, a portion or all of the indicators may be set.</p>
<p id="p-0117" num="0116">Code coverage application <b>1400</b> analyzes access indicator data <b>1402</b> to identify paths of instructions that have been covered or not covered during the execution of code <b>1404</b>. This execution data is displayed using graphic interface (GUI) <b>1406</b>. The display of this data may include highlighting or the use of different colors or graphical indicators to identify instructions that have been executed and to identify memory locations for data that has been accessed. GUI <b>1406</b> also may be used by the user to set new parameters for use in testing code <b>1404</b>. When code <b>1404</b> is again tested, the new access or coverage information is then analyzed and displayed in GUI <b>1406</b> to allow the user to see how code coverage has changed.</p>
<p id="p-0118" num="0117">In the illustrative examples, code coverage application <b>1400</b> may be a daemon that runs periodically to sample the coverage and provide updated reports or presentations. The user may change various parameters or may define a set of scenarios that may be used in executing code <b>1404</b>.</p>
<p id="p-0119" num="0118">The code coverage data may be collected and presented to user for analysis. With reference now to <figref idref="DRAWINGS">FIG. 15</figref>, a diagram illustrating a presentation of executed and unexecuted instructions is depicted in accordance with the preferred embodiment of the present invention. In this illustrative embodiment, code <b>1500</b> is an example of source code that has been executed using hardware assistance to mark instruction access indicators for instructions actually executed by the processor.</p>
<p id="p-0120" num="0119">In this example, sections <b>1502</b>, <b>1504</b>, and <b>1506</b> have been executed, while sections <b>1508</b>, <b>1510</b>, <b>1512</b>, and <b>1514</b> are instructions that have not been executed. Code <b>1500</b> may be presented such that executed instructions are presented using one color, such as green, while unexecuted instructions are presented in another color, such as red. In this manner, the user may easily identify executed and unexecuted instructions. In another embodiment, only the executed or unexecuted instructions are displayed. Further, graphical indicators may be associated or placed next to instructions that have been executed. Many different types of presentation techniques may be used to display code coverage information. For example, the graphical user interface also may employ the use of highlighting, different fonts, and displaying only executed instructions in the display. Any type of presentation system may be used to allow the user to identify executed and unexecuted lines of code.</p>
<p id="p-0121" num="0120">Turning now to <figref idref="DRAWINGS">FIG. 16</figref>, a flowchart of a process for collecting code coverage data and displaying paths that are covered and not covered within a program is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 16</figref> may be implemented in a code coverage or testing application. The process illustrated in <figref idref="DRAWINGS">FIG. 16</figref> is directed towards the collection of code coverage data with respect to the execution of instructions.</p>
<p id="p-0122" num="0121">The process begins by receiving test parameters for use by the program (step <b>1600</b>). The following is an example of a command line that may be entered: Test -code -data Application. In this example, Test is the testing program, Application is the application to be tested, -code indicates code coverage, and -data indicates data coverage. Next, the program is executed (step <b>1602</b>). Execution of the program in step <b>1602</b> causes the generation of code coverage data in the form of access indicators, such as instruction access indicators, being set during execution of instructions for the program by the processor.</p>
<p id="p-0123" num="0122">Then, a determination is made as to whether collection of code coverage data using hardware assistance execution instructions is complete (step <b>1604</b>). If the collection of code coverage data is not complete, the process returns to step <b>1602</b> to continue to execute the program. Otherwise, executed instructions are identified (step <b>1606</b>). Step <b>1606</b> is implemented in these illustrative examples by identifying instructions with instruction access indicators that have been set. Next, instructions not executed are identified (step <b>1608</b>). Step <b>1608</b> is implemented in these illustrative examples by identifying instructions with instruction access indicators that have not been set. Then, execution data identifying paths of execution covered and paths of execution not covered are displayed (step <b>1610</b>). In these examples, the display is in a GUI in which execution paths covered and not covered may be graphically presented to a user for analysis.</p>
<p id="p-0124" num="0123">Next, a determination is made as to whether new parameters are present for use in executing the program (step <b>1612</b>). If there are not new parameters the process terminates. If there are new parameters then the process proceeds to step <b>1600</b> as described above.</p>
<p id="p-0125" num="0124">In this illustrative example, the presentation of coverage data is displayed after execution of the program. Depending on the implementation, the display of data may occur periodically during the execution of the program and may allow the user to change parameters during execution to see how code coverage changes.</p>
<p id="p-0126" num="0125">The mechanism of the present invention also provides a mechanism for determining coverage in the form of data access. Indicators may be stored with metadata in which the metadata selects specific pieces of data for instrumentation. The indication of whether data has been accessed may be stored in a number of different places. For example, a word may be extended by extra bits, a shadow cache area may be provided, and a page table may be designed to include this information.</p>
<p id="p-0127" num="0126">In supporting data access coverage, the compilers are updated to support producing a metadata debug section (similar to a symbols section) and the operating system in conjunction with the linker/loader and a performance monitoring or testing coverage device driver allow for specialized operational modes. These techniques mimic an extra bit or word per word of memory. Using different mechanisms, as the specified application is executed, a bit is set to indicate that the specified data areas have been executed. A variety of ways are present for indicating this support. For example, a bit may be provided for each data byte or a bit for each data word. The compiler generated metadata may provide this mapping for the hardware to use. The mapping may have data type dependencies. When a data field is accessed, the appropriate bit for a data access indicator is set. The same bit may be set for different data accesses, depending upon the mapping.</p>
<p id="p-0128" num="0127">Turning now to <figref idref="DRAWINGS">FIG. 17</figref>, a flowchart of a process for marking access to memory locations containing data is depicted in accordance with the preferred embodiment of the present invention. This process is initiated whenever data access occurs in these illustrative examples. The process illustrated in <figref idref="DRAWINGS">FIG. 17</figref> may be implemented in a data cache, such as data cache <b>216</b> in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0129" num="0128">The process begins by detecting access to the data in a memory location (step <b>1700</b>). This data access is identified by the data cache in these examples through a signal generated by a completion buffer to indicate that data has been accessed in executing an instruction. In one embodiment, the instruction executed is identified and its data operand is known by the instruction cache unit, which receives a signal from the completion buffer and sends a signal to the data cache unit indicating the data operand of the instruction has been accessed. Alternatively, the completion buffer could send an indication of the data being accessed to the data cache directly. This approach would require the data information to be known by the completion buffer.</p>
<p id="p-0130" num="0129">Next, data access indicator associated with memory location containing the data to indicate access is set (step <b>1702</b>). In these illustrative examples, the data access indicators may be located in a shadow memory or in a page table. The setting of the indicator occurs when the processor is in a selected or special mode to cause a bit to be set for data having a length, such as a byte, a word, or a double word. Then, memory location access is processed (step <b>1704</b>), with the process terminating thereafter.</p>
<p id="p-0131" num="0130">Determining testing coverage is a difficult issue in which understanding data access and data use may be helpful. In other words, it is helpful to know if an allocated array has been used or if a static piece of data has been exercised. In addition, testing data boundaries also is important in testing coverage. For example, determining whether enough space has been allocated for an array is useful. This determination may be performed by determining whether access outside of an array has occurred.</p>
<p id="p-0132" num="0131">The mechanism of the present invention provides for the construction and maintenance of call flow trees that may be accessed by an executing program for use in dynamic data area coverage. When a request is made for an allocation of data, such as a malloc, a routine is called to build trees. One methodology for determining the call stack is to walk the stack to determine the calling sequence at the time of the malloc. Another methodology it to use the hardware information generated through setting data access indicators. Techniques similar to that described in United States patent application entitled “Method and Apparatus for Determining Computer Program Flows Autonomically Using Hardware Assisted Thread Stack Tracking and Cataloged Symbolic Data”, Ser. No. 10/803,663, filed on Mar. 18, 2004, which is incorporated herein by reference. This technique is used to identify the calling sequence; hereafter called call stack. This tree is maintained in memory and may be accessed through calls such as application programming interface (API) calls to a device driver which reads the call stack information for the current thread. The process for maintaining the hardware thread maintained call stack and to convert the addresses to symbolic names also is described in United States patent application entitled “Method and Apparatus for Determining Computer Program Flows Autonomically Using Hardware Assisted Thread Stack Tracking and Cataloged Symbolic Data”, Ser. No. 10/803,663, filed on Mar. 18, 2004. The call stack retrieved from the device driver is sent to the arcflow program, which walks the stack into its thread oriented trees. This process is described in United States patent application, entitled “Method and System for Merging Event-Based Data and Sampled Data Into Postprocessed Trace Output”, Ser. No. 09/343,438, filed on Jun. 30, 1999. One approach involves indicating the start area, the end area, and one byte beyond the end area for flagging. Further, other statistics may also be kept in this memory area. Examples of other statistics involved using other hardware assist capabilities, the number of accesses, cache misses, cycles, etc. may be maintained.</p>
<p id="p-0133" num="0132">Turning now to <figref idref="DRAWINGS">FIG. 18</figref>, a flowchart of a process for illustrating a process followed by a data cache is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 18</figref> may be implemented in a data cache, such as data cache <b>216</b> in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0134" num="0133">The process begins by a signal indicating that instruction execution accessing data in a memory location has completed is received (step <b>1800</b>). This signal is typically received from a completion buffer. Update information in storage is saved (step <b>1802</b>), with the process terminating thereafter. Information stored in registers in the data cache is saved. This information may be saved in a page table, as well as setting a data access indicator in another storage, such as in a shadow cache. The information saved in a page table typically contains any changes made by the data accessed by the instruction. While the information saved in the other storage involves setting a data access indicator to indicate that access has occurred to the memory location.</p>
<p id="p-0135" num="0134">Turning now to <figref idref="DRAWINGS">FIG. 19</figref>, a flowchart of a process for obtaining call stack information when a dynamic memory allocation occurs during runtime is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 19</figref> may be implemented software. The process begins by detecting a dynamic memory allocation (step <b>1900</b>). The dynamic memory allocation is requested during runtime when an instruction requires an allocation of memory. Next, call stack information is obtained (step <b>1902</b>). Then, allocated memory is identified (step <b>1904</b>). Next, memory for reporting is marked (step <b>1906</b>), with the process terminating thereafter. The memory is marked for reporting to let the hardware, such as a data cache, know when to mark access to data within the allocated memory. The memory allocation may be such that the memory allocation routine allocates more memory than specified in order to allow for checking for errors. For example, memory allocation routine may allocate an additional byte and flag the start address, the end address, and one byte beyond the end address. In other words, these flagged sections will have data access indicators set if access occurs to these marked addresses. In these examples, one byte beyond the end address is marked such that an access to this memory location causes a data access indicator to be set. In this manner, a determination is made as to whether sufficient memory has been allocated for use. If this data access indicator is set during execution of a program, then insufficient memory may have been allocated since access occurs beyond the area of memory that was allocated.</p>
<p id="p-0136" num="0135">Turning now to <figref idref="DRAWINGS">FIG. 20</figref>, a flowchart of a process for sending information regarding data access that occurs during execution of a program when memory is deallocated is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 20</figref> may be implemented in software.</p>
<p id="p-0137" num="0136">The process begins by memory deallocation being detected (step <b>2000</b>), such as, a free request. Next, information identifying access to data in allocated memory is collected (step <b>2002</b>). Then, access data and call stack information is sent for processing (step <b>2004</b>), with the process terminating thereafter. This data is sent to a software tool for processing. Step <b>2004</b> may involve placing the data in a location accessible by the software tool.</p>
<p id="p-0138" num="0137">In these examples, the data is sent in real time as the memory is deallocated. Other times that the information may be collected and sent for processing include sampling that is performed by a monitor process. In other cases, the information may be sent after the program has completed execution. The information identifying access to data may include information other than an identification of the memory location. For example, the information also may include an identification of the code that requested the allocation of the memory and the size of the memory that was allocated. Further, the number of accesses to the memory location may be recorded using hardware assist mechanisms described in the cross referenced applications.</p>
<p id="p-0139" num="0138">Turning now to <figref idref="DRAWINGS">FIG. 21</figref>, a flowchart of a process for generating a call flow tree to identify areas that have not been initialized or accessed is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 21</figref> may be implemented in a software tool used to identify code coverage. This process uses the information collected in <figref idref="DRAWINGS">FIGS. 19 and 20</figref> to generate a call flow tree to identify areas that have not been initialized or accessed. This call flow tree also includes information on memory locations that have been accessed, as well as, memory locations that have not been accessed.</p>
<p id="p-0140" num="0139">The process begins when access data and call stack information is received (step <b>2100</b>). Next, the received data and call stack information is processed (step <b>2102</b>). Then, call flow tree identifying callers and code allocating memory is generated (step <b>2104</b>). Next, leaf node ID data containing data access information is generated (step <b>2106</b>), with the process terminating thereafter. The access information for the data area is placed into a leaf node that is associated with the node that allocated the memory in which the data was accessed.</p>
<p id="p-0141" num="0140">With coverage regarding access to data areas, the mechanisms of the present invention provide information on areas of data that have not been initialized, not accessed, or accessed. In identifying these data areas, the original source code may be marked or presented in a manner to indicate which data areas have been accessed, and which data areas have not been accessed. With respect to dynamic allocation of data, the portions of the source code in which dynamic memory allocation occurs may be flagged such that memory areas allocated during execution have data access indicators marked when access occurs in those memory areas. Further, the instructions in the code may be marked to cause the hardware to set indicators when static data structures are accessed.</p>
<p id="p-0142" num="0141">Turning now to <figref idref="DRAWINGS">FIG. 22</figref>, a diagram illustrating a graphical report showing coverage of data areas is depicted in accordance with a preferred embodiment of the present invention. In this example, report <b>2200</b> shows data access coverage in area <b>2202</b>. This area shows static data areas. Sections <b>2204</b>, <b>2206</b>, and <b>2208</b> in area <b>2202</b> are memory locations in which data access has occurred. These sections are identified by locating data access indicators that have been set during execution of the code.</p>
<p id="p-0143" num="0142">Call flow tree <b>2210</b> is an example of a call flow tree in which node D represents a section of code that dynamically allocated memory as shown in area <b>2212</b>. This information in area <b>2212</b> is information located in a leaf node associated with node D in call flow tree <b>2210</b>. Section <b>2214</b> in area <b>2212</b> shows portions of area <b>2212</b> that were accessed.</p>
<p id="p-0144" num="0143">Turning now to <figref idref="DRAWINGS">FIG. 23</figref>, a flowchart of a process for generating the display information is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 23</figref> may be implemented into a software tool for determining coverage of data access.</p>
<p id="p-0145" num="0144">The process begins by obtaining data access information for static and dynamic data (step <b>2300</b>). This information includes obtaining data access indicators that were allocated for execution of the code. Other information obtained includes call flow trees generated during dynamic allocation of memory as described above.</p>
<p id="p-0146" num="0145">Next, the coverage map for access to static and dynamic data is generated (step <b>2302</b>). Then, the coverage map is displayed (step <b>2304</b>) with the process terminating thereafter. The coverage map is similar to report <b>2200</b> in <figref idref="DRAWINGS">FIG. 22</figref>. The reporting program may have support to allow offsets to be used in the reporting structures. For example, the c:\program files\appl.exe(func1:100) may be used to indicate that the malloc was issued from location <b>100</b> in func1.</p>
<p id="p-0147" num="0146">Processor bus speeds and memory access is significantly slower than processor speeds. It is more the case that the performance of a data processing system is gated or limited by memory access, rather than by the speed of the processor. The result of this phenomenon is the use of multi-level caching, as well as, attempts at prefetching data into these caches for quicker access to data. Attempts at prefetching, however, are usually code or stride driven and do not handle data dependant dynamic access well. Most existing approaches require the compilers or programmers to create prefetch hints in the code stream. Once the object code is generated, these hints give information that allows prefetching. This system, however, provides little opportunity to change the code. Examples include chasing references in Java objects for garbage collection or pointer chasing.</p>
<p id="p-0148" num="0147">The mechanism of the present invention improves prefetching through the use of hardware assistance. With the use of metadata, a prefetch indicator may be associated with data. For example, the prefetch indicator data may indicate that the data is to be treated as a pointer to be prefetched. The prefetch indicator itself may be a pointer to the data structure. When the data is loaded into the cache the processor detects the pointer prefetch condition and prefetches the cache line pointed to by the data.</p>
<p id="p-0149" num="0148">Turning now to <figref idref="DRAWINGS">FIG. 24</figref>, a flowchart of a process for prefetching of data into a cache using metadata is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 24</figref> may be implemented in a load/store unit in these examples. The data prefetched is a pointer in these examples.</p>
<p id="p-0150" num="0149">The process begins by loading an instruction (step <b>2400</b>). Next, a determination is made as to whether metadata for prefetch is associated with instruction (step <b>2402</b>). In these examples, the metadata is a prefetch indicator that is associated with an instruction.</p>
<p id="p-0151" num="0150">If metadata for prefetch is associated with instruction, then a determination is made as to whether hardware decides to prefetch data (step <b>2404</b>). In a preferred embodiment, the instruction cache determines when and if the instruction cache will speculatively prefetch. For example, the instruction cache may determine that it has no outstanding cache misses and it has cache entries that may be replaced that have not been used for quite some time. In this case, the instruction cache speculatively prefetches. However, if the instruction cache has outstanding misses and/or no convenient cache lines to replace, it may not speculatively prefetch. A threshold may be set for the number of cache misses and/or for a number of replaceable cache lines to determine whether the instruction cache will prefetch data when a prefetch indicator is present. For example, a prefetch may occur if outstanding cache misses are less than a selected threshold. Prefetching also may occur in these illustrative examples if replacement of cache lines is desired and if the number of cache lines chosen to be replaced are greater than a selected threshold. The load store unit may issue request to speculatively load into the cache unit, but the cache unit determines if it will actually prefetch.</p>
<p id="p-0152" num="0151">Alternatively, a load store unit may make the determination as to whether to speculatively load into the cache unit depending upon the hardware implementation. If the hardware decides to prefetch data, then data is prefetched into a cache using the metadata associated with the instruction (step <b>2406</b>). In these examples, the data is a pointer. This pointer is a pointer to a data structure or a block of data. Next, the instruction is sent to a unit for processing (step <b>2408</b>), with the process terminating thereafter.</p>
<p id="p-0153" num="0152">Referring back to step <b>2404</b>, if hardware decides not to prefetch data then the process returns to step <b>2408</b> as described above. In step <b>2302</b>, if metadata for prefetch is not associated with instruction, then the process proceeds to step <b>2408</b> as described above. In these examples, the hardware may send the instruction to a unit for processing before, at the same time, or after the hardware issues an indication that a prefetch should occur.</p>
<p id="p-0154" num="0153">In addition to prefetching a pointer to a data structure or a block of data, the mechanism of the present invention provides an ability to prefetch data from a memory location within the data structure. A stride or offset in conjunction with the pointer may be used to identify the data to be prefetched. Alternatively, an address may be used to identify the location of the data that is desired.</p>
<p id="p-0155" num="0154">Turning now to <figref idref="DRAWINGS">FIG. 25</figref>, a flowchart of a process for illustrating metadata including an identification of what data is to be prefetched from the starting point is depicted in accordance with the preferred embodiment of the present invention. The process illustrated in <figref idref="DRAWINGS">FIG. 25</figref> may be implemented into a load store unit, such as load store unit <b>228</b> in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0156" num="0155">The process begins detecting metadata which indicates a prefetch (step <b>2500</b>). The metadata may include an identification of what data is to be prefetched from a data structure identified by the pointer. This metadata may include a prefetch indicator in the form of a pointer. The metadata also may include an identification of the data itself through the use of an offset or address. A determination is made as to whether a prefetch should occur based on the state of the cache unit (step <b>2502</b>). The prefetches of these examples are speculative with the processes being performed selectively depending on the state of the cache unit. For example, if a number of cache misses exceeding some value has occurred, the prefetch does not occur and the process terminates.</p>
<p id="p-0157" num="0156">In step <b>2502</b> if the prefetch is to occur, a selected point in memory for the prefetch is located (step <b>2504</b>). This selected point memory may be identified in the metadata using a pointer and an offset or stride, or a memory address. Next, data is prefetched from a selected point in the memory into the cache (step <b>2506</b>), with the process terminating thereafter. Referring to step <b>2502</b>, if the prefetch does not occur, the process terminates.</p>
<p id="p-0158" num="0157">Thus, the present invention provides an improved method, apparatus, and computer instructions for providing hardware assistance for code coverage. The mechanisms of the present invention allow for an ability to monitor the execution of instructions and access to memory locations during execution of a program. Access indicators are provided for indicating instruction execution or access to data in memory locations. The setting of these indicators are performed by hardware, such as different components in a processor. In this manner, software tools may obtain and analyze coverage data with better coverage and avoiding changing the code being tested.</p>
<p id="p-0159" num="0158">Further, the steps illustrated in the flowcharts described above, with respect to hardware providing assistance in determining coverage in program execution, provide a logical flow of processes that may be executed by different components in hardware. In particular, these steps may be implemented as microcode or hardware logic in a processor. Microcode, in these examples, are the lowest level instructions that directly control a processor. A single machine language instruction typically translates into several microcode instructions. Microcode may be in hardware or software form. In many modern processors, the microcode is hard-wired into the processors.</p>
<p id="p-0160" num="0159">It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.</p>
<p id="p-0161" num="0160">The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. For example, it is important to note that different processor architectures may distribute the functions specified in this application across different units with a variety of mechanisms used to communicate information across the units. Additionally, although specific processor units have been described as implementing the functions of the present invention, these different functions may be incorporated into other processor units within the hardware. Further, the steps described in the figures may be implemented as either hardware circuitry or as instructions for specific use by the different processor units within a processor, such as microcode for use by an execution unit.</p>
<p id="p-0162" num="0161">The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method in a data processing system for generating coverage data during execution of code in the data processing system, the method comprising:
<claim-text>responsive to executing an instruction in the code by a processor in the data processing system, determining whether an access indicator is associated with the instruction, wherein the access indicator associated with the instruction is located in a shadow memory; and</claim-text>
<claim-text>if the access indicator is associated with the instruction, changing, by the processor, a state of the access indicator when the instruction is executed, wherein coverage data is generated during execution of the code by the processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the changing step comprises:
<claim-text>receiving a signal at an instruction cache in the processor from a processor unit in the processor; and</claim-text>
<claim-text>responsive to receiving the signal, changing the state of the access indicator by the instruction cache.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the instruction is dispatched to one of a plurality of different execution units for execution and the signal is received from a completion buffer when the execution of the instruction has occurred.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein instructions in the instruction cache are located in different positions within the instruction cache and wherein the signal includes an identification of a position in the instruction cache for the instruction.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>marking selected instructions in the code for generating the coverage data by associating access indicators with selected instructions in the code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the access indicator is an instruction access indicator.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein access indicators are associated with every instruction within the code.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A method in a data processing system for generating coverage data during execution of code in the data processing system, the method comprising:
<claim-text>responsive to executing an instruction in the code by a processor in the data processing system, determining whether an access indicator is associated with the instruction, wherein the access indicator associated with the instruction is located in a page table; and</claim-text>
<claim-text>if the access indicator is associated with the instruction, changing, by the processor, a state of the access indicator when the instruction is executed, wherein coverage data is generated during execution of the code by the processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method in a data processing system for generating coverage data during execution of code in the data processing system, the method comprising:
<claim-text>responsive to executing an instruction in the code by a processor in the data processing system, determining whether an access indicator is associated with the instruction, wherein access indicators are associated only with subroutines within the code; and</claim-text>
<claim-text>if the access indicator is associated with the instruction, changing, by the processor, a state of the access indicator when the instruction is executed, wherein coverage data is generated during execution of the code by the processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A data processing system for generating coverage data during execution of code in the data processing system, the data processing system comprising:
<claim-text>determining means, responsive to executing an instruction in the code by a processor in the data processing system, for determining whether an access indicator is associated with the instruction; and</claim-text>
<claim-text>changing means, if the access indicator is associated with the instruction, for changing, by the processor, a state of the access indicator when the instruction is executed, wherein coverage data is generated during execution of the code by the processor, wherein executed instructions in the code have set access indicators set when the state of the access indicators associated with the executed instructions are changed, while unexecuted instructions have unset access indicators because the state of the unset access indicators remain unchanged.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The data processing system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the changing means comprises:
<claim-text>receiving means for receiving a signal at an instruction cache in the processor from a processor unit in the processor; and</claim-text>
<claim-text>means, responsive to receiving the signal, for changing the state of the access indicator by the instruction cache.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The data processing system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the instruction is dispatched to one of a plurality of different execution units for execution and the signal is received from a completion buffer when the execution of the instruction has occurred.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The data processing system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein instructions in the instruction cache are located in different positions within the instruction cache and wherein the signal includes an identification of a position in the instruction cache for the instruction.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The data processing system of <claim-ref idref="CLM-00010">claim 10</claim-ref> further comprising:
<claim-text>marking means for marking selected instructions in the code for generating the coverage data by associating access indicators with selected instructions in the code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The data processing system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the access indicator is located in a field in the instruction.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The data processing system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the access indicator associated with the instruction is located in at least one of a shadow memory and a page table.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A data processing system for generating coverage data during execution of code in the data processing system, the data processing system comprising:
<claim-text>determining means, responsive to executing an instruction in the code by a processor in the data processing system, for determining whether an access indicator is associated with the instruction; and</claim-text>
<claim-text>changing means, if the access indicator is associated with the instruction, for changing, by the processor, a state of the access indicator when the instruction is executed, wherein coverage data is generated during execution of the code by the processor, wherein access indicators are associated only with subroutines within the code.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
