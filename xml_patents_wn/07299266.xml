<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299266-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299266</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10235679</doc-number>
<date>20020905</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>700</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>173</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>709213</main-classification>
<further-classification>709217</further-classification>
<further-classification>709223</further-classification>
<further-classification>711100</further-classification>
<further-classification>711113</further-classification>
</classification-national>
<invention-title id="d0e53">Memory management offload for RDMA enabled network adapters</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5920881</doc-number>
<kind>A</kind>
<name>Porterfield</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6034963</doc-number>
<kind>A</kind>
<name>Minami et al.</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by other</category>
<classification-national><country>US</country><main-classification>370401</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6321276</doc-number>
<kind>B1</kind>
<name>Forin</name>
<date>20011100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710  3</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6578122</doc-number>
<kind>B2</kind>
<name>Beukema et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711163</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6834332</doc-number>
<kind>B2</kind>
<name>Craddock et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711159</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2002/0078271</doc-number>
<kind>A1</kind>
<name>Berry</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 36</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2002/0091844</doc-number>
<kind>A1</kind>
<name>Craft et al.</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2002/0107962</doc-number>
<kind>A1</kind>
<name>Richter et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709225</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2002/0172195</doc-number>
<kind>A1</kind>
<name>Pekkala et al.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370360</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2003/0005039</doc-number>
<kind>A1</kind>
<name>Craddock et al.</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709203</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2003/0014544</doc-number>
<kind>A1</kind>
<name>Pettey</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709249</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2003/0058870</doc-number>
<kind>A1</kind>
<name>Mizrachi et al.</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2003/0084209</doc-number>
<kind>A1</kind>
<name>Chadalapaka</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710  5</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2003/0145045</doc-number>
<kind>A1</kind>
<name>Pellegrino et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709203</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2003/0158906</doc-number>
<kind>A1</kind>
<name>Hayes</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709211</main-classification></classification-national>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2004/0034725</doc-number>
<kind>A1</kind>
<name>Elzur</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 22</main-classification></classification-national>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2004/0037299</doc-number>
<kind>A1</kind>
<name>Pandya</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2004/0093411</doc-number>
<kind>A1</kind>
<name>Elzur et al.</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2004/0139237</doc-number>
<kind>A1</kind>
<name>Rangan et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710  1</main-classification></classification-national>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>WO</country>
<doc-number>WO 01/92998</doc-number>
<kind>A2</kind>
<date>20011200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00021">
<othercit>Boyd et al., ISCSI Driver to Adapter Interface Protocol, no date.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>24</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711159</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711173</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711202</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711113</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709223</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709214</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709215</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709213</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709217</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718105</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>18</number-of-drawing-sheets>
<number-of-figures>22</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040049600</doc-number>
<kind>A1</kind>
<date>20040311</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Boyd</last-name>
<first-name>William Todd</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Joseph</last-name>
<first-name>Douglas J.</first-name>
<address>
<city>Danbury</city>
<state>CT</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Ko</last-name>
<first-name>Michael Anthony</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Recio</last-name>
<first-name>Renato John</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Yee</last-name>
<first-name>Duke W.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Salys</last-name>
<first-name>Casimer K.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="03" rep-type="attorney">
<addressbook>
<last-name>Fay, III</last-name>
<first-name>Theodore D.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Najjar</last-name>
<first-name>Saleh</first-name>
<department>2155</department>
</primary-examiner>
<assistant-examiner>
<last-name>Nguyen</last-name>
<first-name>Thuong (Tina) T</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method, computer program product, and distributed data processing system for memory management. Memory regions are registered and have access rights and Protection domains associated with them in response to receiving a request for a memory operation including a virtual address, which is used to address into a data structure. A second data structure is then used to translate the virtual address into physical addresses for the operation. A third data structure is used to allow an incoming request responsive to a remote operation being initiated.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="135.72mm" wi="212.43mm" file="US07299266-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="253.07mm" wi="162.48mm" orientation="landscape" file="US07299266-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="242.57mm" wi="187.37mm" file="US07299266-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="224.79mm" wi="182.03mm" file="US07299266-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="205.15mm" wi="191.69mm" file="US07299266-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="244.01mm" wi="196.60mm" file="US07299266-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="168.83mm" wi="183.47mm" file="US07299266-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="193.38mm" wi="181.61mm" file="US07299266-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="249.17mm" wi="172.80mm" file="US07299266-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="253.41mm" wi="188.47mm" orientation="landscape" file="US07299266-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="263.91mm" wi="183.81mm" orientation="landscape" file="US07299266-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="221.32mm" wi="145.29mm" orientation="landscape" file="US07299266-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="240.54mm" wi="185.93mm" orientation="landscape" file="US07299266-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="256.29mm" wi="188.13mm" file="US07299266-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="255.19mm" wi="175.60mm" orientation="landscape" file="US07299266-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="250.95mm" wi="181.86mm" orientation="landscape" file="US07299266-20071120-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="242.57mm" wi="193.04mm" orientation="landscape" file="US07299266-20071120-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="261.20mm" wi="185.59mm" file="US07299266-20071120-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="228.60mm" wi="186.61mm" file="US07299266-20071120-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">The present invention is related to an application entitled iSCSI DRIVER TO ADAPTER INTERFACE PROTOCOL, Ser. no. 10/235,686, filed Sep. 5, 2002, assigned to the same assignee, and incorporated herein by reference.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">1. Technical Field</p>
<p id="p-0004" num="0003">The present invention relates generally to communication protocols between a host computer and an input/output (I/O) device. More specifically, the present invention provides a method for memory management in the context of communication between a host and I/O device.</p>
<p id="p-0005" num="0004">2. Description of Related Art</p>
<p id="p-0006" num="0005">In an Internet Protocol (IP) Network, the software provides a message passing mechanism that can be used to communicate with input/output devices, general purpose computers (host), and special purpose computers. The message passing mechanism consists of a transport protocol, an upper level protocol, and an application programming interface. The key standard transport protocols used on IP networks today are the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP). TCP provides a reliable service and UDP provides an unreliable service. In the future the Stream Control Transmission Protocol (SCTP) will also be used to provide a reliable service. Processes executing on devices or computers access the IP network through upper level protocols, such as Sockets, iSCSI, and Direct Access File System (DAFS).</p>
<p id="p-0007" num="0006">Unfortunately, the TCP/IP software consumes a considerable amount of processor and memory resources. This problem has been covered extensively in the literature (see J. Kay, J. Pasquale, “Profiling and reducing processing overheads in TCP/IP”, IEEE/ACM Transactions on Networking, Vol. 4, No. 6, pp. 817-828, December 1996; and D. D. Clark, V. Jacobson, J. Romkey, H. Salwen, “An analysis of TCP processing overhead”, IEEE Communications Magazine, Vol. 27, Issue <b>6</b>, June 1989, pp 23-29). In the future the network stack will continue to consume excessive resources for several reasons, including: increased use of networking by applications; use of network security protocols; and the underlying fabric bandwidths are increasing at a higher rate than microprocessor and memory bandwidths. To address this problem the industry is offloading the network stack processing to an IP Suite Offload Engine (IPSOE).</p>
<p id="p-0008" num="0007">There are two offload approaches being taken in the industry. The first approach uses the existing TCP/IP network stack, without adding any additional protocols. This approach can offload TCP/IP to hardware, but unfortunately does not remove the need for receive side copies. As noted in the papers above, copies are one of the largest contributors to central processing unit (CPU) utilization. To remove the need for copies, the industry is pursuing the second approach that consists of adding Framing, Direct Data Placement (DDP), and Remote Direct Memory Access (RDMA) over the TCP and the latter two over SCTP. The IP Suite Offload Engine (IPSOE) required to support these two approaches is similar, the key difference being that in the second approach the hardware must support the additional protocols.</p>
<p id="p-0009" num="0008">The IPSOE provides a message passing mechanism that can be used by sockets, iSCSI, and DAFS to communicate between nodes. Processes executing on host computers, or devices, access the IP network by posting send/receive messages to send/receive work queues on an IPSOE. These processes also are referred to as “consumers”.</p>
<p id="p-0010" num="0009">The send/receive work queues (WQ) are assigned to a consumer as a queue pair (QP). The messages can be sent over three different transport types: traditional TCP, RDMA TCP, UDP, or SCTP. Consumers retrieve the results of these messages from a completion queue (CQ) through IPSOE send and receive work completion (WC) queues. The source IPSOE takes care of segmenting outbound messages and sending them to the destination. The destination IPSOE takes care of reassembling inbound messages and placing the inbound messages in the memory space designated by the destination's consumer. These consumers use IPSOE verbs to access the functions supported by the IPSOE. The software that interprets verbs and directly accesses the IPSOE is known as the IPSO interface (IPSOI).</p>
<p id="p-0011" num="0010">Today the host CPU performs most IP suite processing. IP Suite Offload Engines offer a higher performance interface for communicating to other general purpose computers and I/O devices. Data sends or receives through the IPSOE require that the CPU either copy data from one memory location to another or register the memory so that the IPSOE can directly access the memory region. Each of these options requires significant CPU resources with the memory registration option being preferred for large memory transfers, however, as network speeds increase the amount of CPU resources required will increase. It would be advantageous to have an improved method, apparatus, and computer instructions for reducing the amount of CPU resources required to register these memory locations, expose them to remote systems through memory windows, and then provide one touch access as an option on the exposed memory windows. It would also be advantageous to have the mechanism apply for iSCSI 1.0, RDMA, and iSCSI-R.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0012" num="0011">The present invention provides a method, computer program product, and distributed data processing system for registering memory locations, exposing previously registered memory locations through memory windows, and then providing one touch access as an option on the exposed memory windows.</p>
<p id="p-0013" num="0012">Specifically, the present invention is directed to memory regions that are written to and from by an Internet Protocol Suite Offload Engine (IPSOE) in accordance with a preferred embodiment of the present invention. A mechanism is provided for implicitly or explicitly registering memory regions and allowing hardware to directly use the region through memory region tables and address translation tables while keeping the region isolated from use by other applications. A method for accessing previously registered memory regions by incoming requests by utilizing a tag table to associate the request to with either a physical or virtual address. A mechanism for unbinding a previously bound window upon first use by an incoming message.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram of a distributed computer system illustrated in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> is a functional block diagram of a host processor node in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3A</figref> is a diagram of an IP Suite Offload Engine in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3B</figref> is a diagram of a switch in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 3C</figref> is a diagram of a router in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating processing of work requests in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram illustrating a portion of a distributed computer system in accordance with a preferred embodiment of the present invention in which a TCP or SCTP transport is used;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 6</figref> is an illustration of a data frame in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram illustrating a portion of a distributed computer system in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram illustrating the network addressing used in a distributed networking system in accordance with the present invention;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram of a portion of a distributed computer system containing subnets in a preferred embodiment of the present invention;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram of a layered communication architecture used in a preferred embodiment of the present invention;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart and diagram illustrating two Memory Registration mechanisms in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 12</figref> depicts the memory management system in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 13</figref> is a diagram depicting memory region table entries in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 14</figref> is a flowchart depicting the checks that must be made upon registering a memory region in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 15</figref> is a flowchart and diagram representation of the process used by the IPSOE to validate memory accesses performed by Work Queue Elements posted by the Consumer as Work Request on an IPSOE Work Queue in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 16</figref> is a flowchart and diagram representation of a process used to distinguish between the different types of streams that can be associated with a remote operation in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 17A</figref> is a flowchart and diagram illustrating memory management mechanisms associated with an iSCSI QP in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 17B</figref> is a flowchart and diagram representation of a memory management process used to validate a remote iSCSI 1.0 operation in accordance with a preferred embodiment of the present invention; and</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIGS. 18A-18B</figref> are a flowchart and diagram eepresentation of the memory management process used to provide a one touch access mechanism with the deregistration function unexposed to the remote node and validate a remote RDMA read Request, RDMA Read Response, and RDMA Write Message in accordance with a preferred embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
<p id="p-0036" num="0035">The present invention provides a distributed computing system having endnodes, switches, routers, and links interconnecting these components. The endnodes can be Internet Protocol Suite Offload Engines or traditional host software based Internet protocol suites. Each endnode uses send and receive queue pairs to transmit and receive messages. The endnodes segment the message into frames and transmit the frames over the links. The switches and routers interconnect the endnodes and route the frames to the appropriate endnode. The endnodes reassemble the frames into a message at the destination.</p>
<p id="p-0037" num="0036">With reference now to the figures and in particular with reference to <figref idref="DRAWINGS">FIG. 1</figref>, a diagram of a distributed computer system is illustrated in accordance with a preferred embodiment of the present invention. The distributed computer system represented in <figref idref="DRAWINGS">FIG. 1</figref> takes the form of an Internet protocol network (IP net), such as IP net <b>100</b> and is provided merely for illustrative purposes and the embodiments of the present invention described below can be implemented on computer systems of numerous other types and configurations. For example, computer systems implementing the present invention can range from a small server with one processor and a few input/output (I/O) adapters to massively parallel supercomputer systems with hundreds or thousands of processors and thousands of I/O adapters. Furthermore, the present invention can be implemented in an infrastructure of remote computer systems connected by an internet or intranet.</p>
<p id="p-0038" num="0037">IP net <b>100</b> is a high-bandwidth, low-latency network interconnecting nodes within the distributed computer system. A node is any component attached to one or more links of a network and forming the origin and/or destination of messages within the network. In the depicted example, IP net <b>100</b> includes nodes in the form of host processor node <b>102</b>, host processor node <b>104</b>, and redundant array independent disk (RAID) subsystem node <b>106</b>. The nodes illustrated in <figref idref="DRAWINGS">FIG. 1</figref> are for illustrative purposes only, as IP net <b>100</b> can connect any number and any type of independent processor nodes, storage nodes, and special purpose processing nodes. Any one of the nodes can function as an endnode, which is herein defined to be a device that originates or finally consumes messages or frames in IP net <b>100</b>.</p>
<p id="p-0039" num="0038">In one embodiment of the present invention, an error handling mechanism in distributed computer systems is present in which the error handling mechanism allows for TCP or SCTP communication between endnodes in a distributed computing system, such as IP net <b>100</b>.</p>
<p id="p-0040" num="0039">A message, as used herein, is an application-defined unit of data exchange, which is a primitive unit of communication between cooperating processes. A frame is one unit of data encapsulated by Internet Protocol Suite headers and/or trailers. The headers generally provide control and routing information for directing the frame through IP net <b>100</b>. The trailer generally contains control and cyclic redundancy check (CRC) data for ensuring frames are not delivered with corrupted contents.</p>
<p id="p-0041" num="0040">Within a distributed computer system, IP net <b>100</b> contains the communications and management infrastructure supporting various forms of traffic, such as storage, interprocess communications (IPC), file access, and sockets. IP net <b>100</b> shown in <figref idref="DRAWINGS">FIG. 1</figref> includes a switched communications fabric <b>116</b>, which allows many devices to concurrently transfer data with high-bandwidth and low latency in a secure, remotely managed environment. Endnodes can communicate over multiple ports and utilize multiple paths through the IP net fabric. The multiple ports and paths through the IP net shown in <figref idref="DRAWINGS">FIG. 1</figref> can be employed for fault tolerance and increased bandwidth data transfers.</p>
<p id="p-0042" num="0041">The IP net <b>100</b> in <figref idref="DRAWINGS">FIG. 1</figref> includes switch <b>112</b>, switch <b>114</b>, and router <b>117</b>. A switch is a device that connects multiple links together and allows routing of frames from one link to another link using the layer <b>2</b> destination address field. When the Ethernet is used as the link, the destination field is known as the media access control (MAC) address. A router is a device that routes frames based on the layer <b>3</b> destination address field. When Internet Protocol (IP) is used as the layer <b>3</b> protocol, the destination address field is an IP address.</p>
<p id="p-0043" num="0042">In one embodiment, a link is a full duplex channel between any two network fabric elements, such as endnodes, switches, or routers. Example suitable links include, but are not limited to, copper cables, optical cables, and printed circuit copper traces on backplanes and printed circuit boards.</p>
<p id="p-0044" num="0043">For reliable service types (TCP and SCTP), endnodes, such as host processor endnodes and I/O adapter endnodes, generate request frames and return acknowledgment frames. Switches and routers pass frames along, from the source to the destination.</p>
<p id="p-0045" num="0044">In IP net <b>100</b> as illustrated in <figref idref="DRAWINGS">FIG. 1</figref>, host processor node <b>102</b>, host processor node <b>104</b>, and RAID subsystem node <b>106</b> include at least one IPSOE to interface to IP net <b>100</b>. In one embodiment, each IPSOE is an endpoint that implements the IPSOI in sufficient detail to source or sink frames transmitted on IP net <b>100</b>. Host processor node <b>102</b> contains IPSOEs in the form of host IPSOE <b>118</b> and IPSOE <b>120</b>. Host processor node <b>104</b> contains IPSOE <b>122</b> and IPSOE <b>124</b>. Host processor node <b>102</b> also includes central processing units <b>126</b>-<b>130</b> and a memory <b>132</b> interconnected by bus system <b>134</b>. Host processor node <b>104</b> similarly includes central processing units <b>136</b>-<b>140</b> and a memory <b>142</b> interconnected by a bus system <b>144</b>.</p>
<p id="p-0046" num="0045">IPSOE <b>118</b> provides a connection to switch <b>112</b>, while IPSOE <b>124</b> provides a connection to switch <b>114</b>, and IP Suite Offload Engines <b>120</b> and <b>122</b> provide a connection to switches <b>112</b> and <b>114</b>.</p>
<p id="p-0047" num="0046">In one embodiment, an IP Suite Offload Engine is implemented in hardware or a combination of hardware and offload microprocessor(s). In this implementation, IP suite processing is offloaded to the IPSOE. This implementation also permits multiple concurrent communications over a switched network without the traditional overhead associated with communicating protocols. In one embodiment, the IPSOEs and IP net <b>100</b> in <figref idref="DRAWINGS">FIG. 1</figref> provide the consumers of the distributed computer system with zero processor-copy data transfers without involving the operating system kernel process, and employs hardware to provide reliable, fault tolerant communications.</p>
<p id="p-0048" num="0047">As indicated in <figref idref="DRAWINGS">FIG. 1</figref>, router <b>117</b> is coupled to wide area network (WAN) and/or local area network (LAN) connections to other hosts or other routers.</p>
<p id="p-0049" num="0048">In this example, RAID subsystem node <b>106</b> in <figref idref="DRAWINGS">FIG. 1</figref> includes processor <b>168</b>, memory <b>170</b>, IP Suite Offload Engine (IPSOE) <b>172</b>, and multiple redundant and/or striped storage disk unit <b>174</b>.</p>
<p id="p-0050" num="0049">IP net <b>100</b> handles data communications for storage, interprocessor communications, file accesses, and sockets. IP net <b>100</b> supports high-bandwidth, scalable, and extremely low latency communications. User clients can bypass the operating system kernel process and directly access network communication components, such as IPSOEs, which enable efficient message passing protocols. IP net <b>100</b> is suited to current computing models and is a building block for new forms of storage, cluster, and general networking communication. Further, IP net <b>100</b> in <figref idref="DRAWINGS">FIG. 1</figref> allows storage nodes to communicate among themselves or communicate with any or all of the processor nodes in a distributed computer system. With storage attached to IP net <b>100</b>, the storage node has substantially the same communication capability as any host processor node in IP net <b>100</b>.</p>
<p id="p-0051" num="0050">In one embodiment, the IP net <b>100</b> shown in <figref idref="DRAWINGS">FIG. 1</figref> supports channel semantics and memory semantics. Channel semantics is sometimes referred to as send/receive or push communication operations. Channel semantics are the type of communications employed in a traditional I/O channel where a source device pushes data and a destination device determines a final destination of the data. In channel semantics, the frame transmitted from a source process specifies a destination processes' communication port, but does not specify where in the destination processes' memory space the frame will be written. Thus, in channel semantics, the destination process pre-allocates where to place the transmitted data.</p>
<p id="p-0052" num="0051">In memory semantics, a source process directly reads or writes the virtual address space of a remote node destination process. The remote destination process need only communicate the location of a buffer for data, and does not need to be involved in the transfer of any data. Thus, in memory semantics, a source process sends a data frame containing the destination buffer memory address of the destination process. In memory semantics, the destination process previously grants permission for the source process to access its memory.</p>
<p id="p-0053" num="0052">Channel semantics and memory semantics are typically both necessary for storage, cluster, and general networking communications. A typical storage operation employs a combination of channel and memory semantics. In an illustrative example storage operation of the distributed computer system shown in <figref idref="DRAWINGS">FIG. 1</figref>, a host processor node, such as host processor node <b>102</b>, initiates a storage operation by using channel semantics to send a disk write command to the RAID subsystem IPSOE <b>172</b>. The RAID subsystem examines the command and uses memory semantics to read the data buffer directly from the memory space of the host processor node. After the data buffer is read, the RAID subsystem employs channel semantics to push an I/O completion message back to the host processor node.</p>
<p id="p-0054" num="0053">In one exemplary embodiment, the distributed computer system shown in <figref idref="DRAWINGS">FIG. 1</figref> performs operations that employ virtual addresses and virtual memory protection mechanisms to ensure correct and proper access to all memory. Applications running in such a distributed computer system are not required to use physical addressing for any operations.</p>
<p id="p-0055" num="0054">Turning next to <figref idref="DRAWINGS">FIG. 2</figref>, a functional block diagram of a host processor node is depicted in accordance with a preferred embodiment of the present invention. Host processor node <b>200</b> is an example of a host processor node, such as host processor node <b>102</b> in <figref idref="DRAWINGS">FIG. 1</figref>. In this example, host processor node <b>200</b>, shown in <figref idref="DRAWINGS">FIG. 2</figref>, includes a set of consumers <b>202</b>-<b>208</b>, which are processes executing on host processor node <b>200</b>. Host processor node <b>200</b> also includes IP Suite Offload Engine (IPSOE) <b>210</b> and IPSOE <b>212</b>. IPSOE <b>210</b> contains ports <b>214</b> and <b>216</b> while IPSOE <b>212</b> contains ports <b>218</b> and <b>220</b>. Each port connects to a link. The ports can connect to one IP net subnet or multiple IP net subnets, such as IP net <b>100</b> in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0056" num="0055">Consumers <b>202</b>-<b>208</b> transfer messages to the IP net via the verbs interface <b>222</b> and message and data service <b>224</b>. A verbs interface is essentially an abstract description of the functionality of an IP Suite Offload Engine. An operating system may expose some or all of the verb functionality through its programming interface. Basically, this interface defines the behavior of the host. Additionally, host processor node <b>200</b> includes a message and data service <b>224</b>, which is a higher-level interface than the verb layer and is used to process messages and data received through IPSOE <b>210</b> and IPSOE <b>212</b>. Message and data service <b>224</b> provides an interface to consumers <b>202</b>-<b>208</b> to process messages and other data.</p>
<p id="p-0057" num="0056">With reference now to <figref idref="DRAWINGS">FIG. 3A</figref>, a diagram of an IP Suite Offload Engine is depicted in accordance with a preferred embodiment of the present invention. IP Suite Offload Engine <b>300</b>A shown in <figref idref="DRAWINGS">FIG. 3A</figref> includes a set of queue pairs (QPs) <b>302</b>A-<b>310</b>A, which are used to transfer messages to the IPSOE ports <b>312</b>A-<b>316</b>A. Buffering of data to IPSOE ports <b>312</b>A-<b>316</b>A is channeled using the network layer's quality of service field (QOSF), for example, the Traffic Class field in the IP Version 6 specification, <b>318</b>A-<b>334</b>A. Each network layer quality of service field has its own flow control. Internet Engineering Task Force (IETF) standard network protocols are used to configure the link and network addresses of all IP Suite Offload Engine ports connected to the network. Two such protocols are Address Resolution Protocol (ARP) and Dynamic Host Configuration Protocol. Memory translation and protection (MTP) <b>338</b>A is a mechanism that translates virtual addresses to physical addresses and validates access rights. Direct memory access (DMA) <b>340</b>A provides for direct memory access operations using memory <b>350</b>A with respect to queue pairs <b>302</b>A-<b>310</b>A.</p>
<p id="p-0058" num="0057">A single IP Suite Offload Engine, such as the IPSOE <b>300</b>A shown in <figref idref="DRAWINGS">FIG. 3A</figref>, can support thousands of queue pairs. Each queue pair consists of a send work queue (SWQ) and a receive work queue (RWQ). The send work queue is used to send channel and memory semantic messages. The receive work queue receives channel semantic messages. A consumer calls an operating system specific programming interface, which is herein referred to as “verbs”, to place work requests (WRs) onto a work queue.</p>
<p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. 3B</figref> depicts a switch <b>300</b>B in accordance with a preferred embodiment of the present invention. Switch <b>300</b>B includes a packet relay <b>302</b>B in communication with a number of ports <b>304</b>B through link or network layer quality of service fields such as IP version 4's Type of Service field <b>306</b>B. Generally, a switch such as switch <b>300</b>B can route frames from one port to any other port on the same switch.</p>
<p id="p-0060" num="0059">Similarly, <figref idref="DRAWINGS">FIG. 3C</figref> depicts a router <b>300</b>C according to a preferred embodiment of the present invention. Router <b>300</b>C includes a frame relay <b>302</b>C in communication with a number of ports <b>304</b>C through network layer quality of service fields such as IP version 4's Type of Service field <b>306</b>C. Like switch <b>300</b>B, router <b>300</b>C will generally be able to route frames from one port to any other port on the same router.</p>
<p id="p-0061" num="0060">With reference now to <figref idref="DRAWINGS">FIG. 4</figref>, a diagram illustrating processing of work requests is depicted in accordance with a preferred embodiment of the present invention. In <figref idref="DRAWINGS">FIG. 4</figref>, a receive work queue <b>400</b>, send work queue <b>402</b>, and completion queue <b>404</b> are present for processing requests from and for consumer <b>406</b>. These requests from consumer <b>406</b> are eventually sent to hardware <b>408</b>. In this example, consumer <b>406</b> generates work requests <b>410</b> and <b>412</b> and receives work completion <b>414</b>. As shown in <figref idref="DRAWINGS">FIG. 4</figref>, work requests placed onto a work queue are referred to as work queue elements (WQEs).</p>
<p id="p-0062" num="0061">Send work queue <b>402</b> contains work queue elements (WQEs) <b>422</b>-<b>428</b>, describing data to be transmitted on the IP net fabric. Receive work queue <b>400</b> contains work queue elements (WQEs) <b>416</b>-<b>420</b>, describing where to place incoming channel semantic data from the IP net fabric. A work queue element is processed by hardware <b>408</b> in the IPSOE.</p>
<p id="p-0063" num="0062">The verbs also provide a mechanism for retrieving completed work from completion queue <b>404</b>. As shown in <figref idref="DRAWINGS">FIG. 4</figref>, completion queue <b>404</b> contains completion queue elements (CQEs) <b>430</b>-<b>436</b>. Completion queue elements contain information about previously completed work queue elements. Completion queue <b>404</b> is used to create a single point of completion notification for multiple queue pairs. A completion queue element is a data structure on a completion queue. This element describes a completed work queue element. The completion queue element contains sufficient information to determine the queue pair and specific work queue element that completed. A completion queue context is a block of information that contains pointers to, length, and other information needed to manage the individual completion queues.</p>
<p id="p-0064" num="0063">Example work requests supported for send work queue <b>402</b> shown in <figref idref="DRAWINGS">FIG. 4</figref> are as follows. A send work request is a channel semantic operation to push a set of local data segments to the data segments referenced by a remote node's receive work queue element. For example, work queue element <b>428</b> contains references to data segment <b>4</b> <b>438</b>, data segment <b>5</b> <b>440</b>, and data segment <b>6</b> <b>442</b>. Each of the send work request's data segments contains part of a virtually contiguous memory region. The virtual addresses used to reference the local data segments are in the address context of the process that created the local queue pair.</p>
<p id="p-0065" num="0064">A remote direct memory access (RDMA) read work request provides a memory semantic operation to read a virtually contiguous memory space on a remote node. A memory space can either be a portion of a memory region or portion of a memory window. A memory region references a previously registered set of virtually contiguous memory addresses defined by a virtual address and length. A memory window references a set of virtually contiguous memory addresses that have been bound to a previously registered region.</p>
<p id="p-0066" num="0065">The RDMA read work request reads a virtually contiguous memory space on a remote endnode and writes the data to a virtually contiguous local memory space. Similar to the send work request, virtual addresses used by the RDMA read work queue element to reference the local data segments are in the address context of the process that created the local queue pair. The remote virtual addresses are in the address context of the process owning the remote queue pair targeted by the RDMA read work queue element.</p>
<p id="p-0067" num="0066">A RDMA write work queue element provides a memory semantic operation to write a virtually contiguous memory space on a remote node. For example, work queue element <b>416</b> in receive work queue <b>400</b> references data segment <b>1</b> <b>444</b>, data segment <b>2</b> <b>446</b>, and data segment <b>3</b> <b>448</b>. The RDMA write work queue element contains a scatter list of local virtually contiguous memory spaces and the virtual address of the remote memory space into which the local memory spaces are written.</p>
<p id="p-0068" num="0067">A RDMA FetchOp work queue element provides a memory semantic operation to perform an atomic operation on a remote word. The RDMA FetchOp work queue element is a combined RDMA Read, Modify, and RDMA Write operation. The RDMA FetchOp work queue element can support several read-modify-write operations, such as Compare and Swap if equal. The RDMA FetchOp is not included in current RDMA over IP standardization efforts, but is described here, because it may be used as a value-added feature in some implementations.</p>
<p id="p-0069" num="0068">A bind (unbind) remote access key (STag) work queue element provides a command to the IP Suite Offload Engine hardware to modify (destroy) a memory window by associating (disassociating) the memory window to a memory region. The STag is part of each RDMA access and is used to validate that the remote process has permitted access to the buffer.</p>
<p id="p-0070" num="0069">In one embodiment, receive work queue <b>400</b> shown in <figref idref="DRAWINGS">FIG. 4</figref> only supports one type of work queue element, which is referred to as a receive work queue element. The receive work queue element provides a channel semantic operation describing a local memory space into which incoming send messages are written. The receive work queue element includes a scatter list describing several virtually contiguous memory spaces. An incoming send message is written to these memory spaces. The virtual addresses are in the address context of the process that created the local queue pair.</p>
<p id="p-0071" num="0070">For interprocessor communications, a user-mode software process transfers data through queue pairs directly from where the buffer resides in memory. In one embodiment, the transfer through the queue pairs bypasses the operating system and consumes few host instruction cycles. Queue pairs permit zero processor-copy data transfer with no operating system kernel involvement. The zero processor-copy data transfer provides for efficient support of high-bandwidth and low-latency communication.</p>
<p id="p-0072" num="0071">When a queue pair is created, the queue pair is set to provide a selected type of transport service. In one embodiment, a distributed computer system implementing the present invention supports three types of transport services: TCP, SCTP, and UDP.</p>
<p id="p-0073" num="0072">TCP and SCTP associate a local queue pair with one and only one remote queue pair. TCP and SCTP require a process to create a queue pair for each process that TCP and SCTP are to communicate with over the IP net fabric. Thus, if each of N host processor nodes contains P processes, and all P processes on each node wish to communicate with all the processes on all the other nodes, each host processor node requires P<sup>2</sup>×(N−1) queue pairs. Moreover, a process can associate a queue pair to another queue pair on the same IPSOE.</p>
<p id="p-0074" num="0073">A portion of a distributed computer system employing TCP or SCTP to communicate between distributed processes is illustrated generally in <figref idref="DRAWINGS">FIG. 5</figref>. The distributed computer system <b>500</b> in <figref idref="DRAWINGS">FIG. 5</figref> includes a host processor node <b>1</b>, a host processor node <b>2</b>, and a host processor node <b>3</b>. Host processor node <b>1</b> includes a process A <b>510</b>. Host processor node <b>3</b> includes a process C <b>520</b> and a process D <b>530</b>. Host processor node <b>2</b> includes a process E <b>540</b>.</p>
<p id="p-0075" num="0074">Host processor node <b>1</b> includes queue pairs 4, 6 and 7, each having a send work queue and receive work queue. Host processor node <b>2</b> has a queue pair 9 and host processor node <b>3</b> has queue pairs 2 and 5. The TCP or SCTP of distributed computer system <b>500</b> associates a local queue pair with one and only one remote queue pair. Thus, the queue pair 4 is used to communicate with queue pair 2; queue pair 7 is used to communicate with queue pair 5; and queue pair 6 is used to communicate with queue pair 9.</p>
<p id="p-0076" num="0075">A WQE placed on one send queue in a TCP or SCTP causes data to be written into the receive memory space referenced by a receive WQE of the associated queue pair. RDMA operations operate on the address space of the associated queue pair.</p>
<p id="p-0077" num="0076">In one embodiment of the present invention, the TCP or SCTP is made reliable because hardware maintains sequence numbers and acknowledges all frame transfers. A combination of hardware and IP net driver software retries any failed communications. The process client of the queue pair obtains reliable communications even in the presence of bit errors, receive underruns, and network congestion. If alternative paths exist in the IP net fabric, reliable communications can be maintained even in the presence of failures of fabric switches, links, or IP Suite Offload Engine ports.</p>
<p id="p-0078" num="0077">In addition, acknowledgements may be employed to deliver data reliably across the IP net fabric. The acknowledgement may, or may not, be a process level acknowledgement, i.e. an acknowledgement that validates that a receiving process has consumed the data. Alternatively, the acknowledgement may be one that only indicates that the data has reached its destination.</p>
<p id="p-0079" num="0078">The User Datagram Protocol is connectionless. The UDP is employed by management applications to discover and integrate new switches, routers, and endnodes into a given distributed computer system. The UDP does not provide the reliability guarantees of the TCP or SCTP. The UDP accordingly operates with less state information maintained at each endnode.</p>
<p id="p-0080" num="0079">Turning next to <figref idref="DRAWINGS">FIG. 6</figref>, an illustration of a data frame is depicted in accordance with a preferred embodiment of the present invention. A data frame is a unit of information that is routed through the IP net fabric. The data frame is an endnode-to-endnode construct, and is thus created and consumed by endnodes. For frames destined to an IPSOE, the data frames are neither generated nor consumed by the switches and routers in the IP net fabric. Instead for data frames that are destined to an IPSOE, switches and routers simply move request frames or acknowledgment frames closer to the ultimate destination, modifying the link header fields in the process. Routers may modify the frame's network header when the frame crosses a subnet boundary. In traversing a subnet, a single frame stays on a single service level.</p>
<p id="p-0081" num="0080">Message data <b>600</b> contains data segment <b>1</b> <b>602</b>, data segment <b>2</b> <b>604</b>, and data segment <b>3</b> <b>606</b>, which are similar to the data segments illustrated in <figref idref="DRAWINGS">FIG. 4</figref>. In this example, these data segments form a frame <b>608</b>, which is placed into frame payload <b>610</b> within data frame <b>612</b>. Additionally, data frame <b>612</b> contains cyclic redundancy check (CRC) <b>614</b>, which is used for error checking. Additionally, routing header <b>616</b> and transport header <b>618</b> are present in data frame <b>612</b>. Routing header <b>616</b> is used to identify source and destination ports for data frame <b>612</b>. Transport header <b>618</b> in this example specifies the sequence number and the source and destination port number for data frame <b>612</b>. The sequence number is initialized when communication is established and incremented by 1 for each byte of frame header, DDP/RDMA header, data payload, and CRC. Frame header <b>620</b> in this example specifies the destination queue pair number associated with the frame and the length of the Direct Data Placement and/or Remote Direct Memory Access (DDP/RDMA) header plus data payload plus CRC. DDP/RDMA header <b>622</b> specifies the message identifier and the placement information for the data payload. The message identifier is constant for all frames that are part of a message. Example message identifiers include, for example, send, write RDMA, and read RDMA.</p>
<p id="p-0082" num="0081">In <figref idref="DRAWINGS">FIG. 7</figref>, a portion of a distributed computer system <b>700</b> is depicted to illustrate an example request and acknowledgment transaction. Distributed computer system <b>700</b> in <figref idref="DRAWINGS">FIG. 7</figref> includes a host processor node <b>702</b> running process A <b>716</b> and a host processor node <b>704</b> running process B <b>718</b>. Host processor node <b>702</b> includes an IPSOE <b>706</b>. Host processor node <b>704</b> includes an IPSOE <b>708</b>. The distributed computer system in <figref idref="DRAWINGS">FIG. 7</figref> includes IP net fabric <b>710</b>, which includes switch <b>712</b> and switch <b>714</b>. The IP net fabric includes a link coupling IPSOE <b>706</b> to switch <b>712</b>; a link coupling switch <b>712</b> to switch <b>714</b>; and a link coupling IPSOE <b>708</b> to switch <b>714</b>.</p>
<p id="p-0083" num="0082">In the example transactions, host processor node <b>702</b> includes a client process A. Host processor node <b>704</b> includes a client process B. Client process A interacts with host IPSOE <b>706</b> through queue pair 23 <b>720</b> comprising send queue <b>724</b> and receive queue <b>726</b>. Client process B interacts with host IPSOE <b>708</b> through queue pair 24 <b>722</b> comprising send queue <b>728</b> and receive queue <b>730</b>. Queue pairs 23 and 24 are data structures that include a send work queue and a receive work queue.</p>
<p id="p-0084" num="0083">Process A initiates a message request by posting work queue elements to the send queue of queue pair 23. Such a work queue element is illustrated in <figref idref="DRAWINGS">FIG. 4</figref>. The message request of client process A is referenced by a gather list contained in the send work queue element. Each data segment in the gather list points to part of a virtually contiguous local memory region, which contains a part of the message, such as indicated by data segments <b>1</b>, <b>2</b>, and <b>3</b>, which respectively hold message parts <b>1</b>, <b>2</b>, and <b>3</b>, in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0085" num="0084">Hardware in host IPSOE <b>706</b> reads the work queue element and segments the message stored in virtual contiguous buffers into data frames, such as the data frame illustrated in <figref idref="DRAWINGS">FIG. 6</figref>. Data frames are routed through the IP net fabric, and for reliable transfer services, are acknowledged by the final destination endnode. If not successfully acknowledged, the data frame is retransmitted by the source endnode. Data frames are generated by source endnodes and consumed by destination endnodes.</p>
<p id="p-0086" num="0085">With reference to <figref idref="DRAWINGS">FIG. 8</figref>, a diagram illustrating the network addressing used in a distributed networking system is depicted in accordance with the present invention. A host name provides a logical identification for a host node, such as a host processor node or I/O adapter node. The host name identifies the endpoint for messages such that messages are destined for processes residing on an endnode specified by the host name. Thus, there is one host name per node, but a node can have multiple IPSOEs.</p>
<p id="p-0087" num="0086">A single link layer address (e.g. Ethernet Media Access Layer Address) <b>804</b> is assigned to each port <b>806</b> of a endnode component <b>802</b>. A component can be an IPSOE, switch, or router. All IPSOE and router components must have a MAC address. A media access point on a switch is also assigned a MAC address.</p>
<p id="p-0088" num="0087">One network address (e.g. IP Address) <b>812</b> is assigned to each port <b>806</b> of an endnode component <b>802</b>. A component can be an IPSOF, switch, or router. All IPSOE and router components must have a network address. A media access point on a switch is also assigned a MAC address.</p>
<p id="p-0089" num="0088">Each port of switch <b>810</b> does not have a link layer address associated with it. However, switch <b>810</b> can have a media access port <b>814</b> that has a link layer address <b>816</b> and a network layer address <b>808</b> associated with it.</p>
<p id="p-0090" num="0089">A portion of a distributed computer system in accordance with a preferred embodiment of the present invention is illustrated in <figref idref="DRAWINGS">FIG. 9</figref>. Distributed computer system <b>900</b> includes a subnet <b>902</b> and a subnet <b>904</b>. Subnet <b>902</b> includes host processor nodes <b>906</b>, <b>908</b>, and <b>910</b>. Subnet <b>904</b> includes host processor nodes <b>912</b> and <b>914</b>. Subnet <b>902</b> includes switches <b>916</b> and <b>918</b>. Subnet <b>904</b> includes switches <b>920</b> and <b>922</b>.</p>
<p id="p-0091" num="0090">Routers create and connect subnets. For example, subnet <b>902</b> is connected to subnet <b>904</b> with routers <b>924</b> and <b>926</b>. In one example embodiment, a subnet has up to 216 endnodes, switches, and routers.</p>
<p id="p-0092" num="0091">A subnet is defined as a group of endnodes and cascaded switches that is managed as a single unit. Typically, a subnet occupies a single geographic or functional area. For example, a single computer system in one room could be defined as a subnet. In one embodiment, the switches in a subnet can perform very fast wormhole or cut-through routing for messages.</p>
<p id="p-0093" num="0092">A switch within a subnet examines the destination link layer address (e.g. MAC address) that is unique within the subnet to permit the switch to quickly and efficiently route incoming message frames. In one embodiment, the switch is a relatively simple circuit, and is typically implemented as a single integrated circuit. A subnet can have hundreds to thousands of endnodes formed by cascaded switches.</p>
<p id="p-0094" num="0093">As illustrated in <figref idref="DRAWINGS">FIG. 9</figref>, for expansion to much larger systems, subnets are connected with routers, such as routers <b>924</b> and <b>926</b>. The router interprets the destination network layer address (e.g. IP address) and routes the frame.</p>
<p id="p-0095" num="0094">An example embodiment of a switch is illustrated generally in <figref idref="DRAWINGS">FIG. 3B</figref>. Each I/O path on a switch or router has a port. Generally, a switch can route frames from one port to any other port on the same switch.</p>
<p id="p-0096" num="0095">Within a subnet, such as subnet <b>902</b> or subnet <b>904</b>, a path from a source port to a destination port is determined by the link layer address (e.g. MAC address) of the destination host IPSOE port. Between subnets, a path is determined by the network layer address (IP address) of the destination IPSOE port and by the link layer address (e.g. MAC address) of the router port, which will be used to reach the destination's subnet.</p>
<p id="p-0097" num="0096">In one embodiment, the paths used by the request frame and the request frame's corresponding positive acknowledgment (ACK) frame are not required to be symmetric. In one embodiment employing oblivious routing, switches select an output port based on the link layer address (e.g. MAC address). In one embodiment, a switch uses one set of routing decision criteria for all its input ports in the switch. In one example embodiment, the routing decision criteria are contained in one routing table. In an alternative embodiment, a switch employs a separate set of criteria for each input port.</p>
<p id="p-0098" num="0097">A data transaction in the distributed computer system of the present invention is typically composed of several hardware and software steps. A client process data transport service can be a user-mode or a kernel-mode process. The client process accesses IP Suite Offload Engine hardware through one or more queue pairs, such as the queue pairs illustrated in <figref idref="DRAWINGS">FIGS. 3A</figref>, <b>5</b>, and <b>8</b>. The client process calls an operating system specific programming interface, which is herein referred to as “verbs.” The software code implementing verbs posts a work queue element to the given queue pair work queue.</p>
<p id="p-0099" num="0098">There are many possible methods of posting a work queue element and there are many possible work queue element formats, which allow for various cost/performance design points, but which do not affect interoperability. A user process, however, must communicate to verbs in a well-defined manner, and the format and protocols of data transmitted across the IP net fabric must be sufficiently specified to allow devices to interoperate in a heterogeneous vendor environment.</p>
<p id="p-0100" num="0099">In one embodiment, IPSOE hardware detects work queue element postings and accesses the work queue element. In this embodiment, the IPSOE hardware translates and validates the work queue element's virtual addresses and accesses the data.</p>
<p id="p-0101" num="0100">An outgoing message is split into one or more data frames. In one embodiment, the IPSOE hardware adds a DDP/RDMA header, frame header and CRC, transport header and a network header to each frame. The transport header includes sequence numbers and other transport information. The network header includes routing information, such as the destination IP address and other network routing information. The link header contains the destination link layer address (e.g. MAC address) or other local routing information.</p>
<p id="p-0102" num="0101">If a TCP or SCTP is employed, when a request data frame reaches its destination endnode, acknowledgment data frames are used by the destination endnode to let the request data frame sender know the request data frame was validated and accepted at the destination. Acknowledgement data frames acknowledge one or more valid and accepted request data frames. The requester can have multiple outstanding request data frames before it receives any acknowledgments. In one embodiment, the number of multiple outstanding messages, i.e. request data frames, is determined when a queue pair is created.</p>
<p id="p-0103" num="0102">One embodiment of a layered architecture <b>1000</b> for implementing the present invention is generally illustrated in diagram form in <figref idref="DRAWINGS">FIG. 10</figref>. The layered architecture diagram of <figref idref="DRAWINGS">FIG. 10</figref> shows the various layers of data communication paths, and organization of data and control information passed between layers.</p>
<p id="p-0104" num="0103">IPSOE endnode protocol layers (employed by endnode <b>1011</b>, for instance) include upper level protocols <b>1002</b> defined by consumer <b>1003</b>, transport layer <b>1004</b>, network layer <b>1006</b>, link layer <b>1008</b>, and physical layer <b>1010</b>. Switch layers (employed by switch <b>1013</b>, for instance) include link layer <b>1008</b> and physical layer <b>1010</b>. Router layers (employed by router <b>1015</b>, for instance) include network layer <b>1006</b>, link layer <b>1008</b>, and physical layer <b>1010</b>.</p>
<p id="p-0105" num="0104">Layered architecture <b>1000</b> generally follows an outline of a classical communication stack in order to complete consumer operations <b>1012</b> of transferring data between consumers <b>1003</b> and <b>1005</b>. With respect to the protocol layers of endnode <b>1011</b>, for example, upper layer protocols <b>1002</b> employs verbs to create messages at transport layer <b>1004</b>. Transport layer <b>1004</b> passes messages <b>1014</b> to network layer <b>1006</b>. Network layer <b>1006</b> routes frames between network subnets <b>1016</b>. Link layer <b>1008</b> routes frames within a network subnet <b>1018</b>. Physical layer <b>1010</b> sends bits or groups of bits to the physical layers of other devices. Each of the layers is unaware of how the upper or lower layers perform their functionality.</p>
<p id="p-0106" num="0105">Consumers <b>1003</b> and <b>1005</b> represent applications or processes that employ the other layers for communicating between endnodes. Transport layer <b>1004</b> provides end-to-end message movement. In one embodiment, the transport layer provides four types of transport services as described above which are traditional TCP, RDMA over TCP, SCTP, and UDP. Network layer <b>1006</b> performs frame routing through a subnet or multiple subnets to destination endnodes. Link layer <b>1008</b> performs flow-controlled <b>1020</b>, error checked, and prioritized frame delivery across links.</p>
<p id="p-0107" num="0106">Physical layer <b>1010</b> performs technology-dependent bit transmission. Bits or groups of bits are passed between physical layers via links <b>1022</b>, <b>1024</b>, and <b>1026</b>. Links can be implemented with printed circuit copper traces, copper cable, optical cable, or with other suitable links.</p>
<p id="p-0108" num="0107">Turning now to <figref idref="DRAWINGS">FIG. 11</figref>, a flowchart and diagram illustrating two Memory Registration mechanisms in accordance with a preferred embodiment of the present invention are provided. In the “Traditional Mechanism” (<b>1120</b>) for registering a Memory Region with the IPSOE, Consumer <b>1100</b>, uses a single step <b>1104</b> to register the Memory Region with the IPSOE. The single step uses either Memory Mapped I/O (MMIO), Programmed I/O (PIO), or perhaps a Direct Memory Access (DMA) CPU assist to transfer the Memory Translation and Protection Table (TPT) entry into IPSOE <b>1112</b>'s Memory TPT <b>1108</b>. If the Traditional Mechanism uses MMIOs or PIOs to perform the transfer, the Consumer must wait for these MMIOs or PIOs to return control to the Host CPU before the Consumer can use the newly create Memory TPT. Depending on the implementation the delay may degrade system performance.</p>
<p id="p-0109" num="0108"><figref idref="DRAWINGS">FIG. 11</figref> also shows a Send Queue based Physical Memory Registration Mechanism <b>1130</b>. Under this mechanism, Physical Memory Registration through the Send Queue is explicitly exposed through the verbs used by the Consumer to access the IPSOE. Consumer <b>1140</b> must first enable the use of this mechanism on the QP. This is the first step (<b>1144</b>) of the Send Queue based Physical Memory Registration Mechanism. This step consists of by setting the Enable Send Queue based Physical Memory Registration field in QP Context <b>1148</b>. After the QP Context has been enabled to support Send Queue based Physical Memory Registration, (<b>1152</b>) Consumer <b>1140</b> requests the IPSOE <b>1192</b> to create an entry in the Memory TPT <b>1172</b> by posting a Send Queue (SQ) Work Request (WR) on one of the IPSOEs SQs, such as SQ <b>1164</b>. The Verbs interface immediately returns the STag associated with the Memory Registration WR, converts the Memory Registration WR into a SQ Work Queue Element (WQE) <b>1160</b>, and places the Memory Registration WQE into the SQ <b>1164</b> (step <b>1156</b>). Upon receiving the immediate return, Consumer <b>1140</b> may begin using the STag in local or remote WRs placed on the same SQ <b>1164</b>.</p>
<p id="p-0110" num="0109">When IPSOE <b>1192</b>'s SQ <b>1164</b> processes the Physical Memory Registration WQE <b>1160</b>, it validates the Memory Registration WQE. If the QP has the Send Queue based Physical Memory Registration Mechanism enabled and the STag is valid (e.g. STag points to an entry in the Memory TPT and the STag Tag_Instance matches the Tag_Instance in that entry and there is enough space in the Memory TPT for the new entry), then the new Memory TPT entry <b>1172</b> is created (step <b>1168</b>).</p>
<p id="p-0111" num="0110">If the Memory Registration WQE encounters an error (e.g. STag does not point to an entry in the Memory TPT, or the STag Tag_Instance does not match the Tag_Instance in the entry pointed to by the STag, or the entry pointed to by the STag does not have enough space for the new Memory TPT entry), there are two semantic options for an implementation to take. Option <b>1</b> (step <b>1174</b>) is reactive and presumes that Consumer <b>1140</b> is not keeping track of the Memory TPT space. If an IPSOE implementation uses option <b>1</b>, then the following process is performed: the IPSOE places the QP associated with the SQ in the Send Queue Drained State, stops processing WQEs subsequent to Memory Registration WQE <b>1160</b> (but continues processing all RQ WQEs, all incoming RDMA Read Requests, any Terminate message, and all preceding SQ WQEs), generates a completion error CQE <b>1180</b> identifying the error in the Memory Registration WQE, places CQE <b>1180</b> in Completion Queue <b>1184</b>, and returns all subsequent SQ WQEs with a Flush error CQE through CQ <b>1184</b>. Consumer <b>1140</b> can retry the Memory Registration WR that was completed in error and all subsequent WRs.</p>
<p id="p-0112" num="0111">Option <b>2</b> (step <b>1176</b>) is anticipatory and presumes that Consumer <b>1140</b> is keeping track of the Memory TPT space. That is, Consumer keeps track of how the Memory TPT space is being used by IPSOE <b>1192</b>. Under this option, Consumer <b>1140</b> only issues Memory Registration WRs that are guaranteed to have enough space in the Memory TPT. If an IPSOE implementation uses option <b>2</b>, then the following process is performed: the IPSOE places the QP associated with the SQ in the Error State, stops processing all local and remote operations, issues a Terminate Message to bring down the RDMA Stream, generates a completion error CQE <b>1180</b> identifying the error in the Memory Registration WQE, places CQE <b>1180</b> in Completion Queue <b>1184</b>, and returns all other SQ and RQ WQEs with a Flush error CQE through CQ <b>1184</b>.</p>
<p id="p-0113" num="0112">Finally (step <b>1188</b>), Consumer <b>1140</b> retrieves the result of the Physical Memory Registration WR through a Work Completion <b>1188</b>.</p>
<p id="p-0114" num="0113">Turning next to <figref idref="DRAWINGS">FIG. 12</figref>, a diagram of a memory management system is depicted in accordance with a preferred embodiment of the present invention. Memory management system <b>1200</b> employs a two-table memory translation and protection management structure, which includes memory region/window table <b>1202</b> and address translation tables <b>1204</b>. Together these tables are known as the Memory Translation and Protection Table (Memory TPT). Memory region/window table <b>1202</b> contains information used by IPSOE hardware to determine whether access to an area of memory referenced in a work request or a remote operation is authorized. In this example, the access may be requested in WQE data segment <b>1206</b> within work queue <b>1208</b>. Address translation tables <b>1204</b> contain the information used to convert a virtual address provided in WQE data segment <b>1206</b> into a list of one or more real addresses of pages making up a data buffer within a memory region, such as memory region <b>1210</b>. The data buffer may encompass one or more pages in these examples.</p>
<p id="p-0115" num="0114">When a WQE data segment, such as WQE data segment <b>1206</b> is received, the key index within the WQE data segment is used as an index into memory region/window table <b>1202</b> to identify a memory region entry or a memory window entry within the memory region/window table, such as memory region entry <b>1212</b> or memory window entry <b>1213</b>. Memory region table entry <b>1212</b> is used to determine whether the requested memory access is authorized for the memory region defined by the memory region entry. If access is authorized, then an address translation table <b>1204</b> is accessed. Multiple address translation tables are present in which one address translation table is used for every memory region/window defined. Each entry in an address translation table is the real address of a page that makes up part of the memory region/window. Entries are arranged in ascending order corresponding to the incrementing virtual address associated with the memory region/window. The IPSOE hardware indexes into the address translation table <b>1204</b> based on the offset into the memory region/window, which is calculated by subtracting starting virtual address <b>1214</b> of the memory region/window obtained from memory region/window table entry <b>1212</b> from virtual address <b>1216</b> specified in the work request or remote operation packet header. This result forms offset <b>1218</b> into the area of memory to be accessed. The low order bits of this offset are used to index into the page specified in the address translation table entry, and the high order bits are used to index into the address translation table. In this example, offset <b>1218</b> results in a translation of the address into real addresses identifying pages <b>1220</b>-<b>1226</b> as those containing the data buffer referenced by WQE data segment <b>1206</b>.</p>
<p id="p-0116" num="0115"><figref idref="DRAWINGS">FIG. 13</figref> depicts the layout of a memory region/window table (MRWT) <b>1300</b> and the Memory Region and Memory Window Entries that are inserted upon the registration of a memory region or the bind of a memory window with an underlying memory region, respectively, in accordance with a preferred embodiment of the present invention.</p>
<p id="p-0117" num="0116">In this example, the memory region/window entry <b>1302</b> includes the virtual address of the start of memory region/window <b>1304</b>, length of memory region/window <b>1306</b>, protection domain <b>1308</b>, tag_instance <b>1310</b>, entry type <b>1311</b>, valid entry <b>1312</b>, access control <b>1314</b>, iSCSI control <b>1315</b>, ATT control <b>1316</b>, page size <b>1318</b>, and address translation pointer <b>1320</b>.</p>
<p id="p-0118" num="0117">Each entry in memory region/window table <b>1300</b> defines the characteristics of a memory region or a memory window. A Memory Region Entry (<b>1302</b>) is used to describe a Memory Region. A Memory Window Entry (<b>1303</b>) is used to describe a Memory Window. The remainder of this section will describe the contents of the Memory Region Entry. Except where noted otherwise, the description is applicable to a Memory Window Entry, because both MREs and MWEs contain the same fields. Though the Memory Window Entry can be optimized to use the Address Translation Table of the Memory Region that the Memory Window is bound to.</p>
<p id="p-0119" num="0118">A portion of the STag that is used to reference the data buffer is called the Tag_Index, and this is used by the IPSOE hardware to index into the memory region/window table to obtain the memory region table entry (MRE) for the memory region that is to be accessed. More specifically, the STag Tag_Index is used to reference the memory region. The STag of the memory region are included in the Bind WQE.</p>
<p id="p-0120" num="0119">Virtual address <b>1304</b> of the start of the memory region and length <b>1306</b> of the memory region define the bounds of the memory region. Protection domain (PD) <b>1308</b> is used to determine if the QP originating the work queue request has authorization to access this memory region. That is, the PD value stored in the Memory Region Entry must match the PD value stored in the QP. Tag_Instance <b>1310</b> is the value of the Tag instance associated with the memory region and is used to validate the portion of the STag that is not part of the Tag_Index. The Tag_Instance provides access control when the definitions of memory regions change. More specifically, the STag Tag_Instance is validated with the Tag_Instance stored in the memory region entry for the region.</p>
<p id="p-0121" num="0120">Entry Type <b>1311</b> specifies whether the entry is for: an RDMA Region, an RDMA Window, or iSCSI. It can be implemented as two bits, with three values used and one reserved or as three bits.</p>
<p id="p-0122" num="0121">The following example is for a two bit implementation: if the Entry Type field is ‘00’b, then the entry is for RDMA Region; if the Entry Type field is ‘01’b, then the entry is for a RDMA Window; if the Entry Type field is ‘10’b, then the entry is for a iSCSI Region; and an Entry Type field of ‘11’b is reserved and unused.</p>
<p id="p-0123" num="0122">If the entry is for a RDMA Region (including iSCSI-R), then the first Address Translation Table entry for the Memory Region points to the byte offset into the first physical page associated of the Memory Region. If the entry is for a RDMA Window (including iSCSI-R), then the first Address Translation Table entry for the Memory Window can be implemented as an index into the Memory Region's ATT which is bound to the Memory Window. If the entry is for iSCSI 1.0, then the Virtual Address <b>1304</b> field is used as a pointer to a WQE in the send queue that contains the iSCSI command and the first Address Translation Table entry for the iSCSI 1.0 Region points to the byte offset into the first physical page associated of the iSCSI 1.0 Region.</p>
<p id="p-0124" num="0123">Valid Entry <b>1312</b> denotes whether the entry is valid or invalid. Valid Entry <b>1312</b> can be implemented as a single bit. If the bit is set, the entry is valid, otherwise it is not valid.</p>
<p id="p-0125" num="0124">Access control <b>1314</b> determines the write access rights for this memory region. The Access Control <b>1314</b> field contains three sub-fields: Type of Access Control <b>1330</b>, Window Binding Control <b>1332</b>, and Touch Access Control <b>1334</b>.</p>
<p id="p-0126" num="0125">The Type of Access Control <b>1330</b> field contains four distinct access types: local read, local write, remote read, and remote write access. These distinct access types can be encoded as four bits, where if a bit is set, the access type associated with the bit is enabled. If a bit is not set, the access type associated with the bit is disabled. For example, if the local write access bit is set, local write access is enabled. If the local write access bit is not set, local write access is disabled. Note: if standard specifications prohibit Windows from being used for local access, then a Memory Window Entry would only have two distinct access types: remote read access and remote write access.</p>
<p id="p-0127" num="0126">Window Binding Control <b>1332</b> field contains a single bit denoting whether Memory Windows can be bound to the Memory Region or not. If the bit is set, Memory Windows can be bound to the Memory Region. If the bit is not set, Memory Windows cannot be bound to the Memory Region.</p>
<p id="p-0128" num="0127">Touch Access Control <b>1334</b> field contains at least two bits: a One Touch Enabled bit which designates whether the entry has One Touch Enabled or not; and Touched bit which only has meaning if the One Touch Enabled bit is set and designates whether the entry has been touched before or not.</p>
<p id="p-0129" num="0128">A One Touch entry cannot be used after the incoming byte-stream lines up with the end of the last segment associated with the first RDMA Message that targets the entry. A Multiple Touch entry can be used after the incoming byte-stream lines up with the end of the last segment associated with the first RDMA Message that targets the Region.</p>
<p id="p-0130" num="0129">For One Touch Memory Region, the Memory Region's Valid Region <b>1312</b> field is reset, when the incoming byte stream lines up with the end of the last segment associated with the first RDMA Message that targets the Region. For a Multiple Touch Memory Region, the Memory Region's Valid Region <b>1312</b> field is not affected, when the incoming byte stream lines up with the end of the last segment associated with the first RDMA Message that targets the Region. A more detailed description of this process is provided in <figref idref="DRAWINGS">FIGS. 18A-18B</figref> and the accompanying text.</p>
<p id="p-0131" num="0130">If standard specifications enable one touch access on Windows only, then an implementation may choose to use one touch access on Memory Window Entries only (or may offer one touch access on Memory Regions as an option).</p>
<p id="p-0132" num="0131">The Stored DDP Sequence Number <b>1315</b> is used to store the DDP Sequence Number associated with the last byte of the payload of a DDP Segment that has the Last bit set in the DDP Header. A more detailed description of this process is provided in <figref idref="DRAWINGS">FIGS. 18A-18B</figref> and the accompanying text.</p>
<p id="p-0133" num="0132">ATT Control <b>1316</b> specifies whether the ATT entries reference physical page address (Direct Pointers), a list of physical page addresses (1st Order Indirect Pointers), or an indirect ATT page that contains a list of ATT pages (2nd Order Indirect Pointers). Address translation pointer <b>1212</b> references the address translation table associated with this memory region. Note the first entry in the ATT that references a physical page can point to an offset into the page. Similarly, the last entry can end at an offset from the start of the last physical page.</p>
<p id="p-0134" num="0133">Page size <b>1318</b> specifies the size of the page. For example, 4 KB, 8 KB, 64 KB, 1 MB, 16 MB, and 256 MB may also be valid page sizes, as well as other possible sizes, as one skilled in the art will appreciate.</p>
<p id="p-0135" num="0134">ATT Entries <b>1320</b> specifies one or more 64-bit physical addresses. If ATT Control field <b>1316</b> is set to Direct Pointers <b>1320</b>, then each ATT Entry <b>1320</b> points to a physical address. If ATT Control field <b>1316</b> is set to 1st Order Indirect Pointers <b>1338</b>, then each ATT Entry <b>1320</b> points to a list of Physical Addresses <b>1340</b>. If ATT Control field <b>1316</b> is set to 2nd Order Indirect Pointers <b>1348</b>, then each ATT Entry <b>1320</b> points to a list of ATT Entries <b>1350</b> and each Entry in the ATT Entries <b>1350</b> points to a list of Physical Addresses <b>1354</b>.</p>
<p id="p-0136" num="0135"><figref idref="DRAWINGS">FIG. 14</figref> is a flowchart of the process used by a Memory Registration Consumer (Consumer for short) to register a Memory Region in accordance with a preferred embodiment of the present invention. First, the Consumer checks to see if the memory region is shared by multiple processes with common address translation table entries (step <b>1400</b>). If the memory region is not shared in this way (step <b>1400</b>: No), then both the memory region table entry (MRTE) and address translation table entries (ATTE) must be created (step <b>1410</b>) by the Consumer. If multiple processes use common address translation table entries (step <b>1400</b>: Yes) to share the memory, then the Consumer must create only the MRTE using the same ATTEs (step <b>1412</b>).</p>
<p id="p-0137" num="0136">We now turn to <figref idref="DRAWINGS">FIG. 15</figref>, which is a flowchart and diagram representation of the process used by the IPSOE to validate memory accesses performed by Work Queue Elements posted by the Consumer as Work Request on an IPSOE Work Queue, in accordance with a preferred embodiment of the present invention.</p>
<p id="p-0138" num="0137">First (step <b>1552</b>), the Consumer <b>1540</b> posts a Work Request into an IPSOE Work Queue <b>1564</b>. The Work Queue can either be a Send Queue or a Receive Queue. The Work Request contains zero or more Data Segments. For RDMA (including iSCSI-R), each Data Segment contains a STag, Virtual Address, and Length. For iSCSI 1.0: a single STag is used for all Data Segments in the WR; each Data Segment in the WR contains a physical address; the first Data Segment contains an additional field that is used to define the starting offset into the first physical page; the last Data Segment also contains an additional field that is used to define the ending offset into the last physical page; and all intermediate Data Segments only contain a physical address, because the intermediate pages must start and end on a page boundary.</p>
<p id="p-0139" num="0138">Next (step <b>1556</b>), the verbs interface converts the WR into a Work Queue Element (WQE) and places WQE <b>1560</b> into WQ <b>1564</b>.</p>
<p id="p-0140" num="0139">Then (step <b>1568</b>), the IPSOE <b>1592</b> accesses the WQE <b>1560</b>. If the WQ <b>1564</b> is a RDMA (including iSCSI-R) WQ, then each Data Segment referenced in WQE <b>1560</b> is validated. The validation includes the following checks: a) the Valid Entry field is set; b) the Entry Type for the entry is set to region (i.e. windows cannot be used for local access); c) the PD (protection domain) in the QP context associated with WQ <b>1564</b> matches the PD of Memory Region Entry <b>1570</b> referenced by the Data Segment's STag; d) the portion of the Data Segment's STag that is the Tag_Instance matches Tag_Instance in the MRE <b>1570</b>; e) the base address and length of the Data Segment is within the range of addresses associated with the MRE <b>1570</b>; f) the type of access is valid (SQ RDMA Write and Send WRs, require local read access; and RQ WRs require local write access); and g) for SQ Bind WR, the MRE <b>1570</b> being bound to the memory window has window access enabled. Note: if the WR is a SQ Bind WR and it requests that one touch access be set for the associated Window, then the one touch access bit will be set when the IPSOE creates the associated Window.</p>
<p id="p-0141" num="0140">If the WQ, is a iSCSI 1.0 WQE, then the STag provided in the WQE is used to create an iSCSI Memory Region from the list of Data Segments provided in the WQE. iSCSI 1.0 Memory Regions are referenced from a zero base, because they do not have a virtual address field.</p>
<p id="p-0142" num="0141">If the Data Segment provided by the Consumer is valid, then the associated Memory Region is accessed and the WQE is processed. Upon good completion a CQE is returned through the CQ associated with the WQ.</p>
<p id="p-0143" num="0142">Next (step <b>1576</b>), If any of the Data Segments are invalid, then the associated Memory Region is not accessed and an error is returned through a CQE <b>1580</b> on the CQ <b>1584</b> associated with the WQ <b>1564</b>.</p>
<p id="p-0144" num="0143">Finally, in step <b>1588</b>, Consumer <b>1540</b> retrieves a WC for the WR submitted in step <b>1552</b>.</p>
<p id="p-0145" num="0144">We now turn to <figref idref="DRAWINGS">FIG. 16</figref>, which is a flowchart and diagram representation of the process used to distinguish between the different types of streams that can be associated with a remote operation.</p>
<p id="p-0146" num="0145">The IPSOE receives an incoming TCP/IP Segment <b>1600</b>.</p>
<p id="p-0147" num="0146">In step <b>1604</b>, The IPSOE uses well-known TCP/IP/Ethernet validation mechanisms to validate an incoming TCP Segment <b>1604</b>. In step <b>1608</b>, IPSOE checks if an error was encountered during TCP/IP Segment validation. If incoming TCP/IP Segment is valid, the process continues to step <b>1612</b>. Otherwise <b>1616</b> the segment is dropped and the process continues waiting for TCP/IP Segment (step <b>1616</b>).</p>
<p id="p-0148" num="0147">In step <b>1612</b>, after the validation process is completed, the TCP/IP quintuple (Transport Type, Destination TCP Port Number, Source TCP Port Number, Destination IP Address, and Source IP Address) of the incoming TCP Segment is used to access the QP Context associated with the incoming TCP Segment.</p>
<p id="p-0149" num="0148">In step <b>1620</b>, if no QP Context exists for the incoming TCP Segment, then the Consumer is not using any of the IPSOE's TCP/IP Offload mechanisms and the incoming TCP Segment is passed up to the Consumer through well-known traditional NIC mechanisms.</p>
<p id="p-0150" num="0149">In step <b>1624</b>, If the incoming TCP Segment references a iSCSI 1.0 QP Context, then the processing described in <figref idref="DRAWINGS">FIG. 17</figref> is performed on the incoming TCP Segment.</p>
<p id="p-0151" num="0150">In step <b>1630</b>, If the incoming TCP Segment references a RDMA (including iSCSI-R) QP Context, then Marker with PDU Alignment (MPA) mechanism is used to by the IPSOE to retrieve a DDP Segment and its associated DDP Header and the processing described in <figref idref="DRAWINGS">FIGS. 18A-18B</figref> is performed on the incoming TCP Segment.</p>
<p id="p-0152" num="0151"><figref idref="DRAWINGS">FIG. 17A</figref> is a flowchart and diagram illustrating the Memory Registration and Deregistration mechanisms associated with an iSCSI QP in accordance with a preferred embodiment of the present invention. <figref idref="DRAWINGS">FIG. 17</figref><i>a </i>shows the memory management functions associated with a QP that has been initialized in iSCSI mode, such as QP Context <b>1706</b> in IPSOE <b>1708</b>.</p>
<p id="p-0153" num="0152">In step <b>1704</b>, when Consumer <b>1702</b> (which is typically an iSCSI Device Driver running in the host CPU's Operating System Kernel) initializes QP Context <b>1706</b>, Consumer <b>1702</b> sets the mode of the QP to iSCSI 1.0. When a QP Context has been initialized in iSCSI mode, the Work Request posted to the QP's Send Queue, such as SQ <b>1728</b>, contains the iSCSI Command and a list of Data Transfer Data Segments associated with the SCSI Command. The IPSOE will follow the flowchart described in <figref idref="DRAWINGS">FIG. 17A</figref> to: create (register) a Memory TPT entry for the iSCSI Command and the Data Transfer Data Segments associated with the iSCSI Command; issue the iSCSI Command to the Target; perform the data transfer associated with the iSCSI Command (<figref idref="DRAWINGS">FIG. 17B</figref>) and upon reception of the iSCSI Response destroy the iSCSI Command's Memory TPT entry (deregister) and create a WC containing the iSCSI Response.</p>
<p id="p-0154" num="0153">Before Consumer <b>1702</b> can send an iSCSI Command to the Target, Consumer <b>1702</b> must create a RQ WQE to receive the iSCSI Response. In step <b>1710</b>, Consumer <b>1702</b> passes a RQ WR to IPSOE <b>1708</b> for the iSCSI Response that will be associated with an iSCSI Command. The Verbs interface, in step <b>1712</b>, validates the RQ WR and if valid the Verbs interfaces creates a RQ WQE <b>1714</b> from the WR, places RQ WQE <b>1714</b> in the associated RQ <b>1716</b>, and immediately returns to the Consumer <b>1702</b>. If the WR is not valid, the Verbs interface returns an error to the Consumer <b>1702</b>.</p>
<p id="p-0155" num="0154">In step <b>1720</b>, Consumer <b>1702</b> then requests the IPSOE <b>1708</b> to perform an iSCSI Command by passing a SQ WR to the IPSOE containing the iSCSI Command and the Data Transfer Data Segments associated with the iSCSI Command. The Verbs interface, in step <b>1732</b>, validates the SQ WR and if valid the Verbs interfaces creates a SQ WQE from the WR, places the SQ WQE <b>1724</b> in the associated SQ <b>1728</b>, and immediately returns an iSCSI Command ID to the Consumer <b>1702</b>. The Command ID is used between the Consumer and the IPSOE to associate the iSCSI Response with the iSCSI Command. If the WR is not valid, the Verbs interface returns an error to the Consumer <b>1702</b>.</p>
<p id="p-0156" num="0155">When IPSOE <b>1708</b>'s SQ <b>1728</b> processes iSCSI Command SQ WQE <b>1724</b>, it validates the WQE. In step <b>1736</b>, if the QP is initialized to iSCSI mode, the iSCSI Command is valid for the type of device it will be sent to, and the Data Transfer Data Segments associated with the iSCSI Command are valid (e.g. they do not wrap), and there is enough space in the Memory TPT for the new entry, then new iSCSI Memory TPT entry <b>1740</b> is created in Memory TPT <b>1744</b>.</p>
<p id="p-0157" num="0156">If iSCSI Command SQ WQE <b>1724</b> encounters an error (e.g. there isn't enough space in the Memory TPT for another entry or the iSCSI Command op-code is invalid for the type of device being referenced), then there are two semantic options for an implementation to take. Option <b>1</b> (step <b>1748</b>) is reactive and presumes that Consumer <b>1702</b> is not keeping track of the Memory TPT space. If an IPSOE implementation uses option <b>1</b>, then the following process is performed: the IPSOE places the QP associated with the SQ in the Send Queue Drained State, stops processing WQEs subsequent to iSCSI Command SQ WQE <b>1724</b> (but continues processing all RQ WQEs, all incoming R2Ts, all preceding SQ WQEs, and other incoming iSCSI Control Messages), generates a completion error CQE <b>1776</b> identifying the error in iSCSI Command SQ WQE <b>1724</b>, places CQE <b>1776</b> in the Completion Queue <b>1772</b>, and returns all subsequent SQ WQEs with a Flush error CQE through CQ <b>1772</b>. Consumer <b>1772</b> can retry the iSCSI Command WR that was completed in error and all subsequent WRs.</p>
<p id="p-0158" num="0157">Option <b>2</b> (step <b>1152</b>) is anticipatory and presumes that Consumer <b>1702</b> is keeping track of the Memory TPT space. That is, the Consumer keeps track of how the Memory TPT space is being used by the IPSOE. Under this option, Consumer <b>1702</b> only issues iSCSI Command WRs that are guaranteed to have enough space in the Memory TPT. If an IPSOE implementation uses option <b>2</b>, then the following process is performed: the IPSOE places the QP associated with the SQ (QP <b>1706</b>) in the Error State, stops processing all local and remote operations, terminates the iSCSI Stream, generates a completion error CQE <b>1776</b> identifying the error in the iSCSI Command SQ WQE, places CQE <b>1776</b> in Completion Queue <b>1772</b>, and returns all other SQ and RQ WQEs with a Flush error CQE through CQ <b>1772</b>.</p>
<p id="p-0159" num="0158">In step <b>1156</b>, when the IPSOE Target Side Processing logic reaches the iSCSI Command SQ WQE, the IPSOE sends the iSCSI Command to the Target.</p>
<p id="p-0160" num="0159">The flowchart in <figref idref="DRAWINGS">FIG. 17B</figref>, which is described below, describes a mechanism used by the IPSOE to perform the data transfer phase of the iSCSI Command in accordance with a preferred embodiment of the present invention.</p>
<p id="p-0161" num="0160">When the Target completes the iSCSI Command, (step <b>1764</b>), the Target sends an iSCSI Response (or, for Device Reads, includes the iSCSI Status in a Data-In Message) to the initiator.</p>
<p id="p-0162" num="0161">In step <b>1768</b>, when the IPSOE receives the iSCSI Response the IPSOE validates that QP Context <b>1706</b> is associated with the stream (e.g., via SCTP) or connection (e.g., via TCP) that received the iSCSI Response. For TCP/IP, the IPSOE performs this step by assuring that the quintuple (Transport Type, Destination Port Number, Source Port Number, Destination IP Address, and Source IP Address) associated with the incoming iSCSI Response matches the quintuple associated with the QP Context. The IPSOE then validates the other iSCSI and TCP fields associated with the iSCSI Response Message (e.g. the Sequence Number in the TCP Segment containing the iSCSI Response matches the next expected Sequence Number stored in the QP). The IPSOE then uses the Tag_Index portion of the iSCSI Initiator Tag to look-up the Memory TPT entry (<b>1740</b>) associated with the iSCSI Response. The IPSOE validates the Tag_Instance portion of the iSCSI Initiator Tag.</p>
<p id="p-0163" num="0162">If the incoming iSCSI Response is valid (including the Tag_Instance portion of the iSCSI Initiator Tag), then IPSOE <b>1708</b>: accesses Memory TPT entry <b>1740</b> to retrieve the Command ID of the iSCSI Command that is associated with the iSCSI Response; retrieves the Command ID from Memory TPT entry <b>1740</b>; destroys (deregisters) Memory TPT entry <b>1740</b>; and places the Command ID and the incoming iSCSI Response into RQ WQE <b>1714</b> of the QP associated with the incoming iSCSI Response. Otherwise IPSOE <b>1708</b> drops the incoming iSCSI Response.</p>
<p id="p-0164" num="0163">Finally, in step <b>12</b> <b>1778</b>, the Consumer <b>1702</b> retrieves the WC containing the iSCSI Command ID and the iSCSI Response. The Consumer <b>1702</b> uses the iSCSI Command ID to associate the iSCSI Response with the iSCSI Command.</p>
<p id="p-0165" num="0164">The mechanism described in <figref idref="DRAWINGS">FIG. 17A</figref> can be applied to a general purpose QP. That is, the memory registration step can be combined with a general purpose WR and the deregistration step can be performed when the remote node sends a message containing the Tag (e.g. Steering Tag) that is to be deregistered.</p>
<p id="p-0166" num="0165"><figref idref="DRAWINGS">FIG. 17B</figref> is a flowchart and diagram representation of a memory management process used to perform the initiator data transfer portion of iSCSI that validates a remote iSCSI 1.0 data transfer (e.g. R2T or Data-In) operation in accordance with a preferred embodiment of the present invention. The implementation described below only covers the data transfer messages. Non-data transfer messages are passed up to the consumer through the iSCSI QP's Receive Queue.</p>
<p id="p-0167" num="0166">In step <b>1796</b>, the Tag_Index portion of the incoming iSCSI Header's Initiator Task Tag is used to validate the incoming DDP Segment. Continue to step B.</p>
<p id="p-0168" num="0167">In step <b>1794</b>, the following checks are performed on the entry that has been indexed by the Tag_Index portion of the incoming iSCSI Header's Initiator Task Tag: a) the Valid Entry field is set; b) the Entry Type for the entry is set to iSCSI 1.0 (i.e. Regions or Windows cannot be used for iSCSI 1.0); c) the PD in the QP context associated with the incoming TCP Segment matches the PD of the Memory TPT Entry; d) the portion of the iSCSI 1.0 Header's Initiator Task Tag that is the Tag_Instance matches Tag_Instance in the Memory TPT Entry; e) the Offset of the incoming iSCSI 1.0 Segment's Header does not exceed the size of Length field stored in the Memory TPT Entry; f) the type of access is valid (e.g. for R2T the Memory TPT Entry has remote read access enabled and for Data-In the Memory TPT Entry has remote write access enabled) and g) the Initiator's iSCSI Command (looked up by using the Virtual Address field of the Memory TPT entry) matches the incoming (Target) iSCSI message's action (i.e. Initiator iSCSI Command is a Disk Write and the incoming iSCSI Message is a R2T or the iSCSI Command is a Disk Read and the incoming iSCSI Message is a Data). If these checks pass, processing continues to step <b>1792</b>. Otherwise the erroneous iSCSI Message is passed to the Consumer through the iSCSI QP's Receive Queue.</p>
<p id="p-0169" num="0168">In step <b>1792</b>, the type of iSCSI message is determined. In step <b>1790</b>, if the incoming iSCSI Header is a R2T, the Target Offset is used to offset into the buffer pointed to by the Tag Index portion of the Initiator Task Tag and the contents of the buffer, up to the length specified in the iSCSI header is transferred to the remote node. The iSCSI Header's control information is passed to the Consumer through the iSCSI QP's Receive Queue.</p>
<p id="p-0170" num="0169">In step <b>1788</b>, if the incoming iSCSI Header is a Data-in Transfer, the Target Offset is used to offset into the buffer pointed to by the Tag Index portion of the Initiator Task Tag and the contents of the buffer, up to the length specified in the iSCSI Header is transferred to the remote node. The iSCSI Header's control information is passed to the Consumer through the iSCSI QP's Receive Queue.</p>
<p id="p-0171" num="0170">In step <b>1786</b>, if the incoming iSCSI Header is something other than a Data-in or R2T Transfer, the entire iSCSI message (control information and any data) is passed to the Consumer through the iSCSI QP's Receive Queue.</p>
<p id="p-0172" num="0171"><figref idref="DRAWINGS">FIGS. 18A-18B</figref> are a flowchart and diagram representation of a memory management process used in accordance with a preferred embodiment of the present invention: to provide a one touch access mechanism with the deregistration function unexposed to the remote node; and to validate the memory access associated with a remote RDMA Read Request, RDMA Read Response, and RDMA Write operation. RDMA Read Requests reference a DDP Untagged Buffer. RDMA Read Response or RDMA Write reference a DDP Tagged Buffer. It should be noted that RDMA Send Message processing is described in <figref idref="DRAWINGS">FIG. 11</figref>.</p>
<p id="p-0173" num="0172">For RDMA Read Request <b>1800</b>, if the incoming DDP Segment's Header references an Untagged Buffer with Buffer Number 2, then the incoming DDP Header's Message Sequence Number (MSN) is used to index into the RDMA Read Resource Queue. This corresponds to step <b>1804</b>.</p>
<p id="p-0174" num="0173">To index into the RDMA Read Request Queue the IPSOE maintains a next expected MSN. In step <b>1806</b>, if the incoming DDP Header's MSN is the next expected MSN or corresponds to the MSN that would be associated with an available RDMA Read Request Queue Entry, then the incoming DDP Segment's payload (i.e. the RDMA Read Request) is placed in the RDMA Read Request Queue Entry referenced by the incoming DDP Header's MSN. Otherwise the RDMA Stream termination process is invoked by the IPSOE. The RDMA Stream termination process consists of creating a Terminate RDMA Message that contains the cause of the termination, sending the Terminate RDMA Message to the other side of the RDMA Stream, and then tearing down the RDMA Stream (e.g. by tearing down the TCP Connection).</p>
<p id="p-0175" num="0174">In step <b>1808</b>, the Tag_Index portion of the incoming RDMA Read Request Header's Source STag is used to validate the incoming RDMA Read Request.</p>
<p id="p-0176" num="0175">In step <b>1812</b>, the following checks are then performed on the entry that has been indexed by the Tag_Index portion of the incoming RDMA Read Request Header's Source STag: a) the Valid Entry field is set; b) the Entry Type for the entry is set to window (i.e. regions cannot be used for remote access); c) the PD in the QP context associated with the incoming TCP Segment matches the PD of the Memory Window Entry; d) the portion of the DDP Header's STag that is the Tag_Instance matches Tag_Instance in the MWE; e) the base address (Target Offset) and length (MPA Header Length) of the incoming DDP Segment is within the range of addresses associated with the MWE; and f) the type of access is valid (i.e. the MWE has remote read access enabled).</p>
<p id="p-0177" num="0176">If all the checks pass, the IPSOE creates the RDMA Read Responses by reading the Memory Window referenced by the RDMA Read Request and issuing the RDMA Read Responses. Otherwise a Terminate Message is generated describing the cause of the error.</p>
<p id="p-0178" num="0177">For RDMA Read Response or RDMA Write <b>1814</b>, in step <b>1816</b>, if the incoming DDP Segment's Header references a Tagged Buffer, then the Tag_Index portion of the DDP Header's STag is used to index into the Memory Region/Window Table.</p>
<p id="p-0179" num="0178">In step <b>1820</b>, the following checks are performed on the entry that has been indexed by the Tag_Index portion of the incoming DDP Header's STag: a) the Valid Entry field is set; b) the Entry Type for the entry is set to window (i.e. regions cannot be used for remote access); c) the PD in the QP context associated with the incoming TCP Segment matches the PD of the Memory Window Entry; d) the portion of the DDP Header's STag that is the Tag_Instance matches Tag_Instance in the MWE; e) the base address (Target Offset) and length (MPA Header Length) of the incoming DDP Segment is within the range of addresses associated with the MWE; and f) the type of access is valid (i.e. the MWE has remote write access enabled). If all the checks pass, then processing continues to step <b>1824</b>, otherwise a Terminate Message is generated describing the cause of the error.</p>
<p id="p-0180" num="0179">In step <b>1824</b>, the following fields are checked: the DDP standard's Last bit in the incoming DDP Header (if set it indicates the incoming DDP Segment is the last DDP Segment of a RDMA Message); the One Touch Enabled bit stored in the Memory TPT entry referenced by the STag; the Touched bit stored in the Memory TPT entry referenced by the STag; Stored DDP (Byte Stream) Sequence Number stored in the Memory TPT entry referenced by the STag; the underlying TCP Byte Sequence Number; and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number. In step <b>1828</b>, the following set of checks is performed against the above-listed fields.</p>
<p id="p-0181" num="0180">If the Last bit is not set, then the incoming DDP Header's Target Offset field is used to index into the Memory Region/Window referenced by the Memory TPT entry and the incoming DDP Segment's payload is transferred into the Memory Region/Window (starting at the TO).</p>
<p id="p-0182" num="0181">If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit reset, then the incoming DDP Header's Target Offset field is used to index into the Memory Region/Window referenced by the Memory TPT entry and the incoming DDP Segment's payload is transferred into the Memory Region/Window (starting at the TO).</p>
<p id="p-0183" num="0182">If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is also set, then the Memory TPT entry's Valid Entry bit is reset and a Terminate Message is generated describing the cause of the error (e.g. two access attempted on a One Touch Region/Window).</p>
<p id="p-0184" num="0183">If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is not set and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number is equal to the Next Expected TCP Byte Sequence Number minus 1, then the Memory TPT entry's Valid Entry bit is reset and the incoming DDP Header's Target Offset field is used to index into the Memory Region/Window referenced by the Memory TPT entry and the incoming DDP Segment's payload is transferred into the Memory Region/Window (starting at the TO). This covers the case where the Incoming DDP Segment is the last segment of a Tagged Buffer Message and is received in order.</p>
<p id="p-0185" num="0184">If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is not set and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number is within the TCP Byte Sequence Number Window, but is not the Next Expected TCP Byte Sequence Number minus 1, then the Memory TPT entry's Touched bit is set, the (Byte Stream) Sequence Number associated with the Last Byte of the incoming DDP Segment's payload is stored in the Memory TPT entry's DDP Sequence Number field, and the incoming DDP Segment's payload is transferred into the Memory Region/Window (starting at the TO). When the incoming byte stream lines up with the end of the Memory TPT entry's DDP Sequence Number field, the Memory TPT's Valid Entry field is reset. This covers the case where the Incoming DDP Segment is the last segment of a Tagged Buffer Message and is received out of order.</p>
<p id="p-0186" num="0185">If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is not set and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number is outside of the TCP Byte Sequence Number Window, then the Incoming DDP Segment is dropped (the sender will resend).</p>
<p id="p-0187" num="0186">It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions or other functional descriptive material and in a variety of other forms and that the present invention is equally applicable regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system. Functional descriptive material is information that imparts functionality to a machine. Functional descriptive material includes, but is not limited to, computer programs, instructions, rules, facts, definitions of computable functions, objects, and data structures.</p>
<p id="p-0188" num="0187">The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprising:
<claim-text>receiving a work request in an Internet protocol suite offload engine from a host, wherein the Internet protocol suite offload engine is embodied in hardware coupled to the host;</claim-text>
<claim-text>in response to receiving the work request, registering in a translation table a memory region associated with the host, wherein the hardware maintains sequence numbers and acknowledges all frame transfers, and wherein paths used by the work request and a corresponding positive acknowledgement of the work request are asymmetric;</claim-text>
<claim-text>translating, in the Internet protocol suite offload engine, a virtual address to a physical address associated with the memory region;</claim-text>
<claim-text>validating, in the Internet protocol suite offload engine, the virtual address;</claim-text>
<claim-text>accessing data associated with the virtual address;</claim-text>
<claim-text>generating a tag associated with the memory region;</claim-text>
<claim-text>in response to registering the memory region returning the tag to the host wherein the tag is associated with the memory region;</claim-text>
<claim-text>performing an input/output transaction over a connection protocol in a network with a remote node using the tag to refer to the memory region wherein in the input/output transaction data is transferred using direct access to the memory region;</claim-text>
<claim-text>wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol and the method further includes:</claim-text>
<claim-text>receiving an incoming transaction send message in the upper level protocol, wherein the transaction send message includes a request to deregister a tag associated with the memory region; and</claim-text>
<claim-text>in response to receiving the send message deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the work request includes memory protection information associated with the memory region and the method further includes: storing the memory protection information in the translation table.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the work request is received through a send queue.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the tag includes an index into the translation table.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising: in response to registering the memory region, placing a completion queue element on a completion queue.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the work request includes Internet Small Computer Systems Interface command.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the memory region is registered in response to processing an Internet Small Computer Systems Interface command and the method further includes:
<claim-text>performing a transaction in fulfillment of the Internet Small Computer Systems Interface command;</claim-text>
<claim-text>receiving an Internet Small Computer Systems Interface response associated with the transaction; and</claim-text>
<claim-text>in response to receiving the Internet Small Computer Systems Interface response, deregistering the memory region associated with the Internet Small Computer Systems Interface transaction.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the connection protocol is transmission control protocol (TCP).</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising: establishing data representing a setting associated with the memory region, wherein the setting indicates that the memory region is configured to be valid for a single access by a remote node, such that the memory region will be invalidated in response to the memory region being accessed in fulfillment of a valid, incoming remote operation.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method comprising:
<claim-text>placing a work request on a send queue in an Internet protocol suite offload engine, wherein the work request contains an identification of a memory region to be registered with the Internet protocol suite offload engine, wherein the Internet protocol suite offload engine is embodied in hardware coupled to the host, wherein the hardware maintains sequence numbers and acknowledges all frame transfers, and wherein paths used by the work request and a corresponding positive acknowledgement of the work request are asymmetric;</claim-text>
<claim-text>generating a tag associated with the memory region;</claim-text>
<claim-text>receiving from the Internet protocol suite offload engine the tag associated with the memory region as registered;</claim-text>
<claim-text>in response to registering the memory region, returning the tag to the host wherein the tams associated with the memory regions;</claim-text>
<claim-text>performing an input/output transaction over a connection protocol in a network with a remote node using the tag to refer to the memory region, wherein in the input/output transaction data is transferred using direct access to the memory region;</claim-text>
<claim-text>wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol and the method further includes:</claim-text>
<claim-text>receiving an incoming transaction send message in the upper level protocol, wherein the transaction send message includes a request to deregister a tag associated with the memory region; and</claim-text>
<claim-text>in response to receiving the send message, deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A method comprising:
<claim-text>registering a memory region in an Internet protocol suite offload engine for transactional use with respect to a remote node, wherein the Internet protocol suite offload engine is embodied in hardware coupled to the host, wherein the hardware maintains sequence numbers and acknowledges all frame transfers, and wherein paths used by a work request and a corresponding positive acknowledgement of the work request are asymmetric;</claim-text>
<claim-text>performing a single transaction with the remote node with respect to the memory region, wherein the single transaction comprises the work request;</claim-text>
<claim-text>in response to performing the single transaction, deregistering the memory region;</claim-text>
<claim-text>generating a tag associated with the memory region;</claim-text>
<claim-text>in response to registering the memory region, returning the tag to the host wherein the tag is associated with the memory region;</claim-text>
<claim-text>performing an input/output transaction over a connection protocol in a network with a remote node using the tag to refer to the memory region wherein in the input/output transaction data is transferred using direct access to the memory region;</claim-text>
<claim-text>wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol and the method further includes:</claim-text>
<claim-text>receiving an incoming transaction send message in the upper level protocol wherein the transaction send message includes a request to deregister a tag associated with the memory region; and</claim-text>
<claim-text>in response to receiving the send message deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A computer program product in at least one computer-readable media include recordable-type media comprising functional descriptive material that, when executed by a computer, enables the computer to perform acts including:
<claim-text>receiving a work request in an Internet protocol suite offload engine from a host, wherein the Internet protocol suite offload engine is embodied in hardware coupled to the host;</claim-text>
<claim-text>in response to receiving the work request, registering in a translation table a memory region associated with the host, wherein the hardware maintains sequence numbers and acknowledges all frame transfers, and wherein paths used by the work request and a corresponding positive acknowledgement of the work request are asymmetric;</claim-text>
<claim-text>translating, in the Internet protocol suite offload engine, a virtual address to a physical address associated with the memory region;</claim-text>
<claim-text>validating, in the Internet protocol suite offload engine, the virtual address;</claim-text>
<claim-text>accessing data associated with the virtual address;</claim-text>
<claim-text>generating a tag associated with the memory region;</claim-text>
<claim-text>in response to registering the memory region, returning the tag to the host, wherein the tag associated with the memory region:</claim-text>
<claim-text>performing an input/output transaction over a connection protocol in a network with a remote node using he tag to refer to the memory region, wherein in the input/output transaction data is transferred using direct access to the memory region;</claim-text>
<claim-text>wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol and the method further includes:</claim-text>
<claim-text>receiving an incoming transaction send message in the upper level protocol wherein the transaction send message includes a request to deregister a tag associated with the memory region; and</claim-text>
<claim-text>in response to receiving the send message, deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computer program product of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the work request includes memory protection information associated with the memory region and the computer program product includes additional functional descriptive material that, when executed by the computer, enables the computer to perform additional acts including: storing the memory protection information in the translation table.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer program product of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the work request is received through a send queue.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer program product of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the tag includes an index into the translation table.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer program product of <claim-ref idref="CLM-00012">claim 12</claim-ref>, comprising additional functional descriptive material that, when executed by the computer, enables the computer to perform additional acts including: in response to registering the memory region, placing a completion queue element on a completion queue.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer program product of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the work request includes an Internet Small Computer Systems Interface command.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer program product of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the memory region is registered in response to processing an Internet Small Computer Systems Interface command and the computer program product includes additional functional descriptive material that, when executed by the computer, enables the computer to perform additional acts including:
<claim-text>performing a transaction in fulfillment of the Internet Small Computer Systems Interlace command;</claim-text>
<claim-text>receiving an Internet Small Computer Systems Interface response associated with the transaction; and</claim-text>
<claim-text>in response to receiving the Internet Small Computer Systems Interface response, deregistering the memory region.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer program product of <claim-ref idref="CLM-00012">claim 12</claim-ref>, comprising additional functional descriptive material that, when executed by the computer, enables the computer to perform additional acts including: establishing data representing a setting associated with the memory region, wherein the setting indicates that the memory region is configured to be valid for a single access by a remote node, such that the memory region will be invalidated in response to the memory region being accessed in fulfillment of a valid, incoming remote operation.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer program product of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol, and the computer program product includes additional functional descriptive material that, when executed by the computer, enables the computer to perform additional acts including:
<claim-text>receiving an incoming transaction send message in the upper level protocol, wherein the transaction send message includes a request to deregister a tag associated with the memory region; and</claim-text>
<claim-text>in response to receiving the send message, deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. A computer program product in at least one computer-readable medium include recordable-type media comprising functional descriptive material that, when executed by a computer, enables the computer to perform acts including:
<claim-text>placing a work request on a send queue in an Internet protocol suite off load engine, wherein the work request contains an identification of a memory region to be registered with the Internet protocol suite offload engine, wherein the Internet protocol suite offload engine is embodied in hardware coupled to the host, wherein the hardware maintains sequence numbers and acknowledges all frame transfers, and wherein paths used by the work request and a corresponding positive acknowledgement of the work request are asymmetric;</claim-text>
<claim-text>generating a tag associated with the memory region;</claim-text>
<claim-text>receiving from the Internet protocol suite offload engine the tag associated with the memory region as registered;</claim-text>
<claim-text>in response to registering the memory region, returning the tams to the host, wherein the tag is associated with the memory region;</claim-text>
<claim-text>performing an input/output transaction over a connection protocol in a network with a remote node using the tag to refer to the memory region, wherein in the input/output transaction data is transferred using direct access to the memory region;</claim-text>
<claim-text>wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol and the method further includes:</claim-text>
<claim-text>receiving an incoming transaction send message in the upper level protocol, wherein the transaction send message includes a request to deregister a tag associated with the memory region; and</claim-text>
<claim-text>in response to receiving the send message, deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A computer program product in at least one computer-readable medium include recordable-type media comprising functional descriptive material that, when executed by a computer, enables the computer to perform acts including:
<claim-text>registering a memory region in an Internet protocol suite offload engine for transactional use with respect to a remote node, wherein the Internet protocol suite offload engine is embodied in hardware coupled to the host, wherein the hardware maintains sequence numbers and acknowledges all frame transfers, and wherein paths used by the work request and a corresponding positive acknowledgement of the work request are asymmetric;</claim-text>
<claim-text>performing a single transaction with the remote node with respect to the memory region, wherein the single transaction comprises the work request;</claim-text>
<claim-text>in response to performing the single transaction, deregistering the memory region request are asymmetric;</claim-text>
<claim-text>generating a tag associated with the memory region;</claim-text>
<claim-text>in response to registering the memory region returning the tag, to the host wherein the tag is associated with the memory region;</claim-text>
<claim-text>performing an input/output transaction over a connection protocol in a network with a remote node using the tag to refer to the memory region wherein in the input/output transaction data is transferred using direct access to the memory region;</claim-text>
<claim-text>wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol and the method further includes:</claim-text>
<claim-text>receiving an incoming transaction send message in the upper level protocol wherein the transaction send message includes a request to deregister a tag associated with the memory region; and</claim-text>
<claim-text>in response to receiving the send message, deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. A host data processing system comprising:
<claim-text>means for placing a work request on a send queue in an Internet protocol suite offload engine associated with the host, wherein the work request contains an identification of a memory region to be registered with the Internet protocol suite offload engine, wherein the Internet protocol suite offload engine is embodied in hardware coupled to the host, wherein the hardware maintains sequence numbers and acknowledges all frame transfers, and wherein paths used by the work request and a corresponding positive acknowledgement of the work request are asymmetric;</claim-text>
<claim-text>means for receiving from the Internet protocol suite offload engine a tag associated with the memory region as registered;</claim-text>
<claim-text>request are asymmetric;</claim-text>
<claim-text>means for generating a tag associated with the memory region;</claim-text>
<claim-text>means for, in response to registering the memory region returning the tag to the host, wherein the tag is associated with the memory region;</claim-text>
<claim-text>means for performing an input/output transaction over a connection protocol in a network with a remote node using the tag to refer to the memory region wherein in the input/output transaction data is transferred using direct access to the memory region;</claim-text>
<claim-text>wherein the memory region is registered in response to processing a combined register memory region and send work request associated with a transaction in an upper level protocol and the host data processing system further includes:</claim-text>
<claim-text>means for receiving an incoming transaction send message in the upper level protocol, wherein the transaction send message includes a request to deregister a tag-associated with the memory region; and</claim-text>
<claim-text>means for, in response to receiving the send message deregistering the memory region associated with the tag.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The Internet protocol suite offload engine of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein the tag includes an index into the translation table.</claim-text>
</claim>
</claims>
</us-patent-grant>
