<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299213-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299213</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11225251</doc-number>
<date>20050912</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>18</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>706 12</main-classification>
<further-classification>706 14</further-classification>
<further-classification>706 46</further-classification>
</classification-national>
<invention-title id="d0e43">Method of using kernel alignment to extract significant features from a large dataset</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5587922</doc-number>
<kind>A</kind>
<name>Hendrickson et al.</name>
<date>19961200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5747810</doc-number>
<kind>A</kind>
<name>Schotland</name>
<date>19980500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5758653</doc-number>
<kind>A</kind>
<name>Schotland</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5762607</doc-number>
<kind>A</kind>
<name>Schotland</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5787888</doc-number>
<kind>A</kind>
<name>Schotland</name>
<date>19980800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6038197</doc-number>
<kind>A</kind>
<name>Sitton et al.</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6128608</doc-number>
<kind>A</kind>
<name>Barnhill</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6157921</doc-number>
<kind>A</kind>
<name>Barnhill</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6427141</doc-number>
<kind>B1</kind>
<name>Barnhill</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6658395</doc-number>
<kind>B1</kind>
<name>Barnhill</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6714925</doc-number>
<kind>B1</kind>
<name>Barnhill et al.</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6760715</doc-number>
<kind>B1</kind>
<name>Barnhill et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6789069</doc-number>
<kind>B1</kind>
<name>Barnhill et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6882990</doc-number>
<kind>B1</kind>
<name>Barnhill et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6944602</doc-number>
<kind>B2</kind>
<name>Cristianini</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00016">
<othercit>Nello Cristianini et al, An Introduction to Support Vector Machines, Mar. 2000, University of Cambridge, Cover and title page.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>Nello Cristianini et al, On Kernel-Target Alignment, Dec. 2001, MIT Press, 7.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>Nello Cristianini, Spectral Kernel Methods for Clustering, Dec. 2001, MIT Press, 7.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>Fernando Perez-Cruz et al, Kernel Methods and their Potential Use in Signal Processing, 2004, IEEE, 1-19.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00020">
<othercit>Gang Wu et al, KBA: Kernel Boundary Alignment Considering Imbalanced Data Distribution, 2005, IEEE, 1-13.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00021">
<othercit>Nello Cristianini et al., An Introduction to Support Vector Machines and Other Kernel Based Learning Methods, Cambridge, 1997, 93, 94.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00022">
<othercit>F.R.K. Chung, et al., “A Near Optimum Algorithm for Edge Spearators (Preliminary Version)”, 1994, ACM, 0-89791-663-8/94/0005.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00023">
<othercit>Fan R.K. Chung, <i>Spectral Graph Theory</i>, 1997, AMS, ISBN 0-821-80315-8 (review only).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00024">
<othercit>X. S. Zhou, “Comparing Discriminating Transformations and SVM for Learning during Multimedia Retrieval”, 2001, ACM 1-581 13-394-4/01/0009 pp. 137-145.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00025">
<othercit>M. Meilå, “Data Centering in Feature Space”, 9<sup>th </sup><i>International Workshop on Artificial Intelligence and Statistics</i>, Jan. 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00026">
<othercit>N. Cristianini, et al., “Spectral Kernel Methods for Clustering”, Poster Presentation, <i>Advances in Neural Information Processing Systems 2001 </i>(“<i>NIPS01</i>”), MIT Press, Dec. 3-8, 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00027">
<othercit>N. Cristianini, et al., “On Kernel-Target Alignment”, Spotlight Presentation, <i>Advances in Neural Information Processing Systems 2001 </i>(“<i>NIPS01</i>”), MIT Press, Dec. 3-8, 2001.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00028">
<othercit>G. Wu &amp; E.Y. Chang, “Class-Boundary Alignment for Imbalanced Dataset Learning”, <i>Workshop on Learning from Imbalanced Datasets II, ICML</i>, Washington, D.C., 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00029">
<othercit>F. Peréz-Cruz &amp; O. Bousquet, “Kernel Methods and their Potential Use in Signal Processing”, <i>IEEE Signal Processing Magazine</i>, (2004) 21:3, pp. 57-65.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00030">
<othercit>X. Zhu, et al., “Nonparametric Transforms of Graph Kernels for Semi-Supervised Learning”, <i>Advances in Neural Information Processing Systems 2004 </i>(“<i>NIPS04”</i>), MIT Press, 2005.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00031">
<othercit>G.G. Wu &amp; E.Y. Chang, “KBA: Kernel boundary Alignment Considering Imbalanced Data Distribution”, <i>IEEE Transactions on Knowledge and Data Engineering </i>(2005) 17:6, pp. 786-795.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>15</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>706 12</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>706 14</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>706 46</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>10087145</doc-number>
<kind>00</kind>
<date>20020301</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>6944602</doc-number>
<kind>A </kind>
<date>20050913</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>11225251</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60272391</doc-number>
<kind>00</kind>
<date>20010301</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20060074821</doc-number>
<kind>A1</kind>
<date>20060406</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Cristianini</last-name>
<first-name>Nello</first-name>
<address>
<city>Berkeley</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Musick</last-name>
<first-name>Eleanor M.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Procopio, Cory, Hargreaves &amp; Savitch LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Health Discovery Corporation</orgname>
<role>02</role>
<address>
<city>Savannah</city>
<state>GA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Hirl</last-name>
<first-name>Joseph P</first-name>
<department>2129</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The spectral kernel machine combines kernel functions and spectral graph theory for solving problems of machine learning. The data points in the dataset are placed in the form of a matrix known as a kernel matrix, or Gram matrix, containing all pairwise kernels between the data points. The dataset is regarded as nodes of a fully connected graph. A weight equal to the kernel between the two nodes is assigned to each edge of the graph. The adjacency matrix of the graph is equivalent to the kernel matrix, also known as the Gram matrix. The eigenvectors and their corresponding eigenvalues provide information about the properties of the graph, and thus, the dataset. The second eigenvector can be thresholded to approximate the class assignment of graph nodes. Eigenvectors of the kernel matrix may be used to assign unlabeled data to clusters, merge information from labeled and unlabeled data by transduction, provide model selection information for other kernels, detect novelties or anomalies and/or clean data, and perform supervised learning tasks such as classification.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="123.27mm" wi="144.78mm" file="US07299213-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="228.09mm" wi="145.12mm" file="US07299213-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="232.41mm" wi="138.94mm" file="US07299213-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="232.58mm" wi="144.02mm" file="US07299213-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="212.60mm" wi="146.05mm" orientation="landscape" file="US07299213-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application is a continuation of application Ser. No. 10/087,145, filed Mar. 1, 2002, issued Sep. 13, 2005 as U.S. Pat. No. 6,944,602, which claims the benefit of priority of U.S. provisional application Ser. No. 60/272,391, filed Mar. 1, 2001, which is incorporated herein by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates generally to learning machines and more particularly to kernel-based machines for data analysis.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">In recent years, machine-learning approaches for data analysis have been widely explored for recognizing patterns which, in turn, allow extraction of significant features within a large amount of data that often contains irrelevant detail. Learning machines comprise algorithms that may be trained to generalize. Trained learning machine algorithms may then be applied to predict the outcome in cases of unknown outcome. Machine-learning approaches, which include neural networks, hidden Markov models, belief networks, support vector and other kernel-based machines, are ideally suited for domains characterized by the existence of large amounts of data, noisy patterns and the absence of general theories.</p>
<p id="p-0005" num="0004">To date, the majority of learning machines that have been applied to data analysis are neural networks trained using back-propagation, a gradient-based method in which errors in classification of training data are propagated backwards through the network to adjust the bias weights of the network elements until the mean squared error is minimized. A significant drawback of back-propagation neural networks is that the empirical risk function may have many local minima, a case that can easily obscure the optimal solution from discovery. Standard optimization procedures employed by back-propagation neural networks may converge to a minimum, but the neural network method cannot guarantee that even a localized minimum is attained, much less the desired global minimum. The quality of the solution obtained from a neural network depends on many factors. In particular, the skill of the practitioner implementing the neural network determines the ultimate benefit, but even factors as seemingly benign as the random selection of initial weights can lead to poor results. Furthermore, the convergence of the gradient-based method used in neural network learning is inherently slow. A further drawback is that the sigmoid function has a scaling factor, which affects the quality of approximation. Possibly the largest limiting factor of neural networks as related to knowledge discovery is the “curse of dimensionality” associated with the disproportionate growth in required computational time and power for each additional feature or dimension in the training data.</p>
<p id="p-0006" num="0005">Kernel methods, based on statistical learning theory, are used for their conceptual simplicity as well as their remarkable performance. Support vector machines, kernel PCA (principal component analysis), kernel Gram-Schmidt, kernel Fischer discriminant, Bayes point machines, and Gaussian processes are just a few of the algorithms that make use of kernels for problems of classification, regression, density estimation and clustering. Kernel machines can operate in extremely rich feature spaces with low computational cost, in some cases accessing spaces that would be inaccessible to standard systems, e.g., gradient-based neural networks, due to their high dimensionality.</p>
<p id="p-0007" num="0006">Kernel methods operate by mapping data into a high dimensional feature space then applying one of many available general-purpose algorithms suitable for work in conjunction with kernels. Put simply, the kernel virtually maps data into a feature space so that the relative positions of the data in feature space can be used as the means for evaluating, e.g., classifying, the data. The degree of clustering achieved in the feature space, and the relation between the clusters and the labeling to be learned, should be captured by the kernel.</p>
<p id="p-0008" num="0007">Kernel methods exploit information about pairwise similarity between data points. “Similarity” is defined as the inner product between two points in a suitable feature space, information that can be obtained with little computational cost. The mapping into feature space is achieved in an implicit way: the algorithms are rewritten to need only inner product information between input points. The inner product is then replaced with a generalized inner product, or “kernel function”. This function returns the value of an inner product between feature vectors representing images of the inputs in some feature space.</p>
<p id="p-0009" num="0008">While the learning module is general purpose, the kernel is problem specific. It is the kernel that makes it possible to effectively work in very rich feature spaces, provided the inner products can be computed. By developing algorithms that use only the inner products, it is possible to avoid the need to compute the feature vector for a given input. One of the key advantages to this approach is its modularity: the decoupling of algorithm design and statistical analysis from the problem of creating appropriate function/feature spaces for a particular application.</p>
<p id="p-0010" num="0009">Defining the appropriate kernel function allows one to use a range of different algorithms to analyze the data while, at the same time, avoiding many practical prediction problems. It is crucial for the performance of a system that the kernel function fits the learning target in some way, i.e., that in the feature space, the data distribution is somehow correlated to the label distribution. Measuring the similarity between two kernels, or the degree of agreement between a kernel and a given target function is, therefore, an important problem.</p>
<p id="p-0011" num="0010">For a given application, selection of a kernel corresponds to implicitly choosing a feature space since the kernel function is defined by
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>k</i>(<i>x,z</i>)=&lt;φ(<i>x</i>),φ(<i>z</i>)&gt;  (1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
for the feature map φ. Given a training set S={x<sub>1</sub>, x<sub>2 </sub>. . . x<sub>m</sub>}, the information available to kernel-based algorithms is contained entirely in the matrix of inner products
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>G=K</i>=(<i>k</i>(<i>x</i><sub>i</sub><i>,x</i><sub>j</sub>))<sub>i,j−1</sub><sup>m</sup>,  (2)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
known as the Gram matrix G or the kernel matrix K. This matrix encodes the similarity level between all pairs of data items induced by the kernel.
</p>
<p id="p-0012" num="0011">Kernels can be used without actually having the feature space F implicitly defined, as long as one can guarantee that such extra space exists, i.e., that the kernel can actually be regarded as an inner product of some space.</p>
<p id="p-0013" num="0012">It is possible to characterize the kernel in many ways. One of the simplest is that a function k(x,z) is a valid kernel if and only if it always produces symmetric and positive definite Gram matrices for any finite set of data. Given an explicit feature map φ, Equation 1, above, can be used to compute the corresponding kernel. Often, however, methods are sought to directly provide the value of the kernel without explicitly computing φ. This enables one to use extremely rich features spaces, even infinite dimensional, at least from a computational perspective.</p>
<p id="p-0014" num="0013">Starting with kernels K(x,z)=(x,z), one can define more complex kernels, the best known of which is the polynomial kernel. Given a kernel k, the polynomial construction creates a kernel {circumflex over (k)} by applying a polynomial with positive coefficients to k. For example,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>{circumflex over (k)}</i>(<i>x,z</i>)=(<i>k</i>(<i>x,z</i>)+<i>D</i>)<sup>p</sup>,  (3)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
for fixed values of D and integer p. If the features space of k is F, then the feature space of {circumflex over (k)} is indexed by t-tuples of features from F, for t=0, 1 . . . , p. Hence, for a relatively small computational cost, the algorithms can be applied in a feature space of vastly expanded expressive power. Further, the example of the Gaussian kernel <o ostyle="single">k</o> can be considered:
</p>
<p id="p-0015" num="0014">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mrow>
          <mrow>
            <mrow>
              <mover>
                <mi>k</mi>
                <mi>_</mi>
              </mover>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>z</mi>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>=</mo>
            <mrow>
              <mi>exp</mi>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mfrac>
                <mrow>
                  <mrow>
                    <mi>k</mi>
                    <mo>⁡</mo>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mi>x</mi>
                        <mo>,</mo>
                        <mi>x</mi>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <mi>k</mi>
                    <mo>⁡</mo>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mi>z</mi>
                        <mo>,</mo>
                        <mi>z</mi>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mn>2</mn>
                    <mo>⁢</mo>
                    <mrow>
                      <mi>k</mi>
                      <mo>⁡</mo>
                      <mrow>
                        <mo>(</mo>
                        <mrow>
                          <mi>x</mi>
                          <mo>,</mo>
                          <mi>z</mi>
                        </mrow>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                  </mrow>
                </mrow>
                <msup>
                  <mi>σ</mi>
                  <mn>2</mn>
                </msup>
              </mfrac>
            </mrow>
          </mrow>
          <mo>,</mo>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>4</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
with a feature space of infinitely many dimensions. Other kernels include sigmoid, B<sub>n</sub>-spline of odd order, and radial basis function (RBF) kernels, among others.
</p>
<p id="p-0016" num="0015">An important object in machine learning is minimization of expected risk in translating concepts from statistical learning theory into practical algorithms. Whether or not one has knowledge of the test patterns during training makes a significant difference in the design of learning algorithms. The difference is between minimizing test error in a specific test set versus minimizing expected error over all possible test sets. The problem of overall risk minimization is known as “transduction,” where the goal is to directly estimate the values of the unknown function for points of interest from the given data. This can be compared with the classical scheme of first using an inductive step to approximate the function then, using deduction, deriving the values of the given function for the points of interest. In the inductive/deductive method, the structural or specific test risk is minimized. With overall risk minimization provided by transduction, better generalization can be obtained. Unfortunately, transduction is very difficult to address, both computationally and conceptually.</p>
<p id="p-0017" num="0016">Methods such as spectral graph theory (SGT) were introduced in the 1970's, with one of their main goals being to deduce the principal properties and structure of a graph comprising a plurality of nodes from its graph spectrum, where the graph spectrum is made up of the eigenvalues of the graph. It has recently been proposed that a graph theoretic, i.e., non-kernel based, approach to learning machines might be used to retrieve useful information from a dataset. In SGT, eigenvectors of a matrix are used to bisect, or partition, nodes in a graph corresponding to the matrix. To provide an example, from graph spectra, one can obtain information about the number of strongly connected components within the graph, the limiting distribution of a random walk on the graph and the time to reach it, etc. Applications of SGT are known and have been reported in many different disciplines, including chemistry, theoretical physics, quantum physics and communication networks.</p>
<p id="p-0018" num="0017">Both kernel methods and graph theory provide certain advantages in the area of information extraction and learning from data, however, because of the very different approaches used by the two methods, they have heretofore not been combined. It is an object of the present invention to exploit the advantages of both kernel methods and spectral graph theory to solve problems of machine learning, including the problem of transduction.</p>
<heading id="h-0004" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0019" num="0018">The present invention provides means for solving problems of machine learning based on the use of a combination of kernel functions and spectral graph theory. The kernel function outputs the inner product between the images of two data items in a feature space. The inner product can often be computed at low computational cost, however, the features being used are implicitly very complex. The data is stored in a matrix known as a kernel matrix or Gram matrix containing all pairwise kernels between the data. Other types of matrices may be used as well, including Laplacian matrices. Eigenvectors of the kernel matrix may be used to assign unlabeled data to clusters, merge information from labeled and unlabeled data by transduction, provide model selection information for other kernels, detect novelties or anomalies and/or clean data, and perform supervised learning tasks such as classification.</p>
<p id="p-0020" num="0019">In one exemplary application of the invention, the sign (+or −) of the entries of the second eigenvector of the kernel matrix are used to assign the data to classes, e.g., positive or negative.</p>
<p id="p-0021" num="0020">In another exemplary application, transduction is performed by taking a dataset that is at least partially labeled, selecting a kernel K, which is normalized to be −1≦K≦+1, then filling the kernel matrix with y<sub>i</sub>y<sub>j </sub>if the relative points are both labeled, and K(x<sub>i</sub>,x<sub>j</sub>) otherwise. The second eigenvector of the kernel matrix is obtained to provide the maximally aligned solution consistent with the known labels. The second eigenvector is thresholded, then labels can be assigned to the unlabeled data according to the aligned solution.</p>
<p id="p-0022" num="0021">In applying SGT methods to kernel methods, the dataset is regarded as nodes of a fully connected graph. A weight equal to the kernel between the two nodes is assigned to each edge of the graph. The adjacency matrix of the graph is equivalent to the Gram matrix. The eigenvectors and their corresponding eigenvalues provide information about the properties of the graph. The second eigenvector can be thresholded to approximate the class assignment of graph nodes, minimizing the cost of a cut of a clustering. The first eigenvector of the adjacency matrix provides distribution of an ergodic random walk, using such matrix as the transition matrix. The relations between first and second eigenvalues also give information about the connectivity of the graph. Looking at the random walk on the graph associated with the Gram matrix, the stationary distribution will provide information about the “popularity” of a point based on how many other points are similar to it. This allows anomalous points to be easily spotted.</p>
<p id="p-0023" num="0022">The inventive spectral kernel machine is applicable to kernel-based learning machines in general and to support vector machines in particular. In an exemplary embodiment, a computer system is provided for analysis of a data using a support vector machine. The exemplary system comprises a storage device for storing a database containing a training data set and a test data set, and a processor for executing one or more support vector machines. The processor is also operable for collecting the training data set from the database, optionally pre-processing the training data set to enhance each of a plurality of training data points, training the support vector machine using the pre-processed training data set. If the learning process is supervised or semi-supervised, the results of the training process may be tested, in which case the processor also collects test data set from the database, optionally pre-processes the test data set in the same manner as was the training data set, and tests the trained support vector machine using the pre-processed test data set. The processor may optionally post-process the test output to determine if the test output is an optimal solution. The exemplary system may also comprise a communications device for receiving the test data set and the training data set from a remote source. In such a case, the processor may be operable to store the training data set in the storage device prior to pre-processing of the training data set and, if test data is used, to store the test data set in the storage device prior to pre-processing of the test data set. The exemplary system may also comprise a display device for displaying the post-processed test data. The processor of the exemplary system may further be operable for performing each additional function described above. An exemplary computer system for implementing a support vector machine is described in U.S. Pat. Nos. 6,157,921 and 6,128,608 which are incorporated herein by reference in their entirety.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0024" num="0023">Exemplary embodiments of the present invention will hereinafter be described with reference to the below-listed drawings, in which like numerals indicate like elements throughout the figures.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 1(</figref><i>a</i>) is a plot of the alignment of different eigenvectors with the labels in the UW breast cancer dataset with a linear kernel, in order of increasing eigenvalue.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 1(</figref><i>b</i>) is a plot of the upper bound, alignment and accuracy of the solution following unsupervised learning in a linear kernel on the UW breast cancer dataset in which the alignment of the kernel to a label vector is optimized.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 2</figref> is a plot of the upper bound, alignment and accuracy of the solution following unsupervised learning in a Gaussian kernel on the UW breast cancer dataset in which the alignment of the kernel to a label vector is optimized.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 3</figref> is a plot of the upper bound, alignment and accuracy of the solution following unsupervised learning in a linear kernel on the UCI ionosphere dataset in which the alignment of the kernel to a label vector is optimized.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 4(</figref><i>a</i>) is a plot of cut cost and error rate versus threshold number following unsupervised learning in a linear kernel trained on the UW breast cancer dataset.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 4(</figref><i>b</i>) is a plot of cut cost and error rate versus threshold number following unsupervised learning in a Gaussian kernel trained on the UW breast cancer dataset.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 5</figref> is a functional block diagram illustrating an exemplary operating environment for an exemplary embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0032" num="0031">The following detailed description utilizes a number of acronyms which are generally well known in the art. While definitions are typically provided with the first instance of each acronym, for convenience, Table 1 below provides a list of the acronyms and abbreviations used herein along with their respective definitions.</p>
<p id="p-0033" num="0032">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>ACRONYM</entry>
<entry>DESCRIPTION</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>ATAPI</entry>
<entry>attachment packet interface</entry>
</row>
<row>
<entry/>
<entry>DMA</entry>
<entry>direct memory access</entry>
</row>
<row>
<entry/>
<entry>EIDE</entry>
<entry>enhanced IDE</entry>
</row>
<row>
<entry/>
<entry>I/O</entry>
<entry>input/output</entry>
</row>
<row>
<entry/>
<entry>IDE</entry>
<entry>integrated drive electronics</entry>
</row>
<row>
<entry/>
<entry>LAN</entry>
<entry>local area network</entry>
</row>
<row>
<entry/>
<entry>RAM</entry>
<entry>random access memory</entry>
</row>
<row>
<entry/>
<entry>ROM</entry>
<entry>read-only memory</entry>
</row>
<row>
<entry/>
<entry>SCSI</entry>
<entry>small computer system interface</entry>
</row>
<row>
<entry/>
<entry>SGT</entry>
<entry>spectral graph theory</entry>
</row>
<row>
<entry/>
<entry>SVM</entry>
<entry>support vector machine</entry>
</row>
<row>
<entry/>
<entry>UCI</entry>
<entry>University of California, Irvine</entry>
</row>
<row>
<entry/>
<entry>UW</entry>
<entry>University of Wisconsin</entry>
</row>
<row>
<entry/>
<entry>WAN</entry>
<entry>wide area network</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0034" num="0033">The present invention provides improved methods for training of kernel-based learning machines for use in analyzing data using learning machines. Specifically, the present invention combines results from spectral graph theory (SGT) with the kernel function to obtain a new class of learning algorithm. The algorithms disclosed herein provide means for supervised learning, unsupervised learning (clustering) and semi-supervised learning (transduction), model selection, and novelty detection in learning machines, including support vector machines.</p>
<p id="p-0035" num="0034">All of the information needed by the learning machine is contained within the “kernel matrix”, or Gram matrix, which can be regarded as a pairwise similiarity matrix between all pairs of points in the dataset. The resulting matrix is symmetric and positive semi-definite (its eigenvalues are always non-negative real numbers) and consequently can be written as</p>
<p id="p-0036" num="0035">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>K</mi>
    <mo>=</mo>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mi>i</mi>
      </munder>
      <mo>⁢</mo>
      <mrow>
        <msub>
          <mi>λ</mi>
          <mi>i</mi>
        </msub>
        <mo>⁢</mo>
        <msub>
          <mi>v</mi>
          <mi>i</mi>
        </msub>
        <mo>⁢</mo>
        <msubsup>
          <mi>v</mi>
          <mi>i</mi>
          <mi>′</mi>
        </msubsup>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
where v<sub>i </sub>and λ<sub>i</sub>≧0 are the eigenvectors and eigenvalues of K, and v<sub>i</sub>′ is the transpose of v<sub>i</sub>, so that v<sub>i</sub>v<sub>i</sub>′ is the outer product of v<sub>i </sub>and its transpose. The properties of the kernel matrix reflect the relative positions of the points in the feature space. For example, a kernel matrix K=I, where I is the identity, would correspond to having all points orthogonal to each other in feature space and, hence, there would be no useful notion of similarity since every point is similar to every other point in the same way.
</p>
<p id="p-0037" num="0036">All of the information needed to specify a clustering of a set of data is contained in the matrix K<sub>ij</sub>=(cluster (x<sub>i</sub>)==cluster (x<sub>j</sub>)), where (a==b) ε {−1,+1}. After a clustering is specified, the cost of that clustering can be measured. The general problem to be solved using graph theory is to assign class-labels to data points so as to maximize the cost function, i.e., minimize the “cut cost” C(S,K,y) of partitioning:</p>
<p id="p-0038" num="0037">
<maths id="MATH-US-00003" num="00003">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mrow>
              <mi>C</mi>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>S</mi>
                  <mo>,</mo>
                  <mi>K</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>=</mo>
            <mfrac>
              <mrow>
                <munder>
                  <mo>∑</mo>
                  <mrow>
                    <mrow>
                      <mi>ij</mi>
                      <mo>⁢</mo>
                      <mstyle>
                        <mtext>∷</mtext>
                      </mstyle>
                      <mo>⁢</mo>
                      <msub>
                        <mi>y</mi>
                        <mi>i</mi>
                      </msub>
                    </mrow>
                    <mo>≠</mo>
                    <msub>
                      <mi>y</mi>
                      <mi>j</mi>
                    </msub>
                  </mrow>
                </munder>
                <mo>⁢</mo>
                <mrow>
                  <mi>k</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <msub>
                        <mi>x</mi>
                        <mi>i</mi>
                      </msub>
                      <mo>,</mo>
                      <msub>
                        <mi>x</mi>
                        <mi>j</mi>
                      </msub>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
              <mrow>
                <mi>m</mi>
                <mo>⁢</mo>
                <msub>
                  <mrow>
                    <mo></mo>
                    <mi>K</mi>
                    <mo></mo>
                  </mrow>
                  <mi>F</mi>
                </msub>
              </mrow>
            </mfrac>
          </mrow>
          <mo>,</mo>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>5</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
where K is the kernel matrix, S is the sample, and F is an index referring to the Frobenius norm that corresponds to the inner product between matrices (K<sub>1</sub>, K<sub>2</sub>)<sub>F</sub>.
</p>
<p id="p-0039" num="0038">If the kernel matrix is considered as an adjacency matrix, the cost of partitioning a graph is given by the total weight of the edges that need to be cut or removed, and is exactly the numerator of the cut cost, i.e.,</p>
<p id="p-0040" num="0039">
<maths id="MATH-US-00004" num="00004">
<math overflow="scroll">
<mrow>
  <mrow>
    <munderover>
      <mo>∑</mo>
      <mrow>
        <mrow>
          <mi>ij</mi>
          <mo>⁢</mo>
          <mstyle>
            <mtext>∷</mtext>
          </mstyle>
          <mo>⁢</mo>
          <msub>
            <mi>y</mi>
            <mi>i</mi>
          </msub>
        </mrow>
        <mo>≠</mo>
        <msub>
          <mi>y</mi>
          <mi>j</mi>
        </msub>
      </mrow>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
    </munderover>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <mrow>
        <mi>k</mi>
        <mo>⁡</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mi>x</mi>
              <mi>i</mi>
            </msub>
            <mo>,</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <msub>
              <mi>x</mi>
              <mi>j</mi>
            </msub>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>.</mo>
    </mrow>
  </mrow>
  <mo>⁢</mo>
  <mstyle>
    <mspace width="0.3em" height="0.3ex"/>
  </mstyle>
</mrow>
</math>
</maths>
</p>
<p id="p-0041" num="0040">The concept underlying the present invention is the application of spectral graph theory (SGT) methods to kernel methods by regarding the dataset (for the kernel method) as the nodes, or vertices, of a fully connected graph. At least a portion of these nodes are connected together by one or more edges. Each edge of the graph is assigned a weight equal to the kernel between the two nodes that are connected by that edge. As a definition, let G=(V,E) be a graph whose vertices (nodes) are V and whose edges are E. The adjacency matrix of the graph is made up of rows and columns labeled by the nodes, with a 1 or 0 in position (V<sub>i</sub>,V<sub>j</sub>) according to whether V<sub>i </sub>and V<sub>j </sub>are adjacent or not. Thus, the |V|×|V| adjacency matrix A(ij) contains a 0 (zero) if there is no edge c<sub>ij </sub>connecting V<sub>i </sub>to V<sub>j</sub>, and contains a weight w<sub>ij </sub>otherwise. (Note that for unweighted graphs, the weight is always 1.) This adjacency matrix is equivalent to the kernel matrix, also known as the Gram matrix. Thus, the kernel method and graph theory are combined.</p>
<p id="p-0042" num="0041">The Laplacian matrix L of a graph G is defined as L=D−A, where A is the adjacency matrix, D=diag(d<sub>1</sub>, d<sub>2 </sub>. . . , d<sub>m</sub>) and d<sub>i</sub>=Σ<sub>j</sub>w<sub>ij</sub>. (Note that since the adjacency matrix A and the kernel matrix K are equivalent, A and K may be used interchangeably in the following description.)</p>
<p id="p-0043" num="0042">The eigenvectors of A and L, and their eigenvalues (also known as the “graph spectrum”), provide a significant amount of information about the graph. The second eigenvector (Fiedler's eigenvector) can be thresholded to approximate the class assignment of graph nodes, minimizing the cost of a cut. Many variations on the preceding theme can be applied including using the Laplacian matrix L instead of the adjacency matrix A.</p>
<p id="p-0044" num="0043">A standard proof technique used is to relax the constraint in a (NP-hard) discrete optimization problem so as to transform it into a continuous problem, allowing it to be solved approximately. The continuous solution can be thresholded to find an approximation of the discrete problem's solution. Such techniques rest on the Courant-Fischer Minimax Theorem, where, if A ε R<sup>m×m </sup>is symmetric, then for k=1, . . . , m,</p>
<p id="p-0045" num="0044">
<maths id="MATH-US-00005" num="00005">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <msub>
            <mi>λ</mi>
            <mi>k</mi>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mi>A</mi>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mrow>
            <munder>
              <mi>max</mi>
              <mrow>
                <mrow>
                  <mi>dim</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>S</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>=</mo>
                <mi>k</mi>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mrow>
              <munder>
                <mi>min</mi>
                <mrow>
                  <mrow>
                    <mn>0</mn>
                    <mo>≠</mo>
                    <mi>y</mi>
                  </mrow>
                  <mo>∈</mo>
                  <mi>S</mi>
                </mrow>
              </munder>
              <mo>⁢</mo>
              <mfrac>
                <mrow>
                  <msup>
                    <mi>y</mi>
                    <mi>′</mi>
                  </msup>
                  <mo>⁢</mo>
                  <mi>Ay</mi>
                </mrow>
                <mrow>
                  <msup>
                    <mi>y</mi>
                    <mi>′</mi>
                  </msup>
                  <mo>⁢</mo>
                  <mi>y</mi>
                </mrow>
              </mfrac>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <munder>
              <mi>min</mi>
              <mrow>
                <mrow>
                  <mi>dim</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>S</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mi>m</mi>
                  <mo>-</mo>
                  <mi>k</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mrow>
              <munder>
                <mi>max</mi>
                <mrow>
                  <mrow>
                    <mn>0</mn>
                    <mo>≠</mo>
                    <mi>y</mi>
                  </mrow>
                  <mo>∈</mo>
                  <mi>S</mi>
                </mrow>
              </munder>
              <mo>⁢</mo>
              <mfrac>
                <mrow>
                  <msup>
                    <mi>y</mi>
                    <mi>′</mi>
                  </msup>
                  <mo>⁢</mo>
                  <mi>Ay</mi>
                </mrow>
                <mrow>
                  <msup>
                    <mi>y</mi>
                    <mi>′</mi>
                  </msup>
                  <mo>⁢</mo>
                  <mi>y</mi>
                </mrow>
              </mfrac>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>6</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
where the first eigenvector of A is Frobenius' eigenvector and the second eigenvector of L is Fiedler's eigenvector.
</p>
<p id="p-0046" num="0045">The first eigenvector of the adjacency matrix A gives the stationary distribution of an ergodic random walk, using the matrix as a transition matrix. The relationship between the first and second eigenvalues also gives information about the connectivity of the graph. Looking at the random walk on the graph associated with the Gram (kernel) matrix, which, as stated previously, is equivalent to the adjacency matrix, the stationary distribution provides information about the “popularity” of a point based on how many other points are similar to it, i.e., the “typicity”. This allows anomalous points to be readily spotted. The entropy of this distribution provides a measure of the amount of clusterization achieved by a kernel. The distribution can be thresholded to separate typical cases from anomalies, then, if desired, only the typical cases can be kept for training.</p>
<p id="p-0047" num="0046">Looking now at spectral graph bisection, finding a balanced dichotomy of a weighted graph that minimizes the cost of the cut is an NP-hard problem, so it is necessary to settle for a heuristic solution. Preferred methods provide high quality partitionings at moderate cost and have formal properties that fit in with the kernel approach. In the preferred embodiment, eigenvectors of the Laplacian matrix are used to bisect a graph.</p>
<p id="p-0048" num="0047">The problem of spectral graph bisection can be stated as a discrete optimization problem. A weighted graph needs to be split into two equal parts while minimizing the cost of the cut. This problem is NP-hard.</p>
<p id="p-0049" num="0048">Consider the quantity cut-cost</p>
<p id="p-0050" num="0049">
<maths id="MATH-US-00006" num="00006">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mi>C</mi>
          <mo>=</mo>
          <mrow>
            <munder>
              <mo>∑</mo>
              <mrow>
                <msub>
                  <mi>y</mi>
                  <mi>i</mi>
                </msub>
                <mo>≠</mo>
                <msub>
                  <mi>y</mi>
                  <mi>j</mi>
                </msub>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mrow>
              <mi>K</mi>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>7</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
and define a quantity referred to as “alignment”:
</p>
<p id="p-0051" num="0050">
<maths id="MATH-US-00007" num="00007">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mover>
            <mi>A</mi>
            <mo>^</mo>
          </mover>
          <mo>=</mo>
          <mrow>
            <munder>
              <mo>∑</mo>
              <mrow>
                <mi>i</mi>
                <mo>,</mo>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
                <mo>⁢</mo>
                <mi>j</mi>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mrow>
              <msub>
                <mi>y</mi>
                <mi>i</mi>
              </msub>
              <mo>⁢</mo>
              <msub>
                <mi>y</mi>
                <mi>j</mi>
              </msub>
              <mo>⁢</mo>
              <mrow>
                <mrow>
                  <mi>K</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mi>j</mi>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>.</mo>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>8</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0052" num="0051">Alignment is a measure of similarity between clustering of a set of points that can not only be used to assess the relationships between the embeddings generated by two different kernels, such as a selected kernel and an “ideal” kernel, but also can be used to assess the similarity between the clustering of a labeled dataset induced by a kernel and the clustering induced by the labels themselves. Alignment captures the notion of a good clustering as achieving high similarity within the clusters and low similarity between them. Formally, alignment can be regarded as a Frobenius inner product between normalized kernel matrices. Alignment has certain convenient properties: it can be calculated before any training of the kernel machine takes place, and based only on training data information; it is sharply concentrated around its expected value, and hence, its empirical value is stable with respect to different splits of the data. If the kernel is very aligned with the labels, there exists a separation of the data with a low upper bound on the generalization error. Thus, it is possible to measure and optimize alignment based on training set information while achieving a better generalization power on the test set in a transductive setting.</p>
<p id="p-0053" num="0052">A dichotomy of the set is denoted by y ε {−1, +1}<sup>m</sup>. The preceding definitions imply the following two equations:</p>
<p id="p-0054" num="0053">
<maths id="MATH-US-00008" num="00008">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mrow>
              <munder>
                <mo>∑</mo>
                <mrow>
                  <msub>
                    <mi>y</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>=</mo>
                  <msub>
                    <mi>y</mi>
                    <mi>j</mi>
                  </msub>
                </mrow>
              </munder>
              <mo>⁢</mo>
              <mrow>
                <mi>K</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>j</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>-</mo>
            <mrow>
              <munderover>
                <mo>∑</mo>
                <mrow>
                  <msub>
                    <mi>y</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>≠</mo>
                  <msub>
                    <mi>y</mi>
                    <mi>j</mi>
                  </msub>
                </mrow>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
              </munderover>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mrow>
                <mi>K</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>j</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mover>
            <mi>A</mi>
            <mo>^</mo>
          </mover>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mtext>
</mtext>
        </mstyle>
        <mo>⁢</mo>
        <mi>and</mi>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>9</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mrow>
              <munderover>
                <mo>∑</mo>
                <mrow>
                  <msub>
                    <mi>y</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>=</mo>
                  <msub>
                    <mi>y</mi>
                    <mi>j</mi>
                  </msub>
                </mrow>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
              </munderover>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mrow>
                <mi>K</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>j</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>+</mo>
            <mrow>
              <munderover>
                <mo>∑</mo>
                <mrow>
                  <msub>
                    <mi>y</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>≠</mo>
                  <msub>
                    <mi>y</mi>
                    <mi>j</mi>
                  </msub>
                </mrow>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
              </munderover>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mrow>
                <mi>k</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>j</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <munderover>
              <mo>∑</mo>
              <mi>ij</mi>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
            </munderover>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <mi>K</mi>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mstyle>
          <mtext>
</mtext>
        </mstyle>
        <mo>⁢</mo>
        <mi>hence</mi>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>10</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <munderover>
              <mo>∑</mo>
              <mrow>
                <msub>
                  <mi>y</mi>
                  <mi>i</mi>
                </msub>
                <mo>≠</mo>
                <msub>
                  <mi>y</mi>
                  <mi>j</mi>
                </msub>
              </mrow>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
            </munderover>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <mi>K</mi>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>j</mi>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <mi>C</mi>
            <mo>=</mo>
            <mrow>
              <mrow>
                <mfrac>
                  <mn>1</mn>
                  <mn>2</mn>
                </mfrac>
                <mo>⁢</mo>
                <mrow>
                  <munderover>
                    <mo>∑</mo>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mstyle>
                        <mspace width="0.3em" height="0.3ex"/>
                      </mstyle>
                      <mo>⁢</mo>
                      <mi>j</mi>
                    </mrow>
                    <mstyle>
                      <mspace width="0.3em" height="0.3ex"/>
                    </mstyle>
                  </munderover>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mrow>
                    <mi>K</mi>
                    <mo>⁡</mo>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mi>i</mi>
                        <mo>,</mo>
                        <mi>j</mi>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mover>
                <mi>A</mi>
                <mo>^</mo>
              </mover>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>11</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
which gives the relation
</p>
<p id="p-0055" num="0054">
<maths id="MATH-US-00009" num="00009">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mrow>
              <munderover>
                <mo>∑</mo>
                <mrow>
                  <msub>
                    <mi>y</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>,</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <msub>
                    <mi>y</mi>
                    <mi>j</mi>
                  </msub>
                </mrow>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
              </munderover>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mrow>
                <msub>
                  <mi>y</mi>
                  <mi>i</mi>
                </msub>
                <mo>⁢</mo>
                <msub>
                  <mi>y</mi>
                  <mi>j</mi>
                </msub>
                <mo>⁢</mo>
                <mrow>
                  <mi>K</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mi>j</mi>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
            <mo>=</mo>
            <mrow>
              <mrow>
                <mover>
                  <mi>A</mi>
                  <mo>^</mo>
                </mover>
                <mo>-</mo>
                <mrow>
                  <munderover>
                    <mo>∑</mo>
                    <mrow>
                      <msub>
                        <mi>y</mi>
                        <mi>i</mi>
                      </msub>
                      <mo>,</mo>
                      <mstyle>
                        <mspace width="0.3em" height="0.3ex"/>
                      </mstyle>
                      <mo>⁢</mo>
                      <msub>
                        <mi>y</mi>
                        <mi>j</mi>
                      </msub>
                    </mrow>
                    <mstyle>
                      <mspace width="0.3em" height="0.3ex"/>
                    </mstyle>
                  </munderover>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mrow>
                    <mi>K</mi>
                    <mo>⁡</mo>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mi>i</mi>
                        <mo>,</mo>
                        <mi>j</mi>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
              </mrow>
              <mo>=</mo>
              <mrow>
                <mrow>
                  <mo>-</mo>
                  <mn>2</mn>
                </mrow>
                <mo>⁢</mo>
                <mi>C</mi>
              </mrow>
            </mrow>
          </mrow>
          <mo>,</mo>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>12</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
showing that the quantity y′Ly=2C does, in fact, give the cut cost for the dichotomy
</p>
<p id="p-0056" num="0055">
<maths id="MATH-US-00010" num="00010">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mi>y</mi>
          <mo>⁢</mo>
          <mstyle>
            <mtext>(</mtext>
          </mstyle>
          <mo>⁢</mo>
          <msup>
            <mi>y</mi>
            <mi>′</mi>
          </msup>
          <mo>⁢</mo>
          <mi>Ly</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mrow>
              <msup>
                <mi>y</mi>
                <mi>′</mi>
              </msup>
              <mo>⁢</mo>
              <mi>Dy</mi>
            </mrow>
            <mo>-</mo>
            <mrow>
              <msup>
                <mi>y</mi>
                <mi>′</mi>
              </msup>
              <mo>⁢</mo>
              <mi>Ky</mi>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <mrow>
              <mrow>
                <munderover>
                  <mo>∑</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mstyle>
                      <mspace width="0.3em" height="0.3ex"/>
                    </mstyle>
                    <mo>⁢</mo>
                    <mi>j</mi>
                  </mrow>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                </munderover>
                <mo>⁢</mo>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
                <mo>⁢</mo>
                <mrow>
                  <mi>K</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mi>i</mi>
                      <mo>,</mo>
                      <mi>j</mi>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mover>
                <mi>A</mi>
                <mo>^</mo>
              </mover>
            </mrow>
            <mo>=</mo>
            <mrow>
              <mn>2</mn>
              <mo>⁢</mo>
              <mi>C</mi>
              <mo>⁢</mo>
              <mrow>
                <mstyle>
                  <mtext>)</mtext>
                </mstyle>
                <mo>.</mo>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>13</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0057" num="0056">It would be desirable to minimize the cut cost by finding y ε {−1,+1}<sup>m</sup>, however this problem is NP-hard. Therefore, the solution must be approximated. One option for solution is to impose a slightly looser constraint on y, y ε</p>
<p id="p-0058" num="0057">
<maths id="MATH-US-00011" num="00011">
<math overflow="scroll">
<mrow>
  <msup>
    <mi>R</mi>
    <mi>m</mi>
  </msup>
  <mo>,</mo>
  <mrow>
    <mrow>
      <munderover>
        <mo>∑</mo>
        <mrow>
          <mi>i</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
        </mrow>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </munderover>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
      <mo>⁢</mo>
      <msubsup>
        <mi>y</mi>
        <mi>i</mi>
        <mn>2</mn>
      </msubsup>
    </mrow>
    <mo>=</mo>
    <mi>m</mi>
  </mrow>
  <mo>,</mo>
  <mrow>
    <mrow>
      <mover>
        <munder>
          <mo>∑</mo>
          <mi>i</mi>
        </munder>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
      </mover>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
      <mo>⁢</mo>
      <msub>
        <mi>y</mi>
        <mi>i</mi>
      </msub>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
which represents the case of a balanced split. This yields the relationship
</p>
<p id="p-0059" num="0058">
<maths id="MATH-US-00012" num="00012">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mi>min</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.8em" height="0.8ex"/>
            </mstyle>
            <mo>⁢</mo>
            <msup>
              <mi>y</mi>
              <mi>′</mi>
            </msup>
            <mo>⁢</mo>
            <mi>Ly</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.8em" height="0.8ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>subject</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.8em" height="0.8ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>to</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.8em" height="0.8ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>y</mi>
          </mrow>
          <mo>∈</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <msup>
            <mi>R</mi>
            <mi>m</mi>
          </msup>
        </mrow>
        <mo>,</mo>
        <mrow>
          <mrow>
            <munder>
              <mo>∑</mo>
              <mi>i</mi>
            </munder>
            <mo>⁢</mo>
            <msubsup>
              <mi>y</mi>
              <mi>i</mi>
              <mn>2</mn>
            </msubsup>
          </mrow>
          <mo>=</mo>
          <mi>m</mi>
        </mrow>
        <mo>,</mo>
        <mrow>
          <mrow>
            <munder>
              <mo>∑</mo>
              <mi>i</mi>
            </munder>
            <mo>⁢</mo>
            <msub>
              <mi>y</mi>
              <mi>i</mi>
            </msub>
          </mrow>
          <mo>=</mo>
          <mn>0.</mn>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>14</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0060" num="0059">Since zero is an eigenvalue of L with eigenvector j, the all ones vector, the problem is equivalent to finding the eigenvector of the smallest non-zero eigenvalue</p>
<p id="p-0061" num="0060">
<maths id="MATH-US-00013" num="00013">
<math overflow="scroll">
<mrow>
  <mi>λ</mi>
  <mo>=</mo>
  <mrow>
    <munder>
      <mi>min</mi>
      <mrow>
        <mn>0</mn>
        <mo>≠</mo>
        <mi>y</mi>
        <mo>⊥</mo>
        <mi>j</mi>
      </mrow>
    </munder>
    <mo>⁢</mo>
    <mrow>
      <mfrac>
        <mrow>
          <msup>
            <mi>y</mi>
            <mi>′</mi>
          </msup>
          <mo>⁢</mo>
          <mi>Ly</mi>
        </mrow>
        <mrow>
          <msup>
            <mi>y</mi>
            <mi>′</mi>
          </msup>
          <mo>⁢</mo>
          <mi>y</mi>
        </mrow>
      </mfrac>
      <mo>.</mo>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
Hence, the eigenvalue λ provides a lower bound on the cut cost
</p>
<p id="p-0062" num="0061">
<maths id="MATH-US-00014" num="00014">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <munder>
            <mi>min</mi>
            <mrow>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mrow>
                <mi>y</mi>
                <mo>⁢</mo>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
                <mo>⁢</mo>
                <mi>ε</mi>
                <mo>⁢</mo>
                <msup>
                  <mrow>
                    <mo>{</mo>
                    <mrow>
                      <mrow>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                    <mo>}</mo>
                  </mrow>
                  <mi>m</mi>
                </msup>
              </mrow>
            </mrow>
          </munder>
          <mo>⁢</mo>
          <mrow>
            <mi>C</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>S</mi>
                <mo>,</mo>
                <mi>k</mi>
                <mo>,</mo>
                <mi>y</mi>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo>≥</mo>
        <mrow>
          <mfrac>
            <mi>λ</mi>
            <mrow>
              <mn>2</mn>
              <mo>⁢</mo>
              <msub>
                <mrow>
                  <mo></mo>
                  <mi>K</mi>
                  <mo></mo>
                </mrow>
                <mi>F</mi>
              </msub>
            </mrow>
          </mfrac>
          <mo>.</mo>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>15</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
Thus, the eigenvector corresponding to the eigenvalue λ of the Laplacian can be used to obtain a good approximate split, and λ gives a lower bound on the cut-cost. One can now threshold the entries of the eigenvector in order to obtain a vector with −1 and +1 entries.
</p>
<p id="p-0063" num="0062">The following observations may be made: the number of connected components (clusters) is equal to the number of zero eigenvalues of the Laplacian L; the Laplacian is positive semidefinite, its rows sum to zero, its smallest eigenvalue λ<sub>1 </sub>is 0; since L is positive semidefinite, all other eigenvalues must be greater than zero for a connected graph. The eigenvector corresponding to the next smallest eigenvalue λ<sub>2 </sub>approximately gives the best balanced split since it enforces the condition that the weight of positives is the same as the weight of negatives by being orthogonal to the constant smallest eigenvector. If the graph is not connected, the multiplicity of eigenvalue 0 is related to the number of disconnected components. Thus, an eigenvalue near zero must belong to an eigenvector with both positive and negative components which partition the graph into nearly disconnected components. Further, λ<sub>2</sub>(L) is the algebraic connectivity of the graph. Similarly, λ<sub>2</sub>(K) is the maximum alignment of the kernel. Finally, the separation between eigenvalues gives information about the stability of the eigenvectors (or eigenspaces.)</p>
<p id="p-0064" num="0063">It can be shown that the spectrum of a Gram matrix is sharply concentrated around its mean. Given the variational characterization of eigenvalues, it is apparent that they are a function of a sum of random variables, and the maximum variation of this sum by varying or removing one element is bounded. Hence, the spectrum, and the performance of the eigenvectors, are concentrated.</p>
<p id="p-0065" num="0064">Informally, a random variable is concentrated when the probability of assuming values much different from its expected value is very low. The information that a random variable is concentrated can be exploited as a powerful tool in learning theory, and can be obtained with relative ease by applying known techniques such as McDiarmid's bound, Talagrand's inequalities, and other concentration theorems.</p>
<p id="p-0066" num="0065">If a quantity is concentrated, there is a high probability that its empirical value is close to its true value, and observing it on a training dataset gives confidence that it will have a similar value on the test dataset.</p>
<p id="p-0067" num="0066">According to McDiarmid's bound, let X<sub>1</sub>, . . . , X<sub>m </sub>be independent random variables taking values in a set E and assume that there exists a function f: x<sup>m</sup>→R satisfies</p>
<p id="p-0068" num="0067">
<maths id="MATH-US-00015" num="00015">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <munder>
              <mi>sup</mi>
              <mrow>
                <msub>
                  <mi>x</mi>
                  <mi>i</mi>
                </msub>
                <mo>,</mo>
                <mi>…</mi>
                <mo>,</mo>
                <msub>
                  <mi>x</mi>
                  <mi>m</mi>
                </msub>
                <mo>,</mo>
                <msubsup>
                  <mi>x</mi>
                  <mi>i</mi>
                  <mi>′</mi>
                </msubsup>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mrow>
              <mo></mo>
              <mrow>
                <mrow>
                  <mi>f</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <msub>
                        <mi>x</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>,</mo>
                      <mi>…</mi>
                      <mo>⁢</mo>
                      <mstyle>
                        <mspace width="0.6em" height="0.6ex"/>
                      </mstyle>
                      <mo>,</mo>
                      <msub>
                        <mi>x</mi>
                        <mi>m</mi>
                      </msub>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <mi>f</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <msub>
                        <mi>x</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>,</mo>
                      <mi>…</mi>
                      <mo>⁢</mo>
                      <mstyle>
                        <mspace width="0.6em" height="0.6ex"/>
                      </mstyle>
                      <mo>,</mo>
                      <msubsup>
                        <mi>x</mi>
                        <mi>i</mi>
                        <mi>′</mi>
                      </msubsup>
                      <mo>,</mo>
                      <msub>
                        <mi>x</mi>
                        <mrow>
                          <mi>i</mi>
                          <mo>+</mo>
                          <mn>1</mn>
                        </mrow>
                      </msub>
                      <mo>,</mo>
                      <mi>…</mi>
                      <mo>⁢</mo>
                      <mstyle>
                        <mspace width="0.6em" height="0.6ex"/>
                      </mstyle>
                      <mo>,</mo>
                      <msub>
                        <mi>x</mi>
                        <mi>m</mi>
                      </msub>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
              <mo></mo>
            </mrow>
          </mrow>
          <mo>≤</mo>
          <msub>
            <mi>c</mi>
            <mi>i</mi>
          </msub>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>16</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
where 1≦i≦m. Then, for all c&gt;0,
</p>
<p id="p-0069" num="0068">
<maths id="MATH-US-00016" num="00016">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mi>P</mi>
            <mo>⁢</mo>
            <mrow>
              <mo>{</mo>
              <mrow>
                <mrow>
                  <mo></mo>
                  <mrow>
                    <mrow>
                      <mi>f</mi>
                      <mo>⁡</mo>
                      <mrow>
                        <mo>(</mo>
                        <mrow>
                          <msub>
                            <mi>X</mi>
                            <mn>1</mn>
                          </msub>
                          <mo>,</mo>
                          <mi>…</mi>
                          <mo>⁢</mo>
                          <mstyle>
                            <mspace width="0.6em" height="0.6ex"/>
                          </mstyle>
                          <mo>,</mo>
                          <msub>
                            <mi>X</mi>
                            <mi>m</mi>
                          </msub>
                        </mrow>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                    <mo>-</mo>
                    <mrow>
                      <mi>Ef</mi>
                      <mo>⁡</mo>
                      <mrow>
                        <mo>(</mo>
                        <mrow>
                          <msub>
                            <mi>X</mi>
                            <mn>1</mn>
                          </msub>
                          <mo>,</mo>
                          <mi>…</mi>
                          <mo>⁢</mo>
                          <mstyle>
                            <mspace width="0.6em" height="0.6ex"/>
                          </mstyle>
                          <mo>,</mo>
                          <msub>
                            <mi>X</mi>
                            <mi>m</mi>
                          </msub>
                        </mrow>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                  </mrow>
                  <mo></mo>
                </mrow>
                <mo>&gt;</mo>
                <mi>ɛ</mi>
              </mrow>
              <mo>}</mo>
            </mrow>
          </mrow>
          <mo>≤</mo>
          <mrow>
            <mn>2</mn>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mi>exp</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <mo>(</mo>
              <mfrac>
                <mrow>
                  <mrow>
                    <mo>-</mo>
                    <mn>2</mn>
                  </mrow>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <msup>
                    <mi>ɛ</mi>
                    <mn>2</mn>
                  </msup>
                </mrow>
                <mrow>
                  <mo>∑</mo>
                  <msubsup>
                    <mi>c</mi>
                    <mi>i</mi>
                    <mn>2</mn>
                  </msubsup>
                </mrow>
              </mfrac>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>17</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
which means that a bound similar to the law of large numbers can be applied to any function f which does not overly depend on individual samples x<sub>i</sub>.
</p>
<p id="p-0070" num="0069">Alternatively, known leave-one-out estimates may be used to determine concentration following the premise that if the function does not change significantly when one variable is removed altogether, the group of variables is concentrated.</p>
<p id="p-0071" num="0070">The present invention is applicable to all types of machine learning, i.e., supervised, semi-supervised, and unsupervised. For purposes of this discussion, the following assumptions apply: a dataset of m points is drawn from a set X according to a fixed distribution D. In the supervised learning case, it is also assumed that a vector yε{−1, +1}<sup>m </sup>(labels) is given. In the semi-supervised case, it is assumed that a vector y ε{−1, *,+1}<sup>m </sup>is given, where * means that there is no label for some point or points within the dataset.</p>
<p id="p-0072" num="0071">Consider the constraint C<b>1</b>: Σ<sub>+</sub>p<sub>i</sub>=Σ<sub>−</sub>p<sub>i</sub>. The requirement that y=−1 or +1 is relaxed and the following conditions are applied: Σy<sub>i</sub><sup>2</sup>=m and Σ<sub>+</sub>p<sub>i</sub>=Σ<sub>−</sub>p<sub>i</sub>, so that the two classes have equal probability under the distribution of the first eigenvector.</p>
<p id="p-0073" num="0072">Under these constraints, the alignment can be maximized by spectral techniques. Defining</p>
<p id="p-0074" num="0073">
<maths id="MATH-US-00017" num="00017">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>v</mi>
    <mo>=</mo>
    <mfrac>
      <mi>y</mi>
      <msqrt>
        <mrow>
          <mo>(</mo>
          <mi>m</mi>
          <mo>)</mo>
        </mrow>
      </msqrt>
    </mfrac>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
the problem becomes:
</p>
<p id="p-0075" num="0074">
<maths id="MATH-US-00018" num="00018">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <msub>
        <mi>min</mi>
        <mrow>
          <mrow>
            <mi>C</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
            <mrow>
              <mo>∑</mo>
              <msubsup>
                <mi>y</mi>
                <mi>i</mi>
                <mn>2</mn>
              </msubsup>
            </mrow>
            <mo>-</mo>
            <mi>m</mi>
          </mrow>
        </mrow>
      </msub>
      <mo>⁢</mo>
      <mrow>
        <msup>
          <mi>y</mi>
          <mi>′</mi>
        </msup>
        <mo>⁢</mo>
        <mi>Ky</mi>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mrow>
        <msub>
          <mi>min</mi>
          <mrow>
            <mrow>
              <mrow>
                <mo>∑</mo>
                <msubsup>
                  <mi>v</mi>
                  <mn>2</mn>
                  <mn>2</mn>
                </msubsup>
              </mrow>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mo>;</mo>
            <mrow>
              <mrow>
                <mo>+</mo>
                <mi>otherconstra</mi>
              </mrow>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="1.1em" height="1.1ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mi>int</mi>
            </mrow>
          </mrow>
        </msub>
        <mo>⁢</mo>
        <mfrac>
          <mrow>
            <msup>
              <mi>v</mi>
              <mi>′</mi>
            </msup>
            <mo>⁢</mo>
            <mi>Kv</mi>
          </mrow>
          <mrow>
            <msup>
              <mi>v</mi>
              <mi>′</mi>
            </msup>
            <mo>⁢</mo>
            <mi>v</mi>
          </mrow>
        </mfrac>
      </mrow>
      <mo>=</mo>
      <msub>
        <mi>λ</mi>
        <mn>2</mn>
      </msub>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
where v<sub>2 </sub>is the minimizer, the second eigenvector. Constraint C<b>1</b> requires the probability of the two classes to be the same under the distribution given by the first eigenvector.
</p>
<p id="p-0076" num="0075">In other words, the second eigenvector maximizes the alignment under the constraint, and thresholding it provides a labeling that approximately maximizes alignment. The second eigenvalue gives the value of the alignment in this case, and is a lower bound under the true value of the optimal alignment. This provides an absolute measure of kernel alignment so that the maximal alignment can be achieved on all possible labeling. One can also tune the kernel parameters in a principled way, possibly by gradient descent, to achieve maximal alignment.</p>
<p id="p-0077" num="0076">Consider a graph G whose adjacency matrix is K. Next, consider a random walk on that graph, and its stationary or ergodic distribution. The popularity of a given node of graph G is determined by the amount of time a random walker would spend on the node. The popularity of a given node also depends on the number, popularity and closeness of its neighbor nodes.</p>
<p id="p-0078" num="0077">Alignment can be used to measure the level of fitness between a kernel and a fixed labeling of the data, with the goal of selecting better kernel parameters, i.e., the best aligned set of labels. The absolute measure of a kernel is its second eigenvalue, which can be used to optimize kernel parameters. Using eigentechniques, the measure of the kernel can be lower-bounded with the second eigenvalue.</p>
<p id="p-0079" num="0078">This information is provided by the first eigenvector of K. The distance between the first two eigenvalues provides information about the degree of connectivity of the graph, which can be used to measure the amount of structure in the data. Similarly, the entropy of the stationary distribution can quantify connectivity. Alternatively, lifting can be used to explicitly adapt the first eigenvector and, therefore, the kernels. “Lifting” is described by H. Chang, et al. in “Creating Customized Authority Lists”, 17<sup>th </sup>International Conference on Machine Learning, Jun. 29-Jul. 2, 2000, which is incorporated herein by reference. Briefly, lifting involves using gradient ascent on the elements of a matrix to alter the weights of elements to more closely align the first eigenvector with a certain element or group of elements which is considered to be more important. The element or combination of elements to which the first eigenvector is aligned is referred to as a “handle” that can be used to “lift” the desired data points away from the rest of the elements in the matrix.</p>
<p id="p-0080" num="0079">Any of the preceding procedures can be used as a pre-processing step to clean or expand data. Further, pre-processing may include expanding the data by treating the label as another feature. Using such techniques, identifying isolated points, e.g., outliers, would amount to flagging unusual combinations of x and y.</p>
<p id="p-0081" num="0080">Alignment can be used to measure the level of fitness between a kernel and a fixed labeling of the data, with the goal of selecting better kernel parameters, i.e., the best aligned set of labels. The absolute measure of a kernel is its second eigenvalue.</p>
<p id="p-0082" num="0081">Consider the constraint C<b>1</b>: Σ<sub>+</sub>p<sub>i</sub>=Σ<sub>−</sub>p<sub>i</sub>. The requirement that y=−1 or +1 is relaxed and the following conditions are applied: Σy<sub>i</sub><sup>2</sup>=m and Σ<sub>+</sub>p<sub>i</sub>=Σ<sub>−</sub>p<sub>i</sub>, so that the two classes have equal probability under the distribution of the first eigenvector.</p>
<p id="p-0083" num="0082">Under these constraints, the alignment can be maximized by spectral techniques. Defining</p>
<p id="p-0084" num="0083">
<maths id="MATH-US-00019" num="00019">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>v</mi>
    <mo>=</mo>
    <mfrac>
      <mi>y</mi>
      <msqrt>
        <mrow>
          <mo>(</mo>
          <mi>m</mi>
          <mo>)</mo>
        </mrow>
      </msqrt>
    </mfrac>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
the problem becomes:
</p>
<p id="p-0085" num="0084">
<maths id="MATH-US-00020" num="00020">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <msub>
        <mi>min</mi>
        <mrow>
          <mrow>
            <mi>C</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
            <mrow>
              <mo>∑</mo>
              <msubsup>
                <mi>y</mi>
                <mi>i</mi>
                <mn>2</mn>
              </msubsup>
            </mrow>
            <mo>-</mo>
            <mi>m</mi>
          </mrow>
        </mrow>
      </msub>
      <mo>⁢</mo>
      <mrow>
        <msup>
          <mi>y</mi>
          <mi>′</mi>
        </msup>
        <mo>⁢</mo>
        <mi>Ky</mi>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mrow>
        <msub>
          <mi>min</mi>
          <mrow>
            <mrow>
              <mrow>
                <mo>∑</mo>
                <msubsup>
                  <mi>v</mi>
                  <mn>2</mn>
                  <mn>2</mn>
                </msubsup>
              </mrow>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mo>;</mo>
            <mrow>
              <mrow>
                <mo>+</mo>
                <mi>otherconstra</mi>
              </mrow>
              <mo>⁢</mo>
              <mstyle>
                <mspace width="1.1em" height="1.1ex"/>
              </mstyle>
              <mo>⁢</mo>
              <mi>int</mi>
            </mrow>
          </mrow>
        </msub>
        <mo>⁢</mo>
        <mfrac>
          <mrow>
            <msup>
              <mi>v</mi>
              <mi>′</mi>
            </msup>
            <mo>⁢</mo>
            <mi>Kv</mi>
          </mrow>
          <mrow>
            <msup>
              <mi>v</mi>
              <mi>′</mi>
            </msup>
            <mo>⁢</mo>
            <mi>v</mi>
          </mrow>
        </mfrac>
      </mrow>
      <mo>=</mo>
      <msub>
        <mi>λ</mi>
        <mn>2</mn>
      </msub>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
where v<sub>2 </sub>is the minimizer, the second eigenvector. Constraint C<b>1</b> requires the probability of the two classes to be the same under the distribution given by the first eigenvector.
</p>
<p id="p-0086" num="0085">In other words, the second eigenvector maximizes the alignment under the constraint, and thresholding it provides a labeling that approximately maximizes alignment. The second eigenvalue gives the value of the alignment in this case, and is a lower bound under the true value of the optimal alignment. This provides an absolute measure of kernel alignment so that the maximal alignment can be achieved on all possible labeling. One can also tune the kernel parameters in a principled way, possibly by gradient descent, to achieve maximal alignment.</p>
<p id="p-0087" num="0086">The empirical alignment of a kernel k<sub>1 </sub>with a kernel k<sub>2 </sub>with respect to the sample S is the quantity</p>
<p id="p-0088" num="0087">
<maths id="MATH-US-00021" num="00021">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mover>
              <mi>A</mi>
              <mo>^</mo>
            </mover>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>S</mi>
                <mo>,</mo>
                <msub>
                  <mi>k</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>k</mi>
                  <mn>2</mn>
                </msub>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mfrac>
            <msub>
              <mrow>
                <mo>〈</mo>
                <mrow>
                  <msub>
                    <mi>K</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>,</mo>
                  <msub>
                    <mi>K</mi>
                    <mn>2</mn>
                  </msub>
                </mrow>
                <mo>〉</mo>
              </mrow>
              <mi>F</mi>
            </msub>
            <msqrt>
              <mrow>
                <msub>
                  <mrow>
                    <mo>〈</mo>
                    <mrow>
                      <msub>
                        <mi>K</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>,</mo>
                      <msub>
                        <mi>K</mi>
                        <mn>1</mn>
                      </msub>
                    </mrow>
                    <mo>〉</mo>
                  </mrow>
                  <mi>F</mi>
                </msub>
                <mo>⁢</mo>
                <msub>
                  <mrow>
                    <mo>〈</mo>
                    <mrow>
                      <msub>
                        <mi>K</mi>
                        <mn>2</mn>
                      </msub>
                      <mo>,</mo>
                      <msub>
                        <mi>K</mi>
                        <mn>2</mn>
                      </msub>
                    </mrow>
                    <mo>〉</mo>
                  </mrow>
                  <mi>F</mi>
                </msub>
              </mrow>
            </msqrt>
          </mfrac>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>18</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
where K<sub>i </sub>is the kernel matrix for the sample S using the kernel k<sub>i</sub>;
</p>
<p id="p-0089" num="0088">the inner product between matrices</p>
<p id="p-0090" num="0089">
<maths id="MATH-US-00022" num="00022">
<math overflow="scroll">
<mrow>
  <mrow>
    <msub>
      <mrow>
        <mo>〈</mo>
        <mrow>
          <msub>
            <mi>K</mi>
            <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
            <mi>K</mi>
            <mn>2</mn>
          </msub>
        </mrow>
        <mo>〉</mo>
      </mrow>
      <mi>F</mi>
    </msub>
    <mo>=</mo>
    <mrow>
      <munderover>
        <mo>∑</mo>
        <mrow>
          <mi>i</mi>
          <mo>,</mo>
          <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
        </mrow>
        <mi>m</mi>
      </munderover>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
      <mo>⁢</mo>
      <mrow>
        <mrow>
          <msub>
            <mi>K</mi>
            <mn>1</mn>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>x</mi>
                <mi>i</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>x</mi>
                <mi>j</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mrow>
          <msub>
            <mi>K</mi>
            <mn>2</mn>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>x</mi>
                <mi>i</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>x</mi>
                <mi>j</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>;</mo>
</mrow>
</math>
</maths>
<br/>
and
</p>
<p id="p-0091" num="0090">F refers to the Frobenius norm that corresponds to this inner product.</p>
<p id="p-0092" num="0091">The alignment can also be viewed as the cosine of the angle between two bi-dimensional vectors K<sub>1 </sub>and K<sub>2</sub>, representing the Gram matrices. If k<sub>2</sub>=yy′, where y is the vector of {−1, +1} labels for the sample, then:</p>
<p id="p-0093" num="0092">
<maths id="MATH-US-00023" num="00023">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mover>
              <mi>A</mi>
              <mo>^</mo>
            </mover>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>S</mi>
                <mo>,</mo>
                <mi>k</mi>
                <mo>,</mo>
                <mi>y</mi>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <mfrac>
              <msub>
                <mrow>
                  <mo>〈</mo>
                  <mrow>
                    <mi>K</mi>
                    <mo>,</mo>
                    <msup>
                      <mi>yy</mi>
                      <mi>′</mi>
                    </msup>
                  </mrow>
                  <mo>〉</mo>
                </mrow>
                <mi>F</mi>
              </msub>
              <msqrt>
                <mrow>
                  <msub>
                    <mrow>
                      <mo>〈</mo>
                      <mrow>
                        <mi>K</mi>
                        <mo>,</mo>
                        <mi>K</mi>
                      </mrow>
                      <mo>〉</mo>
                    </mrow>
                    <mi>F</mi>
                  </msub>
                  <mo>⁢</mo>
                  <msub>
                    <mrow>
                      <mo>〈</mo>
                      <mrow>
                        <msup>
                          <mi>yy</mi>
                          <mi>′</mi>
                        </msup>
                        <mo>,</mo>
                        <msup>
                          <mi>yy</mi>
                          <mi>′</mi>
                        </msup>
                      </mrow>
                      <mo>〉</mo>
                    </mrow>
                    <mi>F</mi>
                  </msub>
                </mrow>
              </msqrt>
            </mfrac>
            <mo>=</mo>
            <mfrac>
              <msub>
                <mrow>
                  <mo>〈</mo>
                  <mrow>
                    <mi>K</mi>
                    <mo>,</mo>
                    <msup>
                      <mi>yy</mi>
                      <mi>′</mi>
                    </msup>
                  </mrow>
                  <mo>〉</mo>
                </mrow>
                <mi>F</mi>
              </msub>
              <mrow>
                <mi>m</mi>
                <mo>⁢</mo>
                <msub>
                  <mrow>
                    <mo></mo>
                    <mi>K</mi>
                    <mo></mo>
                  </mrow>
                  <mi>F</mi>
                </msub>
              </mrow>
            </mfrac>
          </mrow>
        </mrow>
        <mo>,</mo>
        <mstyle>
          <mtext>
</mtext>
        </mstyle>
        <mo>⁢</mo>
        <mrow>
          <mrow>
            <mi>since</mi>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.8em" height="0.8ex"/>
            </mstyle>
            <mo>⁢</mo>
            <msub>
              <mrow>
                <mo>〈</mo>
                <mrow>
                  <msup>
                    <mi>yy</mi>
                    <mi>′</mi>
                  </msup>
                  <mo>,</mo>
                  <msup>
                    <mi>yy</mi>
                    <mi>′</mi>
                  </msup>
                </mrow>
                <mo>〉</mo>
              </mrow>
              <mi>F</mi>
            </msub>
          </mrow>
          <mo>=</mo>
          <mrow>
            <msup>
              <mi>m</mi>
              <mn>2</mn>
            </msup>
            <mo>.</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>19</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
The relationship between alignment and cut cost is
</p>
<p id="p-0094" num="0093">
<maths id="MATH-US-00024" num="00024">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mover>
              <mi>A</mi>
              <mo>^</mo>
            </mover>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>S</mi>
                <mo>,</mo>
                <mi>k</mi>
                <mo>,</mo>
                <mi>y</mi>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <mfrac>
              <mrow>
                <mrow>
                  <munder>
                    <mo>∑</mo>
                    <mi>ij</mi>
                  </munder>
                  <mo>⁢</mo>
                  <mstyle>
                    <mspace width="0.3em" height="0.3ex"/>
                  </mstyle>
                  <mo>⁢</mo>
                  <mrow>
                    <mi>k</mi>
                    <mo>⁡</mo>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <msub>
                          <mi>x</mi>
                          <mi>i</mi>
                        </msub>
                        <mo>,</mo>
                        <msub>
                          <mi>x</mi>
                          <mi>j</mi>
                        </msub>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <mn>2</mn>
                  <mo>⁢</mo>
                  <mrow>
                    <mi>C</mi>
                    <mo>⁡</mo>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mi>S</mi>
                        <mo>,</mo>
                        <mi>k</mi>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
              </mrow>
              <mrow>
                <mi>m</mi>
                <mo>⁢</mo>
                <msqrt>
                  <msub>
                    <mrow>
                      <mo>〈</mo>
                      <mrow>
                        <mi>K</mi>
                        <mo>,</mo>
                        <mi>K</mi>
                      </mrow>
                      <mo>〉</mo>
                    </mrow>
                    <mi>F</mi>
                  </msub>
                </msqrt>
              </mrow>
            </mfrac>
            <mo>=</mo>
            <mrow>
              <mrow>
                <mi>T</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>S</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
                <mn>2</mn>
                <mo>⁢</mo>
                <mrow>
                  <mi>C</mi>
                  <mo>⁡</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mi>S</mi>
                      <mo>,</mo>
                      <mi>k</mi>
                      <mo>,</mo>
                      <mi>y</mi>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>20</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
where T(S,k)=Â(S,k,j), for j the all ones vector. For normalized kernels ∥φ(x<sub>i</sub>)−φ(x<sub>j</sub>)∥<sup>2</sup>=2−2K(x<sub>i</sub>,x<sub>j</sub>), and with a fixed K, choosing y to minimize
</p>
<p id="p-0095" num="0094">
<maths id="MATH-US-00025" num="00025">
<math overflow="scroll">
<mrow>
  <munder>
    <mo>∑</mo>
    <mrow>
      <msub>
        <mi>y</mi>
        <mi>i</mi>
      </msub>
      <mo>≠</mo>
      <msub>
        <mi>y</mi>
        <mi>j</mi>
      </msub>
    </mrow>
  </munder>
  <mo>⁢</mo>
  <mstyle>
    <mspace width="0.3em" height="0.3ex"/>
  </mstyle>
  <mo>⁢</mo>
  <msub>
    <mi>K</mi>
    <mi>ij</mi>
  </msub>
</mrow>
</math>
</maths>
<br/>
is equivalent to maximizing
</p>
<p id="p-0096" num="0095">
<maths id="MATH-US-00026" num="00026">
<math overflow="scroll">
<mrow>
  <mrow>
    <munder>
      <mo>∑</mo>
      <mrow>
        <msub>
          <mi>y</mi>
          <mi>i</mi>
        </msub>
        <mo>=</mo>
        <msub>
          <mi>y</mi>
          <mi>j</mi>
        </msub>
      </mrow>
    </munder>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <msub>
      <mi>K</mi>
      <mi>ij</mi>
    </msub>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
which in turn is equivalent to minimizing the sum of the average square distances between all couples of points in the same class
</p>
<p id="p-0097" num="0096">
<maths id="MATH-US-00027" num="00027">
<math overflow="scroll">
<mrow>
  <munder>
    <mo>∑</mo>
    <mrow>
      <msub>
        <mi>y</mi>
        <mi>i</mi>
      </msub>
      <mo>=</mo>
      <msub>
        <mi>y</mi>
        <mi>j</mi>
      </msub>
    </mrow>
  </munder>
  <mo>⁢</mo>
  <mrow>
    <msup>
      <mrow>
        <mo></mo>
        <mrow>
          <mrow>
            <mi>ϕ</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <msub>
                <mi>x</mi>
                <mi>i</mi>
              </msub>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
            <mi>ϕ</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <msub>
                <mi>x</mi>
                <mi>j</mi>
              </msub>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo></mo>
      </mrow>
      <mn>2</mn>
    </msup>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
Furthermore, minimizing this quantity is equivalent to minimizing the sum of the average square distances of points from the class means since
</p>
<p id="p-0098" num="0097">
<maths id="MATH-US-00028" num="00028">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <munder>
              <mo>∑</mo>
              <mrow>
                <msub>
                  <mi>y</mi>
                  <mi>i</mi>
                </msub>
                <mo>=</mo>
                <mi>C</mi>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <msup>
              <mrow>
                <mo></mo>
                <mrow>
                  <mrow>
                    <mi>ϕ</mi>
                    <mo>⁡</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>x</mi>
                        <mi>i</mi>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mi>μ</mi>
                    <mo>(</mo>
                    <mstyle>
                      <mspace width="0.3em" height="0.3ex"/>
                    </mstyle>
                    <mo>⁢</mo>
                    <mi>C</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo></mo>
              </mrow>
              <mn>2</mn>
            </msup>
          </mrow>
          <mo>=</mo>
          <mrow>
            <msub>
              <mi>n</mi>
              <mi>C</mi>
            </msub>
            <mo>-</mo>
            <mrow>
              <mfrac>
                <mn>1</mn>
                <msub>
                  <mi>n</mi>
                  <mi>C</mi>
                </msub>
              </mfrac>
              <mo>⁢</mo>
              <mrow>
                <munder>
                  <mo>∑</mo>
                  <mrow>
                    <msub>
                      <mi>y</mi>
                      <mi>i</mi>
                    </msub>
                    <mo>=</mo>
                    <mrow>
                      <mi>C</mi>
                      <mo>=</mo>
                      <msub>
                        <mi>Y</mi>
                        <mi>j</mi>
                      </msub>
                    </mrow>
                  </mrow>
                </munder>
                <mo>⁢</mo>
                <mstyle>
                  <mspace width="0.3em" height="0.3ex"/>
                </mstyle>
                <mo>⁢</mo>
                <msub>
                  <mi>K</mi>
                  <mi>ij</mi>
                </msub>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>21</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mi>where</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.8em" height="0.8ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mi>μ</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mrow>
            <mo>(</mo>
            <mi>C</mi>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mfrac>
            <mn>1</mn>
            <msub>
              <mi>n</mi>
              <mi>C</mi>
            </msub>
          </mfrac>
          <mo>⁢</mo>
          <mrow>
            <munder>
              <mo>∑</mo>
              <mi>i</mi>
            </munder>
            <mo>⁢</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>⁢</mo>
            <mrow>
              <mrow>
                <mi>ϕ</mi>
                <mo>⁡</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>x</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>.</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
This approach is directed to finding clusters that have minimal “scatter” around their mean. Among other appealing properties of the alignment is that this quantity is sharply concentrated around its mean, thus showing that the expected alignment can be reliably estimated from its empirical estimate Â(S). Since the cut cost can be expressed as the difference of two alignments
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i>(<i>S,k,y</i>)=0.5(<i>T</i>(<i>S,k</i>)−<i>Â</i>(<i>S,K,y</i>)),  (22)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
cut cost will be similarly concentrated around its expected value.
</p>
<p id="p-0099" num="0098">To optimize the alignment, the problem is to find the best-aligned set of labels</p>
<p id="p-0100" num="0099">
<maths id="MATH-US-00029" num="00029">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mover>
            <mi>A</mi>
            <mo>^</mo>
          </mover>
          <mo>*</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>S</mi>
              <mo>,</mo>
              <mi>k</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mrow>
            <munder>
              <mi>max</mi>
              <mrow>
                <mi>y</mi>
                <mo>∈</mo>
                <msup>
                  <mrow>
                    <mo>{</mo>
                    <mrow>
                      <mrow>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mrow>
                        <mo>+</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                    <mo>}</mo>
                  </mrow>
                  <mi>m</mi>
                </msup>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mrow>
              <mover>
                <mi>A</mi>
                <mo>^</mo>
              </mover>
              <mo>⁡</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>S</mi>
                  <mo>,</mo>
                  <mi>k</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <munder>
              <mi>max</mi>
              <mrow>
                <mi>y</mi>
                <mo>∈</mo>
                <msup>
                  <mrow>
                    <mo>{</mo>
                    <mrow>
                      <mrow>
                        <mo>-</mo>
                        <mn>1</mn>
                      </mrow>
                      <mo>,</mo>
                      <mrow>
                        <mo>+</mo>
                        <mn>1</mn>
                      </mrow>
                    </mrow>
                    <mo>}</mo>
                  </mrow>
                  <mi>m</mi>
                </msup>
              </mrow>
            </munder>
            <mo>⁢</mo>
            <mrow>
              <mfrac>
                <msub>
                  <mrow>
                    <mo>〈</mo>
                    <mrow>
                      <mi>K</mi>
                      <mo>,</mo>
                      <msup>
                        <mi>yy</mi>
                        <mi>′</mi>
                      </msup>
                    </mrow>
                    <mo>〉</mo>
                  </mrow>
                  <mi>F</mi>
                </msub>
                <mrow>
                  <mi>m</mi>
                  <mo>⁢</mo>
                  <msqrt>
                    <msub>
                      <mrow>
                        <mo>〈</mo>
                        <mrow>
                          <mi>K</mi>
                          <mo>,</mo>
                          <mi>K</mi>
                        </mrow>
                        <mo>〉</mo>
                      </mrow>
                      <mi>F</mi>
                    </msub>
                  </msqrt>
                </mrow>
              </mfrac>
              <mo>.</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>23</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
Since in this setting the kernel is fixed, maximizing the alignment reduces to choosing yε{−1,+1}<sup>m </sup>to maximize (K, yy′)=y′Ky. If y is selected from the larger set R<sup>m </sup>subject to the constraint ∥y∥<sup>2</sup>=m, an approximate maximum alignment problem can be solved efficiently. After solving the relaxed problem, an approximate discrete solution can be obtained by choosing a suitable threshold to the entries in the vector y and applying a sign function. Bounds will be given on the quality of approximations.
</p>
<p id="p-0101" num="0100">Solution of the approximate problem follows from the Courant-Fischer Minimax Theorem (Equation 6, above), which provides a variational characterization of the spectrum of symmetric matrices.</p>
<p id="p-0102" num="0101">Looking at the first eigenvector, the first minimum does not apply, and the approximate alignment problem is solved by the first eigenvector, so that the maximal alignment is upper bounded by a multiple of the first eigenvalue,</p>
<p id="p-0103" num="0102">
<maths id="MATH-US-00030" num="00030">
<math overflow="scroll">
<mrow>
  <msub>
    <mi>λ</mi>
    <mi>max</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <munder>
      <mi>max</mi>
      <mrow>
        <mrow>
          <mn>0</mn>
          <mo>≠</mo>
          <mi>ν</mi>
        </mrow>
        <mo>∈</mo>
        <msup>
          <mi>R</mi>
          <mi>m</mi>
        </msup>
      </mrow>
    </munder>
    <mo>⁢</mo>
    <mrow>
      <mfrac>
        <mrow>
          <msup>
            <mi>ν</mi>
            <mi>′</mi>
          </msup>
          <mo>⁢</mo>
          <mi>K</mi>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <mi>ν</mi>
        </mrow>
        <mrow>
          <msup>
            <mi>v</mi>
            <mi>′</mi>
          </msup>
          <mo>⁢</mo>
          <mi>ν</mi>
        </mrow>
      </mfrac>
      <mo>.</mo>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
Vector v can now be transformed into a vector in {−1,+1}<sup>m </sup>by choosing the threshold θ that gives maximum alignment of y=sign(V<sup>max</sup>−θ). By definition, the value of alignment Â(S,k,y) obtained by this y will be a lower bound of the optimal alignment, such that
</p>
<p id="p-0104" num="0103">
<maths id="MATH-US-00031" num="00031">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mover>
            <mi>A</mi>
            <mo>^</mo>
          </mover>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>S</mi>
              <mo>,</mo>
              <mi>k</mi>
              <mo>,</mo>
              <mi>y</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>≤</mo>
        <mrow>
          <mover>
            <mi>A</mi>
            <mo>^</mo>
          </mover>
          <mo>*</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>S</mi>
              <mo>,</mo>
              <mi>k</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>≤</mo>
        <mrow>
          <mfrac>
            <msub>
              <mi>λ</mi>
              <mi>max</mi>
            </msub>
            <msub>
              <mrow>
                <mo></mo>
                <mi>K</mi>
                <mo></mo>
              </mrow>
              <mi>F</mi>
            </msub>
          </mfrac>
          <mo>.</mo>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>23</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
The quality of the dichotomy can be estimated by comparing its value with the upper bound. The absolute alignment indicates how special a kernel is on a given dataset: the higher the quantity, the more committed to a specific dichotomy.
</p>
<p id="p-0105" num="0104">The first eigenvector can be calculated in a number of ways. One example is the Lanczos procedure, an algorithm for computing the eigenvalues and eigenvectors for large symmetric sparse matrices which has been shown to be effective for very large datasets. (Given any n×n sparse symmetric matrix A, Lanczos computes a k×k symmetric tridiagonal matrix T, whose eigenvalues are good approximations of the eigenvalues of T, and whose eigenvectors can be used to get approximate eigenvectors of A. Building T requires k matrix-vector multiplications with A; which is typically the most expensive part of the algorithm. Ideally, one would obtain a good enough approximation with k much smaller than n, which means one only approximates a small subset of k of A's n eigenvalues. Fortunately, the ones which converge first are the largest and the smallest, including λ<sub>2</sub>.). To illustrate, Internet search engines such as Google® are based on estimating the first eigenvector of a matrix with dimensionality of more than 10<sup>9</sup>, so for very large datasets, there are effective approximation techniques.</p>
<p id="p-0106" num="0105">Training methods using the present invention can be unsupervised, semi-supervised, or supervised.</p>
<p id="p-0107" num="0106">Training according to the present invention using unlabeled data, i.e., unsupervised training, provides means for clustering the data. The choice of kernel automatically defines two classes in the unlabeled dataset by means of the sign of the second eigenvector. Successive eigenvectors can be used for further partitionings. A measure of the goodness of a given cluster is the second eigenvalue, or its alignment. Kernel parameters can be tuned to optimize it. This can be done in similar manner with a Laplacian.</p>
<p id="p-0108" num="0107">An algorithm for assessing the clustering power of a kernel follows the sequence:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0108">1) build K (the kernel matrix)</li>
        <li id="ul0002-0002" num="0109">2) build L (the Laplacian matrix)</li>
        <li id="ul0002-0003" num="0110">3) compute eigL (first eigenvector of L)</li>
        <li id="ul0002-0004" num="0111">4) find the number of clusters, i.e., the number of (approx.) zero eigenvalues.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0109" num="0112">For multiclass cases, the alignment is defined, however, y<sub>i</sub>y<sub>j </sub>should be replaced with y<sub>i</sub>==y<sub>j </sub>in the matrix to be compared against K. Again, this provides a measure of the clustering power of a kernel.</p>
<p id="p-0110" num="0113">In the case of semi-supervised training, perhaps the most interesting application of the present invention is to provide an effective procedure for transduction, the learning framework in which the algorithm is required to label a known set of unlabeled points given a set of labeled points.</p>
<p id="p-0111" num="0114">The labels that are known can be inserted into the kernel matrix as y<sub>i</sub>y<sub>j</sub>, i.e., the labels vector, while the other entries are set to (K<sub>i,j</sub>). If the kernel is bounded between MIN and MAX, then one should set to MIN the entries corresponding to different labels, and to MAX the ones corresponding to the same label.</p>
<p id="p-0112" num="0115">The kernel will be required to output the maximally-aligned solution consistent with the known labels. This can be obtained by the second eigenvector. Analogously, it can be done using the Laplacian, obtaining a minimum cut cost solution. In this case, one obtains an algorithm that is somewhat similar to the Graph Mincuts algorithm for performing semi-labeled learning. (See, e.g., A. Blum and S. Chawla, “Learning from Labeled and Unlabeled Data Using Graph Mincuts”, 18<sup>th </sup>International Conference on Machine Learning, Jun. 28-Jul. 1, 2001, which is incorporated herein by reference. Note, however, that this reference uses neither kernels nor spectral graph theory, nor does it mention transduction.)</p>
<p id="p-0113" num="0116">In application of the present invention to supervised classification, the solution is completely determined once the kernel is selected. The training consists of optimizing the kernel parameters, thus reducing the training error of the adjacency eigenvector solution. The process is similar for the Laplacian. Concentration of the cost functions will provide good performance in the test phase. Given a test set, one can be confident that the eigenvector solution will identify a split similarly matching the one given by the labels.</p>
<p id="p-0114" num="0117">Assessment of kernel quality using model selection can be used in conjunction with any other kernel-based learning method. One can use the absolute alignment as a measure of the fitness of a kernel and, hence, choose the kernel parameters to maximize it. Expressing the derivative of the second eigenvalue as a function of the tunable parameters would result in direct optimization of the kernel. Tuning of kernel parameters will provide more aligned solutions. A SVM would benefit from such an aligned kernel.</p>
<p id="p-0115" num="0118">Novelty detection can be achieved using the first eigenvector of the adjacency matrix, which produces a ranking of the data items based on their “typicity” or popularity. The points that are more clustered in feature space will receive a higher ranking, while isolated points receive a very low ranking. Such a procedure can serve as a data cleaning technique, anomaly detection or other identification of “dirty data”, and, thus, may be used in a pre-processing step prior to SVM (or other kernel machine) analysis to clean the data by removing or correcting the dirty data. The entropy of this eigenvector, or the relation between the two first eigenvalues, can give a measure of how connected the graph is, or how organized the data are in feature space. The same method can be used for data cleaning by considering the labels as another feature and by spotting rare combinations of x and y.</p>
<p id="p-0116" num="0119">The present invention combines results from spectral graph theory with the concept of the kernel function to obtain a new class of learning algorithms for supervised, semi-supervised, and unsupervised learning. Methods can be developed for automatically tuning parameters by working out the gradient of eigenvalues or alignment with respect to the parameters, or by technique akin to lifting, which is discussed above. Also, kernel adaptation can be performed to rotate a second eigenvector to align with a given set of labels. Higher order eigenvectors can be exploited for further refining partitions and for obtaining greater robustness against noise.</p>
<p id="p-0117" num="0120">To demonstrate the performance of the present invention, two binary classification datasets were used: The Wisconsin breast cancer dataset, obtained from the University of Wisconsin hospitals, which contains nine integer values inputs, a single binary output (benign or malignant) and 699 datapoints; and the ionosphere dataset available from the UCI (University of California, Irvine) Machine Learning Repository, which contains 34 inputs, a single binary output and 351 datapoints. The data was pre-processed by first normalizing the input vectors in the kernel-defined feature space, then centering them by shifting the origin (of the feature space) to their center of gravity. Pre-processing was performed by the following transformation of the kernel matrix:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>K←K−m</i><sup>−1</sup><i>jg′−m</i><sup>−1</sup><i>gj′+m</i><sup>−2</sup><i>j′KjJ</i>  (24)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
where j is the all one vector, J the all ones matrix, and g the vector of row sums of K.
</p>
<heading id="h-0007" level="1">EXAMPLE 1</heading>
<p id="p-0118" num="0121">Using the breast cancer dataset, the unsupervised technique was applied with a linear kernel, with alignment being optimized. <figref idref="DRAWINGS">FIG. 1(</figref><i>a</i>) is a plot of the alignment of the different eigenvectors with the labels in order of increasing eigenvalue. The highest alignment is shown by the last eigenvector corresponding to the largest eigenvalue. For each value θ<sub>i </sub>of the threshold, <figref idref="DRAWINGS">FIG. 1(</figref><i>b</i>) shows the upper bound of λ<sub>max</sub>/∥K∥<sub>F </sub>(the straight line at the top), the alignment Â(S,k,y) for y=sign(v<sup>max</sup>−θ<sub>i</sub>) (the bottom curve), and the accuracy of y (the middle curve). Where actual alignment and upper bound on alignment are the closest, there is confidence that the data has been partitioned well, and that accuracy is maximized. The choice of the threshold corresponds to maintaining the correct proportion between positives and negatives. Another possible threshold strategy is based on the availability of enough labeled points to provide a good estimate of the proportion of positive points in the dataset. In this way, label information can be used to select the threshold.</p>
<heading id="h-0008" level="1">EXAMPLE 2</heading>
<p id="p-0119" num="0122">Using the same breast cancer dataset as in Example 1, a Gaussian kernel (σ=6) was used. As above, alignment was optimized. In this case, the accuracy obtained by optimizing the alignment was less impressive. For the breast cancer dataset (threshold number <b>316</b>), the accuracy was about 79.65%, as shown in <figref idref="DRAWINGS">FIG. 2</figref>, where the straight line at the top shows the upper bound of λ<sub>max</sub>/∥K∥<sub>F</sub>, alignment Â(S,k,y) for y=sign(v<sup>max</sup>−θ<sub>i</sub>) is shown in the bottom (dashed) curve, and the accuracy of y is plotted in the middle curve.</p>
<heading id="h-0009" level="1">EXAMPLE 3</heading>
<p id="p-0120" num="0123">For the ionosphere dataset using a linear kernel and optimized alignment, the accuracy split that optimizes the alignment (threshold number <b>158</b>) is approximately 71.37%. For each value θ<sub>i </sub>of the threshold, <figref idref="DRAWINGS">FIG. 3</figref> shows the upper bound of λ<sub>max</sub>/∥K∥<sub>F </sub>(the straight line at the top), the alignment Â(S,k,y) for y=sign(v<sup>max</sup>−θ<sub>i</sub>) (the bottom (dashed) curve), and the accuracy of y (the middle curve).</p>
<p id="p-0121" num="0124">An overall approach can be used to adapt the kernel to the data. For example, the kernel parameters can be chosen so as to optimize λmax/∥K∥<sub>F</sub>. Then, find the first eigenvector, choose a threshold to maximize the alignment, and output the corresponding y. The cost to the alignment of changing a label y<sub>i </sub>is</p>
<p id="p-0122" num="0125">
<maths id="MATH-US-00032" num="00032">
<math overflow="scroll">
<mrow>
  <mfrac>
    <mrow>
      <mn>2</mn>
      <mo>⁢</mo>
      <mstyle>
        <mspace width="0.3em" height="0.3ex"/>
      </mstyle>
      <mo>⁢</mo>
      <mrow>
        <munder>
          <mo>∑</mo>
          <mi>j</mi>
        </munder>
        <mo>⁢</mo>
        <mrow>
          <msub>
            <mi>y</mi>
            <mi>j</mi>
          </msub>
          <mo>⁢</mo>
          <mrow>
            <mi>k</mi>
            <mo>⁡</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <msub>
                  <mi>x</mi>
                  <mi>i</mi>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>x</mi>
                  <mi>j</mi>
                </msub>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
    <msub>
      <mrow>
        <mo></mo>
        <mi>K</mi>
        <mo></mo>
      </mrow>
      <mi>F</mi>
    </msub>
  </mfrac>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
so that if a point is isolated from the others, or if it is equally close to the two different classes, then changing its label will have only a small effect. On the other hand, labels in strongly clustered points clearly contribute to the overall cost such that changing their label will alter the alignment significantly.
</p>
<p id="p-0123" num="0126">The method described herein can be viewed as projecting the data into a 1-dimensional space and finding a threshold. The projection also implicitly sorts the data so that points from the same class are nearby in the ordering. The problem is addressed in the 2-class class. The set is embedded into the real line so as to satisfy a clustering criterion. The resulting kernel matrix should appear as a block diagonal matrix.</p>
<p id="p-0124" num="0127">Let the coordinate of the point x<sub>i </sub>on the real line be v(i). The cost function</p>
<p id="p-0125" num="0128">
<maths id="MATH-US-00033" num="00033">
<math overflow="scroll">
<mrow>
  <munder>
    <mo>∑</mo>
    <mi>ij</mi>
  </munder>
  <mo>⁢</mo>
  <mrow>
    <mrow>
      <mi>v</mi>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mi>i</mi>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <mi>v</mi>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mi>j</mi>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>⁢</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
    <mo>⁢</mo>
    <mrow>
      <mi>K</mi>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>i</mi>
          <mo>,</mo>
          <mi>j</mi>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
is maximized when points with high similarity have the same sign and high absolute value, and when points with different sign have low similarity. The choice of coordinates v that optimizes the cost function is the first eigenvector. Thus, by sorting the data according to the value of their entry in this eigenvector, a good permutation should be found which renders the kernel matrix block diagonal.
</p>
<heading id="h-0010" level="1">EXAMPLE 4</heading>
<p id="p-0126" num="0129">Using the breast cancer dataset with both linear and Gaussian kernel, cut cost (see Equation 5) was used to select the best threshold. The results are plotted in <figref idref="DRAWINGS">FIGS. 4(</figref><i>a</i>) and (<i>b</i>), where cut cost C(S, k, y)−λ/(2∥K∥<sub>F </sub>for y=sign(v<sup>max</sup>−θ<sub>i</sub>) is indicated by the dashed curve and error rate of y against threshold i is indicated by the solid curve. For the linear kernel, <figref idref="DRAWINGS">FIG. 4(</figref><i>a</i>), the threshold was set at 378 with an accuracy of 67.86%, which is significantly worse than the results obtained by optimizing the alignment. With the Gaussian kernel, <figref idref="DRAWINGS">FIG. 4(</figref><i>b</i>), the method selects threshold <b>312</b> with an accuracy of 80.31%, a slight improvement over the results obtained with the Gaussian kernel by optimizing the alignment.</p>
<p id="p-0127" num="0130">Thus far, the examples use unsupervised data. Transduction, or semi-supervised learning, can be performed if the dataset is partially labeled. The idea that some labeled data could improve performance comes from observing <figref idref="DRAWINGS">FIG. 4(</figref><i>b</i>), where the selection based on the cut cost is suboptimal. By incorporating some label information, improved threshold selection can be achieved.</p>
<p id="p-0128" num="0131">Let z be the vector containing known labels and 0 elsewhere. Set KP=K+C<sub>0</sub>zz′, where C<sub>0 </sub>is a positive constant parameter. The original matrix K is used to generate the eigenvector, while the matrix KP is used when measuring the cut cost of the classifications generated by different thresholds. Taking C<sub>0</sub>=1, 5 random selections of 20% of the data were performed, obtaining a mean success rate of 85.56% (standard deviation of 0.67%) for the breast cancer dataset with the Gaussian kernel, a marked improvement over the 80.31% obtained with no label information.</p>
<p id="p-0129" num="0132">The spectral kernel method of the present invention can be utilized for a wide range of kernel-based learning machines. In an exemplary embodiment, the spectral kernel is used in conjunction with one or more support vector machines. A suitable computing environment for implementing the exemplary support vector machine is illustrated in <figref idref="DRAWINGS">FIG. 5</figref> and incorporates a conventional personal computer <b>1000</b>. Nonetheless, those skilled in the art will recognize that the invention also may be implemented using other types of computer system configurations. The computer <b>1000</b> includes a central processing unit <b>1022</b>, a system memory <b>1020</b>, and an Input/Output (I/O) bus <b>1026</b>. A system bus <b>1021</b> couples the central processing unit <b>1022</b> to the system memory <b>1020</b>. A bus controller <b>1023</b> controls the flow of data on the I/O bus <b>1026</b> and between the central processing unit <b>1022</b> and a variety of internal and external I/O devices. The I/O devices connected to the I/O bus <b>1026</b> may have direct access to the system memory <b>1020</b> using a Direct Memory Access (“DMA”) controller <b>1024</b>.</p>
<p id="p-0130" num="0133">The I/O devices are connected to the I/O bus <b>1026</b> via a set of device interfaces. The device interfaces may include both hardware components and software components. For instance, a hard disk drive <b>1030</b> and a floppy disk drive <b>1032</b> for reading or writing removable media <b>1050</b> may be connected to the I/O bus <b>1026</b> through disk drive controllers <b>1040</b>. An optical disk drive <b>1034</b> for reading or writing optical media <b>1052</b> may be connected to the I/O bus <b>1026</b> using a Small Computer System Interface (“SCSI”) <b>1041</b>. Alternatively, an IDE (Integrated Drive Electronics, i.e., a hard disk drive interface for PCs), ATAPI (ATtAchment Packet Interface, i.e., CD-ROM and tape drive interface), or EIDE (Enhanced IDE) interface may be associated with an optical drive such as may be the case with a CD-ROM drive. The drives and their associated computer-readable media provide nonvolatile storage for the computer <b>1000</b>. In addition to the computer-readable media described above, other types of computer-readable media may also be used, such as ZIP drives, or the like.</p>
<p id="p-0131" num="0134">A display device <b>1053</b>, such as a monitor, is connected to the I/O bus <b>1026</b> via another interface, such as a video adapter <b>1042</b>. A parallel interface <b>1043</b> connects synchronous peripheral devices, such as a laser printer <b>1056</b>, to the I/O bus <b>1026</b>. A serial interface <b>1044</b> connects communication devices to the I/O bus <b>1026</b>. A user may enter commands and information into the computer <b>1000</b> via the serial interface <b>1044</b> or by using an input device, such as a keyboard <b>1038</b>, a mouse <b>1036</b> or a modem <b>1057</b>. Other peripheral devices (not shown) may also be connected to the computer <b>1000</b>, such as audio input/output devices or image capture devices.</p>
<p id="p-0132" num="0135">A number of program modules may be stored on the drives and in the system memory <b>1020</b>. The system memory <b>1020</b> can include both Random Access Memory (“RAM”) and Read Only Memory (“ROM”). The program modules control how the computer <b>1000</b> functions and interacts with the user, with I/O devices or with other computers. Program modules include routines, operating systems <b>1065</b>, application programs, data structures, and other software or firmware components. In an illustrative embodiment, the learning machine may comprise one or more pre-processing program modules <b>1075</b>A, one or more post-processing program modules <b>1075</b>B, and/or one or more optimal categorization program modules <b>1077</b> and one or more SVM program modules <b>1070</b> stored on the drives or in the system memory <b>1020</b> of the computer <b>1000</b>. A plurality of SVMs can be configured to hierarchically process multiple data sets in parallel or sequentially. Specifically, pre-processing program modules <b>1075</b>A, post-processing program modules <b>1075</b>B, together with the SVM program modules <b>1070</b> may comprise computer-executable instructions for pre-processing data and post-processing output from a learning machine and implementing the learning algorithm.</p>
<p id="p-0133" num="0136">The computer <b>1000</b> may operate in a networked environment using logical connections to one or more remote computers, such as remote computer <b>1060</b>. The remote computer <b>1060</b> may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described in connection with the computer <b>1000</b>. In a networked environment, program modules and data may be stored on the remote computer <b>1060</b>. The logical connections depicted in <figref idref="DRAWINGS">FIG. 8</figref> include a local area network (“LAN”) <b>1054</b> and a wide area network (“WAN”) <b>1055</b>. In a LAN environment, a network interface <b>1045</b>, such as an Ethernet adapter card, can be used to connect the computer <b>1000</b> to the remote computer <b>1060</b>. In a WAN environment, the computer <b>1000</b> may use a telecommunications device, such as a modem <b>1057</b>, to establish a connection. It will be appreciated that the network connections shown are illustrative and other devices of establishing a communications link between the computers may be used.</p>
<p id="p-0134" num="0137">Alternative embodiments of the present invention will become apparent to those having ordinary skill in the art to which the present invention pertains. Such alternate embodiments are considered to be encompassed within the spirit and scope of the present invention. Accordingly, the scope of the present invention is to be limited solely by the appended claims, which are supported by the foregoing exemplary embodiments of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US07299213-20071120-M00001.NB">
<img id="EMI-M00001" he="6.35mm" wi="76.20mm" file="US07299213-20071120-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US07299213-20071120-M00002.NB">
<img id="EMI-M00002" he="7.03mm" wi="76.20mm" file="US07299213-20071120-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00003" nb-file="US07299213-20071120-M00003.NB">
<img id="EMI-M00003" he="11.68mm" wi="76.20mm" file="US07299213-20071120-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00004" nb-file="US07299213-20071120-M00004.NB">
<img id="EMI-M00004" he="8.81mm" wi="76.20mm" file="US07299213-20071120-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00005" nb-file="US07299213-20071120-M00005.NB">
<img id="EMI-M00005" he="7.45mm" wi="76.20mm" file="US07299213-20071120-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00006" nb-file="US07299213-20071120-M00006.NB">
<img id="EMI-M00006" he="7.79mm" wi="76.20mm" file="US07299213-20071120-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00007" nb-file="US07299213-20071120-M00007.NB">
<img id="EMI-M00007" he="7.45mm" wi="76.20mm" file="US07299213-20071120-M00007.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00008" nb-file="US07299213-20071120-M00008.NB">
<img id="EMI-M00008" he="37.76mm" wi="76.20mm" file="US07299213-20071120-M00008.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00009" nb-file="US07299213-20071120-M00009.NB">
<img id="EMI-M00009" he="8.81mm" wi="76.20mm" file="US07299213-20071120-M00009.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00010" nb-file="US07299213-20071120-M00010.NB">
<img id="EMI-M00010" he="8.13mm" wi="76.20mm" file="US07299213-20071120-M00010.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00011" nb-file="US07299213-20071120-M00011.NB">
<img id="EMI-M00011" he="7.79mm" wi="76.20mm" file="US07299213-20071120-M00011.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00012" nb-file="US07299213-20071120-M00012.NB">
<img id="EMI-M00012" he="7.03mm" wi="76.20mm" file="US07299213-20071120-M00012.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00013" nb-file="US07299213-20071120-M00013.NB">
<img id="EMI-M00013" he="7.03mm" wi="76.20mm" file="US07299213-20071120-M00013.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00014" nb-file="US07299213-20071120-M00014.NB">
<img id="EMI-M00014" he="7.45mm" wi="76.20mm" file="US07299213-20071120-M00014.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00015" nb-file="US07299213-20071120-M00015.NB">
<img id="EMI-M00015" he="6.35mm" wi="76.20mm" file="US07299213-20071120-M00015.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00016" nb-file="US07299213-20071120-M00016.NB">
<img id="EMI-M00016" he="7.79mm" wi="76.20mm" file="US07299213-20071120-M00016.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00017" nb-file="US07299213-20071120-M00017.NB">
<img id="EMI-M00017" he="6.69mm" wi="76.20mm" file="US07299213-20071120-M00017.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00018" nb-file="US07299213-20071120-M00018.NB">
<img id="EMI-M00018" he="6.69mm" wi="76.20mm" file="US07299213-20071120-M00018.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00019" nb-file="US07299213-20071120-M00019.NB">
<img id="EMI-M00019" he="6.69mm" wi="76.20mm" file="US07299213-20071120-M00019.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00020" nb-file="US07299213-20071120-M00020.NB">
<img id="EMI-M00020" he="6.69mm" wi="76.20mm" file="US07299213-20071120-M00020.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00021" nb-file="US07299213-20071120-M00021.NB">
<img id="EMI-M00021" he="8.81mm" wi="76.20mm" file="US07299213-20071120-M00021.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00022" nb-file="US07299213-20071120-M00022.NB">
<img id="EMI-M00022" he="8.81mm" wi="76.20mm" file="US07299213-20071120-M00022.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00023" nb-file="US07299213-20071120-M00023.NB">
<img id="EMI-M00023" he="13.38mm" wi="76.20mm" file="US07299213-20071120-M00023.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00024" nb-file="US07299213-20071120-M00024.NB">
<img id="EMI-M00024" he="12.36mm" wi="76.20mm" file="US07299213-20071120-M00024.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00025" nb-file="US07299213-20071120-M00025.NB">
<img id="EMI-M00025" he="7.79mm" wi="76.20mm" file="US07299213-20071120-M00025.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00026" nb-file="US07299213-20071120-M00026.NB">
<img id="EMI-M00026" he="7.79mm" wi="76.20mm" file="US07299213-20071120-M00026.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00027" nb-file="US07299213-20071120-M00027.NB">
<img id="EMI-M00027" he="7.79mm" wi="76.20mm" file="US07299213-20071120-M00027.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00028" nb-file="US07299213-20071120-M00028.NB">
<img id="EMI-M00028" he="18.03mm" wi="76.20mm" file="US07299213-20071120-M00028.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00029" nb-file="US07299213-20071120-M00029.NB">
<img id="EMI-M00029" he="8.81mm" wi="76.20mm" file="US07299213-20071120-M00029.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00030" nb-file="US07299213-20071120-M00030.NB">
<img id="EMI-M00030" he="7.03mm" wi="76.20mm" file="US07299213-20071120-M00030.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00031" nb-file="US07299213-20071120-M00031.NB">
<img id="EMI-M00031" he="7.03mm" wi="76.20mm" file="US07299213-20071120-M00031.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00032" nb-file="US07299213-20071120-M00032.NB">
<img id="EMI-M00032" he="10.58mm" wi="76.20mm" file="US07299213-20071120-M00032.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00033" nb-file="US07299213-20071120-M00033.NB">
<img id="EMI-M00033" he="7.45mm" wi="76.20mm" file="US07299213-20071120-M00033.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00034" nb-file="US07299213-20071120-M00034.NB">
<img id="EMI-M00034" he="7.45mm" wi="76.20mm" file="US07299213-20071120-M00034.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00035" nb-file="US07299213-20071120-M00035.NB">
<img id="EMI-M00035" he="8.47mm" wi="76.20mm" file="US07299213-20071120-M00035.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00036" nb-file="US07299213-20071120-M00036.NB">
<img id="EMI-M00036" he="8.81mm" wi="76.20mm" file="US07299213-20071120-M00036.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>What is claimed:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for extracting information from a dataset comprising identifying significant features within the dataset containing data items, at least a portion of which comprise irrelevant detail, wherein at least a portion of the data items in the dataset have associated labels, comprising:
<claim-text>downloading the dataset into a memory of a computer having a processor for executing a plurality of clustering kernels;</claim-text>
<claim-text>filling a pairwise similarity matrix K in the memory for all pairs of data items i and j in the dataset;</claim-text>
<claim-text>applying the plurality of clustering kernels to the dataset in the memory to define distinct clusters of datapoints in feature space;</claim-text>
<claim-text>determining an alignment between the clusters in feature space according to the relationship</claim-text>
</claim-text>
<claim-text>
<maths id="MATH-US-00034" num="00034">
<math overflow="scroll">
<mrow>
  <mrow>
    <mover>
      <mi>A</mi>
      <mo>^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mrow>
          <mi>i</mi>
          <mo>,</mo>
          <mi>j</mi>
        </mrow>
      </munder>
      <mo>⁢</mo>
      <mrow>
        <msub>
          <mi>y</mi>
          <mi>i</mi>
        </msub>
        <mo>⁢</mo>
        <msub>
          <mi>y</mi>
          <mi>j</mi>
        </msub>
        <mo>⁢</mo>
        <mrow>
          <mi>K</mi>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>i</mi>
              <mo>,</mo>
              <mi>j</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
</claim-text>
<claim-text>where y<sub>i</sub>y<sub>j </sub>is a labels vector;
<claim-text>selecting for execution by the processor the clustering kernel in the memory that produces a maximally aligned solution that is consistent with the labels; and</claim-text>
<claim-text>separating the significant features from the irrelevant detail in the memory by processing</claim-text>
<claim-text>the data items in the dataset using the selected kernel;</claim-text>
<claim-text>generating an output in the memory comprising the significant features identified by the selected kernel; and</claim-text>
<claim-text>transferring the output from the memory to a media.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the selected kernel comprises a support vector machine.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>calculating a first eigenvector of the matrix K; and</claim-text>
<claim-text>ranking the data items in the memory based upon their clustering, wherein data items that are more clustered in feature space are deemed more significant features and are assigned a higher ranking and data items that are isolated are deemed irrelevant details and have a lower ranking.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising, after the step of ranking the data items:
<claim-text>removing from the memory or correcting the lower ranking data items in the memory to produce a modified dataset; and</claim-text>
<claim-text>analyzing the modified dataset using a kernel machine.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the kernel machine comprises a support vector machine.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the dataset comprises cancer data comprising data items corresponding to a binary output value of either benign or malignant.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a separate portion of the data items in the dataset comprises unlabeled data and the cluster kernel further acts to assign labels to the unlabeled data.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising displaying the output on a display device.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the media comprises a disk drive or a removable media.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method for extracting information within a dataset comprising identifying significant features within the data set, at least a portion of which comprises irrelevant detail, comprising:
<claim-text>inputting a memory resident data set S into a processor for executing a plurality of clustering kernels;</claim-text>
<claim-text>using each of the plurality of kernels, mapping points of the data set into a feature space to generate a plurality of kernel matrices in the memory;</claim-text>
<claim-text>calculating an alignment of a first kernel k<sub>1 </sub>with a second kernel k<sub>2 </sub>with respect to the data set S according to the relationship</claim-text>
</claim-text>
<claim-text>
<maths id="MATH-US-00035" num="00035">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <mover>
        <mi>A</mi>
        <mo>^</mo>
      </mover>
      <mo>⁡</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>S</mi>
          <mo>,</mo>
          <msub>
            <mi>k</mi>
            <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
            <mi>k</mi>
            <mn>2</mn>
          </msub>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
      <msub>
        <mrow>
          <mo>〈</mo>
          <mrow>
            <msub>
              <mi>K</mi>
              <mn>1</mn>
            </msub>
            <mo>,</mo>
            <msub>
              <mi>K</mi>
              <mn>2</mn>
            </msub>
          </mrow>
          <mo>〉</mo>
        </mrow>
        <mi>F</mi>
      </msub>
      <msqrt>
        <mrow>
          <msub>
            <mrow>
              <mo>〈</mo>
              <mrow>
                <msub>
                  <mi>K</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>K</mi>
                  <mn>1</mn>
                </msub>
              </mrow>
              <mo>〉</mo>
            </mrow>
            <mi>F</mi>
          </msub>
          <mo>⁢</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>⁢</mo>
          <msub>
            <mrow>
              <mo>〈</mo>
              <mrow>
                <msub>
                  <mi>K</mi>
                  <mn>2</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>K</mi>
                  <mn>2</mn>
                </msub>
              </mrow>
              <mo>〉</mo>
            </mrow>
            <mi>F</mi>
          </msub>
        </mrow>
      </msqrt>
    </mfrac>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
</claim-text>
<claim-text>where k<sub>i </sub>is the kernel matrix for the data set S using the kernel k<sub>i</sub>, an inner product between kernel matrices</claim-text>
<claim-text>
<maths id="MATH-US-00036" num="00036">
<math overflow="scroll">
<mrow>
  <mrow>
    <msub>
      <mrow>
        <mo>〈</mo>
        <mrow>
          <msub>
            <mi>K</mi>
            <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
            <mi>K</mi>
            <mn>2</mn>
          </msub>
        </mrow>
        <mo>〉</mo>
      </mrow>
      <mi>F</mi>
    </msub>
    <mo>=</mo>
    <mrow>
      <munderover>
        <mo>∑</mo>
        <mrow>
          <mi>i</mi>
          <mo>,</mo>
          <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
        </mrow>
        <mi>m</mi>
      </munderover>
      <mo>⁢</mo>
      <mrow>
        <mrow>
          <msub>
            <mi>K</mi>
            <mn>1</mn>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>x</mi>
                <mi>i</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>x</mi>
                <mi>j</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>⁢</mo>
        <mstyle>
          <mspace width="0.3em" height="0.3ex"/>
        </mstyle>
        <mo>⁢</mo>
        <mrow>
          <msub>
            <mi>K</mi>
            <mn>2</mn>
          </msub>
          <mo>⁡</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>x</mi>
                <mi>i</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>x</mi>
                <mi>j</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
</claim-text>
<claim-text>and F refers to the Frobenius norm corresponding to the inner product; and
<claim-text>selecting for execution by the processor the kernel in the memory producing the best alignment with the data set S;</claim-text>
<claim-text>processing the data set S using the selected kernel to separate the significant features from the irrelevant detail for extracting information from the data; and</claim-text>
<claim-text>transferring the significant features to a media.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the selected kernel comprises a support vector machine.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the data set S comprises cancer data comprising data items corresponding to a binary output value of either benign or malignant.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein a first portion of the dataset comprises labeled data and a second portion of the dataset comprises unlabeled data, and wherein the kernel further acts to assign labels to the unlabeled data.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising displaying the output on a display device.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the media comprises a disk drive or a removable media.</claim-text>
</claim>
</claims>
</us-patent-grant>
