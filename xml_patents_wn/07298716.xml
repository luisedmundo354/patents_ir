<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298716-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298716</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10702748</doc-number>
<date>20031106</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>729</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>B</subclass>
<main-group>7</main-group>
<subgroup>212</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>370321</main-classification>
<further-classification>370329</further-classification>
<further-classification>370331</further-classification>
<further-classification>370338</further-classification>
<further-classification>455 412</further-classification>
<further-classification>455 417</further-classification>
<further-classification>455450</further-classification>
<further-classification>4554521</further-classification>
<further-classification>4555531</further-classification>
<further-classification>4555562</further-classification>
</classification-national>
<invention-title id="d0e53">Clustering based load adaptive sleeping protocol for ad hoc networks</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5008879</doc-number>
<kind>A</kind>
<name>Fischer et al.</name>
<date>19910400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370401</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6041046</doc-number>
<kind>A</kind>
<name>Scott et al.</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370319</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7009991</doc-number>
<kind>B2</kind>
<name>Shachar et al.</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370436</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2002/0132603</doc-number>
<kind>A1</kind>
<name>Lindskog et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>455343</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2003/0210658</doc-number>
<kind>A1</kind>
<name>Hernandez et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370311</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00006">
<othercit>Ye et al. “Medium Access Control with Coordinated. Adaptive Sleeping for Wireless Sensor Networks”., Jan. 2003. USC/ISI.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>“Power-Saving Protocols for IEEE 802.11-Based Multi-Hop Ad Hoc Networks,” Yu-Chee Tseng, et al., Proceedings of IEEE INFOCOM 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>“Medium Access Control with Coordinated, Adaptive Sleeping for Wireless Sensor Networks,” Wei Ye, et al., USC/Information Sciences Institute, Jan. 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00009">
<othercit>“Multicluster, mobile, multimedia radio network,” Mario Gerla et al., Wireless Networks 1 (1995), pp. 255-265.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00010">
<othercit>“An Ad Hoc Network with Mobile Backbones,” Kaixin Xu, et al., IEEE ICC 2002, New York, NY, Apr. 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>23</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>455 411</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>455 412</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>455 413</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>4555531</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>4555562</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>455450-4521</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>455507</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370329</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370331</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370338</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370321</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>6</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050117530</doc-number>
<kind>A1</kind>
<date>20050602</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Abraham</last-name>
<first-name>Santosh P.</first-name>
<address>
<city>Keasbey</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Chuah</last-name>
<first-name>Mooi Choo</first-name>
<address>
<city>Marlboro</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Lucent Technologies Inc.</orgname>
<role>02</role>
<address>
<city>Murray Hill</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>D'Agosta</last-name>
<first-name>Steve M.</first-name>
<department>2617</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A clustering based load adaptive sleeping protocol for ad hoc networks includes a plurality of nodes forming a cluster, where the nodes in the cluster are partitioned into n groups. This partitioning is performed based on the node ID (e.g. node_id modulo n). The cluster head transmits a beacon at fixed intervals. The beacon interval is divided into N slots, where N is a multiple of n. Node sleep/activation times are synchronized to the beacon interval slots. The node's group number is used to determine the slots within a beacon interval that a node begins it s sleep cycle. Therefore, no additional signaling is required between nodes to indicate sleep patterns. The sleeping time of each node may be increased when extended periods of inactivity are detected according to an adaptive procedure.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="144.70mm" wi="235.97mm" file="US07298716-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="236.90mm" wi="144.70mm" orientation="landscape" file="US07298716-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="180.42mm" wi="154.86mm" file="US07298716-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="236.90mm" wi="188.98mm" file="US07298716-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="267.80mm" wi="174.24mm" file="US07298716-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="240.45mm" wi="186.94mm" file="US07298716-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF INVENTION</heading>
<p id="p-0002" num="0001">The present invention relates to network management. More specifically, the invention relates to adapting sleep intervals to traffic loads for nodes in ad hoc networks.</p>
<heading id="h-0002" level="1">BACKGROUND OF INVENTION</heading>
<p id="p-0003" num="0002">An ad hoc network comprises portable wireless devices (nodes) that do not require fixed infrastructure. Wireless devices may become part of the network when they are located within the range of another node in the network. Each node in the ad hoc network may serve as a client, host, or router. The nodes are mobile devices, such as laptop computers, PDAs, among other mobile communication devices.</p>
<p id="p-0004" num="0003">Currently, a number of wireless technologies exist for supporting ad hoc networks, including those operating under the Bluetooth, Infrared Data Association (IrDA), HiperLAN, and 802.11 standards. Potential applications of ad hoc networks illustratively include battlefield networks, emergency networks in disaster areas, among other network environments not requiring a stationary communications device, such as a base station for establishing communications between mobile devices.</p>
<p id="p-0005" num="0004">The mobile nodes rely on battery power to operate, and consequently have power limitations. In order to extend the battery life for such wireless devices, various sleeping protocols have been implemented to force the nodes to turn off their radios when extended periods of communication inactivity are detected.</p>
<p id="p-0006" num="0005">A node (host) in the active mode is fully powered, and thus may transmit and receive at any time. By contrast, a host operating in a power saving (sleep) mode, illustratively under the 802.11 standard, only wakes up periodically to check for possible incoming packets from other nodes. The nodes are grouped into clusters, where one of the nodes is selected as a cluster-head node, as conventionally known in the art. Periodically, the cluster-head transmits beacon frames spaced by a fixed beacon interval. Each beacon frame, delivers a traffic indication map (TIM), which contains ID's of those nodes with buffered unicast packets stored in the cluster-head. A node hearing its ID will stay awake for the remaining beacon interval.</p>
<p id="p-0007" num="0006">Various sleeping protocols have been proposed to coordinate the sleep time of nodes. For example, one approach has been to impose a power saving mode to stay awake at for at least half of a beacon interval in each beacon interval. Accordingly, each node is awake long enough to ensure that neighboring nodes are aware of each others presence, such that buffered packets may be delivered, as required. However, since the clocks between the various nodes are not synchronized, this sleeping protocol requires that each host must stay in the active state more than half of the time, which is not very efficient for saving power.</p>
<p id="p-0008" num="0007">Another proposed sleeping protocol is a “periodically-fully-awake-interval protocol. In this protocol, two types of beacon intervals are provided. The first interval is a low power interval protocol, where the length of the active window is reduced to the minimum, and the second interval is a fully-awake interval protocol, where the length of the active window is extended to the maximum. Since fully-awake intervals require a lot of power, they only appear periodically and are interleaved by low-power intervals. Although the energy required may be significantly reduced by using either of these two sleeping protocols, a node must still contend with other nodes to send a beacon in each beacon interval. Therefore, there is a need in the art for an improved sleeping protocol for ad hoc networks.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0009" num="0008">Accordingly, we have recognized that there is a need for a clustering based load adaptive sleeping protocol for ad hoc networks. In one embodiment, we eliminate the need for synchronization between users and do not require each user to transmit a beacon. Instead, we exploit the structure provided by node clustering to produce the framework for the protocol to operate. In a cluster, the nodes are partitioned into n groups. This partitioning is performed based on the node ID (e.g. node_id modulo n). The cluster head transmits a beacon at fixed intervals (BI). The beacon interval is divided into N slots, where N is a multiple of n. Node sleep/activation times are synchronized to the beacon interval slots. The node's group number is used to determine the slots within a beacon interval that a node begins it s sleep cycle. Therefore, no additional signaling is required between nodes to indicate sleep patterns. The sleeping time of each node may be increased when extended periods of inactivity are detected according to an adaptive procedure.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0010" num="0009">The teachings of the present invention can be readily understood by considering the following detailed description in conjunction with the accompanying drawings, in which:</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 1</figref> depicts a schematic diagram of a plurality of clusters forming an ad hoc network environment suitable for understanding the present invention;</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 2</figref> depicts a flow diagram of a method of providing a cluster based load adaptive sleeping protocol;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 3</figref> depicts a graphical representation of a beacon interval suitable for understanding the present invention;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 4</figref> depicts a flow diagram of a method of adaptively adjusting a sleeping time interval of a node;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 5</figref> depicts a flow diagram of a method for synchronizing a node with a beacon signal when associating with a cluster; and</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 6</figref> depicts a flow diagram of a method for transmitting data between nodes.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0017" num="0016">To facilitate understanding of the invention, identical reference numerals have been used, where possible, to designate identical elements that are common to the figures.</p>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0018" num="0017">The present invention provides a clustering based load adaptive sleeping protocol for ad hoc networks. In particular, the sleeping protocol of the present invention may be used by mobile devices (nodes) to decrease power consumption to thereby extend battery life of the device, while adapting the sleep intervals of a node to the traffic load of such node. The sleeping protocol of the present invention may be implemented in ad hoc networks illustratively operating under the Bluetooth, Infrared Data Association (IrDA), HiperLAN, and 802.11 standards, among other wireless standards.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> depicts a schematic diagram of a plurality of clusters <b>102</b> forming an ad hoc network environment <b>100</b> suitable for understanding the present invention. The exemplary ad hoc network <b>100</b> comprises at least one cluster <b>102</b>, where each cluster comprises at least two nodes <b>104</b>, and where one of the at least two nodes <b>104</b> is designated as a cluster-head <b>104</b><sub>C</sub>. For example, in <figref idref="DRAWINGS">FIG. 1</figref>, three clusters <b>102</b><sub>1 </sub>through <b>102</b><sub>3 </sub>are illustratively shown, where the first cluster <b>102</b><sub>1 </sub>comprises six exemplary nodes <b>104</b><sub>11</sub>-<b>104</b><sub>15 </sub>and cluster-head <b>104</b><sub>1C </sub>(drawn in black). Similarly, the second cluster <b>102</b><sub>2 </sub>comprises four exemplary nodes <b>104</b><sub>21</sub>-<b>104</b><sub>23 </sub>and cluster-head <b>104</b><sub>2C </sub>(drawn in black), and the third cluster <b>102</b><sub>3 </sub>comprises 20 exemplary nodes <b>104</b><sub>31</sub>-<b>104</b><sub>319 </sub>and cluster-head <b>104</b><sub>3C </sub>(drawn in black).</p>
<p id="p-0020" num="0019">The nodes <b>104</b> are mobile communication devices, such as PDA's, laptops, among other mobile communication devices capable of transmitting and receiving packetized information. The sleeping protocol of the present invention is operable in homogeneous, as well as in heterogeneous ad hoc networks. That is, an ad hoc network <b>100</b> may comprise laptop devices, PDAs, among other types of mobile communication devices.</p>
<p id="p-0021" num="0020">Clustering of nodes in an ad hoc network <b>100</b> is an efficient method for improving the performance of routing algorithms to exchange packetized information between the nodes. A cluster <b>102</b> is a subset of nodes <b>104</b>, which can bi-directionally communicate with a cluster-head <b>104</b><sub>C</sub>, and in some instances, with each other. The nodes <b>104</b> typically communicate with one another via multi-hop routing techniques. The number of hops between nodes <b>104</b> depends on the network environment. Further, by defining the number of hops between nodes, the nodes <b>104</b> may then be grouped into their respective clusters. For example, if the multi-hop count is designated as two hops, then a node that is three hops away is grouped into another cluster <b>102</b>. Thus, the formation of clusters <b>102</b> is dependent on the routing algorithms between nodes <b>104</b>.</p>
<p id="p-0022" num="0021">Each node <b>104</b> comprises a unique identifier. The unique identifier comprises the host ID (e.g., MAC ID) and a group ID. The group ID is associated with the cluster for which the node is a member. Thus, the host ID of a node <b>104</b> remains constant, while the group ID may change in instances where the node <b>104</b> moves from one cluster to another cluster <b>102</b>.</p>
<p id="p-0023" num="0022">The cluster-heads <b>104</b><sub>C </sub>of each cluster <b>102</b> serve as a regional broadcast node, and as a local coordinator to enhance channel throughput. Selection of a cluster-head <b>104</b><sub>C </sub>is conventionally known. For example, one technique to determine the cluster-head <b>104</b><sub>C </sub>is based on the node identifiers. Since each node has a unique ID, a node illustratively having the lowest (or highest) ID among its neighboring nodes may be selected as a cluster-head <b>104</b><sub>C</sub>. Another technique includes electing a node as a cluster-head <b>104</b><sub>C </sub>if it is the most highly connected node. Each node <b>104</b> broadcasts a list of nodes that it can hear, including itself. A node <b>104</b> is elected as a cluster-head <b>104</b><sub>C </sub>if it is the most highly connected node of all its uncovered neighbor nodes, where a node <b>104</b> that has not elected its cluster-head <b>104</b><sub>C </sub>yet is considered an uncovered node. Clusters <b>102</b> provide a hierarchical structure for the ad hoc network <b>100</b>. This hierarchical structure may be exploited to obtain a distributed protocol for co-coordinating transitioning of the nodes from an active state to a sleep state, and vice versa.</p>
<p id="p-0024" num="0023">One benefit of the ad hoc network <b>100</b> is that the nodes <b>104</b> may communicate with each other, illustratively by sending packetized information, such as IP packets to each other. In one embodiment, all the nodes <b>104</b> in each cluster <b>102</b> are assigned the same subnet address. When a node (e.g., node <b>104</b><sub>11</sub>) of a first cluster (i.e., first cluster <b>102</b><sub>1</sub>) requests a routing path for communicating (i.e., sending IP packets) with a node (e.g., node <b>104</b><sub>319</sub>) of another cluster (i.e., third cluster <b>102</b><sub>3</sub>), the requesting node <b>104</b><sub>11 </sub>broadcasts a routing request. Since the broadcasted routing address has a subnet address differing from its own subnet address, the first cluster-head <b>104</b><sub>1C </sub>rebroadcasts the request to the third cluster-head <b>104</b><sub>3C</sub>, which has the same subnet address of the requested node <b>104</b><sub>319</sub>. The third cluster-head <b>104</b><sub>3C </sub>responds to the rebroadcasted request from the first cluster-head <b>104</b><sub>1C</sub>, and provides the routing information, which is subsequently sent to the requesting node <b>104</b><sub>11</sub>. Accordingly, since the number of cluster-heads <b>104</b><sub>C </sub>in the ad hoc network <b>100</b> represents a small fraction of the total number of nodes <b>104</b>, cluster based routing incurs fewer rout exchange messages. Moreover, inter-connections between the cluster-heads <b>104</b><sub>C </sub>may be provided via higher power links or gateway nodes.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 2</figref> depicts a flow diagram of a method <b>200</b> of providing a cluster based load adaptive sleeping protocol. <figref idref="DRAWINGS">FIG. 3</figref> depicts a graphical representation of a beacon interval suitable for understanding the present invention. The graphical representation of <figref idref="DRAWINGS">FIG. 3</figref> should be viewed in conjunction with the flow diagram of <figref idref="DRAWINGS">FIG. 2</figref>. Referring to <figref idref="DRAWINGS">FIG. 2</figref>, the method <b>200</b> starts at step <b>201</b> and proceeds to optional step <b>202</b>, where one or more clusters are formed in a conventionally known manner, such as discussed above. It is noted that the optional clustering of the nodes <b>104</b> is based on the number of nodes in the network <b>100</b>. For example, if there are only a few nodes <b>104</b> in the network that all comply with the multi-hop algorithm for the network, then clustering of the nodes is not necessary and optional step <b>202</b> is not required. However, one of the nodes will be designated as a “cluster-head” to broadcast a beacon signal, as discussed below in further detail.</p>
<p id="p-0026" num="0025">At step <b>204</b>, the nodes <b>104</b> are partitioned into n-subgroups, where n is an integer greater than one. The nodes <b>104</b> are partitioned into subgroups to enable a node to determine the partition of any other node. In one embodiment, each node is assigned to a subgroup based on the node's unique host ID by using a node_id modulo n technique. For example, exemplary cluster <b>3</b> <b>102</b><sub>3 </sub>contains 20 nodes, and if n=4, then five nodes are assigned to each subgroup n in cluster <b>3</b> <b>102</b><sub>3</sub>. Accordingly, subgroup <b>0</b> includes nodes <b>104</b><sub>31</sub>, <b>104</b><sub>35</sub>, <b>104</b><sub>39</sub>, <b>104</b><sub>313</sub>, <b>104</b><sub>317</sub>; subgroup <b>1</b> includes nodes <b>104</b><sub>32</sub>, <b>104</b><sub>36</sub>, <b>104</b><sub>310</sub>, <b>104</b><sub>314</sub>, <b>104</b><sub>318</sub>; subgroup <b>2</b> includes nodes <b>104</b><sub>33</sub>, <b>104</b><sub>37</sub>, <b>104</b><sub>311</sub>, <b>104</b><sub>315</sub>, <b>104</b><sub>319</sub>; and subgroup <b>3</b> includes nodes <b>104</b><sub>34</sub>, <b>104</b><sub>38</sub>, <b>104</b><sub>312</sub>, <b>104</b><sub>316</sub>, <b>104</b><sub>320</sub>.</p>
<p id="p-0027" num="0026">Once the optional clusters <b>102</b> have been formed and the nodes have been partitioned into n-subgroups, the cluster head <b>104</b><sub>C </sub>transmits a beacon at fixed intervals. At step <b>206</b>, the beacon interval (BI) is divided into a number of time slots whose duration is chosen based on the network topology, traffic density, and latency requirements. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, a graphical representation of an exemplary beacon interval <b>300</b> is shown. The beacon interval <b>300</b> comprises a plurality of time slots <b>302</b>, where each time slot <b>302</b> is associated with the n-subgroups of nodes formed in step <b>204</b>. The beacon interval <b>300</b> is selected such that the number of time slots <b>302</b> within the beacon interval is a multiple of n. Each time slot <b>102</b> in the beacon interval <b>300</b> is illustratively marked with a number 0, . . . n−1, as shown in <figref idref="DRAWINGS">FIG. 2</figref>. The time slots that are marked with a number m&lt;n, where m is an integer less than n, are called m-slots. The method <b>200</b> then proceeds to step <b>208</b>.</p>
<p id="p-0028" num="0027">At step <b>208</b>, the time slots are associated to the nodes <b>104</b> in each subgroup. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, the nodes in subgroup m are called m-nodes. Thus, each time slot <b>302</b> is associated with a corresponding subgroup of nodes <b>104</b> in the cluster(s) <b>102</b>. It is noted that in <figref idref="DRAWINGS">FIG. 3</figref>, node subgroups illustratively are shown to occur three times per beacon interval <b>300</b>. Specifically, the nodes <b>104</b> in each subgroup only hear one beacon per beacon interval <b>300</b>, but the nodes <b>104</b> of the subgroup illustratively wake up three times per beacon interval in an instance where their sleeping interval is equal to four time slots <b>302</b>.</p>
<p id="p-0029" num="0028">At step <b>210</b>, sleeping patterns are assigned to each subgroup of nodes corresponding to one or more time slots. The beacon interval time slots <b>302</b> are used to obtain a distributed algorithm that coordinates the sleeping patterns of the nodes <b>104</b> in each subgroup. In one embodiment, m-nodes begin a sleep cycle at time slots marked (m+1) modulo n. The sleep intervals are selected such that the waking times at an m-node occur in an m-slot. For example, those nodes having host ID's corresponding to subgroup <b>1</b>, such nodes transition into the awake mode of operation whenever time slot <b>1</b> begins, and transition into the sleep mode when time slot <b>2</b> begins. The nodes in subgroup <b>1</b> remain in sleep mode for the remaining time slots <b>3</b> and <b>0</b>, until time slot <b>1</b> reoccurs and the node goes into awake mode. Thus, the node is in the sleep state for n−1 time slots. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, the nodes in each subgroup <b>1</b> are awake for three time slots per beacon interval and asleep for nine time slots. Further, each node in subgroup <b>1</b> is awake for one time slot, followed by entering the sleep mode for three successive time slots <b>302</b>, before waking up again. The same analysis is applicable for the nodes of the other subgroups. Accordingly, for exemplary cluster <b>3</b> <b>102</b><sub>3</sub>, which has twenty nodes, there are five nodes that are awake and fifteen nodes that are in sleep mode at any given time slot <b>302</b>. The method <b>200</b> then proceeds to step <b>299</b>, where the method <b>200</b> ends.</p>
<p id="p-0030" num="0029">It is noted that the number of times a subgroup of nodes is awake and asleep per beacon interval is dependent on the network topology, traffic, and latency requirements. For example, if traffic between nodes is light and latency requirements are not stringent, then the total sleeping interval may be increased. For example, a node in subgroup <b>1</b> begins a sleep cycle at slot <b>302</b><sub>3</sub>, it then remains in the sleep state for the slots <b>302</b><sub>4</sub>, <b>302</b><sub>5</sub>, . . . , <b>302</b><sub>9 </sub>and wakes up at slot <b>302</b><sub>10</sub>. The sleeping time is thus increased by n.</p>
<p id="p-0031" num="0030">An advantage of dividing each beacon interval <b>300</b> into a plurality of time slots <b>302</b><sub>m </sub>is that any node in the network <b>100</b> will know the waking times of another node, if the other nodes subgroup_id and host_id is known. For example, a node in subgroup <b>0</b> may determine the waking time of a node in any of the subgroups <b>1</b>-<b>3</b>, as long as the node in subgroup <b>0</b> knows the subgroup_id and host_id of a particular node it wishes to communicate with.</p>
<p id="p-0032" num="0031">It is noted that clock synchronization between the nodes is not required, since the nodes all enter the sleep/awake modes based on receiving the broadcast beacon signal from the cluster-head <b>104</b><sub>C</sub>. Accordingly, a node will always know when it may communicate with another node based on its time slot, and the algorithm defining the awake and sleep modes during the beacon interval.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 4</figref> depicts a flow diagram of a method <b>400</b> of adaptively adjusting a sleeping time interval of a node <b>104</b>. The method <b>400</b> of <figref idref="DRAWINGS">FIG. 4</figref> may be executed by each node to help improve its battery life. It is noted that method <b>400</b> is executed after the clustering process is completed, and the nodes remain active until they become part of the cluster <b>102</b>. The method is based on traffic patterns for each node <b>104</b>.</p>
<p id="p-0034" num="0033">Specifically, if a node <b>104</b> has been idle for some predetermined period (i.e., no transmission, receipt, or forwarding of packets), or does not receive any request to send (RTS) messages and/or traffic indication maps (TIM) during the one slot after waking up from the sleep state, the sleep interval for such node may be extended. It is noted that RTS messages are used between nodes to initiate communications therebetween. For example, if a first node sends a RTS message to a second node, the second node must respond with a clear to send (CTS) message prior to the first node sending any packetized information. Further, TIM messages are used to inform nodes that they should transition into an active state for an extended period of time in order to receive data.</p>
<p id="p-0035" num="0034">The method <b>400</b> starts at step <b>401</b>, and proceeds to step <b>402</b>, where the time that a node <b>104</b> is idle (Tidle) is set to zero (Tidle=0). At step <b>404</b>, the node <b>104</b> receives the beacon signal from its respective cluster-head <b>104</b><sub>C </sub>and transitions or remains in its awake state, as discussed above with respect to <figref idref="DRAWINGS">FIGS. 2 and 3</figref>. During the awake state, the node may be active, i.e., sending, receiving, and or forwarding packets and/or in an idle state, where the node is awake, but not sending, receiving, and or forwarding packets. For example, if the node <b>104</b><sub>37 </sub>is part of a second subgroup of cluster <b>3</b> <b>102</b><sub>3</sub>, then the node <b>104</b><sub>37 </sub>goes into its awake state illustratively during time slot <b>2</b> of the beacon interval <b>300</b>. Once in the awake state, the node <b>104</b><sub>37 </sub>may operate in the active state as long as the node <b>104</b><sub>37 </sub>is sending, receiving, and/or forwarding packetized information. Once the node <b>104</b><sub>37 </sub>stops sending, receiving, and/or forwarding packetized information, the node <b>104</b><sub>37 </sub>becomes idle for some time period, until the node either becomes active (is sends, receives, and/or forwards packetized information) or goes into the sleep state.</p>
<p id="p-0036" num="0035">At step <b>406</b>, an idle timer Tidle is set to zero and begins counting the time the node is in the idle state. At step <b>408</b>, a query is made whether data activity has initiated. If the query at step <b>408</b> is affirmatively answered, then the method proceeds to step <b>410</b>. At step <b>410</b>, the idle timer Tidle is stopped, and the method <b>400</b> proceeds to step <b>402</b>, where the idle time is reset to zero, since the node is now in the active state. If at step <b>408</b>, the query is negatively answered, then the method <b>400</b> proceeds to step <b>412</b>.</p>
<p id="p-0037" num="0036">At step <b>412</b>, a query is made whether the idle time Tidle of the node has exceeded a predetermined threshold for idle time (Thidle). The threshold time Thidle is set to a time value based on various network parameters, such as size of network (e.g., number of nodes), type of network (e.g., 802.11(a), 802.11(b), 802.11(g), Bluetooth, which have different bit rates, how much power is desired to be saved by the sleeping protocol, among other network conditions. It is noted that the smaller the threshold value, the quicker the node will transition into a sleep mode of operation. That is, the protocol schedules the node for transition to the sleep state at the next valid sleep start time. It is further noted that the idle threshold value Thidle may be set using variables associated with either number of slots <b>302</b> in the beacon interval <b>300</b>, or as a set time value.</p>
<p id="p-0038" num="0037">Referring to <figref idref="DRAWINGS">FIG. 1</figref>, if node <b>104</b><sub>37 </sub>is awake at the second slot <b>302</b><sub>3 </sub>and Thidle is illustratively set for a duration equivalent to three time slots, then, the node <b>104</b><sub>37 </sub>will go into sleep mode at time slot <b>302</b><sub>8</sub>, which is the next valid sleep start time. Similarly, if the Thidle is illustratively set for a duration greater than the beacon interval <b>300</b>, the node <b>104</b><sub>37 </sub>will go into sleep mode at the first valid sleep start time (e.g., time slot <b>3</b>) of a subsequent beacon interval <b>300</b>. Alternatively, Thidle may be set to some specific time (e.g., 50 milliseconds).</p>
<p id="p-0039" num="0038">If at step <b>412</b>, the idle time Tidle has not exceeded the idle time threshold Thidle (and has not returned to an active state), then the method <b>400</b> returns to step <b>408</b>, until at such time at step <b>412</b>, the idle time Tidle has exceeded the idle time threshold Thidle. The method <b>400</b> then proceeds to step <b>414</b>.</p>
<p id="p-0040" num="0039">At step <b>414</b>, an inactive indicator (Ninac), which counts the number of times a node has woken up and has not received a request to send (RTS) and/or TIMs sent to it, is set to zero (Ninac=0). Additionally, an inactive indicator Nthresh) is set to q (Nthresh=q), which is associated with the number of times the maximum sleeping period has occurred. Further, at step <b>414</b>, the maximum sleep time threshold (Thsleep) is initially set to n (Thsleep=n), where n equals the subgroups of nodes. It is noted that the value n may change according to the principles of the invention, as discussed in further detail below with respect to steps <b>424</b>-<b>430</b>.</p>
<p id="p-0041" num="0040">Once the variables and counter are set at step <b>414</b>, the method <b>400</b> proceeds to step <b>416</b> where the node <b>104</b> begins the sleep state. That is, the idle time Tidle has exceeded the idle time threshold Thidle. Recall that in <figref idref="DRAWINGS">FIG. 3</figref>, four exemplary subgroups were formed via method <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>, and that a node illustratively sleeps for three time slots and transitions to the awake mode at the fourth time slot. Thus, in the present example, n equals four (e.g., n=4) and the node <b>104</b><sub>37 </sub>will illustratively go into sleep mode at time slot <b>3</b> and awaken four time slots later, when time slot <b>2</b> occurs.</p>
<p id="p-0042" num="0041">At step <b>418</b>, a determination is made whether it is time for the node <b>104</b> to awaken. That is, if Tsleep=Thsleep−1, then the method <b>400</b> proceeds to step <b>424</b>, as discussed below in further detail. If the time in the sleep state (Tsleep) does not exceed the maximum sleep time threshold less one slot (Thsleep−1), then the method <b>400</b> proceeds to step <b>420</b>.</p>
<p id="p-0043" num="0042">At step <b>420</b>, a determination is made as to whether it is time to acquire the beacon signal. In particular, the node may need to acquire the beacon signal because extended sleeping intervals may cause a node to lose the timing synchronization with the cluster head due to clock drifts. It is noted that a node cannot receive the beacon from the cluster head when it is in the sleep mode. If at step <b>420</b>, it is not time to acquire a new beacon signal, then the method <b>400</b> returns to step <b>416</b>, where the node remains in the sleep mode. However, if at step <b>420</b>, a new beacon signal is required, then the method <b>400</b> proceeds to step <b>422</b>, where a beacon acquisition procedure is executed. In particular, the node transitions to the awake mode and waits until the beacon is heard from the cluster head. On hearing the beacon, the node can correct the error (if any) in the synchronization between the node and cluster head. Once the beacon has been acquired, the method <b>400</b> then proceeds to step <b>426</b>.</p>
<p id="p-0044" num="0043">Referring to step <b>418</b>, if the time in the sleep state (Tsleep) does exceed the maximum sleep time threshold (Thsleep−1), then the method <b>400</b> proceeds to step <b>424</b>. That is, using the above example, after the node <b>104</b><sub>37 </sub>has been in the sleep mode for three time slots, the node <b>104</b><sub>37 </sub>then transitions to the awake state beginning in the fourth time slot. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, if the node is awake in slot <b>2</b> <b>302</b><sub>7</sub>, the node will transition into the sleep mode at time slot <b>302</b><sub>8 </sub>and remain in the sleep state until time slot <b>302</b><sub>12</sub>, which is n=4 slots thereafter. Once the node transitions to the awake state, Tsleep is reset to zero (Tsleep=0).</p>
<p id="p-0045" num="0044">In one embodiment, the counter Ninac counts the number of times the node has awoken from the sleep state and remained inactive. That is, the node transitions back and forth between the awake and sleep states at the appropriate slot, as discussed above with respect to <figref idref="DRAWINGS">FIG. 3</figref>, and the counter Ninac counts the number of times the node remained inactive (idle) in the awake mode. For example, if node <b>104</b><sub>37 </sub>is awake at the second slot <b>302</b><sub>3 </sub>and node <b>104</b><sub>37 </sub>wakes up two more times during the beacon interval <b>300</b> without becoming active (i.e., the node stays idle), then Ninac is incremented by two (2).</p>
<p id="p-0046" num="0045">More specifically, if at anytime during the course of alternating between the sleep and awake modes, at step <b>426</b> the node receives at least one RTS or TIM message, then the method <b>400</b> returns to step <b>402</b>, where the idle time Tidle is reset to zero, and the node <b>104</b> remains in an active state (step <b>404</b>), as discussed above. Alternatively, if there are no RTS or TIM messages during the time slots that the node is awake, the method <b>400</b> proceeds to step <b>428</b>.</p>
<p id="p-0047" num="0046">At step <b>428</b> a determination is made whether the count of Ninac has exceeded the predetermined threshold Nthresh. If the count of Ninac has not exceeded the predetermined threshold Nthresh, then the method <b>400</b> returns to step <b>416</b> where the node remains in the sleep state. However, if at step <b>428</b> the count of Ninac has exceeded the predetermined threshold Nthresh, then the method <b>400</b> proceeds to step <b>430</b> where the sleep threshold Thsleep is incremented by a value of n. For example, where n was previously set to four time slots, n is now increased to eight time slots. The method <b>400</b> proceeds to step <b>416</b>, where the node <b>104</b> remains in the sleep state.</p>
<p id="p-0048" num="0047">The exemplary sleeping protocol implemented via method <b>400</b> helps improve the battery life at a node by adapting the sleep time to the traffic arrival/departure profile of the node. Specifically, if no RTS/TIM messages arrive at the node during the time slot when the node is awaken from the sleep state, the counter Ninac is incremented. The counter Ninac continues to increment each time the node transitions to the awake state and no RTS/TIM messages arrive. In other word, the node cumulatively monitors the number of times the node cycles through the sleep/awake states without receiving any messages. When the counter Ninac exceeds the preset threshold Nthresh, the sleep threshold Thsleep is increased to allow the node to remain in the sleep state for a longer period, thereby helping increase the battery life of the node. That is, since the node has remained idle in its awake state for some predefined period, it may be assumed that it will continue to remain idle for at least such subsequent periods. Such assumption is based on the traffic patterns of the node, which are monitored by tracking the absence of RTS/TIM messages received by the node (step <b>420</b>), which reflect the amount of node traffic. Accordingly, the sleep state of a node may be increased as a function of the absence of the RTS/TIM messages received by the node.</p>
<p id="p-0049" num="0048">If a node <b>104</b> has very low traffic arriving or departing therefrom, the sleeping protocol of <figref idref="DRAWINGS">FIG. 4</figref> may cause the sleep times to exceed several beacon intervals. Since the clocks of the nodes may be subject to drifting over some period of time, the nodes may lose synchronization with the beacon signal. Accordingly, the nodes will not wake at the proper time and those nodes may fail to timely receive RTS/TIM messages from the other nodes in the cluster <b>102</b>. To prevent the nodes from becoming unsynchronized with the beacon signal, in one embodiment of the invention, a method is provided to keep the nodes synchronized with the beacon signal from the cluster-head <b>104</b><sub>C</sub>.</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 5</figref> depicts a flow diagram of a method <b>500</b> for synchronizing a node <b>104</b> with a beacon signal when associating with a cluster <b>102</b>. The method <b>500</b> of <figref idref="DRAWINGS">FIG. 5</figref> conveniently combines two aspects of the present invention into a single flow diagram.</p>
<p id="p-0051" num="0050">In particular, one inventive aspect is that the node transitions into the awake state if the node has been in the sleep mode past a predetermined number of beacon intervals, as provided by steps <b>512</b> through <b>516</b> of a first sub-method <b>510</b>. A second inventive aspect is that the node may change its cluster in an instance where the node loses connectivity with its current cluster-head <b>104</b><sub>C </sub>(e.g., moves into another cluster), provided by step <b>532</b> through <b>538</b> of a second sub-method <b>530</b>.</p>
<p id="p-0052" num="0051">Method <b>500</b> begins at step <b>501</b>, and proceeds to step <b>502</b> where a variable “Other_Beacon” is set to zero (Other_Beacon=0). That is, the node is associated with its current or last heard beacon signal, and is not receiving a second (new) beacon signal from another cluster-head. The method <b>500</b> then proceeds to step <b>504</b>. At step <b>504</b>, the node remains in the awake state until it receives a beacon signal. That is, the node is in a time slot corresponding to its awake state, as illustratively shown in <figref idref="DRAWINGS">FIG. 3</figref>. At step <b>512</b>, the node determines whether the beacon signal is being received during its awake state. That is, method <b>400</b> of <figref idref="DRAWINGS">FIG. 4</figref> is executed to acquire the beacon signal (steps <b>402</b>-<b>418</b>), as discussed above. If at step <b>512</b>, the beacon signal is not acquired, then the method <b>500</b> returns to step <b>504</b> and remains in the awake until a beacon signal is acquired.</p>
<p id="p-0053" num="0052">It is noted that <figref idref="DRAWINGS">FIG. 5</figref> depicts a query being performed at step <b>534</b>. Specifically, if at step <b>512</b>, the beacon signal is not received (i.e., the determination is answered negatively), then the method <b>500</b> proceeds to step <b>534</b>, where a determination is made whether the node has been awake long enough to acquire either the current beacon signal or a new beacon signal (i.e., the awake time of the node is greater than the beacon interval (Awake time&gt;BI) and a beacon signal from a different cluster-head has been received (Other_Beacon=1)). In this instance, since there is no other beacon signal being received by the node (i.e., Other_Beacon=0), the determination at step <b>534</b> is answered negatively, and the method proceeds to step <b>504</b>, where the node remains in the awake state until a beacon signal is acquired. More specifically, step <b>534</b> is only applicable in instances where the node has received a beacon signal from a second source, as discussed below with respect to steps <b>532</b>-<b>538</b>.</p>
<p id="p-0054" num="0053">Referring to step <b>512</b>, if the determination is affirmatively answered (i.e., the beacon signal initially/currently associated with the node is received), then the method <b>500</b> proceeds to step <b>514</b>. At step <b>514</b>, a determination is made whether the beacon signal is from the cluster <b>102</b> the node is currently associated. If the determination is affirmatively answered, then at step <b>516</b> the node returns to step <b>426</b> of the sleep procedure of <figref idref="DRAWINGS">FIG. 4</figref>, and the method <b>500</b> ends at step <b>599</b>. If at step <b>514</b> the determination is negatively answered, i.e., the beacon received is from a different cluster, at step <b>532</b> the relevant information of the acquired beacon is recorded (i.e., Other_Beacon=1). The method <b>500</b> proceeds to step <b>504</b> where the node remains in the awake state, and then proceeds to step <b>512</b> to determine whether the new beacon signal has been received by the node.</p>
<p id="p-0055" num="0054">As mentioned above, a second aspect of the invention is to allow the node to be mobile, and still communicate with various nodes, even if such nodes are members of a different cluster. That is, the node may move out of range of a cluster-head of its current cluster, yet still receive beacon signals from one or more respective cluster-heads of other clusters.</p>
<p id="p-0056" num="0055">Referring to step <b>514</b> of <figref idref="DRAWINGS">FIG. 5</figref>, if a determination is made that the beacon received is not from the current cluster (i.e., the last cluster that a beacon signal was received from) then the method <b>500</b> proceeds to step <b>532</b> of the second sleep protocol <b>530</b>. At step <b>532</b>, the node <b>104</b> records the beacon signal information acquired from other cluster-heads <b>104</b><sub>C</sub>. For example, referring to <figref idref="DRAWINGS">FIG. 1</figref>, if node <b>104</b><sub>13 </sub>of the first cluster <b>102</b><sub>1 </sub>moves out of range of its respective cluster-head <b>104</b><sub>1C </sub>towards cluster <b>2</b> <b>102</b><sub>2 </sub>and cluster <b>3</b> <b>102</b><sub>3</sub>, the node <b>104</b><sub>13 </sub>may illustratively receive a beacon signal respectively from cluster-head <b>104</b><sub>2C </sub>of cluster <b>2</b> <b>102</b><sub>2 </sub>and/or cluster-head <b>104</b><sub>3C </sub>of cluster <b>3</b> <b>102</b><sub>3</sub>. Accordingly, at step <b>532</b>, node <b>104</b><sub>13 </sub>maps the acquired beacon signals with their respective clusters <b>102</b>. The method <b>500</b> proceeds to step <b>504</b>, where the node remains in the awake mode.</p>
<p id="p-0057" num="0056">At step <b>512</b>, if the second (new) beacon signal (Other_Beacon=1) is not received, then at step <b>534</b>, a determination is made whether the node has remained awake long enough to acquire the second beacon signal. If not, the method <b>500</b> proceeds to step <b>504</b> and stays awake until at step <b>534</b>, the beacon signal of the second cluster has been received. That is, the method <b>500</b> proceeds to step <b>504</b> to provide additional time to acquire the new beacon signal. Thus, step <b>534</b> ensures that the node stays awake long enough (at least on beacon interval) to acquire the current/original beacon signal or a new beacon signal from another cluster-head.</p>
<p id="p-0058" num="0057">If the determination at step <b>534</b> is affirmatively answered, then the node has (i) stayed awake greater than one beacon interval, and (ii) has received a beacon signal from a new cluster-head. Accordingly, the method <b>500</b> proceeds to step <b>536</b>, where the node changes to the cluster associated with the newly acquired beacon signal. That is, the node changes its group_id (while the host_id always remains the same), and joins a subgroup of the second cluster having the same subgroup number. For example, if node <b>104</b><sub>13 </sub>is assigned to subgroup <b>3</b> of the first cluster <b>102</b><sub>1</sub>, and moves into the second cluster <b>102</b><sub>2</sub>, the awake and sleep time slots for node <b>104</b><sub>13 </sub>will also correspond to the awake and sleep time slots of the nodes assigned to subgroup <b>3</b> of the second cluster <b>102</b><sub>1</sub>. Accordingly, the node may roam between clusters in a seamless manner without having to send out beacon signals to other nodes.</p>
<p id="p-0059" num="0058">In particular, node sleep/activation times are synchronized to the beacon interval slots, where the node's group number is used to determine the slots within a beacon interval that a node begins its sleep cycle. Therefore, no additional signaling is required between nodes to indicate sleep patterns. The method <b>500</b> proceeds to step <b>538</b>, where the node restarts the sleep procedure in the new cluster per method <b>400</b> of <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0060" num="0059">It is noted that the node may choose a cluster from among several respective beacon signals acquired during the awake state, as conventionally known in the art. For example, the node may determine signal strength of the beacon signal and select the cluster associated with the strongest beacon signal, among other conventional selection techniques. The method <b>500</b> then proceeds to step <b>599</b>, where the method <b>500</b> ends.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 6</figref> depicts a flow diagram of a method <b>600</b> for transmitting data between nodes <b>104</b>. Method <b>600</b> may be executed when a first node (e.g., node A) has data to send to an m-node (e.g., node B). The transmission may be from data generated at node A or may be data forwarded through node A to node B.</p>
<p id="p-0062" num="0061">The method <b>600</b> begins at step <b>601</b> and proceeds to step <b>602</b>, where a determination is made whether the sending node (node A) is awake. If the sending node is not awake, at step <b>604</b>, the sending node transitions to an awake state. Once awake, the sending node sets a counter Nretry to zero (Nretry=0). The counter Nretry is used to count the number of times attempts to communicate with an other node are made. It is noted that at step <b>602</b>, if the sending node A is in the active state, then the method <b>600</b> proceeds directly to step <b>606</b> to set the counter Nretry to zero. The method <b>600</b> then proceeds to step <b>608</b>.</p>
<p id="p-0063" num="0062">As soon as the data is available, at step <b>608</b> the sending node A sends a request to send (RTS) or traffic indication map (TIM) message to the destination node (node B). The destination node B can respond to the RTS message only when it is in the awake state. At step <b>610</b>, the sending node A determines whether it has received a clear to send (CTS) message from the destination node B.</p>
<p id="p-0064" num="0063">If a CTS message was received on the first attempt by the sending node A, at step <b>612</b> the sending node transmits the data to the destination node B, and at step <b>699</b>, the method <b>600</b> ends. Otherwise, if the sending node A has not received a CTS message from the destination node B, the method <b>600</b> resends the CTS message for a predetermined number of times.</p>
<p id="p-0065" num="0064">Specifically, at step <b>614</b>, the sending node A increments the Nretry counter by one (1), and at step <b>616</b> a determination is made whether the count in the counter Nretry exceeds a predetermined count threshold (ThNretry). If the sending node A has not resent the RTS message more than the predetermined count threshold ThNretry, then the method returns to step <b>604</b> through <b>616</b>, such that the sending node A may send the RTS message again. Once repeated attempts to send the RTS message have been made and the count threshold ThNretry has been exceeded at step <b>616</b>, the sending node A assumes that the destination node B is in the sleep state, and suspends the RTS messages to the destination node B.</p>
<p id="p-0066" num="0065">The method <b>600</b> then proceeds to step <b>618</b>, where the sending node A waits until the destination node B is in its awake state (i.e., the m-slot of node B). The method <b>600</b> then proceeds to steps <b>604</b> through <b>616</b> to send the RTS message to the destination node B only at those times when the destination node B is in its awake state. Once the destination node B responds to the RTS message by sending a CTS message to the sending node A, then at step <b>612</b>, the sending node A knows that the destination node B is in an awake state and then transmits the data to node B, without waiting for the m-marked slots. Additionally, if the sending node A has data bound for other m-nodes, the sending node A can improve efficiency by sending traffic indicator map (TIM) messages for those m-nodes when transmitting in slot m. The TIM message prevents these other m-nodes from transitioning into the sleep state.</p>
<p id="p-0067" num="0066">The method <b>600</b> of <figref idref="DRAWINGS">FIG. 6</figref> also accommodates instances where the destination node B moves out of its current cluster, yet may still be within the transmission range of the sending node A. In such instances, the destination node B may not hear the RTS/TIM messages due to its differently synchronized sleeping pattern. Optional step <b>620</b> allows the sending node A to verify destination node B's membership in node A's cluster, thereby avoiding excessive RTS transmissions.</p>
<p id="p-0068" num="0067">Specifically, at step <b>620</b>, the sending node A queries whether the destination node has changed clusters. If the query is negative (i.e., node A and node B are members of the same cluster), then the method <b>600</b> proceeds to step <b>618</b>, as discussed above. Otherwise, if the query is affirmatively answered (i.e., node B is in a different cluster than node A), then at step <b>622</b>, the sending node A obtains timing information for the destination node B via node A's cluster-head associated with the destination node. In this instance, the cluster-heads of each cluster must share such synchronized information.</p>
<p id="p-0069" num="0068">In an alternative embodiment, at step <b>622</b>, the sending node A may acquire a new route to the destination node B. Such alternate route may include using different hops between the nodes therebetween to send the data. Accordingly, sending information along a different routing path is subject to the various network conditions, such as the number of hops required, bandwidth capacity between the nodes, traffic flows, among other conventionally known network conditions.</p>
<p id="p-0070" num="0069">The cluster based load adaptive sleeping protocol of the present invention combines several unique features. Specifically, there is no explicit need for synchronization between the nodes, and the node sleep patterns may be modified based on traffic load conditions. Further, there is no explicit exchange of information about sleep pattern between the nodes. Thus, battery life of a node may be further preserved, since the node does not have to transition into the awake (active) state to communicate information there between.</p>
<p id="p-0071" num="0070">The inventive sleeping protocols described herein help improve battery life of a node operating under stable and changing network environments. For example, in networks where node speeds are highly mobile, the topology of the network changes often. Thus, the nodes need to remain in an active state for longer periods of time to update routing and neighbor node information. Conversely, where the node mobility is low, the nodes can remain in the sleep state for extended periods, provided there is no data destined for them. The sleeping protocols described herein are adaptive in that they may accommodate such various network conditions base on traffic load.</p>
<p id="p-0072" num="0071">Although various embodiments that incorporate the teachings of the present invention have been shown and described in detail herein, those skilled in the art can readily devise many other varied embodiments that still incorporate these teachings.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A clustering based load adaptive sleeping protocol for ad hoc networks, comprising:
<claim-text>a beacon signal originating from a cluster-head of a cluster, said beacon signal comprising a plurality of sequential beacon intervals, said beacon intervals each comprises a plurality of time slots associated with groups of nodes in said cluster;</claim-text>
<claim-text>wherein said groups of nodes are defined by node_id modulo n, where node id represents a unique host identification of each node, and n is an integer representing a number of groups in said cluster;</claim-text>
<claim-text>wherein said time slots are sequentially numbered zero to n−1;</claim-text>
<claim-text>wherein each said beacon interval comprises at least one sequence of time slots numbered zero to n−1; and</claim-text>
<claim-text>wherein one of said n time slots represents an epoch when a node is in an awake state, and n−1 time slots represent an epoch when said node is in a sleep state.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The sleeping protocol of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each node is in an awake state during a time slot “m” corresponding to said node's assigned group number such that m=n.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The sleeping protocol of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein said node is in said sleep state during time slots occurring at (m+1) inodulo n.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A method of adapting a sleeping protocol of a node based on traffic patterns of said node, said node being associated with a cluster having a plurality of groups of nodes including a cluster-head node for providing a beacon signal, said method comprising:
<claim-text>sequentially transitioning between an awake state and a sleep state of operation according to the beacon signal;</claim-text>
<claim-text>determining whether said node has received at least one message from another node for a plurality of transition cycles between said awake state and sleep state; and</claim-text>
<claim-text>extending said sleep state for each successive transition cycle, in an instance where no messages are received during a previous transition cycle, further comprising:</claim-text>
<claim-text>incrementing a counter each time said node cycles between said awake and asleep states of operation;</claim-text>
<claim-text>comparing said count to a predetermined count threshold; and</claim-text>
<claim-text>extending said sleep state for each successive transition cycle, in an instance where said count exceeds said predetermined count threshold and no messages are received during a previous transition cycle.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein said at least one message comprises at least one of a request to send (RTS) and a traffic indication map (TIM).</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein said sequentially transitioning between said awake state and said sleep state of operation comprises:
<claim-text>providing said beacon signal with a plurality of sequential beacon intervals, wherein said beacon intervals each comprises a plurality of time slots associated with said plurality of groups of nodes in said cluster.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The sleeping protocol of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein said groups of nodes are defined by node_id modulo n, where node_id is a unique host identification of each node, and n is a number of groups formed in said cluster.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The sleeping protocol of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein said time slots are sequentially numbered zero to n−1.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The sleeping protocol of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein each said beacon interval comprises at least one sequence of time slots numbered zero to n−1.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The sleeping protocol of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein one of said n time slots represents an epoch when a node is in an awake state, and n−1 time slots represent an epoch when said node is in a sleep state.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The sleeping protocol of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein each node is in an awake state during a time slot “m” corresponding to said node's assigned group number such that m=n.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The sleeping protocol of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said node is in said sleep state during time slots occurring at (m+1) modulo n.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, further comprising:
<claim-text>counting said plurality of sequential beacon intervals; and</claim-text>
<claim-text>transitioning said node from an extended sleep state to an awake state, in an instance where said plurality of sequential beacon intervals exceeds a predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method of synchronizing a node moving from a first cluster to a second cluster, said node having a sleeping protocol, the method comprising:
<claim-text>receiving, during an awake state of operation, a first beacon signal originating from a first cluster-head respectively associated with said first cluster, said beacon signal comprising a plurality of sequential beacon intervals, wherein said beacon intervals each comprises a plurality of time slots associated with groups of nodes in said first cluster;</claim-text>
<claim-text>sequentially transitioning between an awake state and a sleep state of operation associated with said first beacon signal;</claim-text>
<claim-text>during a subsequent awake state of operation, receiving a second beacon signal originates from said second cluster;</claim-text>
<claim-text>recording information associated with said second beacon signal;</claim-text>
<claim-text>staying in said awake state for a period exceeding a beacon interval of said second beacon signal; and</claim-text>
<claim-text>synchronizing with said second beacon signal of said second cluster.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising: sequentially transitioning between an awake state and a sleep state of operation associated with said second beacon signal.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein said node is out of range for receiving said first beacon signal.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein said node returns to said sleeping state in an instance where said second beacon signal is not received during an awake state of operation.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A method of transferring data from a first node to a second node, at least one of the two nodes having a sleeping protocol, the method comprising:
<claim-text>transitioning said first node to an active state of operation;</claim-text>
<claim-text>setting a message count clock to zero;</claim-text>
<claim-text>sending a message from said first node to said second node;</claim-text>
<claim-text>in an instance where said second node does not send an acknowledgement message, repeating said message a number of times until a message sent threshold has been exceeded;</claim-text>
<claim-text>determining when said second node is in an awake mode; and</claim-text>
<claim-text>sending said message from said first node to said second node in an instance where said second node is in said awake mode.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein said message comprises a request to send (RTS) message and said acknowledgement message comprises a clear to send (CTS) message.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein said message is a traffic indication message (TIM).</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising:
<claim-text>determining whether said second node has changed from a first cluster to a second cluster; and</claim-text>
<claim-text>obtaining timing information for said second node in an instance where said second node changed clusters.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein said obtaining timing information comprises:
<claim-text>sending said timing information from a cluster-head associated with said second cluster to a cluster-head associated with said first cluster.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising:
<claim-text>determining whether said second node has changed from a first cluster to a second cluster; and</claim-text>
<claim-text>obtaining routing information for said second node in an instance where said second node changed clusters.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
