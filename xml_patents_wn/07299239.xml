<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299239-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299239</doc-number>
<kind>B1</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10308787</doc-number>
<date>20021202</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>574</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707102</main-classification>
<further-classification>707  2</further-classification>
<further-classification>707100</further-classification>
<further-classification>707101</further-classification>
</classification-national>
<invention-title id="d0e53">Methods for partitioning an object</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5551027</doc-number>
<kind>A</kind>
<name>Choy et al.</name>
<date>19960800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707201</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2002/0194157</doc-number>
<kind>A1</kind>
<name>Zait et al.</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2002/0194196</doc-number>
<kind>A1</kind>
<name>Weinberg et al.</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>7071041</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2003/0061263</doc-number>
<kind>A1</kind>
<name>Riddle</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709104</main-classification></classification-national>
</citation>
</references-cited>
<number-of-claims>12</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>7071041</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707201</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  2</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707101</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707102</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>3</number-of-figures>
</figures>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Basu</last-name>
<first-name>Subhransu</first-name>
<address>
<city>Fremont</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Raghavan</last-name>
<first-name>Ananth</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Shankar</last-name>
<first-name>Shrikanth</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Shukla</last-name>
<first-name>Vikram</first-name>
<address>
<city>Fremont</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Hickamn Palermo Troung &amp; Becker LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle International Corporation</orgname>
<role>02</role>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Wong</last-name>
<first-name>Don</first-name>
<department>2163</department>
</primary-examiner>
<assistant-examiner>
<last-name>Shechtman</last-name>
<first-name>Cheryl M</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The concept of partitioning is expanded with a variety of techniques. In particular, one technique involves partitioning an object at multiple levels, where at least one of the levels uses list-based partitioning. Further, a partitioning technique is provided which involves storing a data item in a default partition when the item does not map to any one of the list-based partitions for which a key value group has been defined. Techniques are also provided for efficiently splitting a partition.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="139.11mm" wi="154.43mm" file="US07299239-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="239.27mm" wi="153.42mm" orientation="landscape" file="US07299239-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="153.92mm" wi="160.78mm" file="US07299239-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="249.00mm" wi="163.41mm" orientation="landscape" file="US07299239-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The present invention relates to computer systems and more particularly, to techniques for partitioning objects within computer systems and improving performance of access to partitioned objects.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">In conventional relational database tables, rows are inserted into the table without regard to any type of ordering. Consequently, when a user submits a query that selects data from the table based on a particular value or range of values, the entire table has to be scanned to ensure that all rows that satisfy the criteria are identified. Partitioning is a technique that, in certain situations, avoids the need to search an entire table (or other database object).</p>
<p id="p-0004" num="0003">With partitioning, an object, such as a database table, is divided up into sub-tables, referred to as “partitions”. The most common form of partitioning is referred to as range partitioning. With range partitioning, each individual partition corresponds to a particular range of values for one or more columns of the table. For example, one column of a table may store date values that fall within a particular year, and the table may be divided into twelve partitions, each of which corresponds to a month of that year. All rows that have a particular month in the date column would then be inserted into the partition that corresponds to that month. In this example, partitioning the table will increase the efficiency of processing queries that select rows based on the month contained in the date column. For example, if a particular query selected all rows where month equals January, then only the partition associated with the month of January would have to be scanned.</p>
<p id="p-0005" num="0004">Typically, the criteria used to partition a database object is specified in the statement that creates the database object. For example, the following Structured Query Language (SQL) statement creates a table “sales” that is range partitioned based on date values contained in a column named “saledate”:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0005">create table sales
        <ul id="ul0003" list-style="none">
            <li id="ul0003-0001" num="0006">(saledate DATE,</li>
            <li id="ul0003-0002" num="0007">productid NUMBER, . . . )</li>
            <li id="ul0003-0003" num="0008">partition by range (saledate)
            <ul id="ul0004" list-style="none">
                <li id="ul0004-0001" num="0009">partition sal<b>94</b>Q<b>1</b> values less than to_date (yy-mm-dd, ‘94-04-01’)</li>
                <li id="ul0004-0002" num="0010">partition sal<b>94</b>Q<b>2</b> values less than to_date (yy-mm-dd, ‘94-07-01’)</li>
                <li id="ul0004-0003" num="0011">partition sal<b>94</b>Q<b>3</b> values less than to_date (yy-mm-dd, ‘94-10-01’)</li>
                <li id="ul0004-0004" num="0012">partition sal<b>94</b>Q<b>4</b> values less than to_date (yy-mm-dd, ‘95-01-01’)</li>
            </ul>
            </li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0006" num="0013">Execution of this statement creates a table named “sales” that includes four partitions: sal<b>94</b>Q<b>1</b>, sal<b>94</b>Q<b>2</b>, sal<b>94</b>Q<b>3</b>, and sal<b>94</b>Q<b>4</b>. The partition named sal<b>94</b>Q<b>1</b> includes all rows that have a date less than 94-04-01 in their saledate column. The partition named sal<b>94</b>Q<b>2</b> includes all rows that have a date greater than or equal to 94-04-01 but less than 94-07-01 in their saledate column. The partition named sal<b>94</b>Q<b>3</b> includes all rows that have a date greater than or equal to 94-07-01 but less than 94-10-01 in their saledate column. The partition named sal<b>94</b>Q<b>4</b> includes all rows that have a date greater than or equal to 94-10-01 but less than 95-01-01 in their saledate column.</p>
<p id="p-0007" num="0014">When a database server receives a request to perform an operation, the database server makes a plan of how to execute the query. If the operation involves accessing a partitioned object, part of making the plan involves determining which partitions of the partitioned object, if any, can be excluded from the plan (i.e. which partitions need not be accessed to execute the query). The process of excluding partitions from the execution plan of a query that accesses a partitioned object is referred to as “partition pruning”.</p>
<p id="p-0008" num="0015">Unfortunately, conventional pruning techniques can only be applied to a limited set of statements. For example, the database server can perform partition pruning when the statement received by the database server explicitly limits itself to a partition or set of partitions. Thus, the database server can exclude from the execution plan of the statement “select * from sales PARTITION(sal<b>94</b>Q<b>1</b>)” all partitions of the sales table other than the sal<b>94</b>Q<b>1</b> partition.</p>
<p id="p-0009" num="0016">The database server can also perform partition pruning on statements that do not explicitly limit themselves to particular partitions, but which select data based on the same criteria that was used to partition the partitioned object. For example, the statement:</p>
<p id="p-0010" num="0017">select * from sales where saledate between (94-04-01) and (94-06-15)</p>
<p id="p-0011" num="0018">does not explicitly limit itself to particular partitions. However, because the statement limits itself based on the same criteria (saledate values) as was used to partition the sales table, the database server is able to determine, based on the selection criteria of the statement and the partition definitions of the table, which partitions need not be accessed during execution of the statement. In the present example, the database server would be able to perform partition pruning that limits the execution plan of the statement to sal<b>94</b>Q<b>2</b>.</p>
<p id="p-0012" num="0019">Similarly, database servers can perform partition pruning for queries with WHERE clauses that (1) specify equalities that involve the partition key (e.g. where saledate=94-02-05), (2) include IN lists that specify partition key values (e.g. where saledate IN (94-02-05, 94-03-06)), and (3) include IN subqueries that involve the partition key (e.g. where salesdate in (select datevalue from T)).</p>
<p id="p-0013" num="0020">Another form of partitioning is referred to as hash partitioning. According to hash partitioning, one or more values from each record are applied to a hash function to produce a hash value. A separate partition is established for each possible hash value produced by the hash function, and rows that hash to a particular value are stored within the partition that is associated with that hash value. Similar to range based partitioning, hash partitioning increases the efficiency of processing certain types of queries. For example, when a query selects all rows that contain a particular value in the column that is used to perform the hash partitioning, the database server can apply the value in the query to the hash function to produce a hash value, and then limit the scan of the table to the partition that corresponds to the hash value thus produced.</p>
<p id="p-0014" num="0021">A table that is hash partitioned into four partitions may be created by the following statement:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0022">create table sales
        <ul id="ul0007" list-style="none">
            <li id="ul0007-0001" num="0023">(saledate DATE,</li>
            <li id="ul0007-0002" num="0024">productid NUMBER, . . . )</li>
        </ul>
        </li>
        <li id="ul0006-0002" num="0025">partition by hash (saledate)</li>
        <li id="ul0006-0003" num="0026">partitions <b>4</b>;</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0015" num="0027">Similar to range partitions, hash partitions may be used for queries with WHERE clauses that (1) specify equalities that involve the partition key, (2) include IN lists that specify partition key values, and (3) include IN subqueries that involve the partition key. However, unlike range-based partitioning, partition pruning cannot be performed for statements with predicates that specify ranges of partition key values. Consequently, hash-based partitioning is often used when the nature of the partition key is such that range-based queries are unlikely, such as when the partition key is “social security number”, “area code” or “zip code”.</p>
<p id="p-0016" num="0028">Another form of partitioning is referred to as list-based partitioning. Similar to hash-based partitioning, list-based partitioning can be used with data values that are discrete and cannot be logically ordered. List-based partitioning gives users precise control over which data belongs in each partition. For each partition, the user can specify a list of key values that map to that partition. The set of key values that are mapped to any given partition are referred to herein as the “key value groups” for that partition.</p>
<p id="p-0017" num="0029">List partitioning often complements the functionality of range partitioning when used in data warehouses. Range partitioning is useful for segmenting a table along a continuous domain, such as time. Tables in data warehouses are often range-partitioned by time, so that each range partition contains the data for a given range of time values such as one partition per month or per week. In contrast, list-based partitioning is useful for segmenting a table along a discrete domain, such as products. Each partition in a list-partitioned table contains data matching a list of discrete partition-key values.</p>
<p id="p-0018" num="0030">For example, assume that a data warehouse contains data for many different countries. The user may choose to list partition a large table by the regions europe, north-america, south-america and asia:</p>
<p id="p-0019" num="0031">create table sales_history ( . . . )</p>
<p id="p-0020" num="0032">partition by list (country)(</p>
<p id="p-0021" num="0033">partition europe values (‘United Kingdom’, ‘Germany’, ‘France’),</p>
<p id="p-0022" num="0034">partition north_america values (‘United States’, ‘Canada’, ‘Mexico’),</p>
<p id="p-0023" num="0035">partition south_america values (‘Brazil’, ‘Argentina’),</p>
<p id="p-0024" num="0036">partition asia values (‘Japan’, ‘Korea’)</p>
<p id="h-0003" num="0000">Rows for any of the countries listed above will automatically be placed in the appropriate regional partitions.</p>
<p id="p-0025" num="0037">A user may use the partitioning scheme above if data is accessed or modified according to region or country. Regional partitions enable data centers to take advantage of the different time zones of different regions. For example, Europe's night hours overlap American business hours, so the European partition can be maintained while American partitions remain in full operation.</p>
<p id="p-0026" num="0038">Due to the benefits that result from partition pruning, it is clearly desirable to provide techniques for performing partition pruning for a wider variety of statements.</p>
<heading id="h-0004" level="1">SUMMARY</heading>
<p id="p-0027" num="0039">Techniques are disclosed for expanding the concept of partitioning in a variety of ways. In particular, techniques are described which involve partitioning an object at multiple levels where at least one of the levels uses list-based partitioning. Further, a partitioning technique is provided which involves storing a data item in a default partition when the item does not map to any one of the list-based partitions for which a key value group has been defined. Techniques are also provided for efficiently splitting a partition.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0028" num="0040">The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:</p>
<p id="p-0029" num="0041"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating a table partitioned using range-list partitioning, according to one embodiment;</p>
<p id="p-0030" num="0042"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating a partitioned table including a default partition, according to one embodiment;</p>
<p id="p-0031" num="0043"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram illustrating a computer system on which embodiments of the invention may be implemented.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0032" num="0044">A method and apparatus for partitioning an object are described. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.</p>
<p id="p-0033" num="0045">Embodiments are described herein according to the following outline:</p>
<p id="p-0034" num="0046">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="14pt" align="left"/>
<colspec colname="2" colwidth="203pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>1.0</entry>
<entry>General Overview</entry>
</row>
<row>
<entry>2.0</entry>
<entry>Partitioning an Object at a Plurality of Levels of Using List-Based</entry>
</row>
<row>
<entry/>
<entry>Partitioning</entry>
</row>
<row>
<entry>3.0</entry>
<entry>Default Partitions</entry>
</row>
<row>
<entry>4.0</entry>
<entry>Fast-split Partitioning</entry>
</row>
<row>
<entry>5.0</entry>
<entry>Hardware Overview</entry>
</row>
<row>
<entry>6.0</entry>
<entry>Extensions and Alternatives</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
1.0 General Overview
</p>
<p id="p-0035" num="0047">In one embodiment, an object is statically partitioned at a plurality of levels. Partitioning an object at multiple levels is described in detail in U.S. patent application Ser. No. 09/405,980, which is incorporated herein in its entirety. However, unlike the multi-level partitioning described in U.S. patent application Ser. No. 09/405,980, the techniques described herein involve partitioning an object at multiple levels where at least one of the levels uses list-based partitioning. Further, a partitioning technique is provided which involves storing a data item in a “default partition” when the item does not map to any one of the list-based partitions for which a key value group has been defined. Techniques are also provided for efficiently splitting a partition.</p>
<p id="h-0007" num="0000">2.0 Partitioning an Object at a Plurality of Levels Using List-Based Partitioning</p>
<p id="p-0036" num="0048">According to one embodiment, a partitioning technique is provided which involves partitioning an object at a plurality of levels in which at least one of the plurality of levels is partitioned using list-based partitioning. For example, a table may be partitioned using range-based partitioning to create a set of first-level partitions. Then list-based partitioning may be applied to each of the first-level partitions to create a second level of partitions.</p>
<p id="p-0037" num="0049">In one embodiment, at least one of the plurality of levels of partitioning is made using range-based partitioning. <figref idref="DRAWINGS">FIG. 1</figref> illustrates table <b>100</b> that has been partitioned using range-based partitioning at the first level, and list-based partitioning at the second level. At a first level, table <b>100</b> has been partitioned using range-based partitioning on the first level partitioning key “date”. At the second level, each partition created at the first level has been partitioned using list-based partitioning on the second level partitioning key “areacode”.</p>
<p id="p-0038" num="0050">When a row is inserted in table <b>100</b>, the appropriate partition for the row is determined based on partitioning rules that apply to each level, and the value that the row has for the partitioning key used at that level. For example, assume that a row is inserted into table <b>100</b>, and that within the row, “date=99-02-02” and “areacode=408”. The appropriate first-level partition is selected by determining which of first-level partitions <b>102</b>, <b>104</b> and <b>106</b> is associated with the range into which “date=99-02-02” falls. In the present example, partition <b>104</b> is selected. As described in greater detail hereafter, the appropriate second-level partition of second-level partitions <b>114</b>, <b>116</b>, <b>118</b> is selected based on which key value group area code <b>408</b> belongs to. Assuming that “408” is a member of a key value group associated with partition <b>116</b>, partition <b>116</b> is selected. Having arrived at the lowest level of partitioning, the row is stored within partition <b>116</b>.</p>
<p id="p-0039" num="0051">In one embodiment, a statement may select rows from table <b>100</b> based on both partitioning keys. For example, a statement may select rows from table <b>100</b> where “date=99-02-02” and “areacode=408”. By inspecting the partitioning metadata associated with table <b>100</b>, it is determined that the selection criteria used in the statement uses the first and second-level partitioning keys associated with table <b>100</b>. Therefore, partition pruning is performed at the first and second levels. In the present example, it is determined that “99-02-02” falls within the range associated with partition <b>104</b>, and that “408” is a member of the key value group corresponding to partition <b>116</b>. Therefore, all partitions except partition <b>116</b> are excluded from the execution plan of the query during partition pruning.</p>
<p id="p-0040" num="0052">The example given in <figref idref="DRAWINGS">FIG. 1</figref> illustrates statically partitioning a table at two levels, where the first level of partitions are formed using range-based partitioning, and the second level of partitions are formed using list-based partitioning. However, the techniques described herein apply to any multiple-level static partitioning scheme in which partitions at one or more of the levels are formed using list-based partitioning. For example, rather than using range and list partitioning for the first and second levels, respectively, the first level of partitions may be constructed using list-based partitioning, and the second level may be constructed using range-based partitioning. Further, instead of or in addition to combining list-based partitioning with range-based partitioning, list-based partitioning may be combined with any other form of partitioning, such as hash-based partitioning. For example, a single table may be partitioned at five levels, where the partitions at the first and third levels are formed using list-based partitioning, the partitions at the second and fifth levels are formed using range-based partitioning, and the partitions at the fourth level are formed using hash-based partitioning.</p>
<p id="p-0041" num="0053">When partitioning an object at a plurality of levels, each of the partitions at the Nth level may partitioned in a different manner than the other Nth-level partitions to produce N+1 level partitions. For example, each partition that is created at a first level may itself be partitioned using list-based partitioning to produce second level partitions. However, the key value groups used to partition each of those first-level partitions may be different from the key value groups used to partition each of the other first-level partitions. For example, partitions <b>114</b>, <b>116</b> and <b>118</b> may correspond to key value groups {<b>202</b>, <b>415</b>}, {<b>408</b>, <b>703</b>}, and {<b>714</b>}, respectively. However, partitions <b>120</b>, <b>122</b> and <b>124</b> may correspond to key value groups {<b>714</b>, <b>202</b>}, {<b>408</b>, <b>415</b>}, and {<b>703</b>}, respectively.</p>
<p id="p-0042" num="0054">In many situations, it may be desirable for the same partitioning scheme to be applied to all of the Nth level partitions to create the N+1 level partitions. Therefore, in one embodiment, a “template” mechanism is provided. Using the template mechanism, a user is able to specify one set of key value groups, and have those same key value groups automatically used to partition every Nth level partition to form N+1 level partitions.</p>
<p id="p-0043" num="0055">For example, referring again to <figref idref="DRAWINGS">FIG. 1</figref>, a user may define a template that specifies the key value groups {<b>202</b>, <b>415</b>}, {<b>408</b>, <b>703</b>}, and {<b>714</b>}. That template may then be used as the partitioning criteria for all of first level partitions <b>102</b>, <b>104</b> and <b>106</b> of table <b>100</b>.</p>
<p id="p-0044" num="0056">By applying a template to partitions on a per level basis, instead of a per partition basis, a large range-list table, for example, may be created without having to specify a large number of SQL statements, and the partitioned table has symmetry in which the partitions have the exact same metadata. Thus, second-level partitions <b>108</b>, <b>114</b> and <b>112</b> would all be associated with key value group {<b>202</b>, <b>415</b>}, second-level partitions <b>110</b>, <b>116</b> and <b>122</b> would all be associated with key value group {<b>408</b>, <b>703</b>}, and second-level partitions <b>112</b>, <b>118</b> and <b>124</b> would all be associated with the key value group {<b>714</b>}.</p>
<p id="h-0008" num="0000">3.0 Default Partitions</p>
<p id="p-0045" num="0057">According to one embodiment, a partitioning technique is provided which involves storing data items in a “default partition” when the data items have key values that do not belong to any key value group. Referring to <figref idref="DRAWINGS">FIG. 2</figref>, metadata that is stored for table <b>200</b> includes a set of key value groups <b>201</b>. In the illustrated example, the set of key value groups <b>201</b> includes key value groups <b>202</b>, <b>204</b>, and <b>206</b>. Each key value group <b>202</b>, <b>204</b>, and <b>206</b> of table <b>200</b> corresponds to a different partition <b>210</b>, <b>212</b> and <b>214</b>, respectively, and includes those key values that map to the corresponding partition. The set of key value groups <b>201</b> includes all key value groups <b>202</b>, <b>204</b> and <b>206</b> for table <b>200</b>.</p>
<p id="p-0046" num="0058">In one embodiment, key value groups <b>202</b>, <b>204</b> and <b>206</b> are established, and table <b>200</b> is divided into a plurality of partitions <b>210</b>, <b>212</b> and <b>214</b>, in which each key value group corresponds to a different partition of the plurality of partitions. Assume a request is received to insert a data item into table <b>200</b> whose key value is not a member of any key value group in the set of key value groups <b>201</b>. For example, a request is received to insert a data item into table <b>200</b> whose key value is “6”. The key value “6” is not a member of any key value group in the set of key value groups <b>201</b>. In response to receiving the request, the data item that does not correspond to any of the key value groups <b>202</b>, <b>204</b> and <b>206</b> is stored in a default partition <b>216</b>. In the present example, the data item whose key value is “6” is stored in default partition <b>216</b> of table <b>200</b>.</p>
<p id="p-0047" num="0059">In one embodiment, in response to a request to add a key value to key value group <b>202</b>, <b>204</b> or <b>206</b>, default partition <b>216</b> is inspected to determine whether default partition <b>216</b> has any data items that correspond to the key value to be added. If any data items in default partition <b>208</b> have as their key value the key value to be added, then the data items are moved from default partition <b>216</b> to the partition associated with the key value group to which the new key value is being added.</p>
<p id="p-0048" num="0060">For example, assume a request is received to add key value “12” to key value group <b>206</b> in table <b>200</b>. In response to receiving this request, default partition <b>216</b> is inspected to determine whether default partition <b>216</b> has a data item associated with key value “12”. As illustrated in <figref idref="DRAWINGS">FIG. 2</figref>, default partition <b>216</b> contains data item “12” which has key value “12”. Therefore, data item “12” is moved from the default partition <b>216</b> to the partition <b>214</b> associated with key value group <b>206</b>, which is the partition to which the key value is to be added.</p>
<p id="p-0049" num="0061">In another embodiment, if any data items in default partition <b>216</b> have as their key value the key value to be added, an error message is generated. In the present example, an error message would be generated because a data item in default partition <b>216</b> has as its key value “12”, which is the key value to be added to key value group <b>206</b>.</p>
<p id="h-0009" num="0000">4.0 Fast-Split Partitioning</p>
<p id="p-0050" num="0062">Techniques are described herein for splitting partitions in an efficient manner, referred to herein as fast-split partitioning. The techniques may be used to split a partition of a table that has been statically partitioned. Prior to a fast-split operation, the partition that is to be split will have a corresponding definition. The partition definition specifies a criteria for data items in the original partition. For example, with respect to list-based partitioning, the partition definition is the key value group that defines which data items are included in the corresponding partition. In range-based partitioning, the partition definition may be values that define a particular range, such as 1 to 100.</p>
<p id="p-0051" num="0063">During the split operation, the database system receives partition definitions for the new partitions into which the existing partition is to be split. According to one embodiment, it is determined whether only one partition of the plurality of new partitions would include any data that currently exists in the existing partition. For example, in Table 2, assume a request is received to split partition <b>212</b> into a first new partition with data items associated with key value “2” and a second new partition with data items associated with key value “3”. Upon inspection, it is determined that only the first partition would include data that currently exists in partition <b>212</b>, as partition <b>212</b> only contains the value “2”, which is associated with key value “2”. Because all of the data in the existing partition would go into only one of the new partitions, this partition split operation is a candidate for the “fast-split” technique.</p>
<p id="p-0052" num="0064">In one embodiment, a fast-split operation is performed when a set of conditions is satisfied, where one of the conditions is that one partition of the plurality of new partitions would include all data items that exist in the existing partition. When the plurality of conditions is satisfied, then the fast-split operation is performed by using the existing partition as the new non-empty partition. Metadata for the table is simply updated to update the definition of the existing partition, and to establish each other new partitions. In the present example, the first new partition associated with key value “2” would contain data item “2” that exists in the existing partition, and the second new partition associated with key value “3” would be empty. Therefore, the existing partition <b>212</b> is used as the new non-empty partition, the definition for the existing partition <b>212</b> is updated to indicate that its key value group is now {<b>2</b>}, and the metadata associated with a new partition, associated with key value group {<b>3</b>}, is created.</p>
<p id="p-0053" num="0065">In one embodiment, the set of conditions to be satisfied includes the condition that the storage characteristics specified for the new non-empty partitions are the same as the storage characteristics that exist for the existing partition. Examples of storage characteristics include table space, initial extents or next extents.</p>
<p id="p-0054" num="0066">In one embodiment, the step of determining whether a partition is empty includes formulating queries associated with the new partitions and executing the queries against that existing partition. For example, Structured Query Language (SQL) statements may be issued against the existing partition see if the existing partition returns rows from each of the new partitions. Thus, in the example given above, an SQL query can be issued against partition <b>204</b> to see if partition <b>204</b> contains any data items with key value “2”, and another query can be issued against partition <b>204</b> to see if partition <b>204</b> contains any data items with key value “3”. In this case, only the first query will return rows. Based on this information, the database server knows that all of the data in the existing partition will belong to the new partition associated with the key value group {<b>2</b>}.</p>
<p id="p-0055" num="0067">An index is a data structure that belongs to a table or cluster, which is used to locate requested data faster than scanning the entire object. Given a certain data value, the index points directly to the location of the data. Partitions exist in both index as well as table objects. Two types of partitioned indexes are local indexes and global indexes. In a partitioned table, a user may create a local index, in which every table partition has exactly one corresponding local index partition. A user may also create a global index, which is partitioned independently of the base table. Therefore there may not be a one-to-one correspondence between global index partitions and base table partitions.</p>
<p id="p-0056" num="0068">In one embodiment, following a fast split operation, the global indexes for the partitioned table remain useable. If the storage characteristics specified for the local index for the new non-empty partition are the same as the storage characteristics for the existing partition, then the local index of the existing partition is useable.</p>
<p id="h-0010" num="0000">5.0 Hardware Overview</p>
<p id="p-0057" num="0069"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram that illustrates a computer system <b>300</b> upon which an embodiment of the invention may be implemented. Computer system <b>300</b> includes a bus <b>302</b> or other communication mechanism for communicating information, and a processor <b>304</b> coupled with bus <b>302</b> for processing information. Computer system <b>300</b> also includes a main memory <b>306</b>, such as a random access memory (RAM) or other dynamic storage device, coupled to bus <b>302</b> for storing information and instructions to be executed by processor <b>304</b>. Main memory <b>306</b> also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor <b>304</b>. Computer system <b>300</b> further includes a read only memory (ROM) <b>308</b> or other static storage device coupled to bus <b>302</b> for storing static information and instructions for processor <b>304</b>. A storage device <b>310</b>, such as a magnetic disk or optical disk, is provided and coupled to bus <b>302</b> for storing information and instructions.</p>
<p id="p-0058" num="0070">Computer system <b>300</b> may be coupled via bus <b>302</b> to a display <b>312</b>, such as a cathode ray tube (CRT), for displaying information to a computer user. An input device <b>314</b>, including alphanumeric and other keys, is coupled to bus <b>302</b> for communicating information and command selections to processor <b>304</b>. Another type of user input device is cursor control <b>316</b>, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor <b>304</b> and for controlling cursor movement on display <b>312</b>. This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.</p>
<p id="p-0059" num="0071">The invention is related to the use of computer system <b>300</b> for implementing the techniques described herein. According to one embodiment of the invention, those techniques are performed by computer system <b>300</b> in response to processor <b>304</b> executing one or more sequences of one or more instructions contained in main memory <b>306</b>. Such instructions may be read into main memory <b>306</b> from another computer-readable medium, such as storage device <b>310</b>. Execution of the sequences of instructions contained in main memory <b>306</b> causes processor <b>304</b> to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.</p>
<p id="p-0060" num="0072">The term “computer-readable medium” as used herein refers to any medium that participates in providing instructions to processor <b>304</b> for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device <b>310</b>. Volatile media includes dynamic memory, such as main memory <b>306</b>. Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus <b>302</b>. Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.</p>
<p id="p-0061" num="0073">Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.</p>
<p id="p-0062" num="0074">Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor <b>304</b> for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system <b>300</b> can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus <b>302</b>. Bus <b>302</b> carries the data to main memory <b>306</b>, from which processor <b>304</b> retrieves and executes the instructions. The instructions received by main memory <b>306</b> may optionally be stored on storage device <b>310</b> either before or after execution by processor <b>304</b>.</p>
<p id="p-0063" num="0075">Computer system <b>300</b> also includes a communication interface <b>318</b> coupled to bus <b>302</b>. Communication interface <b>318</b> provides a two-way data communication coupling to a network link <b>320</b> that is connected to a local network <b>322</b>. For example, communication interface <b>318</b> may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface <b>318</b> may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface <b>318</b> sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.</p>
<p id="p-0064" num="0076">Network link <b>320</b> typically provides data communication through one or more networks to other data devices. For example, network link <b>320</b> may provide a connection through local network <b>322</b> to a host computer <b>324</b> or to data equipment operated by an Internet Service Provider (ISP) <b>326</b>. ISP <b>326</b> in turn provides data communication services through the world wide packet data communication network now commonly referred to as the “Internet” <b>328</b>. Local network <b>322</b> and Internet <b>328</b> both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link <b>320</b> and through communication interface <b>318</b>, which carry the digital data to and from computer system <b>300</b>, are exemplary forms of carrier waves transporting the information.</p>
<p id="p-0065" num="0077">Computer system <b>300</b> can send messages and receive data, including program code, through the network(s), network link <b>320</b> and communication interface <b>318</b>. In the Internet example, a server <b>330</b> might transmit a requested code for an application program through Internet <b>328</b>, ISP <b>326</b>, local network <b>322</b> and communication interface <b>318</b>.</p>
<p id="p-0066" num="0078">The received code may be executed by processor <b>304</b> as it is received, and/or stored in storage device <b>310</b>, or other non-volatile storage for later execution. In this manner, computer system <b>300</b> may obtain application code in the form of a carrier wave.</p>
<p id="h-0011" num="0000">6.0 Extensions and Alternatives</p>
<p id="p-0067" num="0079">In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A machine-implemented method of partitioning a table that comprises a plurality of rows that each contain data, the method comprising:
<claim-text>statically partitioning said table at a plurality of levels, wherein the step of statically partitioning said table at a plurality of levels includes the steps of:
<claim-text>(a) statically partitioning said table at a first level based on a first criteria to create a first set of table partitions, wherein each table partition in the first set of partitions is a distinct subtable of said table and contains a distinct subset of said plurality of rows relative to the other table partitions in the first set; and</claim-text>
<claim-text>(b) statically partitioning said table at a second level based on a second criteria to create a second set of table partitions, wherein each table partition in the second set of table partitions is a distinct subtable of said table and contains a distinct subset of said plurality of rows relative to the other partitions in the second set, wherein said first set of table partitions is different than said second set of table partitions, and</claim-text>
<claim-text>wherein said table is partitioned at one or more of said plurality of levels using list-based partitioning;</claim-text>
<claim-text>wherein partitioning said table using list-based partitioning results in a particular set of table partitions;</claim-text>
<claim-text>wherein each table partition in the particular set of table partitions is associated with an explicitly enumerated set of key values;</claim-text>
<claim-text>wherein the explicitly enumerated set of key values that is associated with each table partition in the particular set of table partitions has no key values in common with the explicitly enumerated set of key values associated with any other of the table partitions in the particular set of table partitions;</claim-text>
<claim-text>wherein, for each table partition in the particular set of table partitions, each row in said table partition contains a value from the explicitly enumerated set of key values that has been assigned to said table partition.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one of the levels is partitioned using range-based partitioning.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A computer-readable storage medium carrying instructions which, when executed by one or more processors, cause said one or more processors to perform the method recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one of the levels is partitioned using hash-based partitioning.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A computer-readable storage medium carrying instructions which, when executed by one or more processors, cause said one or more processors to perform the method recited in <claim-ref idref="CLM-00004">claim 4</claim-ref>.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least another one of the levels is partitioned using list-based partitioning.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A computer-readable storage medium carrying instructions which, when executed by one or more processors, cause said one or more processors to perform the method recited in <claim-ref idref="CLM-00006">claim 6</claim-ref>.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>partitions at said second level are created by statically partitioning each partition created at said first level; and</claim-text>
<claim-text>each partition at said first level is statically partitioned using an identical partitioning criteria to produce said partitions at said second level.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref> wherein the step of partitioning each partition created at said first level includes the steps of:
<claim-text>defining a template that specifies partitioning criteria; and</claim-text>
<claim-text>using the partitioning criteria specified in said template to partition all partitions created at said first level.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A computer-readable storage medium carrying instructions which, when executed by one or more processors, cause said one or more processors to perform the method recited in <claim-ref idref="CLM-00009">claim 9</claim-ref>.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A computer-readable storage medium carrying instructions which, when executed by one or more processors, cause said one or more processors to perform the method recited in <claim-ref idref="CLM-00008">claim 8</claim-ref>.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A computer-readable storage medium carrying instructions which, when executed by one or more processors, cause said one or more processors to perform the method recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text>
</claim>
</claims>
</us-patent-grant>
