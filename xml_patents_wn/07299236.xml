<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299236-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299236</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10867588</doc-number>
<date>20040615</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>542</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707101</main-classification>
<further-classification>707102</further-classification>
<further-classification>707  6</further-classification>
</classification-national>
<invention-title id="d0e53">Test data compression and decompression method using zero-detected run-length code in system-on-chip</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>2004/0190331</doc-number>
<kind>A1</kind>
<name>Ross et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>365154</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00002">
<othercit>Gonciari et al.: “Improving Compression Ratio, Area Overhead, and Test Application Time for System-on-a-Chip Test Data Compression/Decompression”, Proceedings of the 2002 Design, Automation and Test in Europe Conference and Exhibition.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00003">
<othercit>Li et al.: “Testing Data Compression Using Dictionaries with Selective Entries and Fixed-Length Indices”, ACM Transactions on Design Automation of Electronic Systems, vol. 8, No. 4, Oct. 2003.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00004">
<othercit>Shi et al.: “FCSCAN: An Efficient Multiscan-based Test Compression Technique fro Test Cost Reduction”, Department of Computer Science, Waseda University, Japan, 2006.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00005">
<othercit>Kay et al.: “Embedded Test Control Schemes for Compression in SOCs”, DAC 2002, Jun. 10-14, New Orleans, Louisiana, USA.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
</references-cited>
<number-of-claims>2</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707101</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707102</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  6</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>2</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050278400</doc-number>
<kind>A1</kind>
<date>20051215</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Kang</last-name>
<first-name>Sung-Ho</first-name>
<address>
<city>Seoul</city>
<country>KR</country>
</address>
</addressbook>
<nationality>
<country>KR</country>
</nationality>
<residence>
<country>KR</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Lee</last-name>
<first-name>Yong</first-name>
<address>
<city>Seoul</city>
<country>KR</country>
</address>
</addressbook>
<nationality>
<country>KR</country>
</nationality>
<residence>
<country>KR</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>GWIPS</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Industry-Academic Cooperation Foundation, Yonsei University</orgname>
<role>03</role>
<address>
<city>Seodaemoon-Gu, Seoul</city>
<country>KR</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Lu</last-name>
<first-name>Kuen S.</first-name>
<department>2167</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method of effectively compressing a test vector is introduced for testing a system-on-chip (SOC) semiconductor device. Since the number of test vectors is increased in a SOC, the number of ‘0’s is increased if adjacent test vectors are properly aligned using an ordering algorithm. ‘0000’ is considered as a single block and a counter of ‘0-group’ is incremented by one to encode each further instance of the string ‘0000’. A codeword capable of being decompressed can be generated using only a counter without using a memory block.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="98.38mm" wi="157.31mm" file="US07299236-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="203.12mm" wi="174.58mm" file="US07299236-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="202.95mm" wi="162.22mm" file="US07299236-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention relates to a method of effectively compressing a test vector required for testing a system-on-chip (SOC) semiconductor device. The present invention is the result of efforts to foster and support university IT research centers, carried out by the Ministry of Information and Communication in Republic of Korea.</p>
<p id="p-0004" num="0003">2. Related Prior Art</p>
<p id="p-0005" num="0004">With the development of semiconductor design techniques, a system-on-chip (SOC) configuration, in which functional blocks are integrated into a single chip, can be manufactured. In order to test semiconductor devices in such a high-performance SOC, the number and complexity of test vectors to be input are increased and automatic test equipment (ATE) requires a high operating frequency and a large memory capacity. This increases time and cost required for testing the semiconductor devices. Accordingly, people have a growing interest in the compression of test vectors. The compression of the test vector enables effective utilization of a restricted channel of the ATE.</p>
<p id="p-0006" num="0005">The test vector used when a semiconductor device is tested has a large number of similar bits. Thus, the test vector can represent only values that are different from each other when the exclusive-OR operation (XOR) is carried out on the bits of the test vector. This is because the elusive-OR operation outputs ‘0’ when the input bits are identical to each other but outputs ‘1’ when the input bits are different from each other. The original test vector T<sub>d </sub>and a test set T<sub>diff </sub>are defined as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>d</sub>={t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, t<sub>4</sub>, t<sub>5</sub>, . . . , t<sub>n</sub>}<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>diff</sub>={d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>, . . . , d<sub>n</sub>}={t<sub>1</sub>, t<sub>1</sub>⊕t<sub>2</sub>, t<sub>2</sub>⊕t<sub>3</sub>, . . . ,t<sub>n−1</sub>⊕t<sub>n</sub>}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0007" num="0006">According to this method, only the bits of the test vector that have different values from the corresponding bits of the previous element are represented by ‘1’. Thus, most of values of T<sub>diff </sub>are continuous ‘0’s considering that the test vector is characterized by having a large number of identical bits.</p>
<p id="p-0008" num="0007">The vector T<sub>diff </sub>generated as above is connected in a single chain as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>diff</sub>: d<sub>1</sub>=00000100<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>d<sub>2</sub>=00110000<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>d<sub>3</sub>=00010001<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
=&gt;000001000011000000010001
</p>
<p id="p-0009" num="0008">The point where the bit ‘1’ first appears in the chain is checked and the number of digits of ‘0’ appearing before the bit ‘1’ is counted to generate a codeword through a method represented by Table 1.</p>
<p id="p-0010" num="0009">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="133pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Codeword</entry>
<entry>T<sub>diff</sub></entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="133pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry/>
<entry>000</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>001</entry>
<entry>01</entry>
</row>
<row>
<entry/>
<entry>010</entry>
<entry>001</entry>
</row>
<row>
<entry/>
<entry>011</entry>
<entry>0001</entry>
</row>
<row>
<entry/>
<entry>100</entry>
<entry>00001</entry>
</row>
<row>
<entry/>
<entry>101</entry>
<entry>000001</entry>
</row>
<row>
<entry/>
<entry>110</entry>
<entry>0000001</entry>
</row>
<row>
<entry/>
<entry>111</entry>
<entry>00000001</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0011" num="0010">The generated data is stored in the ATE for use. A corresponding circuit receives the compressed codeword and decompresses the compressed codeword to use it. A decompression device used for decompressing the codeword is illustrated in <figref idref="DRAWINGS">FIG. 1</figref>. A cyclical scan register (CSR) can obtain the current test vector from T<sub>diff </sub>by applying XOR to T<sub>diff </sub>again. Using this process, the original test vector can be completely restored using only a single decoder.</p>
<p id="p-0012" num="0011">However, as semiconductor device chips are configured as system-on-chips, the number of test vectors increases and the number of vectors having identical bits also increases. Accordingly, the conventional algorithm cannot effectively compress an increasing number of test sets for a circuit. Furthermore, a conventional statistical code compression technique increases hardware overhead and cannot make functional blocks for tests in a circuit large. There is therefore a need for a new compression technique capable of obtaining a high compression ratio using simple hardware.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0013" num="0012">Accordingly, the present invention is directed toward a test data compression and decompression method using a zero-detected run-length (ZDR) code in a system-on-chip (SOC) that substantially obviates one or more problems due to limitations and disadvantages of the related art.</p>
<p id="p-0014" num="0013">An object of the present invention is to provide a method of effectively compressing test data when a device is tested in a SOC.</p>
<p id="p-0015" num="0014">To accomplish the above object, according to the present invention, there is provided a test data compression method using a ZDR code in a system-on-chip (SOC), including the steps of:</p>
<p id="p-0016" num="0015">defining a test vector T<sub>d </sub>to be applied and a test set T<sub>diff </sub>as follows;
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>d</sub>={t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, t<sub>4</sub>, t<sub>5</sub>, . . . , t<sub>n</sub>}<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>diff</sub>={d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>, . . . , d<sub>n</sub>}={t<sub>1</sub>, t<sub>1</sub>⊕t<sub>2</sub>, t<sub>2</sub>⊕t<sub>3</sub>, . . . , t<sub>n−1</sub>⊕t<sub>n</sub>}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0017" num="0016">creating T<sub>d </sub>and T<sub>diff </sub>with values generated by an automatic test pattern generator (ATPG);</p>
<p id="p-0018" num="0017">connecting separate elements of T<sub>diff </sub>in a single chain;</p>
<p id="p-0019" num="0018">sequentially scanning T<sub>diff</sub>, creating a codeword when a bit ‘1’ appears, and when the codeword is ‘0000’, repeatedly checking a ‘0 Group’ while incrementing the bit of the ‘0 Group’ counter by one until a ‘1’ bit appears;</p>
<p id="p-0020" num="0019">recording ‘0111’ when the ‘0 Group’ becomes ‘0000 ’×8 and counting the number of bits having the value ‘0’; and</p>
<p id="p-0021" num="0020">creating a codeword of a ‘1 Group’ when a ‘1’ bit appears.</p>
<p id="p-0022" num="0021">The present invention provides a compression method using a ZDR code having a variable-to-variable-length code. Specifically, in this compression method, two consecutive test vectors are compared to each other, only bits different from corresponding bits of the previous vector are represented by ‘1’, and bits identical to corresponding bits of the previous vector are represented by ‘0’. This process is reversed to obtain the original test vectors.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0023" num="0022">The above and other objects, features and advantages of the present invention will be apparent from the following detailed description of the preferred embodiments of the invention in conjunction with the accompanying drawings, in which:</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a conventional decompression system.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 2</figref> illustrates the configuration of a decompression decoder according to the present invention.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 3</figref> illustrates the operation states of the finite state machine shown in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 4</figref> is a graph showing the comparison between codewords generated by a conventional technique and a technique proposed by the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
<p id="p-0028" num="0027">Reference will now be made in detail to the preferred embodiments of the present invention, examples of which are illustrated in the accompanying drawings.</p>
<p id="p-0029" num="0028">A test vector compression technique according to the present invention includes a compression algorithm and a decompression decoder.</p>
<p id="p-0030" num="0029">[Compression Algorithm]</p>
<p id="p-0031" num="0030">A ZDR code has a variable-to-variable-length code. Here, a test vector T<sub>d </sub>to be applied and a test set T<sub>diff </sub>are defined as follows.
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>d</sub>={t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, t<sub>4</sub>, t<sub>5</sub>, . . . , t<sub>n</sub>}<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>diff</sub>={d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>, . . . , d<sub>n</sub>}={t<sub>1</sub>, t<sub>1</sub>⊕t<sub>2</sub>, t<sub>2</sub>⊕t<sub>3</sub>, . . . , t<sub>n−1</sub>⊕t<sub>n</sub>}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0032" num="0031">The T<sub>diff </sub>compares each bit of two consecutive test vectors to each other, represents bits different from the corresponding bits of the previous vector by ‘1’ and records bits identical to corresponding bits of the previous vector as ‘0’. When this process is reversed, the original test vectors can be obtained. The ZDR compression method according to the present invention will now be explained in more detail with reference to Table 2.</p>
<p id="p-0033" num="0032">Step 1: T<sub>d </sub>and T<sub>diff </sub>are generated with values created by an automatic test pattern generator (ATPG). The elements of T<sub>diff </sub>thus generated are connected in a single chain.</p>
<p id="p-0034" num="0033">Step 2: is sequentially scanned, and when a bit ‘1’ appears, a codeword is created. When the codeword is ‘0000’, that is, when there are four ‘0’s in a row, a ‘0 Group’ is checked while increasing the bit of a ‘0 Group’ counter by one until ‘1’ appears as the next bit in T<sub>diff</sub>. When the ‘0 Group’ becomes ‘0000’×8, 0111 is recorded and bits having the value ‘0’ are counted.</p>
<p id="p-0035" num="0034">Step 3: When a ‘1’ bit appears, a codeword of a ‘1 Group’ is created. Then, the process returns to the second step to scan T<sub>diff </sub>bit by bit.</p>
<p id="p-0036" num="0035">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="49pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="49pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="center"/>
<colspec colname="5" colwidth="56pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="5" rowsep="1">TABLE 2</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
<row>
<entry>Group</entry>
<entry>Data</entry>
<entry>Prefix</entry>
<entry>Tail</entry>
<entry>Codeword</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="49pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="char" char="."/>
<colspec colname="3" colwidth="49pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="char" char="."/>
<colspec colname="5" colwidth="56pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>00</entry>
<entry>100</entry>
</row>
<row>
<entry/>
<entry>01</entry>
<entry/>
<entry>01</entry>
<entry>101</entry>
</row>
<row>
<entry/>
<entry>001</entry>
<entry/>
<entry>10</entry>
<entry>110</entry>
</row>
<row>
<entry/>
<entry>0001</entry>
<entry/>
<entry>11</entry>
<entry>111</entry>
</row>
<row>
<entry>0</entry>
<entry>0000</entry>
<entry>0</entry>
<entry>000</entry>
<entry>0000</entry>
</row>
<row>
<entry/>
<entry>0000x2</entry>
<entry/>
<entry>001</entry>
<entry>0001</entry>
</row>
<row>
<entry/>
<entry>0000x3</entry>
<entry/>
<entry>010</entry>
<entry>0020</entry>
</row>
<row>
<entry/>
<entry>0000x4</entry>
<entry/>
<entry>011</entry>
<entry>0011</entry>
</row>
<row>
<entry/>
<entry>0000x5</entry>
<entry/>
<entry>100</entry>
<entry>0100</entry>
</row>
<row>
<entry/>
<entry>0000x6</entry>
<entry/>
<entry>101</entry>
<entry>0101</entry>
</row>
<row>
<entry/>
<entry>0000x7</entry>
<entry/>
<entry>110</entry>
<entry>0110</entry>
</row>
<row>
<entry/>
<entry>0000x8</entry>
<entry/>
<entry>111</entry>
<entry>0111</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0037" num="0036">According to the above-described process, result values are not changed with the order of inputting the test vectors when a stuck-at fault is judged. Thus, a higher compression ratio can be obtained by aligning the test vectors to decrease the variation in the bits of adjacent patterns. In this case, codewords are created through the method represented in Table 4.</p>
<p id="p-0038" num="0037">Since the number of test vectors is increased in a SOC configuration, the number of ‘0’s is increased if adjacent test vectors are properly aligned using an ordering algorithm. ‘0000’ is considered as a single block and the count of the ‘0-group’is increased one by one to encode each further instance of the string ‘0000’. A codeword capable of being decompressed can be generated using only a counter without using a memory block.</p>
<p id="p-0039" num="0038">Table 3 represents a 32-bit test set to which the compression method according to the present invention is applied, and Table 4 compares the compression method using the ZDR code according to the present invention to a conventional Golomb method.</p>
<p id="p-0040" num="0039">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 3</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>32-bit test set (T<sub>diff</sub>)</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="left"/>
<colspec colname="3" colwidth="84pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>D1</entry>
<entry>0000000000000000</entry>
<entry>0000000100000000</entry>
</row>
<row>
<entry/>
<entry>D2</entry>
<entry>0000000000001000</entry>
<entry>0000000000000000</entry>
</row>
<row>
<entry/>
<entry>D3</entry>
<entry>0001010000000000</entry>
<entry>0000000000000001</entry>
</row>
<row>
<entry/>
<entry>D4</entry>
<entry>0000000000000010</entry>
<entry>0000000000000000</entry>
</row>
<row>
<entry/>
<entry>D5</entry>
<entry>0000000001000000</entry>
<entry>0000000000000001</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0041" num="0040">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" rowsep="1">TABLE 4</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>Compression using ZDR (Present invention)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>0000x5 0001 0000x5 1 0000x5 001 01 0000x6</entry>
</row>
<row>
<entry/>
<entry>0100 111 0100 110 0100 110 101 0101</entry>
</row>
<row>
<entry/>
<entry>01 0000x3 001 0000x8 0001 0000x5 1 0000x5 01</entry>
</row>
<row>
<entry/>
<entry>001 0010 110 0111 111 0100 100 0100 101</entry>
</row>
<row>
<entry/>
<entry>Codeword: 59 bits</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Compression using Golomb technique</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>0000x5 0001 0000x5 1 0000x5 001 01 0000x6 01</entry>
</row>
<row>
<entry/>
<entry>111110 11 111110 00 111110 10 001 1111110 01</entry>
</row>
<row>
<entry/>
<entry>0000x3 001 0000x8 0001 0000x5 1 0000x5 01</entry>
</row>
<row>
<entry/>
<entry>11110 10 111111110 11 111110 00 1111110 01</entry>
</row>
<row>
<entry/>
<entry>Codeword: 69 bits</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0042" num="0041">[Decompression Decoder]</p>
<p id="p-0043" num="0042">A corresponding circuit decompresses the codeword compressed according to the present invention, in order to use it. Herein, a decompression decoder shown in <figref idref="DRAWINGS">FIG. 2</figref> is used as a decompression device. <figref idref="DRAWINGS">FIG. 3</figref> shows operation states of a finite state machine (FSM) of the decompression decoder shown in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0044" num="0043">The operation states of the FSM have five steps, which will be described in detail.</p>
<p id="p-0045" num="0044">Internal signals of the decompression decoder are explained with reference to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0046" num="0045">Step 1: When a signal EN, which represents that the FSM can accept data, is output, a bit is input to the FSM through a signal BIT_IN.</p>
<p id="p-0047" num="0046">Step 2: When the bit input to the FSM is ‘0’, signals 0_SIGN and COUNTER_START of a 3-bit counter are on. When the bit input to the FSM is ‘1’, signals 1_SIGN and COUNTER_START are on.</p>
<p id="p-0048" num="0047">Step 3: 2 bits are input to the 3-bit counter through a signal SHIFT when the 0_SIGN is on and 3 bits are input to the 3-bit counter through the signal SHIFT when the 1_SIGN is on.</p>
<p id="p-0049" num="0048">Step 4: The 3-bit counter is operated. While step 4 is being processed, the FSM continuously outputs ‘0’s through a signal OUT for one clock. When the signal 0_SIGN is input to the 3-bit counter, a signal C_OUT is output from the 3-bit counter. Another 3-bit counter receives the signal C_OUT and records ‘100’. When the counting operation is finished, a signal V<sub>—</sub>2 is on. When the signal V<sub>—</sub>2 is input to the 3-bit counter, the 3-bit counter down-counts one bit. The operations of the counters are finished and the process returns to Step 1 when the 0_SIGN is input. When the signal 1_SIGN is input, the 3-bit counter is operated. In this case, when the count is finished, a signal V<sub>—</sub>1 is on.</p>
<p id="p-0050" num="0049">Step 5: When the signal V<sub>—</sub>1 is input to the FSM, a bit ‘1’ is output through the signal OUT and the process returns to Step 1.</p>
<p id="p-0051" num="0050">The operation of the decompression decoder of the present invention includes the aforementioned five steps. As described above, the operation of the decompression decoder is very simple such that a bit ‘0’ is output through the OUT of the FSM whenever a clock CLK is input in Step 4, a bit ‘1’ is output through the OUT when the signal V<sub>—</sub>1 is input in Step 5, and then the process is repeated.</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. 4</figref> is a graph showing the comparison of the ZDR code according to the present invention to the conventional Golomb code. It can be seen from <figref idref="DRAWINGS">FIG. 4</figref> that the compression ratio of the ZDR code according to the present invention increases abruptly over the conventional Golomb code as the run-length of consecutive ‘0’ bits is increased.</p>
<p id="p-0053" num="0052">In the case of (define) FDR, a counter requires a size capable of accepting 2 bits when a group becomes larger. Accordingly, hardware capable of handling the longest run-length is needed. This considerably increases the counter size.</p>
<p id="p-0054" num="0053">However, according to the compression and decompression method described in the present invention, the compression ratio has a logarithmic function curve and hardware can handle any run-length so that there is no need to reconstruct hardware depending on the core to be tested.</p>
<p id="p-0055" num="0054">Table 5 represents data obtained through a comparative experiment executed for the ZDR code and Golomb code.</p>
<p id="p-0056" num="0055">In Table 5, C.N. means a compression bit number and C.R. denotes a compression ratio.</p>
<p id="p-0057" num="0056">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="56pt" align="center"/>
<colspec colname="3" colwidth="42pt" align="center"/>
<colspec colname="4" colwidth="49pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="4" rowsep="1">TABLE 5</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Bit</entry>
<entry>Golomb code</entry>
<entry>ZDR C. R</entry>
<entry>ZDR Result</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="21pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="28pt" align="center"/>
<colspec colname="8" colwidth="21pt" align="center"/>
<tbody valign="top">
<row>
<entry>Circuit</entry>
<entry>number</entry>
<entry>C. N.</entry>
<entry>C. R.</entry>
<entry>(3, 2)</entry>
<entry>(4, 3)</entry>
<entry>C. N.</entry>
<entry>C. R.</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="35pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="28pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="center"/>
<tbody valign="top">
<row>
<entry>C2670</entry>
<entry>140965</entry>
<entry>51485</entry>
<entry>63.48</entry>
<entry>69.38</entry>
<entry>71.13</entry>
<entry>40699</entry>
<entry>71.13</entry>
</row>
<row>
<entry>C3540</entry>
<entry>25400</entry>
<entry>15706</entry>
<entry>38.17</entry>
<entry>41.00</entry>
<entry>29.69</entry>
<entry>14987</entry>
<entry>41.00</entry>
</row>
<row>
<entry>C5315</entry>
<entry>180492</entry>
<entry>68619</entry>
<entry>61.98</entry>
<entry>67.19</entry>
<entry>66.94</entry>
<entry>59226</entry>
<entry>67.19</entry>
</row>
<row>
<entry>C7552</entry>
<entry>136620</entry>
<entry>75550</entry>
<entry>44.70</entry>
<entry>51.96</entry>
<entry>45.20</entry>
<entry>65635</entry>
<entry>51.96</entry>
</row>
<row>
<entry>C641</entry>
<entry>10692</entry>
<entry>5374</entry>
<entry>49.74</entry>
<entry>52.96</entry>
<entry>44.78</entry>
<entry>5030</entry>
<entry>52.96</entry>
</row>
<row>
<entry>S713</entry>
<entry>10584</entry>
<entry>5370</entry>
<entry>49.26</entry>
<entry>52.31</entry>
<entry>43.78</entry>
<entry>5048</entry>
<entry>52.31</entry>
</row>
<row>
<entry>S1196</entry>
<entry>7808</entry>
<entry>6044</entry>
<entry>22.59</entry>
<entry>25.60</entry>
<entry>12.50</entry>
<entry>5809</entry>
<entry>25.60</entry>
</row>
<row>
<entry>S1238</entry>
<entry>8160</entry>
<entry>6155</entry>
<entry>24.57</entry>
<entry>27.25</entry>
<entry>14.75</entry>
<entry>5936</entry>
<entry>27.25</entry>
</row>
<row>
<entry>S1423</entry>
<entry>33852</entry>
<entry>13605</entry>
<entry>59.81</entry>
<entry>63.68</entry>
<entry>62.66</entry>
<entry>12296</entry>
<entry>63.68</entry>
</row>
<row>
<entry>S5378</entry>
<entry>259680</entry>
<entry>84415</entry>
<entry>67.49</entry>
<entry>72.14</entry>
<entry>73.60</entry>
<entry>68567</entry>
<entry>73.60</entry>
</row>
<row>
<entry>S9234</entry>
<entry>456703</entry>
<entry>153331</entry>
<entry>66.43</entry>
<entry>73.10</entry>
<entry>74.84</entry>
<entry>114909</entry>
<entry>74.84</entry>
</row>
<row>
<entry>S13207</entry>
<entry>2110500</entry>
<entry>559390</entry>
<entry>73.49</entry>
<entry>79.80</entry>
<entry>85.22</entry>
<entry>311834</entry>
<entry>85.22</entry>
</row>
<row>
<entry>S15850</entry>
<entry>1955200</entry>
<entry>526833</entry>
<entry>73.05</entry>
<entry>79.27</entry>
<entry>84.37</entry>
<entry>305501</entry>
<entry>84.37</entry>
</row>
<row>
<entry>S35932</entry>
<entry>5639837</entry>
<entry>1430412</entry>
<entry>74.64</entry>
<entry>80.85</entry>
<entry>86.87</entry>
<entry>740362</entry>
<entry>86.87</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0058" num="0057">The present invention can solve at-speed testing and bottleneck problems generated when the number of test sets is increased in an SOC. Furthermore, the present invention enables tests even in an environment where an internal core structure cannot be easily known due to the copyright of IP. The present invention can meet the time-to-market theory because tests can be executed with compressed test sets by adding hardware using only a counter to the SOC core.</p>
<p id="p-0059" num="0058">While the present invention has been described with reference to the particular illustrative embodiments, it is not to be restricted by the embodiments but only by the appended claims. It is to be appreciated that those skilled in the art can change or modify the embodiments without departing from the scope and spirit of the present invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of a test data compression using a Zero-Detected Run-length (ZDR) code in a system-on-chip, (SOC), which is stored in a form of algorism or computer programming, the method comprising the steps of:
<claim-text>defining a test vector T<sub>d </sub>to be applied and a test set T<sub>diff </sub>as follows,
<claim-text>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>d</sub>={t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, t<sub>4</sub>, t<sub>5</sub>, . . . , t<sub>n</sub>}, and<?in-line-formulae description="In-line Formulae" end="tail"?>
</claim-text>
<claim-text>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>T<sub>diff</sub>={d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>, d<sub>4</sub>, d<sub>5</sub>, . . . , d<sub>n</sub>}={t<sub>1</sub>, t<sub>1</sub>⊕t<sub>2</sub>t<sub>2</sub>⊕t<sub>3</sub>, . . . , t<sub>n-1</sub>⊕t<sub>n</sub>}<?in-line-formulae description="In-line Formulae" end="tail"?>
</claim-text>
<claim-text>wherein ⊕ is an exclusive-OR operator;</claim-text>
</claim-text>
<claim-text>creating the test vector T<sub>d </sub>and the test set T<sub>diff </sub>with values generated by an Automatic Test Pattern Generator (ATPG);</claim-text>
<claim-text>connecting the elements of the test set T<sub>diff </sub>in a single chain;</claim-text>
<claim-text>sequentially scanning the test set T<sub>diff</sub>;</claim-text>
<claim-text>creating a codeword (“100”, “101”, “110” and “111”) when a bit ‘1’ appears, and when the codeword is ‘0000’ (0001, 0020, 0011, 0100, 0101, 0110 and0111);</claim-text>
<claim-text>repeatedly checking a ‘0 Group’ (‘0000’, ‘0000×2’, ‘0000×3’, ‘0000×4’, ‘0000×5’, ‘0000×6’, ‘0000×7’ and ‘0000×8’) while incrementing the bit of the ‘0 Group’ counter by one until ‘1’ appears as the next bit;</claim-text>
<claim-text>recording ‘0111’ when the ‘0 Group’ becomes ‘0000×8’ and counting the number of bits having the value ‘0’; and</claim-text>
<claim-text>creating a codeword of a ‘1 Group’ on the SOC when a ‘1’ bit appears.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A method of decompressing a test data compressed by the compression method using a decompression decoder including an Finite State Machine (FSM) and 3-bit counters in a system-on-chip, (SOC), the method comprising the steps of:
<claim-text>inputting a bit to the FSM through a signal BIT_IN when a signal EN, which represents that the FSM can accept data, is output from the FSMT;</claim-text>
<claim-text>activating signals 0_SIGN and COUNTER_START of a first 3-bit counter when the bit input to the FSM is ‘0’ and activating signals 1_SIGN and COUNTER_START when the bit input to the FSM is ‘1’;</claim-text>
<claim-text>inputting 2 bits to the first 3-bit counter through a signal SHIFT when the signal 0-SIGN is activated;</claim-text>
<claim-text>inputting 3 bits to the first 3-bit counter through the signal SHIFT when the signal 1_SIGN is activated;</claim-text>
<claim-text>operating the first 3-bit counter to output a signal C_OUT when the signal 0_SIGN is activated;</claim-text>
<claim-text>recording ‘100’ in a second 3-bit counter when the second 3-bit counter receives the signal C_OUT;</claim-text>
<claim-text>activating a signal V<sub>—</sub>2 when the counting operation is finished;</claim-text>
<claim-text>allowing the first 3-bit counter to down-count one bit when the signal V<sub>—</sub>2 is input to the first 3-bit counter;</claim-text>
<claim-text>finishing the operation of the first and second counters when the signal 0_SIGN is input to the first 3-bit counter;</claim-text>
<claim-text>operating the 3-bit counters when the signal 1_SIGN is input to the first 3-bit counter and when the counting operation is finished, activating a signal V<sub>—</sub>1; and</claim-text>
<claim-text>outputting a bit ‘1’ through a signal OUT on the SOC when the signal V<sub>—</sub>1 is input to the FSM.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
