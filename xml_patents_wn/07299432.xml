<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299432-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299432</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11105611</doc-number>
<date>20050414</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>394</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>50</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>716  4</main-classification>
<further-classification>716  1</further-classification>
<further-classification>716 18</further-classification>
<further-classification>703 14</further-classification>
</classification-national>
<invention-title id="d0e53">Method for preserving constraints during sequential reparameterization</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6823500</doc-number>
<kind>B1</kind>
<name>Ganesh et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716  9</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00002">
<othercit>Kukula et al., Computer Aided Verification, 12<sup>th </sup>International Conference on Computer Aided Verification, Jul. 15-19, 2000.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00003">
<othercit>Moon et al., Simplifying Circuits for Formal Verification Using Parametric Representation, Formal Methods in Computer-Aided Design, 2002, pp. 52-69.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00004">
<othercit>Yuan et al., Constraint Synthesis for Environment Modeling in Functional Verification, Design Automation Conference, Jun. 2-6, 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>716  1</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716  2</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716  4</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716  9</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716 17</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716 18</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>703 14</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>11</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20060248484</doc-number>
<kind>A1</kind>
<date>20061102</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Baumgartner</last-name>
<first-name>Jason Raymond</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Janssen</last-name>
<first-name>Geert</first-name>
<address>
<city>Putnam Valley</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Mony</last-name>
<first-name>Hari</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Paruthi</last-name>
<first-name>Viresh</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Salys</last-name>
<first-name>Casimer K.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Dillon &amp; Yudell LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Do</last-name>
<first-name>Thuan</first-name>
<department>2825</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method, system and computer program product for preserving constraints is disclosed. The method comprises receiving an initial design including one or more targets, one or more primary inputs, one or more constraints and one or more state elements. A cut of the initial design including one or more cut gates, and a relation of one or more values producible to the one or more cut gates in terms of the one or more primary inputs and the one or more state elements is computed. The relation is constrained to force one or more constraint gates representing the one or more constraints to evaluate to a forced valuation, and one or more dead-end states of the constraints are identified. The inverse of the dead-end states is applied as don't cares to simplify the relation and the simplified relation is synthesized to form a first gate set. An abstracted design is from the first gate set and verification is performed on the abstracted design to generate verification results.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="222.59mm" wi="164.68mm" file="US07299432-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="221.15mm" wi="162.14mm" file="US07299432-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="223.94mm" wi="169.84mm" file="US07299432-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="238.93mm" wi="139.45mm" file="US07299432-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="239.78mm" wi="165.78mm" file="US07299432-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="237.49mm" wi="164.34mm" orientation="landscape" file="US07299432-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="241.64mm" wi="151.81mm" orientation="landscape" file="US07299432-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="240.96mm" wi="155.19mm" orientation="landscape" file="US07299432-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="240.03mm" wi="160.36mm" orientation="landscape" file="US07299432-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="241.89mm" wi="121.92mm" orientation="landscape" file="US07299432-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="223.94mm" wi="96.60mm" file="US07299432-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="228.09mm" wi="159.17mm" file="US07299432-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">The present application is related to the following co-pending U.S. patent applications filed on even date herewith, and incorporated herein by reference in their entirety:</p>
<p id="p-0003" num="0002">Ser. No. 11/105,615 (AUS920050019US1), entitled “METHOD AND SYSTEM FOR PARAMETRIC REDUCTION OF SEQUENTIAL DESIGNS”;</p>
<p id="p-0004" num="0003">Ser. No. 11/105,616 (AUS920050292US1), entitled “METHOD AND SYSTEM FOR REVERSING THE EFFECTS OF SEQUENTIAL REPARAMETERIZATION ON TRACES”;</p>
<p id="p-0005" num="0004">Ser. No. 11/105,617 (AUS920050294US1), entitled “METHOD FOR HEURISTIC PRESERVATION OF CRITICAL INPUTS DURING SEQUENTIAL REPARAMETERIZATION”; and</p>
<p id="p-0006" num="0005">Ser. No. 11/105,618 (AUS920050295US1), entitled “METHOD FOR OPTIMAL SYNTHESIS OF BINARY DECISION DIAGRAMS WITH INVERTED EDGES AND QUANTIFIABLE AS WELL AS NONQUANTIFIABLE VARIABLES”.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0007" num="0006">1. Technical Field</p>
<p id="p-0008" num="0007">The present invention relates in general to verifying designs and in particular to representing a logic function in a decision diagram. Still more particularly, the present invention relates to a system, method and computer program product for performing parametric reduction of sequential designs.</p>
<p id="p-0009" num="0008">2. Description of the Related Art</p>
<p id="p-0010" num="0009">With the increasing penetration of processor-based systems into every facet of human activity, demands have increased on the processor and application-specific integrated circuit (ASIC) development and production community to produce systems that are free from design flaws. Circuit products, including microprocessors, digital signal and other special-purpose processors, and ASICs, have become involved in the performance of a vast array of critical functions, and the involvement of microprocessors in the important tasks of daily life has heightened the expectation of error-free and flaw-free design. Whether the impact of errors in design would be measured in human lives or in mere dollars and cents, consumers of circuit products have lost tolerance for results polluted by design errors. Consumers will not tolerate, by way of example, miscalculations on the floor of the stock exchange, in the medical devices that support human life, or in the computers that control their automobiles. All of these activities represent areas where the need for reliable circuit results has risen to a mission-critical concern.</p>
<p id="p-0011" num="0010">In response to the increasing need for reliable, error-free designs, the processor and ASIC design and development community has developed rigorous, if incredibly expensive, methods for testing and verification for demonstrating the correctness of a design. The task of hardware verification has become one of the most important and time-consuming aspects of the design process.</p>
<p id="p-0012" num="0011">Among the available verification techniques, formal and semiformal verification techniques are powerful tools for the construction of correct logic designs. Formal and semiformal verification techniques offer the opportunity to expose some of the probabilistically uncommon scenarios that may result in a functional design failure, and frequently offer the opportunity to prove that the design is correct (i.e., that no failing scenario exists).</p>
<p id="p-0013" num="0012">Unfortunately, the resources needed for formal verification, or any verification, of designs are proportional to design size. Formal verification techniques require computational resources which are exponential with respect to the design under test. Similarly, simulation scales polynomially and emulators are gated in their capacity by design size and maximum logic depth. Semi-formal verification techniques leverage formal methods on larger designs by applying them only in a resource-bounded manner, though at the expense of incomplete verification coverage. Generally, coverage decreases as design size increases.</p>
<p id="p-0014" num="0013">One commonly-used approach to formal and semiformal analysis for applications operating on representations of circuit structures is to represent the underlying logical problem structurally (as a circuit graph), and then use Binary Decision Diagrams (BDDs) to convert the structural representation into a functionally canonical form. In such an approach, in which a logical problem is represented structurally and binary decision diagrams are used to convert the structural representation into a functionally canonical form, a set of nodes for which binary decision diagrams are required to be built, called “sink” nodes, is identified. Examples of sink nodes include the output node or nodes in an equivalence checking or a false-paths analysis context. Examples of sink nodes also include targets in a property-checking or model-checking context.</p>
<p id="p-0015" num="0014">Techniques for reducing the size of a design representation have become critical in numerous applications. Logic synthesis optimization techniques are employed to attempt to render smaller designs to enhance chip fabrication processes. Numerous techniques have been proposed for reducing the size of a structural design representation. For example, redundancy removal techniques attempt to identify gates in the design which have the same function, and merge one onto the other. Such techniques tend to rely upon binary decision diagram-based or Boolean satisfiability-based analysis to prove redundancy, which tend to be computationally expensive. Further, the prior art deals poorly with constraints in sequential reparameterization.</p>
<p id="p-0016" num="0015">What is needed is a method for preserving constraints during sequential reparameterization.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0017" num="0016">A method, system and computer program product for preserving constraints is disclosed. The method comprises receiving an initial design including one or more targets, one or more primary inputs, one or more constraints and one or more state elements. A cut of the initial design including one or more cut gates, and a relation of one or more values producible to the one or more cut gates in terms of the one or more primary inputs and the one or more state elements is computed. The relation is constrained to force one or more constraint gates representing the one or more constraints to evaluate to a forced valuation, and one or more dead-end states of the constraints are identified. The inverse of the dead-end states is applied as don't cares to simplify the relation and the simplified relation is synthesized to form a first gate set. An abstracted design is from the first gate set and verification is performed on the abstracted design to generate verification results.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0018" num="0017">The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed descriptions of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> depicts a block diagram of a general-purpose data processing system with which the present invention of a method, system and computer program product for performing parametric reduction of sequential designs may be performed;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 2</figref> is a high-level logical flowchart of a process for performing parametric reduction of sequential designs in accordance with an alternative embodiment of the present invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 3</figref> is a high-level logical flowchart of a process for performing parametric reduction of sequential designs in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 4</figref> is a high-level logical flowchart of a process for preservation of constraints during sequential reparameterization in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 5</figref> is a high-level logical flowchart of a process for performing optimal synthesis of binary decision diagrams with inverted edges and quantifiable as well as nonquantifiable variables in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 6</figref> is a high-level logical flowchart of a process for performing reversal of the effects of sequential reparameterization on traces in accordance with a preferred embodiment of the present invention; and</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 7</figref> is a high-level logical flowchart of a process for performing heuristic preservation of critical inputs during sequential reparameterization in accordance with a preferred embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
<p id="p-0026" num="0025">The present invention provides a method, system, and computer program product for parametric reduction of a structural design representation. As will be explained below, the present invention identifies a candidate set of gates of a netlist representation, particularly, a cut of a netlist graph, to attempt to re-encode. The present invention then creates a behaviorally equivalent piece of logic, and replaces the original cut with this new piece of logic, i.e., the present invention replaces each cut gate in the original design by a gate in the replacement logic.</p>
<p id="p-0027" num="0026">With reference now to the figures, and in particular with reference to <figref idref="DRAWINGS">FIG. 1</figref>, a block diagram of a general-purpose data processing system, in accordance with a preferred embodiment of the present invention, is depicted. Data processing system <b>100</b> contains a processing storage unit (e.g., RAM <b>102</b>) and a processor <b>104</b>. Data processing system <b>100</b> also includes non-volatile storage <b>106</b> such as a hard disk drive or other direct-access storage device. An Input/Output (I/O) controller <b>108</b> provides connectivity to a network <b>110</b> through a wired or wireless link, such as a network cable <b>112</b>. I/O controller <b>108</b> also connects to user I/O devices <b>114</b> such as a keyboard, a display device, a mouse, or a printer through wired or wireless link <b>116</b>, such as cables or a radio-frequency connection. System interconnect <b>118</b> connects processor <b>104</b>, RAM <b>102</b>, storage <b>106</b>, and I/O controller <b>108</b>.</p>
<p id="p-0028" num="0027">Within RAM <b>102</b>, data processing system <b>100</b> stores several items of data and instructions while operating in accordance with a preferred embodiment of the present invention. These include an initial design (D) netlist <b>120</b>, a binary decision diagram builder <b>126</b> and an output table <b>122</b> for interaction with a verification environment <b>124</b>. In the embodiment shown in <figref idref="DRAWINGS">FIG. 1</figref>, initial design (D) netlist <b>120</b> contains targets (T) <b>134</b> state elements (R) <b>136</b> and primary inputs (I) <b>138</b>. Other applications <b>128</b> and verification environment <b>124</b> interface with processor <b>104</b>, RAM <b>102</b>, I/O control <b>108</b>, and storage <b>106</b> through operating system <b>130</b>. One skilled in the data processing arts will quickly realize that additional components of data processing system <b>100</b> may be added to or substituted for those shown without departing from the scope of the present invention. Other data structures in RAM <b>102</b> include binary decision diagrams <b>170</b>, cut gates <b>132</b>, cutpoints <b>140</b>, relation (S) <b>142</b>, abstracted design (D′) <b>144</b>, gate set (C″) <b>146</b>, corresponding gates (U′) <b>148</b>, trace (P″) <b>150</b>, abstracted trace (P′) <b>152</b>, unabstracted trace (P) <b>154</b>, set (C′) <b>176</b>, constraint gates in cut gates (BU) <b>180</b>, set (B′) <b>182</b> and new trace (p) <b>178</b>.</p>
<p id="p-0029" num="0028">A netlist, such as design (D) netlist <b>120</b>, is a popular means of compactly representing problems derived from circuit structures in the computer-aided design of digital circuits. Such a representation is non-canonical and offers the ability to analyze the function from the nodes in the graph. Initial design (D) netlist <b>120</b>, contains a directed graph with vertices representing gates and edges representing interconnections between those gates. The gates have associated functions, such as constants, primary inputs (I) <b>138</b> (e.g. RANDOM gates, which deliver random values at the given input), combinational logic (e.g., AND gates), and sequential elements (hereafter referred to as registers). Registers have two associated components; their next-state functions and their initial-value functions, which are represented as other gates in the graph. Certain gates in the netlist may be labeled as primary outputs (O) <b>162</b>, invariants (N) <b>164</b>, targets (T) <b>134</b> and constraints (B) <b>160</b>.</p>
<p id="p-0030" num="0029">Semantically, for a given register, the value appearing at its initial-value gate at time “0” (“initialization” or “reset” time) will be applied by verification environment <b>124</b> as the value of the register itself; the value appearing at its next-state function gate at time “i” will be applied to the register itself at time “i+1”. Certain gates are labeled as targets (T) <b>134</b> or constraints (B) <b>160</b>. Targets (T) <b>134</b> correlate to the properties that require verification. Constraints (B) <b>160</b> are used to artificially limit the stimulus that can be applied to the RANDOM gates of initial design (D) netlist <b>120</b>; in particular, when searching for a way to drive a “1” to a target (T) <b>134</b>, the verification environment <b>124</b> must adhere to rules such as, for purpose of example, that “every constraints (B) <b>160</b> gate must evaluate to a logical 1 for every time-step” or “every constraints (B) <b>160</b> gate must evaluate to a logical 1 for every time-step up to, and including, the time-step at which the target is asserted.” For example, in verification environment <b>124</b>, a constraints (B) <b>160</b> could be added which drives a 1 exactly when a vector of RANDOM gates to simulate even parity. Without its constraints (B) <b>160</b>, the verification environment <b>124</b> would consider valuations with even or odd parity to those RANDOM gates; with the constraints (B) <b>160</b>, only even parity would be explored.</p>
<p id="p-0031" num="0030">Invariants (N) <b>164</b> are similar to constraints in the sense that they will always evaluate to a “1”. However, unlike constraints (B) <b>160</b>, they will naturally evaluate to a 1 even if discarded from the problem formulation (i.e., they are redundant facts about the way the design will behave due to its structural definition). These redundant facts may be useful in formal verification to obtain proofs of correctness. For example, an invariant (N) <b>164</b> node could assert that a set of registers always evaluates to even parity; that fact may help the performance of proof-based techniques.</p>
<p id="p-0032" num="0031">Processor <b>104</b> executes instructions from programs, often stored in RAM <b>102</b>, in the course of performing the present invention. In a preferred embodiment of the present invention, processor <b>104</b> executes verification environment <b>124</b>. Verification environment <b>124</b> contains a parametric reduction toolkit <b>166</b>, including a selection unit <b>156</b>, a replacement unit <b>158</b>, a translation unit <b>168</b>, exploitation unit <b>172</b> and bias unit <b>174</b>.</p>
<p id="p-0033" num="0032">Initial design (D) netlist <b>120</b> includes replaceable gates and gates within the cone of influence of each replaceable gate. For example, assume the existence within initial design (D) netlist <b>120</b> of replaceable gates G<b>1</b> and G<b>2</b>, each of which has a cone of influence including combinational logic as well as registers. Parametric reduction toolkit <b>166</b> is tuned to abstract logic within initial design (D) netlist <b>120</b> which is combinationally driven by RANDOM gates, and hence is less likely to abstract any logic within initial design (D) netlist <b>120</b> which is not combinationally driven by RANDOM gates. When performing an abstraction to replace gates G<b>1</b> and G<b>2</b> within initial design (D) netlist <b>120</b>, parametric reduction toolkit <b>166</b> will replace gates on the fanin-side of a cut at cutpoint <b>140</b>, such that gates within initial design (D) netlist <b>120</b> in the fanout-side of the cut at cutpoint <b>140</b> are not modified by parametric reduction toolkit <b>166</b> when performing the abstraction, and there is a 1:1 mapping between such gates in the fanout-side of the cut at cutpoint <b>140</b> within initial design (D) netlist <b>120</b> and abstracted design (D′) <b>144</b>. Note also that there is a unique mapping from gates on the cut at cutpoint <b>140</b> within initial design (D) netlist <b>120</b> and abstracted design (D′) <b>144</b>.</p>
<p id="p-0034" num="0033">The abstraction performed by parametric reduction toolkit <b>166</b> to generate abstracted design (D′) <b>144</b> results in a trace-equivalence between initial design (D) netlist <b>120</b> and abstracted design (D′) <b>144</b>. Trace equivalence between two designs requires that, first, for all possible traces (sequences of values to gates over time) over all gates of initial design (D) netlist <b>120</b> on the cut at cutpoint <b>140</b> and in the fanout-side of the cut at cutpoint <b>140</b> and, second, for all possible traces over the gates in gate set (C″) <b>146</b> which are to replace cut gates (U) <b>132</b> and over the gates in the fanout-side of the cut at cutpoint <b>140</b> in abstracted design (D′) <b>144</b>, for every trace in the former, there exists an equivalent trace in the latter, and vice-versa. The sequences of values producible to a selected set of gates of initial design (D) netlist <b>120</b> is identical to the sequence of values producible to the corresponding gates in the abstracted design (D′) <b>144</b>.</p>
<p id="p-0035" num="0034">Parametric reduction toolkit <b>166</b> is explicitly tuned for reducing the number of RANDOM gates in abstracted design (D′) <b>144</b>, and heuristically is able to eliminate other gates. As a result, parametric reduction toolkit <b>166</b> has the ability to exponentially improve the run-time of automated formal verification tools within verification environment <b>124</b> with respect to the state-of-the-art possible without this approach, and also provide benefits to other methods such as simulation, emulation, and other design reasoning/optimization paradigms.</p>
<p id="p-0036" num="0035">Parametric reduction toolkit <b>166</b> provides selection unit <b>156</b> to choose candidate cut gates (U) <b>132</b> for abstraction, as well as replacement unit <b>158</b>, for symbolically analyzing and synthesizing gate set (C″) <b>146</b>. When combined, selection unit <b>156</b> and replacement unit <b>158</b> prevent the exponential degradation of the performance of parametric reduction toolkit <b>166</b> as the size of the set of cut gates (U) <b>132</b> being replaced increases. Exponential degradation of the performance of explicit analysis, such as simulation-based analysis, is typical of the problems of the prior art. Gate set (C″) <b>146</b> can be guaranteed to require at most ‘N’ RANDOM gates for a cut of ‘N’ gates. By selecting a set of cut gates (U) <b>132</b> with minimal size, parametric reduction toolkit <b>166</b> may achieve a maximal reduction in RANDOM gates.</p>
<p id="p-0037" num="0036">Selection unit <b>156</b> is utilized for selecting the cut gates to attempt to abstract. Parametric reduction toolkit <b>166</b> reduces RANDOM gate count. Using replacement unit <b>158</b>, discussed below, parametric reduction toolkit <b>166</b> replaces logic for a set of ‘N’ cut gates with a set of new RANDOM gates that will include at most ‘N’ new gates. Thus, parametric reduction toolkit <b>166</b> attempts to select as small of a set of gates to abstract as possible that constitutes a “cut” over as many RANDOM gates in original design (D) netlist <b>120</b> as possible.</p>
<p id="p-0038" num="0037">The operation of selection unit <b>156</b> is more easily understood with respect to a set of requirements in the choice of a cut at a cutpoint <b>140</b> of original design (D) netlist <b>120</b>. A cut at a cutpoint <b>140</b> of original design (D) netlist <b>120</b> is a partition of its gates into two sets: the fanin-side, and the fanout-side. Parametric reduction toolkit <b>166</b> computes a cut at a cutpoint <b>140</b> of original design (D) netlist <b>120</b>, then replaces the fanin-side with a new and simpler piece of logic. This replacement is performed by reconnecting the cut gates (U) <b>132</b> which source edges which cross from the fanin side to the fanout side with source gates in the new logic. Parametric reduction toolkit <b>166</b> attempts to ensure that all invariants (N) <b>164</b>, targets (T) <b>134</b> and constraints (B) <b>160</b> will be in the fanout-side of the cut at cutpoint <b>140</b>, such that the original fanin-side of the cut at cutpoint <b>140</b> will be eliminated from the cone-of-influence of the problem (defined as all logic which fans out to the invariants (N) <b>164</b>, targets (T) <b>134</b> and constraints (B) <b>160</b>) when parametric reduction toolkit <b>166</b> reconnects to the new logic.</p>
<p id="p-0039" num="0038">Selection unit <b>156</b> additionally attempts to find a cut at cutpoint <b>140</b> which has as few cut gates (U) <b>132</b> as possible, because the gate set (C″) <b>146</b> created in replacement unit <b>158</b> requires one RANDOM gate per cut gate (U) <b>132</b>. Selection unit <b>156</b> selects cutpoints <b>140</b> using min-cut analysis in several steps. First, selection unit <b>156</b> labels each invariant (N) <b>164</b>, target (T) <b>134</b> and constraint (B) <b>160</b> gate of original design (D) netlist <b>120</b> as a “sink”. Selection unit <b>156</b> then labels every next-state and initial-value gate as a sink. The failure to label every next-state and initial-value gate as a sink might prevent selection unit <b>156</b> from obtaining a cut at a cutpoint <b>140</b> of the graph whose fanin-side will fall out of the cone of influence when replaced (due to the mapping of registers to initial-value and next-state function gates). Additionally selection unit <b>156</b> labels every next-state and initial-value gate as a sink, because replacement unit <b>158</b> does not explicitly seek to re-encode the sequential behavior of the design.</p>
<p id="p-0040" num="0039">Selection unit <b>156</b> then labels every RANDOM gate as a source. Finally, selection unit <b>156</b> utilizes min-cut analysis between the labeled sources and sinks to find a minimal set of cut nodes at cutpoint <b>140</b>. Selection unit <b>156</b> seeks a cut at a cutpoint <b>140</b> which has minimal size with respect to the number of gates sourcing crossing edges of the cut. Note that the min-cut analysis of selection unit <b>156</b> is combinational in the sense that it does not traverse “through” next-state functions or initial-value functions of registers. The combinational operation of selection unit <b>156</b> is well-suited to the process of maximizing RANDOM gate reduction potential. In the case that multiple min-cuts of identical width exist, parametric reduction toolkit <b>166</b> may attempt to abstract any or all of them to find the solution with greatest reduction potential.</p>
<p id="p-0041" num="0040">As will be discussed with respect to replacement unit <b>158</b>, parametric reduction toolkit <b>166</b> relies upon the ability to identify all possible values producible on cut gates (U) <b>132</b> as a function of any registers that may appear in the cone of influence of the cut gates (U) <b>132</b>, then re-encoding the fanin-side of the cut at cutpoint <b>140</b> using a new set of RANDOM gates. The min-cut result as seeded is ideally suited in this application since it will compute the smallest available cut of cut gates (U) <b>132</b>, including the most original RANDOM gates. As an example, consider a set of seven selected cut gates which originally has 20 RANDOM gates in its fanin-side. After replacing the fanin-side of the cut with the gate set (C″) <b>146</b>, replacement unit <b>158</b> can produce a gate set (C″) <b>146</b> with only seven new RANDOM gates.</p>
<p id="p-0042" num="0041">Note, however, that the methods used by selection unit <b>156</b> to analyze and by replacement unit <b>158</b> to replace the set of cut gates (U) <b>132</b> may be computationally expensive, and it may be the case that replacement unit <b>158</b> cannot succeed in processing the set of cut gates (U) <b>132</b> chosen by selection unit <b>156</b>. Parametric reduction toolkit <b>166</b> solves this problem incrementally, by performing the analysis and replacement in a levelized fashion. Parametric reduction toolkit <b>166</b> defines the level of gates such that all constant gates, RANDOM gates, and registers have level 0; the level of other combinational gates is equal to the maximum level of any of their sourcing gates plus one. Parametric reduction toolkit <b>166</b> iterates between level 1 and the maximum level of any of the chosen “ideal” cut gates (U) <b>132</b> at cutpoints <b>140</b>, solving a min-cut problem involving all gates of the given level and the RANDOM gates in their cone of influence. At each stage, the parametric reduction toolkit <b>166</b> analyzes and abstracts the smaller, partial cone of logic.</p>
<p id="p-0043" num="0042">One benefit of the incremental solution described above is that earlier stages of abstraction by selection unit <b>156</b> and replacement unit <b>158</b> simplify the logic to be analyzed and abstracted in later stages, with the result that earlier stages reduce the resources needed by the later stages. This reduces overall peak resource requirements, and increases the chances that the desired cut may be successfully abstracted in an incremental fashion even if this abstraction is computationally infeasible without incremental processing. Further, even if the process employed by selection unit <b>156</b> and replacement unit <b>158</b> ultimately fails to abstract the desired cut gates (U) <b>132</b> due to resource limitations, it is likely that a fair amount of simplification can still be successfully performed on earlier stages. If applied using a transformation-based verification toolset, which may be included in verification environment <b>124</b>, further transformations are possible between each incremental abstraction, which may further simplify abstracted design (D′) <b>144</b> to enable greater reductions.</p>
<p id="p-0044" num="0043">Parametric reduction toolkit <b>166</b> first process the gates at a hypothetical first level, abstracting the gates at that level with simpler logic. Parametric reduction toolkit <b>166</b> then processes the gates at a hypothetical second level; this processing includes the simplified, replaced logic for at the hypothetical first level obtained during the prior step. Parametric reduction toolkit <b>166</b> then process the gates at a hypothetical third level, and so on; eventually, processing the logic with the highest-level of any gate in the originally selected min-cut. Parametric reduction toolkit <b>166</b> may perform all necessary reductions in a single step, though the reduction may be more computationally efficient in the incremental manner as discussed. Alternative embodiments of this method are possible, such as starting/stopping at a level other than the minimum and the maximum level of any gate in the originally selected min-cut. Incrementing by M levels rather than by 1 is also possible. The latter alternative embodiment may prove useful in cases in which the number of levels is very large, to reduce the number of distinct abstraction steps.</p>
<p id="p-0045" num="0044">Replacement unit <b>158</b> analyzes the cut at cutpoint <b>140</b>, and creates gate set (C″) <b>146</b>. Replacement unit <b>158</b> creates gate set (C″) <b>146</b> so that each original cut gate (U) <b>132</b> will be replaced by one gate in gate set (C″) <b>146</b>. In order to facilitate this one-to-one mapping, replacement unit <b>158</b> adheres to the requirement that the set of values which may be produced by the gate set (C″) <b>146</b> must be identical to set of values which may be produced by the original cut gates (U) <b>132</b> on a per-state basis. For every state (valuation to registers) of original design (D) netlist <b>120</b>, the replacement unit <b>158</b> enumerates the subset of the 2^N (for N cut gates, where symbol ^ denotes exponentiation) possible values which may be produced at those cut gates (U) <b>132</b> under some valuation to the original RANDOM gates. The subset of 2^N possible values to the replacement gate set (C″) <b>146</b> for cut gates (U) <b>132</b> (under some valuation to the new RANDOM gates) must equal that of the original cut gates (U) <b>132</b>, on a per-state basis. Note that replacement unit <b>158</b> uses the same set of registers in both the original design (D) netlist <b>120</b> and abstracted design (D′) <b>144</b>, ensuring that the replacement with gate set (C″) <b>146</b> preserves property checking (i.e., replacement with gate set (C″) <b>146</b> will not render incorrect ‘pass’ nor ‘fail’ results) when the target (T) <b>134</b> constraint (B) <b>160</b> and invariant gates (N) <b>164</b> are in the fanout-side of the logic being replaced.</p>
<p id="p-0046" num="0045">Replacement unit <b>158</b> utilizes binary decision builder <b>126</b> and binary decision diagrams <b>170</b> to avoid bottlenecks in the enumeration process described above (e.g., analyzing 2^N values one-at-a-time in a netlist becomes infeasible as N grows beyond 30). The operation of replacement unit <b>158</b> in enumerating the producible values at cut gates (U) <b>132</b> is discussed below. In the discussion below, C_i represents the i'th cut gate. Replacement unit <b>158</b> declares a distinct binary decision diagram <b>170</b> variable for each cut gate (U) <b>132</b> (hereafter called G_i) at cutpoints <b>140</b>; for each RANDOM gate in the fanin-side of the cut at cutpoint <b>140</b>; and for each register in the fanin-side of the cut at cutpoint <b>140</b>. Replacement unit <b>158</b> builds a binary decision diagram <b>170</b> for the function of each cut gate (U) <b>132</b> (hereafter called F_i) supported by the binary decision diagrams <b>170</b> variables for the RANDOM gates and registers. Replacement unit <b>158</b> next builds binary decision diagrams <b>170</b> for the expression (G_i==F_i), conjuncts this expression over all i's, and then existentially quantifies the RANDOM gate variables from the conjunction. The resulting binary decision diagrams <b>170</b> comprise all possible valuations to the cut gates (U) <b>132</b> (represented by the G_i's) as a function of the registers (represented by their corresponding binary decision diagram <b>170</b> variables).</p>
<p id="p-0047" num="0046">With reference now to <figref idref="DRAWINGS">FIG. 3</figref>, a high-level logical flowchart of a process for performing parametric reduction of sequential designs in accordance with a preferred embodiment of the present invention is illustrated. The process starts at step <b>300</b> and then proceeds to step <b>302</b>, which depicts verification environment <b>124</b> receiving initial design (D) netlist <b>120</b>, including targets (T) <b>134</b>, state elements (R) <b>136</b> and primary inputs (I) <b>138</b>. The process next moves to step <b>304</b>. At step <b>304</b>, selection unit <b>156</b> identifies cut points <b>140</b> for a cut (C, C′) of initial design (D) netlist <b>120</b> where (C′) is a superset of targets (T) <b>134</b>, letting cut gates (U) <b>132</b> represent the cut gates sourcing edges from (C) to (C′).</p>
<p id="p-0048" num="0047">The process then proceeds to step <b>306</b>, which depicts replacement unit <b>158</b> computing the relation (S) <b>142</b> of values producible to (I, R, U), then existentially quantifying primary inputs (I) <b>138</b> from relation (S) <b>142</b>, resulting in a relation (S) <b>142</b> from state elements (R) <b>136</b> to cut gates (U) <b>132</b>. The process then moves to step <b>308</b>. At step <b>308</b>, replacement unit <b>158</b> synthesizes relation (S) <b>142</b> as a function from state elements (R) <b>136</b> to cut gates (U) <b>132</b>, forming gate set (C″) <b>146</b>. The process proceeds to step <b>310</b> which depicts replacement unit <b>158</b> forming abstracted design (D′) <b>144</b> equal to (C″, C′). Corresponding gates (U′) <b>148</b> represent the gates in gate set (C″) <b>146</b> corresponding to cut gates (U) <b>132</b> in constraints (B) <b>160</b>. The process then proceeds to step <b>312</b>, which depicts verification environment <b>124</b> applying verification to abstracted design (D′) <b>144</b>.</p>
<p id="p-0049" num="0048">Next, the process moves to step <b>314</b>. At step <b>314</b>, verification environment <b>124</b> determines whether a trace (P′) <b>152</b> hitting targets (T) <b>134</b> has been obtained. If verification environment <b>124</b> determines that no trace was obtained hitting a target, then the process next moves to step <b>316</b>, which depicts verification environment <b>124</b> propagating target unhittable results to initial design (D) netlist <b>120</b> and reporting results to output table <b>122</b>. The process then ends at step <b>318</b>.</p>
<p id="p-0050" num="0049">If verification environment <b>124</b> determines that abstracted trace (P′) <b>152</b> is obtained hitting a target (T) <b>134</b>, then the process next moves to step <b>320</b>. At step <b>320</b>, verification environment <b>124</b> copies valuations from set (C′) <b>176</b> into new trace (p) <b>178</b>. The process then proceeds to step <b>322</b>, which depicts verification environment <b>124</b> propagating new trace (p) <b>178</b> over initial design (D) netlist <b>120</b> to the user and reporting results to output table <b>122</b>. The process then ends at step <b>318</b>.</p>
<p id="p-0051" num="0050">Given a binary decision diagram <b>170</b> representing all possible valuations to the cut gates (U) <b>132</b> (represented as binary decision diagram <b>170</b> variables G_i) as a function of registers (represented as binary decision diagram <b>170</b> variables R_j), correlating to set S of <b>304</b>, replacement unit <b>158</b> creates the replacement cone in several steps. Note that gate set (C″) <b>146</b> will be a combinational function over a new RANDOM gate for each of the G_i variables, and over the original registers R_j. Additionally, the original RANDOM gates do not appear in the gate set (C″) <b>146</b> (unless they are to be preserved). Gate set (C″) <b>146</b> includes a gate C′_i used to replace each C_i, such that C′_i drives the same behavior as C_i as a function of R_j, constructed using the method embodied in the pseudocode for a Create_Replacement data structure below, which performs appropriately on binary decision diagrams <b>170</b> that include inverted edges.</p>
<p id="p-0052" num="0051">As discussed below, binary decision diagrams <b>170</b> variables are referred to as “nonquantifiable” or “quantifiable”. Binary decision diagrams <b>170</b> variables are created by BDD builder <b>126</b> either for cut gates (U) <b>132</b> (e.g., the G_i variables referred to above), or for RANDOM gates and registers. The variables for RANDOM gates are most often “quantifiable” (unless they are also G_i variables); the G_i variables and those for registers are most often “nonquantifiable”. As will be discussed below, certain RANDOM gate variables (which may or may not be cut gates (U) <b>132</b> themselves) may in cases be deemed “nonquantifiable” if they are to be preserved. Hence, the present invention is discussed with respect to the quantifiable/nonquantiafiable terminology for generality.</p>
<p id="p-0053" num="0052">With reference now to <figref idref="DRAWINGS">FIGS. 5A to 5E</figref>, a high-level logical flowchart of a process for performing optimal synthesis of binary decision diagrams with inverted edges and quantifiable as well as nonquantifiable variables in accordance with a preferred embodiment of the present invention is illustrated. This flowchart correlates to a description of the pseudocode for Create_Replacement to be provided below. The process starts at step <b>500</b> and then proceeds to step <b>502</b>, which depicts replacement unit <b>158</b> receiving a binary decision diagram <b>170</b>, hereafter referred to as B, over quantifiable binary decision diagram <b>170</b> variable Q and nonquantifiable BDD variables X, in addition to mapping n(X) between nonquantifiable variables and gates of initial design (D) netlist <b>120</b>. The process then moves to step <b>504</b>. At step <b>504</b>, for each quantifiable variable q in Q, replacement unit <b>158</b> creates a RANDOM gate n(q). The process next proceeds to macro-step <b>506</b>, which depicts replacement unit <b>158</b> establishing preliminary data structures for B and consists of steps <b>508</b>-<b>512</b>.</p>
<p id="p-0054" num="0053">At step <b>508</b>, replacement unit <b>158</b> traverses each child node of B recursively from root to leaves, tracking whether an even or an odd number of inverted handles were encountered between the root and node b, and neglecting to traverse the children of the same node more than once. The process next moves to step <b>510</b>, which illustrates, for each node b encountered, if through an even number of inverted handles, replacement unit <b>158</b> enqueueing that node in a Vars_To_Nodes(v) storage location. Similarly, for each node b encountered, if through an even number of inverted handles, replacement unit <b>158</b> enqueues the inverse of that node in a Vars_To_Nodes(v) storage location. The process then proceeds to step <b>512</b>. At step <b>512</b>, for each node b encountered, if the immediate parent of node b had a non-inverted handle, then replacement unit <b>158</b> sets variable p to that parent. Otherwise, replacement unit <b>158</b> sets p to the inverse of that parent. If node b was encountered through an even number of inverted handles, then replacement unit <b>158</b> enqueues p in Parents(v). Otherwise, replacement unit <b>158</b> enqueues p in Parents_Ivt(v).</p>
<p id="p-0055" num="0054">The process next moves to macro-step <b>514</b>, which depicts replacement unit <b>158</b> iterating over each binary decision diagram <b>170</b> variable in rank order of B (from root to leaf), through a series of steps labeled <b>516</b>-<b>554</b>. At step <b>516</b>, replacement unit <b>158</b> creates a for loop to iteratively repeat macro-step <b>518</b>, discussed below, for each binary decision diagram <b>170</b> variable v in Q or X, in rank order of B. The process then proceeds to macro-step <b>518</b>, which illustrates replacement unit <b>158</b> building a gate representation of the OR of all parent paths into node b, tracking inversions, and storing into path(b) or Path_Ivt(b) accordingly through a series of steps labeled <b>520</b>-<b>528</b> and steps <b>532</b>-<b>538</b>. At step <b>520</b>, replacement unit <b>158</b> creates a for loop to iteratively repeat steps <b>522</b>-<b>528</b> and steps <b>532</b>-<b>538</b>, discussed below, for each binary decision diagram <b>170</b> node b in Vars_to_Nodes(v). The process next moves to step <b>522</b>, which illustrates replacement unit <b>158</b> determining whether b is the root binary decision diagram <b>170</b> node. If b is the root binary decision diagram <b>170</b> node, then the process proceeds to step <b>524</b>, which depicts replacement unit <b>158</b> setting variable g=GATE_ONE, after which the process continues to step <b>526</b>, which is discussed below. If b is not the root binary decision diagram <b>170</b> node, then the process moves to step <b>534</b>.</p>
<p id="p-0056" num="0055">At step <b>534</b>, replacement unit <b>158</b> determines whether b is inverted. If b is inverted, then the process proceeds to step <b>536</b>, which illustrates replacement unit <b>158</b> setting g equal to a function ‘OR(over all parent nodes b’ In Parents_Ivt(b) of: (inverted(b′)?Path(b′),Path_Ivt(b′0), AND (b is a BDD_THEN branch of b′? r(BDD_VARID(b′)): INVERT (r(BDD_VARID (b′))′. The process then continues to step <b>526</b>, which is discussed below. If b is not inverted, then the process proceeds to step <b>538</b>, which illustrates replacement unit <b>158</b> setting g equal to a function ‘OR(over all parent nodes b’ In Parents (b) of: (inverted(b′)?Path(b′),Path_Ivt(b′0), AND (b is a BDD_THEN branch of b′? r(BDD_VARID(b′)): INVERT (r(BDD_VARID (b′))′. The process then continues to step <b>526</b>.</p>
<p id="p-0057" num="0056">At step <b>526</b>, replacement unit <b>158</b> determines whether b is inverted. If b is inverted, then the process proceeds to step <b>528</b>, which illustrates replacement unit <b>158</b> setting Path_Ivt(b)=g. The process then moves to step <b>530</b>, which is described below. If b is not inverted, then the process proceeds to step <b>532</b>, which illustrates replacement unit <b>158</b> setting Path(b)=g. The process then continues to step <b>530</b>. At step <b>530</b>, replacement unit <b>158</b> determines whether the variable v is quantifiable in Q. If the variable v is quantifiable in Q, then the process next moves to step <b>544</b>, the first step of macro-step <b>542</b>, which contains steps <b>544</b> to <b>554</b>, and depicts replacement unit <b>158</b> creating a synthesized gate for variable v. At step <b>544</b>, replacement unit <b>158</b> sets r(v)=n(v), and the process next proceeds—once iteration over all BDD variables v in macro-step <b>514</b> has completed—to step <b>556</b>, which illustrates replacement unit <b>158</b> returning n(Q) as the synthesized gates for Q binary decision diagram <b>170</b> variables. The process then ends at step <b>556</b>.</p>
<p id="p-0058" num="0057">Returning to step <b>530</b>, if the variable v is not quantifiable in Q, then the process next moves step <b>540</b> wherein it initializes Var_Must_Be<sub>—</sub>0(v) to ZERO, and Var_Must_Be<sub>—</sub>1(v) to ZERO. It then moves to step <b>546</b>, which illustrates replacement unit <b>158</b> setting a for loop to iterate steps <b>548</b>-<b>554</b> over each binary decision diagram <b>170</b> node in Vars_To_Nodes(v). The process next proceeds to step <b>548</b>. At step <b>548</b>, replacement unit <b>158</b> determines whether b is inverted. If b is inverted, then the process next moves to step <b>550</b>, replacement unit <b>158</b> sets g0=Path_Ivt(b) AND (mux-based-synthesis (BDD_EXIST (BDD_INVERT (BDD_THEN (b), Q)))) and sets g1=Path_Ivt(b) AND (mux-based-synthesis(BDD_EXIST (BDD_INVERT(BDD_ELSE(b), Q)))). The process then moves to step <b>552</b>, which depicts replacement unit <b>158</b> setting Var_Must_Be<sub>—</sub>0(v)=Var_Must_Be<sub>—</sub>0(v) OR NOT(g0); and setting Var_Must_Be<sub>—</sub>1(v)=Var_Must_Be<sub>—</sub>1(v) OR NOT (g1); and setting r(v)=Var_Must_Be<sub>—</sub>1(v) OR (n(v) AND NOT(Var_Must_Be<sub>—</sub>0(v))). Once iteration over all BDD variables v in macro-step <b>514</b> has completed, the process then proceeds to step <b>556</b>, which is described above.</p>
<p id="p-0059" num="0058">Returning to step <b>548</b>, if b is not inverted, then the process moves to step <b>554</b>. At step <b>554</b>, replacement unit <b>158</b> sets g0=Path (b) AND (mux-based-synthesis (BDD_EXIST (BDD_INVERT (BDD_THEN (b), Q)))) and sets g1=Path (b) AND (mux-based-synthesis(BDD_EXIST (BDD_INVERT(BDD_ELSE(b), Q)))). The process next returns to step <b>552</b>, which is described above.</p>
<p id="p-0060" num="0059">The following legend will be provide assistance in decoding the pseudocode for Create_Replacement below, which represents a preferred embodiment of replacement unit <b>158</b> and the method of the flowchart of <figref idref="DRAWINGS">FIG. 5</figref>:</p>
<p id="p-0061" num="0060">C_i represents a cut gate (U) <b>132</b> from original design (D) netlist <b>120</b></p>
<p id="p-0062" num="0061">G_i: binary decision diagram <b>170</b> variables for (quantifiable) cut gates (U) <b>132</b></p>
<p id="p-0063" num="0062">R_j: binary decision diagram <b>170</b> variables for nonquantifiable variables (e.g., registers)</p>
<p id="p-0064" num="0063">n (G_i): netlist RANDOM gate to be used in gate set (C″) <b>146</b>, correlating to binary decision diagram <b>170</b> variable G_i (i.e., to replace C_i)</p>
<p id="p-0065" num="0064">n (R_j): netlist gate correlating to nonquantifiable binary decision diagram <b>170</b> variable R_j (e.g., a register)</p>
<p id="p-0066" num="0065">r (G_i): replacement gate C′_i created for C_i (note that G_i uniquely correlates to a C_.</p>
<p id="p-0067" num="0066">r (R_j): netlist gate correlating nonquantifiable BDD variable R_j (e.g., a register gate)</p>
<p id="p-0068" num="0067">BDD_TOP: the binary decision diagram <b>170</b> to be synthesized</p>
<p id="p-0069" num="0068">BDD_ONE: represents the constant-one binary decision diagram <b>170</b></p>
<p id="p-0070" num="0069">BDD_ZERO: represents the constant-zero binary decision diagram <b>170</b></p>
<p id="p-0071" num="0070">GATE_ONE: represents a constant-one gate</p>
<p id="p-0072" num="0071">GATE_ZERO: represents a constant-zero gate</p>
<p id="p-0073" num="0072">BDD_THEN (node): gets the “then” child of binary decision diagram <b>170</b> node “node”</p>
<p id="p-0074" num="0073">BDD_ELSE (node): gets the “else” child of binary decision diagram <b>170</b> node “node”</p>
<p id="p-0075" num="0074">BDD_INVERT (node): inverts the binary decision diagram <b>170</b> node—flipping the “is inverted” flag</p>
<p id="p-0076" num="0075">BDD_IS_INVERTED (node): returns ‘1’ exactly when the “is inverted” flag of the binary decision diagram <b>170</b> is set</p>
<p id="p-0077" num="0076">BDD_CLEAR_INVERTED (node): clears the “is inverted” flag of the binary decision diagram <b>170</b></p>
<p id="p-0078" num="0077">BDD_VARID (node): returns the binary decision diagram <b>170</b> variable associated with “node” (which is undefined only for BDD_ZERO and BDD_ONE)</p>
<p id="p-0079" num="0078">BDD_EXIST (node, Q): returns a binary decision diagram <b>170</b> representing “node” with variables in Q existentially quantified out</p>
<p id="p-0080" num="0079">OR (a,b): creates an OR gate whose inputs are gates a and b</p>
<p id="p-0081" num="0080">OR_QUEUE (q): creates an OR gate whose inputs are the gates in queue q</p>
<p id="p-0082" num="0081">AND (a,b): creates an AND gate whose inputs are gates a and b</p>
<p id="p-0083" num="0082">AND_QUEUE (q): creates an AND gate whose inputs are the gates in queue q</p>
<p id="p-0084" num="0083">NOT(a): creates an INVERTER gate whose input is gate a</p>
<p id="p-0085" num="0084">IF_THEN_ELSE (a,b,c): returns a gate encoding the function (OR (AND (a,b), AND (NOT (a), c)))</p>
<p id="p-0086" num="0085">The pseudocode below represents a top-level function used to create a replacement gate for each G_i void in a preferred embodiment of replacement unit <b>158</b>:</p>
<p id="p-0087" num="0086">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="280pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void Create_Replacement(BDD BDD_TOP) {</entry>
</row>
<row>
<entry> for (each variable G_i)</entry>
</row>
<row>
<entry>  Create a RANDOM gate, called n(G_i);</entry>
</row>
<row>
<entry> // Set up Parent and Var_To_Nodes lists:</entry>
</row>
<row>
<entry> Create_Replacement1(BDD_TOP, BDD_ONE, 0);</entry>
</row>
<row>
<entry> // traverse both quantifiable and nonquantifiable vars</entry>
</row>
<row>
<entry> for (each variable V_i in rank order of BDD_TOP)</entry>
</row>
<row>
<entry>  // follow order of variables from root to leaves</entry>
</row>
<row>
<entry>  Create_Replacement2(V_i);</entry>
</row>
<row>
<entry> for (each variable G_i not in the support of BDD_TOP) {</entry>
</row>
<row>
<entry>  replace the corresponding cut gate C_i directly by n(G_i);</entry>
</row>
<row>
<entry>  r(G_i) = n(G_i);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// this function lists the parent BDD nodes for each node plus its inversion</entry>
</row>
<row>
<entry>// in queue Parents( ) and Parents_Ivt( ) respectively, and lists the BDD nodes</entry>
</row>
<row>
<entry>// plus “inverted” handles for each variable inside of BDD_TOP in queue Vars_To_Nodes( )</entry>
</row>
<row>
<entry>// The parent of the root node (BDD_TOP) is uniquely labeled as BDD_ONE</entry>
</row>
<row>
<entry>void Create_Replacement1(BDD node, BDD parent, bool is_inverted) {</entry>
</row>
<row>
<entry> if (node == BDD_ONE || node == BDD_ZERO)</entry>
</row>
<row>
<entry>  return;</entry>
</row>
<row>
<entry> // Make sure node is positive and incorporate its phase in is_inverted:</entry>
</row>
<row>
<entry> if (BDD_IS_INVERTED(node)) {</entry>
</row>
<row>
<entry>  is_inverted = !is_inverted;</entry>
</row>
<row>
<entry>  node = BDD_CLEAR_INVERTED(node);</entry>
</row>
<row>
<entry>  if (parent != BDD_ONE)</entry>
</row>
<row>
<entry>   parent = BDD_INVERT(parent);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> if (is_inverted) {</entry>
</row>
<row>
<entry>  push(Parents_Ivt(node), parent);</entry>
</row>
<row>
<entry>  push_unique(Vars_To_Nodes(BDD_VARID(node)), BDD_INVERT(node)); // need not</entry>
</row>
<row>
<entry>push a given BDD handle twice onto Vars_To_Nodes</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> else {</entry>
</row>
<row>
<entry>  push(Parents(node), parent);</entry>
</row>
<row>
<entry>  push_unique(Vars_To_Nodes(BDD_VARID(node)), node);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> if (!visited(node)) {</entry>
</row>
<row>
<entry>  visited(node) = TRUE;</entry>
</row>
<row>
<entry>  Create_Replacement1(BDD_THEN(node), node, is_inverted);</entry>
</row>
<row>
<entry>  Create_Replacement1(BDD_ELSE(node), node, is_inverted);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// this function replaces each quantifiable C_i whose G_i is in the support</entry>
</row>
<row>
<entry>// of BDD_TOP with a trace-equivalent gate</entry>
</row>
<row>
<entry>void Create_Replacement2(BDD_VAR v) {</entry>
</row>
<row>
<entry> for (each BDD node in Vars_To_Nodes(v))</entry>
</row>
<row>
<entry>  Create_Replacement3(node);</entry>
</row>
<row>
<entry> if (v is a “quantifiable variable”) {</entry>
</row>
<row>
<entry>  for (each BDD node in Vars_To_Nodes(v))</entry>
</row>
<row>
<entry>  Create_Replacement4(node);</entry>
</row>
<row>
<entry>  // The function to be created is</entry>
</row>
<row>
<entry>  // must_be_1 OR (n(v) AND NOT(OR(must_be_0,must_be_1)))</entry>
</row>
<row>
<entry>  // which simplifies to</entry>
</row>
<row>
<entry>  // must_be_1 OR (n(v) AND NOT(must_be_0))</entry>
</row>
<row>
<entry>  must_be_0 = OR_QUEUE(Var_Must_Be_0(v));</entry>
</row>
<row>
<entry>  must_be_1 = OR_QUEUE(Var_Must_Be_1(v));</entry>
</row>
<row>
<entry>  random = NOT(must_be_0);</entry>
</row>
<row>
<entry>  replacement_gate = OR(must_be_1, AND(n(v), random));</entry>
</row>
<row>
<entry>  replace the corresponding cut gate C_i by replacement_gate;</entry>
</row>
<row>
<entry>  r(G_i) = replacement_gate;</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// this function creates a gate representing the valuations to n(R_i) and</entry>
</row>
<row>
<entry>// n(G_i) variables which correlate to paths from the root BDD_TOP to the</entry>
</row>
<row>
<entry>// present BDD node/its inversion</entry>
</row>
<row>
<entry>void Create_Replacement3(BDD node) {</entry>
</row>
<row>
<entry> assert(node != BDD_ONE &amp;&amp; node != BDD_ZERO);</entry>
</row>
<row>
<entry> is_inverted = BDD_IS_INVERTED(node);</entry>
</row>
<row>
<entry> node = BDD_CLEAR_INVERTED(node);</entry>
</row>
<row>
<entry> if (is_inverted)</entry>
</row>
<row>
<entry>  Path_Ivt(node) = Create_Path(node, is_inverted);</entry>
</row>
<row>
<entry> else</entry>
</row>
<row>
<entry>  Path(node) = Create_Path(node, is_inverted);</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// this is a “helper” function for Create_Replacement3. It produces a gate representing the</entry>
</row>
<row>
<entry>// valuations to gates correlating to BDD variables higher in the rank which “sensitize” the path</entry>
</row>
<row>
<entry>// from the root BDD_TOP to the present node</entry>
</row>
<row>
<entry>gate Create_Path(BDD node, bool is_inverted) {</entry>
</row>
<row>
<entry> list = is_inverted ? Parents_Ivt(node) : Parents(node);</entry>
</row>
<row>
<entry> final_gate = GATE_ZERO;</entry>
</row>
<row>
<entry> // Note: root node has single BDD_ONE parent.</entry>
</row>
<row>
<entry>for (each parent in list) {</entry>
</row>
<row>
<entry> if (parent == BDD_ONE) {</entry>
</row>
<row>
<entry>  // this only happens for “root” node</entry>
</row>
<row>
<entry>  return GATE_ONE;</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> if (BDD_IS_INVERTED(parent)) {</entry>
</row>
<row>
<entry>  invert2 = !is_inverted;</entry>
</row>
<row>
<entry>  parent = BDD_CLEAR_INVERTED(parent);</entry>
</row>
<row>
<entry>  node2 = BDD_INVERT(node);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> else {</entry>
</row>
<row>
<entry>  invert2 = is_inverted;</entry>
</row>
<row>
<entry>  node2 = node;</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> gate = invert2 ? Path_Ivt(parent) : Path(parent);</entry>
</row>
<row>
<entry> // We use r(varid) vs. n(varid) to ensure that the synthesis is correct and</entry>
</row>
<row>
<entry> // preserves the range of the cut. I.e., synthesized functions of lower vars may</entry>
</row>
<row>
<entry> // otherwise not really correlate to values of synthesized functions of higher</entry>
</row>
<row>
<entry> // vars, being “misled” by looking at the free parametric var valuations n(varid)</entry>
</row>
<row>
<entry> // themselves instead of the synthesized functions r(varid) which reflect</entry>
</row>
<row>
<entry> // conditions under which the r(varid) != n(varid)</entry>
</row>
<row>
<entry> if (BDD_THEN(parent) == node2)</entry>
</row>
<row>
<entry>  gate = AND(gate, r(BDD_VARID(parent)));</entry>
</row>
<row>
<entry> else // BDD_ELSE(parent) == node2</entry>
</row>
<row>
<entry>  gate = AND(gate, INVERT(r(BDD_VARID(parent))));</entry>
</row>
<row>
<entry> final_gate = OR(final_gate, gate);</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>return final_gate;</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// this function augments the gates representing paths from BDD_TOP to the</entry>
</row>
<row>
<entry>// current BDD node (or its inversion) recorded in Create_Replacement3, to</entry>
</row>
<row>
<entry>// reflect the impact of “nonquantifiable variables” below the node being considered</entry>
</row>
<row>
<entry>// in Create_Replacement3</entry>
</row>
<row>
<entry>void Create_Replacement4(BDD node) {</entry>
</row>
<row>
<entry> is_inverted = BDD_IS_INVERTED(node);</entry>
</row>
<row>
<entry> node = BDD_CLEAR_INVERTED(node);</entry>
</row>
<row>
<entry> // Note: Q is the set of quantifiable variables:</entry>
</row>
<row>
<entry> if (is_inverted) {</entry>
</row>
<row>
<entry>  gate = Path_Ivt(node);</entry>
</row>
<row>
<entry>  node2 = BDD_EXIST(BDD_INVERT(BDD_THEN(node)), Q);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> else {</entry>
</row>
<row>
<entry>  gate = Path(node);</entry>
</row>
<row>
<entry>  node2 = BDD_EXIST(BDD_THEN(node), Q);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> // The purpose of the following gate_then is to evaluate the conditions under</entry>
</row>
<row>
<entry> // which the current BDD_VARID's synthesized function cannot evaluate to ‘1’.</entry>
</row>
<row>
<entry> // Note: gate_then will be GATE_ZERO if the resut of BDD_EXIST is</entry>
</row>
<row>
<entry> // BDD_ONE - i.e., the corresponding BDD_VARID is allowed to take the value ‘1’.</entry>
</row>
<row>
<entry> // Otherwise, gate_then will represent a synthesis of the valuations to the prior</entry>
</row>
<row>
<entry> // synthesized cut gate functions, and “deeper” non-quantifiable variables,</entry>
</row>
<row>
<entry> // for which the corresponding cut-point may not evaluate to a ‘1’ -</entry>
</row>
<row>
<entry> // we thus push the result onto Var_Must_Be_0</entry>
</row>
<row>
<entry> gate_then = AND(gate, Synthesize(node2));</entry>
</row>
<row>
<entry> push(Var_Must_Be_0(BDD_VARID(node)), NOT(gate_then));</entry>
</row>
<row>
<entry> if (is_inverted)</entry>
</row>
<row>
<entry>  node2 = BDD_EXIST(BDD_INVERT(BDD_ELSE(node)), Q);</entry>
</row>
<row>
<entry> else</entry>
</row>
<row>
<entry>  node2 = BDD_EXIST(BDD_ELSE(node), Q);</entry>
</row>
<row>
<entry> gate_else = AND(gate, Synthesize(node2));</entry>
</row>
<row>
<entry> push(Var_Must_Be_1(BDD_VARID(node)), NOT(gate_else));</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// this performs a common multiplexer-based synthesis of a BDD</entry>
</row>
<row>
<entry>// (without parameterization)</entry>
</row>
<row>
<entry>gate Synthesize(BDD node) {</entry>
</row>
<row>
<entry> if (node == BDD_ZERO)</entry>
</row>
<row>
<entry> return GATE_ZERO;</entry>
</row>
<row>
<entry> if (node == BDD_ONE)</entry>
</row>
<row>
<entry>  return GATE_ONE;</entry>
</row>
<row>
<entry> is_inverted = BDD_IS_INVERTED(node);</entry>
</row>
<row>
<entry> node = BDD_CLEAR_INVERTED(node);</entry>
</row>
<row>
<entry> // Check whether already synthesized:</entry>
</row>
<row>
<entry> gate = Synthesized(node);</entry>
</row>
<row>
<entry> if (!gate) {</entry>
</row>
<row>
<entry>  gate = IF_THEN_ELSE(r(BDD_VARID(node)), // “if” clause</entry>
</row>
<row>
<entry>  SYNTHESIZE(BDD_THEN(node)), // “then” clause</entry>
</row>
<row>
<entry>  SYNTHESIZE(BDD_ELSE(node))); // “else” clause</entry>
</row>
<row>
<entry>  // Remember the gate network that synthesizes this node:</entry>
</row>
<row>
<entry>  Synthesized(node) = gate;</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> // Correct result for inversion if necessary:</entry>
</row>
<row>
<entry> return is_inverted ? NOT(gate) : gate;</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0088" num="0087">The pseudocode for algorithm Create_Replacement_Alternative below represents an alternative top-level function used to create a replacement gate C′_i for each G_i. Though this pseudocode is sufficiently simpler than that of the prior example, it tends to be suboptimal in practice. The reason is the following. Each BDD_EXIST call will create a new BDD, which is directly synthesized as the replacement gate for the corresponding cut gate using algorithm Synthesize above. While this BDD, and hence the logic of the corresponding replacement gate, may be smaller for variables high in the rank of BDD_TOP than the corresponding replacement gate using the algorithm Create_Replacement, the corresponding BDD nodes and logic cannot be reused for the replacement gates of variables lower in the rank of BDD_TOP, overall increasing the cumulative size of the replacement logic.</p>
<p id="p-0089" num="0088">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void Create_Replacement_Alternative(BDD BDD_TOP) {</entry>
</row>
<row>
<entry> for each quantifiable variable V_i</entry>
</row>
<row>
<entry>  n(V_i) = new RANDOM gate</entry>
</row>
<row>
<entry> for (each variable G_i in rank order of BDD_TOP)</entry>
</row>
<row>
<entry> // follow order of variables from root to leaves</entry>
</row>
<row>
<entry> // quantify every lower-rank cut variable</entry>
</row>
<row>
<entry> b_i = BDD_EXISTS(BDD_TOP, {G_{i+1 }, ..., G_N});</entry>
</row>
<row>
<entry> // forced_0_i represents conditions for which the replacement gate of</entry>
</row>
<row>
<entry> G_i must evaluate to 0</entry>
</row>
<row>
<entry> forced_0_i = BDD_NOT( BDD_THEN( b_i ));</entry>
</row>
<row>
<entry> // forced_1_i represents conditions for which the replacement gate of</entry>
</row>
<row>
<entry> G_i must evaluate to 1</entry>
</row>
<row>
<entry> forced_1_i = BDD_NOT( BDD_ELSE( b_i ));</entry>
</row>
<row>
<entry> r(C_i) = OR( SYNTHESIZE( forced_1_i ), AND( n(C_i),</entry>
</row>
<row>
<entry> NOT(SYNTHESIZE( forced_0_i));</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0090" num="0089">Translation unit <b>168</b> translates a counterexample trace, such as abstracted trace (P′) <b>152</b> obtained over abstracted design (D′) <b>144</b> to one consistent with the initial design (D) netlist <b>120</b>, such as unabstracted trace (P) <b>154</b>. A “trace”, such as abstracted trace (P′) <b>152</b> or unabstracted trace (P) <b>154</b> is a set of 0,1 logical evaluations to some of the gates of a design, such as abstracted design (D′) <b>144</b> or initial design (D) netlist <b>120</b>, respectively, over time. Traces generated by verification environment <b>124</b> may be incomplete; e.g., traces may not illustrate values for certain gates at certain points in time. If a consistent trace is generated by verification environment <b>124</b>, it is assumed that, if verification environment <b>124</b> is performing random simulation in a manner which applies any trace values present for a RANDOM gate to drive the random simulation stimulus, and an arbitrarily selected constant is chosen for all other stimuli (for RANDOM gate values at time-steps which are not present in the trace), the value generated in random simulation by verification environment <b>124</b> for any gate in the design must match the value present in the trace (if it exists). Otherwise, the corresponding trace is considered inconsistent, not illustrating sufficient data to demonstrate how certain gates are taking their values. In discussing translation unit <b>168</b>, the value in TRACE for gate G at time I is referred to as TRACE(G,I), which has values 0, 1, or U (where U means “unknown” or “not present”).</p>
<p id="p-0091" num="0090">Abstracted trace (P′) <b>152</b> from the abstracted design (D′) <b>144</b> includes some values for gates in the fanout-side of the cut, registers in the fanin-side of the cut at cutpoint <b>140</b>, the cut gates (U) <b>132</b> themselves, and the gate set (C″) <b>146</b>. Abstracted trace (P′) <b>152</b> will not include any values for the combinational/RANDOM gates on the original fanin-side of the cut at cutpoint <b>140</b>, which are not included in abstracted design (D′) <b>144</b>. Translation unit <b>168</b> employs a 2-step process to translate abstracted trace (P′) <b>152</b> and thereby generate unabstracted trace (P) <b>154</b>, which is consistent with initial design (D) netlist <b>120</b>.</p>
<p id="p-0092" num="0091">Translation unit <b>168</b> obtains values for all cut gates (U) <b>132</b>, and registers in the support of the gate set (C″) <b>146</b>, for all time-steps present in the trace. Note that some gates may be omitted from abstracted trace (P′) <b>152</b>, and some may have values missing for certain time-steps.</p>
<p id="p-0093" num="0092">Turning now to <figref idref="DRAWINGS">FIG. 6</figref>, a high-level logical flowchart of a process for performing reversal of the effects of sequential reparameterization on traces in accordance with a preferred embodiment of the present invention is depicted. The process starts at step <b>600</b> and moves to step <b>602</b>, which depicts translation unit <b>168</b> receiving initial design (D) netlist <b>120</b>, equal to (C, C′), abstracted design (D′) <b>144</b>, equal to (C″,C′), trace p′″ over abstracted design (D′) <b>144</b>, wherein cut gates U <b>132</b> represents the subset of C which sources edges to set C′ <b>176</b> in initial design (D) netlist <b>120</b> and U′ represents the subset of gate set C″ <b>146</b> which source edges of set C′ <b>176</b> in abstracted design (D′) <b>144</b>.</p>
<p id="p-0094" num="0093">Step <b>602</b> provides the step of receiving the original design, the abstracted design, and the first trace over the abstracted design wherein a set of cut gates denotes a subset of an identified gate set of the initial design which sources one or more edges to an initial gate set in the initial design and where a set of corresponding gates denotes a second gate set which sources one or more edges to the initial gate set in the abstracted design. The process then proceeds to step <b>604</b>, wherein verification environment <b>124</b> uses simulation to populate trace p′″. Particularly, verification environment <b>124</b> uses simulation to populate values to corresponding gates (U′) <b>148</b> for the necessary length of trace p′″, generating a resulting populated abstracted trace p′ <b>152</b>. The process then moves to step <b>606</b>.</p>
<p id="p-0095" num="0094">At step <b>606</b>, translation unit <b>168</b>, casts a k-step satisfiability check to obtain a trace (P″) <b>150</b> over (C), witnessing the same sequence evaluations to cut gates (U) <b>132</b>, seen at corresponding gates (U′) <b>148</b> in abstracted trace (P′) <b>152</b>. The process next proceeds to step <b>608</b>, which illustrates translation unit <b>168</b> concatenating values to (C) from trace (P″) with values to (C′) in abstracted trace (P′) <b>152</b> to form unabstracted trace (P) <b>154</b>, demonstrating a hit of the target in initial design (D) netlist <b>120</b>. The process then moves to step <b>610</b>. At step <b>610</b>, translation unit <b>168</b> returns new trace (p) <b>178</b> over initial design (D) netlist <b>120</b>, corresponding to trace p′″ over abstracted design (D′) <b>144</b>. Finally, the process ends at step <b>612</b>.</p>
<p id="p-0096" num="0095">In a preferred embodiment of the flowchart of <figref idref="DRAWINGS">FIG. 6</figref>, translation unit <b>168</b> performs using simple recursive simulation, over the gate set (C″) <b>146</b>, using a method described in pseudocode below:</p>
<p id="p-0097" num="0096">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>for each timestep i in 0 .. length(TRACE)−1 {</entry>
</row>
<row>
<entry> for each cut gate G_i {</entry>
</row>
<row>
<entry>  if( TRACE (G_i,i) = = U ) {</entry>
</row>
<row>
<entry>   TRACE(G_i, i) = Simulate(G_i, i);</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>sim_value Simulate(gate g, unsigned i) {</entry>
</row>
<row>
<entry> if (g has been ‘replaced” by another gate h) {return Simulate(h,i);}</entry>
</row>
<row>
<entry> if( TRACE(g,i) != U ) {return TRACE(g,i);}</entry>
</row>
<row>
<entry> if( g is a register) {</entry>
</row>
<row>
<entry> if(i==0) {val = Simulate(INIT_VALUE (g), 0);}</entry>
</row>
<row>
<entry> else   {val = Simulate(NEXT_STATE(g), i−1);}</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> else if(g is a RANDOM gate) {</entry>
</row>
<row>
<entry>  val = randomly choose a 0,1 value;</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> else { // g is a combinational gate with function F</entry>
</row>
<row>
<entry>  val = F( return value of Simulate( ) applied to each input gate to g,</entry>
</row>
<row>
<entry>  for time i);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> TRACE(g,i) = val;</entry>
</row>
<row>
<entry> return val;</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0098" num="0097">Translation unit <b>168</b> next performs a satisfiability-check over the original logic (from initial design (D) netlist <b>120</b>) driving the cut gates (U) <b>132</b>, to compute values to the RANDOM gates in the original fanin-side of the cut at cutpoint <b>140</b> which will produce the same sequence of values from unabstracted trace (P) <b>154</b> at cut gates (U) <b>132</b>, as a function of the register values in that cut at cutpoint <b>140</b>. By construction, since abstraction to create abstracted trace (P′) <b>152</b> preserves semantics (even under constraints (B) <b>160</b>, as discussed below), such a sequence does exist in initial design (D) netlist <b>120</b>. The pseudocode below represents a function used by translation unit <b>168</b> to obtain a satisfiability check:</p>
<p id="p-0099" num="0098">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="287pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void Translate_Trace( ) {</entry>
</row>
<row>
<entry> gate to satisfiability_check = GATE_ONE;</entry>
</row>
<row>
<entry> for each timestep j in 0. .length(TRACE)−1 {</entry>
</row>
<row>
<entry>  for each cut gate G_i {</entry>
</row>
<row>
<entry>   ASSERT(TRACE(G_i, j) ! = U);</entry>
</row>
<row>
<entry>   // note - the prior pseudocode ensured that these will each be defined</entry>
</row>
<row>
<entry>   if ( TRACE (G_i, j) = = 1 ) {</entry>
</row>
<row>
<entry>    gate = Get_Cone (G_i, j);</entry>
</row>
<row>
<entry>   }</entry>
</row>
<row>
<entry>   else</entry>
</row>
<row>
<entry>    gate = NOT(Get_Cone (G_i, j));</entry>
</row>
<row>
<entry>   }</entry>
</row>
<row>
<entry>   gate_to_satisfiability_check = AND (gate, gate_to_satisfiability_check)</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry>  // need an extra pass over all constraint (B) 160 gates which were not synthesized, in case</entry>
</row>
<row>
<entry>their cones did not overlap that of the targets.</entry>
</row>
<row>
<entry>  // In that case, their semantic impact on RANDOM gate stimulus may not be reflected in</entry>
</row>
<row>
<entry>TRACE;</entry>
</row>
<row>
<entry>  // disjoint cones separately to ensure that the resulting trace satisfies those constraints</entry>
</row>
<row>
<entry>anyway to ensure overall semantic preservation of constraints.</entry>
</row>
<row>
<entry>  for each constraint gate G_i which was not synthesized</entry>
</row>
<row>
<entry>   gate_to_satisfiability check = AND (Get_Cone (G_i, j), gate_to_satisfiability_check)</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> produce a trace TRACE2 showing how to evaluate gate_to_satisfiability_check to a logical ‘1’.</entry>
</row>
<row>
<entry> use Append_Traces( ) to produce a consistent trace for the original design, completing the trace</entry>
</row>
<row>
<entry>translation procedure</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>// this function performs a combinational unfolding of the design to enable a satisfiability-check</entry>
</row>
<row>
<entry>// to produce a trace showing how the original fanin-side of the cut can produce the same</entry>
</row>
<row>
<entry>// sequence of values seen in TRACE to the cut gates in the abstract design, which is consistent</entry>
</row>
<row>
<entry>// with the values to the registers in the gate set (C″) 146</entry>
</row>
<row>
<entry>gate Get_Cone (gate g, unsigned i) {</entry>
</row>
<row>
<entry> if( MAPPING(g,i) ) {return MAPPING(g,i);} // already created the corresponding unfolded</entry>
</row>
<row>
<entry>gate</entry>
</row>
<row>
<entry> if( TRACE(g,i) == 0 ) {return GATE_ZERO;}</entry>
</row>
<row>
<entry> if( TRACE(g,i) == 1 ) {return GATE_ONE;}</entry>
</row>
<row>
<entry> if( g is a register) {</entry>
</row>
<row>
<entry>  if(i==0) {val = Get_Cone(INIT_VALUE(g), 0);}</entry>
</row>
<row>
<entry>  else   {val = Get_Cone(NEXT_STATE(g), i−1);}</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> else if(g is a R2NDOM gate) {</entry>
</row>
<row>
<entry>  val = Create RANDOM GateQ; // this creates a new RANDOM gate</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> else { // g is a combinational gate of type F</entry>
</row>
<row>
<entry>  // here, Create_Gate_F creates a gate of the same type as F, connecting the i-th input to this</entry>
</row>
<row>
<entry>  // gate to the result of calling Get_Cone on the ith-input gate to g, at time i</entry>
</row>
<row>
<entry>  val = Create_Gate_F( return value of Get_Cone applied to each input gate to g, for time i);</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry> MAPPING(g,i) = val;</entry>
</row>
<row>
<entry> return val;</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry>Append_Traces( ) {</entry>
</row>
<row>
<entry> for each timestep i in 0. .length(TRACE)−1 {</entry>
</row>
<row>
<entry>  for each gate g in the replacement cone {</entry>
</row>
<row>
<entry>   if(TRACE(g,i) == U) {</entry>
</row>
<row>
<entry>    TRACE(g,i) = TRACE2( MAPPING(g,i), 0 );</entry>
</row>
<row>
<entry>   }</entry>
</row>
<row>
<entry>  }</entry>
</row>
<row>
<entry> }</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0100" num="0099">Translation unit <b>168</b> uses satisfiability checking over an unfolded instance of the sequential problem embodied in abstracted trace (P′) <b>152</b> to generate a preliminary trace showing values to the original fanin-side of the cut at cutpoint <b>140</b> which drive the same sequence of values seen in the simulated, abstracted trace (P′) <b>152</b>. Translation unit <b>168</b> then “re-folds” that preliminary trace and append it into TRACE, resulting in an unabstracted trace (P) <b>154</b> demonstrating how initial design (D) netlist <b>120</b> drives the same sequence of values present in abstracted trace (P′) <b>152</b> to the cut gates (U) <b>132</b> and in turn, to all gates in the fanout-side of the cut at cutpoint <b>140</b>. It is noteworthy that the trace translation method applied by translation unit <b>168</b> is applicable whether the overall abstraction process of parametric reduction toolkit <b>166</b> processed the cut gates (U) <b>132</b> in one step, or incrementally through many steps.</p>
<p id="p-0101" num="0100">The design of translation unit <b>168</b> includes a noteworthy subtlety. A register in the original fanin-side of the cut at cutpoint <b>140</b> may fall out of the cone in the gate set (C″) <b>146</b>. For example, say a cut gate (U) <b>132</b> g_i is defined as i_i XOR r_i, where i_i is a RANDOM gate and r_i is a register (XOR denotes the exclusive-or function). Abstraction by parametric reduction toolkit <b>166</b> may replace this cut gate (U) <b>132</b> g_i with a new RANDOM gate if, in initial design (D) netlist <b>120</b>, there exists some sequence of values to i_i which will allow the cut gate to drive any possible sequence of 0,1 values, regardless of the values to r_i. The first step of trace translation by translation unit <b>168</b> will not assign values to r_i in its simulation, because gate set (C″) <b>146</b> does not include r_i. However, the second step of trace translation by translation unit <b>168</b> will require the sequence of values r_i takes to enable translation unit <b>168</b> to choose values for i_i which drive the sequence of values seen at the replaced cut gate (U) <b>132</b> in abstracted design (D′) <b>144</b>. The Get_Cone pseudocode above solves this problem, by unfolding “through” such registers with unassigned values in TRACE, to enable the satisfiability check to compute the values of such registers.</p>
<p id="p-0102" num="0101">Exploitation unit <b>172</b> enhances the reduction potential of the parametric reduction toolkit <b>166</b> by exploiting invariants (N) <b>164</b> and constraints (B) <b>160</b> present in initial design (D) netlist <b>120</b>. The semantics of invariants (N) <b>164</b> and constraints (B) <b>160</b> were described above. A constraint (B) <b>160</b> gate is one which must always evaluate to a logical ‘1’ in the verification process. Constraints (B) <b>160</b> represent valuations to RANDOM gates and/or registers which are to be “artificially” disallowed by the verification environment <b>124</b>.</p>
<p id="p-0103" num="0102">Without the constraint (B) <b>160</b>, verification environment <b>124</b> might unnecessarily explore such valuations. Exploitation unit <b>172</b> uses the presence of constraints (B) <b>160</b> to simplify gate set (C″) <b>146</b>, and if possible, to eliminate the need for an “artificial constraint” by synthesizing the constraint (B) <b>160</b>. For example, if a constraint (B) <b>160</b> evaluates to a ‘1’ exactly when a vector of RANDOM gates evaluates to even parity, exploitation unit <b>172</b> can eliminate the need for a constraint (B) <b>160</b> to enforce such a condition by creating a portion of gate set (C″) <b>146</b> for any one of those RANDOM gates which is not RANDOM, but instead deterministically drives a ‘1’ exactly when the other RANDOM gates in the vector have odd parity (to overall ensure that sink logic of the original gates see a vector which is guaranteed to adhere to even parity, even without the constraint). However, in other cases, the constraint (B) <b>160</b> cannot be so synthesized.</p>
<p id="p-0104" num="0103">For example, assume the constraint (B) <b>160</b> is of the form: “a given set of registers has even parity AND a given set of RANDOM gates has odd parity”. Exploitation unit <b>172</b> simplifies this constraint (B) <b>160</b> by synthesizing the latter part, to ensure that the RANDOM gates, when replaced, drive odd parity. Exploitation unit <b>172</b> then simplifies the constraint (B) <b>160</b> to “a given set of registers has even parity.” Because replacement unit <b>158</b> does not re-encode registers themselves (doing so would risk moving the complexity class of this problem from NP to PSPACE), exploitation unit <b>172</b> cannot synthesize away such a constraint (B) <b>160</b> outright, but can indeed work to synthesize aspects of such a constraint (B) <b>160</b> to simplify gate set (C″) <b>146</b>, and retain only a simplified constraint (B) <b>160</b> thereafter.</p>
<p id="p-0105" num="0104">Exploitation unit <b>172</b> performs simplification of the gate set (C″) <b>146</b> and constraints (B) <b>160</b> in several steps. Recall that selection unit <b>156</b> labels sinks of a min-cut process to include constraints (B) <b>160</b>, thereby ensuring that constraints (B) <b>160</b> will be in the fanout-side of cut at cutpoint <b>140</b>, or on the cut at cutpoint <b>140</b> itself. Those constraints (B) <b>160</b> that are not combinationally driven by RANDOM gates cannot be readily simplified by selection unit <b>156</b> and replacement unit <b>158</b>. Those constraints (B) <b>160</b> that are not combinationally driven by RANDOM gates are ignored by replacement unit <b>158</b> in the abstraction process and semantically preserved (inasmuch as all gates in the fanout side of the cut at cutpoint <b>140</b> are semantically preserved). Those constraints (B) <b>160</b> that are combinationally driven by RANDOM gates are candidates for simplification (regardless of whether they are also driven by registers). Alternative embodiments may add such RANDOM-driven constraints (B) <b>160</b> gates to the cut at cutpoint <b>140</b> to abstract, even if they are not chosen as being on the min-cut at cutpoint <b>140</b>, to enable further simplifications.</p>
<p id="p-0106" num="0105">If a constraint (B) <b>160</b> gate is on the cut at cutpoint <b>140</b>, when analyzing the language of the cut at cutpoint <b>140</b> to form BDD_TOP to pass to gate set (C″) <b>146</b> creation code in replacement unit <b>158</b>, BDD_TOP is conjuncted to the binary decision diagrams <b>170</b> representing the function of the constraint gate F_i over register variables R_i, and original RANDOM gate variables (with a small subtlety, discussed below), forcing conjunction of (F_i=1) onto BDD_TOP. For other non-constraint gates, replacement unit <b>158</b> conjuncts in (F_i=G_i), allowing F_i to evaluate to either a 0 or a 1 as consistent with initial design (D) netlist <b>120</b>. The conjunctive behavior above effectively restricts BDD_TOP (representing those valuations to C_i that are sensitizable as a function of R_i) to eliminate any valuations for which the constraint (B) <b>160</b> gate does not evaluate to ‘1’. Synthesis methods used by replacement unit <b>158</b> thereafter create gate set (C″) <b>146</b>, which has been simplified by the constraint (B) <b>160</b>. If the resulting constraint (B) <b>160</b> is a cut gate (U) <b>132</b>, now driven by gate set (C″) <b>146</b>, the resulting constraint (B) <b>160</b> will evaluate to a constant ‘1’ in abstracted design (D′) <b>144</b>, because the resulting constraint (B) <b>160</b> will be replaced by GATE_ONE. Therefore the resulting constraint (B) <b>160</b> may trivially be removed as a constraint (B) <b>160</b> because it has no artificial “constraining power”.</p>
<p id="p-0107" num="0106">Some constraints (B) <b>160</b> have a sequential nature which cannot be synthesized away by replacement unit <b>158</b> with the method discussed above, and exploitation unit <b>172</b> ensures that such constraints (B) <b>160</b> are preserved, rather than allowing them to be discarded by abstraction, and risking a violation of the semantics of the verification problem with abstracted design (D′) <b>144</b>. Exploitation unit <b>172</b> handles such constraints (B) <b>160</b>, for any constraint (B) <b>160</b> gate which is also a cut gate (U) <b>132</b>, in several steps. First exploitation unit <b>172</b> build F_i for a constraint (B) <b>160</b> function over registers and RANDOM gates (with respect to the original design). Then, exploitation unit <b>172</b> existentially quantifies away all RANDOM gate variables from F_i. If the resulting quantified F_i is BDD_ONE, then no special treatment is necessary, because, for all valuations to the registers, there is a legal set of inputs, and the gate set (C″) <b>146</b> will properly reflect exactly that set of inputs. Otherwise, exploitation unit <b>172</b> replaces the constraint (B) <b>160</b> with a simplified constraint to disallow some valuations to registers. The original constraint (B) <b>160</b> gate itself will be driven by GATE_ONE and will be discarded. Exploitation unit <b>172</b> adds a new constraint (B) <b>160</b> to original design (D) netlist <b>120</b>, which is a direct synthesis of this quantified F_i (created using method Synthesize, which is described above).</p>
<p id="p-0108" num="0107">Exploitation unit <b>172</b> further provides means for addressing a subtlety to constraint (B) <b>160</b> handling that may require special treatment. As discussed above, parametric reduction toolkit <b>166</b> conjuncts BDD_TOP to the binary decision diagram <b>170</b> (hereafter called B_i) representing the function of the constraint gate F_i, which is a function of register variables and RANDOM gate variables. This conjunction in turn will force the gate set (C″) <b>146</b> created for the corresponding cut to adhere to evaluating any constraints on the cut to be ‘1’. Forcing the gate set (C″) <b>146</b> created for the corresponding cut to adhere to evaluating any constraints on the cut to be ‘1’ may be excessively aggressive if the B_i includes “dead-end states” (i.e, valuations to registers for which no legal input stimulus is possible).</p>
<p id="p-0109" num="0108">In the example above, given a constraint (B) <b>160</b> such as “a given set of registers has even parity AND a given set of RANDOM gates has odd parity”, the dead-end constraint (B) <b>160</b> contained therein is that “a given set of registers has even parity”. With such constraints (B) <b>160</b>, exploitation unit <b>172</b> will include only the RANDOM-gate-constraining portion of the constraint (B) <b>160</b> (e.g., “a given set of RANDOM gates has odd parity”) to conjunct to BDD_TOP, and parametric reduction toolkit <b>166</b> will factor out the dead-end constraint portion before exploitation unit <b>172</b> conjuncts to BDD_TOP.</p>
<p id="p-0110" num="0109">Exploitation unit <b>172</b> executes the behavior described above when conjuncting the dead-end states to BDD_TOP. Exploitation unit <b>172</b> will force the function of every replacement gate to include the dead-end states in its support, which may, for example, turn a combinationally-driven original cut gate (U) <b>132</b> into a sequentially-driven replacement gate. While this transformation does not necessarily violate the semantics of the verification problem contained in original design (D) netlist <b>120</b>, the transformation may be particularly undesirable if, for example, sequential logic is introduced onto an initial-value cone. In such a case, verification environment <b>124</b> may encounter cyclic definitions when evaluating the initial states of the design, (e.g., the initial value of registers R_<b>1</b> and R_<b>2</b> may both become ((R_<b>1</b> AND R_<b>2</b>) OR (NOT R_<b>1</b> AND NOT R_<b>2</b>)), whereas they originally were GATE_ONE). Exploitation unit <b>172</b> handles this condition by first building the binary decision diagram <b>170</b> B_i for the constraint (B) <b>160</b>, then extracting the dead-end constraints (B) <b>160</b> from B_i by setting the function B′_i=BDD_EXIST(B_i, RANDOM gate variables).</p>
<p id="p-0111" num="0110">If the resulting B′_i is not BDD_ONE, then B′_i contains a list of all dead-end states. Exploitation unit <b>172</b> next forms B″_i in a series of steps:</p>
<p id="p-0112" num="0111">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry> B″_i = BDD_ZERO.</entry>
</row>
<row>
<entry> For each cube of B′_i // a “cube” is a set of min-terms contained</entry>
</row>
<row>
<entry>in B′_i such that every binary decision diagrams 170 variable in the</entry>
</row>
<row>
<entry>support of the cube evaluates to a single value</entry>
</row>
<row>
<entry> B″_i=BDD_OR(B″_i, BDD_COFACTOR</entry>
</row>
<row>
<entry>(B_i, cube)). //BDD_COFACTOR effectively performs BDD_AND</entry>
</row>
<row>
<entry>over B_i and cube, then performs BDD_EXIST over variables</entry>
</row>
<row>
<entry>in the support of cude on the result</entry>
</row>
<row>
<entry>Exploitation unit 172 finally conjuncts the resulting B″_i onto</entry>
</row>
<row>
<entry>BDD_TOP, instead of conjuncting B_i onto BDD_TOP.</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0113" num="0112">An invariant (N) <b>164</b> gate is similar to a constraint (B) <b>160</b> gate in that it will always be evaluated to a logical ‘1’ by the verification environment <b>124</b>. Unlike constraints (B) <b>160</b>, which are generally “artificial” in the sense that verification environment <b>124</b> may evaluate that gate to a logical ‘0’ if not labeled as a constraint (B) <b>160</b>, an invariant (N) <b>164</b> gate will always evaluate to a ‘1’ by the structure of the problem, even if not labeled as an invariant (N) <b>164</b>. This difference allows a greater degree of flexibility and reduction potential, thus invariants (N) <b>164</b> may be treated differently from constraints (B) <b>160</b>.</p>
<p id="p-0114" num="0113">Exploitation unit <b>172</b> first treats invariant (N) <b>164</b> gates in a manner similar to constraint (B) <b>160</b> gates for obtaining the set of cut gates (U) <b>132</b>. Exploitation unit <b>172</b> labels invariant (N) <b>164</b> gates as sinks, placing them on the fanout-side of the cut at cutpoints <b>140</b> (or on the cut at cutpoints <b>140</b>). Exploitation unit <b>172</b> may add any invariant (N) <b>164</b> gates which are combinationally driven by RANDOM gates as cut gates (U) <b>132</b>, without regard to whether the min-cut solution includes them. However, instead of conjuncting to BDD_TOP the binary decision diagrams <b>170</b> representing the function of the invariant (N) <b>164</b> gate, exploitation unit <b>172</b> uses the inverse of the binary decision diagram <b>170</b> for the invariant (N) <b>164</b> gate as a “don't care” against which exploitation unit <b>172</b> may simplify BDD_TOP. Because any valuation in the inverse of the invariant (N) <b>164</b> binary decision diagrams <b>170</b> cannot be evaluated by the verification environment <b>124</b>, the exploitation unit <b>172</b> may freely add or remove any such valuation from BDD_TOP. Note that the dead-end states B′_i of constraints as discussed above may also be used as “don't cares” because re-application of B″_i as a constraint will disallow such conditions from being evaluated during verification of the abstracted design.</p>
<p id="p-0115" num="0114">To additionally preserve the set of invariant (N) <b>164</b> valuations to registers that will never occur (for later methods to exploit), exploitation unit <b>172</b> synthesizes invariant (N) <b>164</b> binary decision diagrams <b>170</b> using the procedure given for the constraint (B) <b>160</b> binary decision diagrams <b>170</b> above. Note that with constraints (B) <b>160</b>, exploitation unit <b>172</b> translates simplified constraints (B) <b>160</b> rather than risk violating verification semantics through the abstraction. In contrast, invariants (N) <b>164</b> are “redundant”. Their synthesis is optional, and their inclusion can be selected by size of the replacement cone or any variety of other metrics.</p>
<p id="p-0116" num="0115">Turning now to <figref idref="DRAWINGS">FIG. 4</figref>, a high-level logical flowchart of a process for preservation of constraints during sequential reparameterization in accordance with a preferred embodiment of the present invention is depicted. The process starts at step <b>400</b> and then proceeds to step <b>402</b>, which depicts verification environment <b>124</b> receiving initial design (D) netlist <b>120</b>, including targets (T) <b>134</b>, state elements (R) <b>136</b>, primary inputs (I) <b>138</b>, and constraints (B) <b>160</b>. The process next moves to step <b>404</b>. At step <b>404</b>, selection unit <b>156</b> identifies cut points <b>140</b> for a cut (C, C′) of initial design (D) netlist <b>120</b> where (C′) and cut gates (U) <b>132</b> are supersets of targets (T) <b>134</b> and constraints (B) <b>160</b>, letting cut gates (U) <b>132</b> represent the cut gates sourcing edges from (C) to (C′).</p>
<p id="p-0117" num="0116">The process then proceeds to step <b>406</b>, which depicts replacement unit <b>158</b> computing the relation (S) <b>142</b> of values producible to (I, R, U) by existentially quantifying primary inputs (I) <b>138</b> from relation (S) <b>142</b>, resulting in a relation (S) <b>142</b> from state elements (R) <b>136</b> to cut gates (U) <b>132</b>. The process next moves to step <b>408</b>. At step <b>408</b>, replacement unit <b>158</b> constrains relation (S) <b>142</b> to force constraint (B) <b>160</b> gates in cut gates (U) <b>132</b>, hereafter referred to as constraint gates in cut gates (BU) <b>180</b>, to evaluate to one. The process then proceeds to step <b>410</b>, which depicts replacement unit <b>158</b> evaluating set (B′) <b>182</b> for dead-end states. For each constraint (B) <b>160</b> gate in constraint gates in cut gates (BU) <b>180</b>, replacement unit <b>158</b> computes a constraint b′ in constraint gates in cut gates (BU) <b>180</b> equal to the value of a function existentially_quantify_inputs(b). If b′ is not tautologically <b>1</b>, then b′ represents a dead-end state of the applicable constraint (B) <b>160</b> gate.</p>
<p id="p-0118" num="0117">The process next proceeds to step <b>412</b>. At step <b>412</b>, replacement unit <b>158</b> calculates the inverse of set (B′) <b>182</b> as ‘don’t cares' to simplify relation (S) <b>142</b>. The process then moves to step <b>414</b>, which depicts replacement unit <b>158</b> synthesizing relation (S) <b>142</b>, forming gate set (C″) <b>146</b>. The process then proceeds to step <b>416</b>. At step <b>416</b>, replacement unit <b>158</b> synthesizes each of cut gates (BU) <b>180</b>, forming set B′ <b>182</b>.</p>
<p id="p-0119" num="0118">The process next proceeds to step <b>418</b>, which depicts replacement unit <b>158</b> forming abstracted design (D′) <b>144</b> equal to (C″, C′) with constraints (B) <b>160</b> from set (B′) <b>182</b> and set (C′) <b>176</b>. Gates (U′) <b>148</b> represent the gates in gate set (C″) <b>146</b> corresponding to cut gates (U) <b>132</b> of <b>404</b>. The process then proceeds to step <b>420</b>, which depicts verification environment <b>124</b> applying verification to abstracted design (D′) <b>144</b>.</p>
<p id="p-0120" num="0119">Next, the process moves to step <b>422</b>. At step <b>422</b>, verification environment <b>124</b> determines whether an abstracted trace (P′) <b>152</b> hitting targets (T) <b>134</b> has been obtained. If verification environment <b>124</b> determines that no such abstracted trace is obtained hitting a target (T) <b>134</b>, then the process next moves to step <b>430</b>, which depicts verification environment <b>124</b> propagating target unhittable results to initial design (D) netlist <b>120</b> and reporting results to output table <b>122</b>. The process then ends at step <b>432</b>.</p>
<p id="p-0121" num="0120">If verification environment <b>124</b> determines that abstracted trace (P′) <b>152</b> is obtained which hit a target (T) <b>134</b>, then the process next moves to step <b>424</b>. At step <b>424</b>, verification environment <b>124</b> uses simulation to populate trace values to corresponding gates (U′) for necessary length (K) to hit targets (T) <b>134</b> in abstracted design (D′) <b>144</b> and defines the resulting abstracted trace (P′) <b>152</b>. The process next moves to step <b>426</b>, which depicts translation unit <b>168</b> casting a k-step satisfiability check to obtain a trace (P″) <b>150</b> over (C), witnessing the same sequence of valuations to cut gates (U) <b>132</b> seen at corresponding gates (U′) <b>148</b> in abstracted trace (P′) <b>152</b>. The process next moves to step <b>428</b>. At step <b>428</b>, translation unit <b>168</b> concatenates values to (C) from trace (P″) with values to (C) from abstracted trace (P′) <b>152</b> to form unabstracted trace (P) <b>154</b>, demonstrating a hit of the target in initial design (D) netlist <b>120</b>. The process then ends at step <b>432</b>.</p>
<p id="p-0122" num="0121">Bias unit <b>174</b> heuristically preserves the “biases” of RANDOM gates, useful if parametric reduction toolkit <b>166</b> for reduction is deployed prior to performing random explicit-state evaluation of initial design (D) netlist <b>120</b> (e.g., using verification environment <b>124</b> to perform random simulation/emulation or semi-formal verification). It is frequently important to specify specific biases for RANDOM gates which dictate the probability with which they will evaluate to a ‘1’. For example, a FLUSH type of signal may need to be toggled occasionally to expose certain design flaws, but an assertion of such a signal to ‘1’ may bring initial design (D) netlist <b>120</b> back to its reset state. As a result, users may desire to and verification environment <b>124</b> will allow them to make such an assertion fairly uncommon. However, the majority of RANDOM gates may be freely toggled without concern for their bias.</p>
<p id="p-0123" num="0122">Selection of RANDOM gates with biases requiring preservation by bias unit <b>174</b> may be done in several ways. For example, bias unit <b>174</b> can include any RANDOM gates whose biases are within a specified set of ranges. Bias unit <b>174</b> can also preserve a user-specified subset; etc. Bias unit <b>174</b> preserves the bias of specified nodes in several steps. Bias unit <b>174</b> treats RANDOM gates to be preserved in a manner similar to the treatment of registers by parametric reduction toolkit <b>166</b>. Selection unit <b>156</b> does not include such RANDOM gates to be preserved as sources in the min-cut selection process, preventing the min-cut method from attempting to eliminate them. Selection unit <b>156</b> naturally will select cut gates (U) <b>132</b> in a manner calculated to attempt to eliminate the remainder of the RANDOM gates, avoiding any suboptimal min-cut choices (e.g., yielding a cut which includes 3 RANDOM gates not to be preserved plus one which is to be preserved, vs. another available cut including 3 RANDOM gates not to be preserved).</p>
<p id="p-0124" num="0123">Bias unit <b>174</b> defines the “nonquantifiable variables” in the binary decision diagram <b>170</b>-based methods described above in this invention to include not only the register variables, but also the RANDOM gate variables whose biases are to be preserved. Bias unit <b>174</b> heuristically attains maximal reductions in RANDOM gates through the abstraction, while preserving the influence of those whose biases need to be fine-tuned.</p>
<p id="p-0125" num="0124">With reference now to <figref idref="DRAWINGS">FIG. 7</figref>, a high-level logical flowchart of a process for performing heuristic preservation of critical inputs during sequential reparameterization in accordance with a preferred embodiment of the present invention is illustrated. The process starts at step <b>700</b> and then moves to step <b>702</b>, which depicts verification environment <b>124</b> receiving initial design (D) netlist <b>120</b>, including targets (T) <b>134</b>, state elements (R) <b>136</b>, primary inputs (I) <b>138</b> which can be eliminated, and primary inputs (I′) which cannot be eliminated. The process next moves to step <b>704</b>. At step <b>704</b>, selection unit <b>156</b> identifies cut points <b>140</b> for a cut (C, C′) of initial design (D) netlist <b>120</b> where (C′) and cut gates (U) <b>132</b> are supersets of targets (T) <b>134</b>. Gates (U) <b>132</b> represent the cut gates sourcing edges from (C) to (C′).</p>
<p id="p-0126" num="0125">The process then proceeds to step <b>706</b>, which depicts replacement unit <b>158</b> computing the relation (S) <b>142</b> of values producible to (I, I′, R, U), then existentially quantifying primary inputs (I) <b>138</b> from relation (S) <b>142</b>, resulting in a relation (S) <b>142</b> from state elements (R) <b>136</b> and nonquantifiable primary inputs (I′) <b>138</b> to U. The process next moves to step <b>708</b>. At step <b>708</b>, replacement unit <b>158</b> synthesizes relation (S) <b>142</b>, forming gate set (C″) <b>146</b>. The process then proceeds to step <b>710</b> which depicts replacement unit <b>158</b> forming abstracted design (D′) <b>144</b> equal to (C″, C′) and letting corresponding gates (U′) <b>148</b> represent the gates in gate set (C″) <b>146</b> corresponding to cut gates (U) <b>132</b> in constraints (B) <b>160</b>. The process then proceeds to step <b>712</b>, which depicts verification environment <b>124</b> applying verification to abstracted design (D′) <b>144</b>.</p>
<p id="p-0127" num="0126">Next, the process moves to step <b>714</b>. At step <b>714</b>, verification environment <b>124</b> determines whether an abstracted trace (p′) <b>154</b> is obtained which hits target (T) <b>134</b>. If verification environment <b>124</b> determines that such a trace has been obtained, then the process next moves to step <b>724</b>, which depicts verification environment <b>124</b> propagating target unhittable results to initial design (D) netlist <b>120</b>. The process then ends at step <b>722</b>.</p>
<p id="p-0128" num="0127">Returning to step <b>714</b>, if verification environment <b>124</b> determines that abstracted trace (p′) <b>154</b> is obtained which hits target (T) <b>134</b>, then the process next moves to step <b>716</b>, which illustrates verification environment <b>124</b> copying valuations to set C′ <b>176</b> into new trace (p) <b>178</b>. The process then proceeds to step <b>718</b>. At step <b>718</b>, verification environment <b>124</b> propagates new trace (p) <b>178</b> over initial design (D) netlist <b>120</b> to the user through output table <b>122</b>. The process then ends at step <b>722</b>.</p>
<p id="p-0129" num="0128">Turning now to <figref idref="DRAWINGS">FIG. 2</figref>, a high-level logical flowchart of a process for parametric reduction of sequential designs is depicted. The process starts at step <b>200</b> and then proceeds to step <b>202</b>, which depicts verification environment <b>124</b> receiving initial design (D) netlist <b>120</b>, including targets (T) <b>134</b>, state elements (R) <b>136</b> and primary inputs (I) <b>138</b>. The process next moves to step <b>204</b>. At step <b>204</b>, selection unit <b>156</b> identifies cut points <b>140</b> for a cut (C, C′) of initial design (D) netlist <b>120</b> where (C′) is a superset of targets (T) <b>134</b>. Gates (U) <b>132</b> represent the cut gates sourcing edges from (C) to (C′). The process then proceeds to step <b>206</b>, which depicts replacement unit <b>158</b> computing the relation (S) <b>142</b> of values producible to (I, R, U). The process then moves to step <b>208</b>. At step <b>208</b>, replacement unit <b>158</b> synthesizes relation (S) <b>142</b>, forming gate set (C″) <b>146</b>. The process proceeds to step <b>210</b> which depicts replacement unit <b>158</b> forming abstracted design (D′) <b>144</b> equal to (C″, C′). Gates (U′) <b>148</b> represent the gates in gate set (C″) <b>146</b> corresponding to cut gates (U) <b>132</b> in constraints (B) <b>160</b>. The process then proceeds to step <b>212</b>, which depicts verification environment <b>124</b> applying verification to abstracted design (D′) <b>144</b>.</p>
<p id="p-0130" num="0129">Next, the process moves to step <b>214</b>. At step <b>214</b>, verification environment <b>124</b> determines whether trace (P′) <b>152</b> has been obtained which hits target (T) <b>134</b>. If verification environment <b>124</b> determines that no such trace has been obtained, then the process next moves to step <b>216</b>, which depicts verification environment <b>124</b> propagating target unhittable results to initial design (D) netlist <b>120</b>. The process then ends at step <b>218</b>.</p>
<p id="p-0131" num="0130">If verification environment <b>124</b> determines that abstracted trace (P′) <b>152</b> has been obtained which hits target (T) <b>134</b>, then the process next moves to step <b>220</b>. At step <b>220</b>, verification environment <b>124</b> uses simulation to populate trace values to corresponding gates (U′) for necessary length (K) to hit targets (T) <b>134</b> in (D′) in abstracted design (D′) <b>144</b> and defines the resulting abstracted trace (P′) <b>152</b>. The process next moves to step <b>222</b>, which depicts translation unit <b>168</b>, casting a case step satisfiability program to obtain a trace (P″) <b>150</b> over (C), witnessing the same sequence evaluations to cut gates (U) <b>132</b>, seen at corresponding gates (U′) <b>148</b> in abstracted trace (P′) <b>152</b>. The process next moves to step <b>224</b>. At step <b>224</b>, translation unit <b>168</b> concatenates values to (C′) and trace (P″) with values to (C) in abstracted trace (P′) <b>152</b> to form unabstracted trace (P) <b>154</b>, demonstrating hit of target in initial design (D) netlist <b>120</b>. The process then ends at step <b>218</b>.</p>
<p id="p-0132" num="0131">While the invention has been particularly shown as described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. It is also important to note that although the present invention has been described in the context of a fully functional computer system, those skilled in the art will appreciate that the mechanisms of the present invention are capable of being distributed as a program product in a variety of forms, and that the present invention applies equally regardless of the particular type of signal bearing media utilized to actually carry out the distribution. Examples of signal bearing media include, without limitation, recordable type media such as floppy disks or CD ROMs and transmission type media such as analog or digital communication links.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for preserving constraints in a digital design, said method comprising:
<claim-text>receiving an initial design including one or more targets, one or more primary inputs, one or more constraints and one or more state elements;</claim-text>
<claim-text>identifying a cut of said initial design including one or more cut gates;</claim-text>
<claim-text>computing a relation of one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements;</claim-text>
<claim-text>constraining said relation to force one or more constraint gates representing said one or more constraints to evaluate to a forced valuation;</claim-text>
<claim-text>identifying one or more dead-end states of said constraints;</claim-text>
<claim-text>applying the inverse of said dead-end states as don't cares to simplify said relation;</claim-text>
<claim-text>synthesizing said simplified relation to form a first gate set;</claim-text>
<claim-text>forming an abstracted design from said first gate set; and</claim-text>
<claim-text>performing verification on said abstracted design to generate verification results.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>synthesizing said dead-end states to form a second gate set;</claim-text>
<claim-text>determining whether said step of performing verification hit one or more targets; and</claim-text>
<claim-text>in response to determining that said step of performing verification did not hit one or more targets, propagating one or more target unhittable results to said initial design.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>using simulation to populate one or more trace values to create a resulting abstracted trace;</claim-text>
<claim-text>casting a satisfiability problem to obtain a trace over said constraints; and</claim-text>
<claim-text>concatenating one or more values to create a result showing a hit target in said initial design.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein:
<claim-text>said step of using simulation to populate one or more trace values to create a resulting abstracted trace further comprises using simulation to populate one or more trace values to cut gates to create a resulting abstracted trace.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said step of identifying said cut of said initial design including said one or more cut gates further comprises:
<claim-text>requiring that said cut gates and said first gate set are a superset of said constraints and said targets.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said step of computing said relation of said one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements further comprises:
<claim-text>existentially quantifying said primary inputs from said relation to result in a relation from said state elements to said cut gates.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said step of computing said relation of said one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements further comprises:
<claim-text>constraining said relation to force said one or more constraint gates representing said one or more constraints to evaluate to one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A system for preserving constraints in a digital design, said system comprising:
<claim-text>means for receiving an initial design including one or more targets, one or more primary inputs, one or more constraints and one or more state elements;</claim-text>
<claim-text>means for identifying a cut of said initial design including one or more cut gates;</claim-text>
<claim-text>means for computing a relation of one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements;</claim-text>
<claim-text>means for constraining said relation to force one or more constraint gates representing said one or more constraints to evaluate to a forced valuation;</claim-text>
<claim-text>means for identifying one or more dead-end states of said constraints;</claim-text>
<claim-text>means for applying the inverse of said dead-end states as don't cares to simplify said relation;</claim-text>
<claim-text>means for synthesizing said simplified relation to form a first gate set;</claim-text>
<claim-text>means for forming an abstracted design from said first gate set; and</claim-text>
<claim-text>means for performing verification on said abstracted design to generate verification results.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising:
<claim-text>means for synthesizing said dead-end states to form a second gate set;</claim-text>
<claim-text>means for determining whether said means for performing verification hit one or more targets; and</claim-text>
<claim-text>means for, in response to determining that said means for performing verification did not hit one or more targets, propagating one or more target unhittable results to said initial design.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:
<claim-text>means for using simulation to populate one or more trace values to create a resulting abstracted trace;</claim-text>
<claim-text>means for casting a satisfiability problem to obtain a trace over said constraints; and</claim-text>
<claim-text>means for concatenating one or more values to create a result showing a hit target in said initial design.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein:
<claim-text>said means for using simulation to populate one or more trace values to create a resulting abstracted trace further comprises:</claim-text>
<claim-text>means for using simulation to populate one or more trace values to cut gates to create a resulting abstracted trace.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said means for identifying said cut of said initial design including said one or more cut gates further comprises:
<claim-text>means for requiring that said cut gates and said first gate set are a superset of said constraints and said targets.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said means for computing said relation of said one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements further comprises:
<claim-text>means for existentially quantifying said primary inputs from said relation to result in a relation from said state elements to said cut gates.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said means for computing said relation of said one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements further comprises:
<claim-text>means for constraining said relation to force said one or more constraint gates representing said one or more constraints to evaluate to one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A computer program product in a computer-readable medium for preserving constraints in a digital design, said computer program product in a computer-readable medium comprising:
<claim-text>a computer-readable medium;</claim-text>
<claim-text>instructions on the computer-readable medium for receiving an initial design including one or more targets, one or more primary inputs, one or more constraints and one or more state elements;</claim-text>
<claim-text>instructions on the computer-readable medium for identifying a cut of said initial design including one or more cut gates;</claim-text>
<claim-text>instructions on the computer-readable medium for computing a relation of one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements;</claim-text>
<claim-text>instructions on the computer-readable medium for constraining said relation to force one or more constraint gates representing said one or more constraints to evaluate to a forced valuation;</claim-text>
<claim-text>instructions on the computer-readable medium for identifying one or more dead-end states of said constraints;</claim-text>
<claim-text>instructions on the computer-readable medium for applying the inverse of said dead-end states as don't cares to simplify said relation;</claim-text>
<claim-text>instructions on the computer-readable medium for synthesizing said simplified relation to form a first gate set;</claim-text>
<claim-text>instructions on the computer-readable medium for forming an abstracted design from said first gate set; and</claim-text>
<claim-text>instructions on the computer-readable medium for performing verification on said abstracted design to generate verification results.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer program product in a computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising:
<claim-text>instructions on the computer-readable medium for synthesizing said dead-end states to form a second gate set;</claim-text>
<claim-text>instructions on the computer-readable medium for determining whether said instructions on the computer-readable medium for performing verification hit one or more targets; and</claim-text>
<claim-text>instructions on the computer-readable medium for, in response to determining that said instructions on the computer-readable medium for performing verification did not hit one or more targets, propagating one or more target unhittable results to said initial design.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer program product in a computer-readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising:
<claim-text>instructions on the computer-readable medium for using simulation to populate one or more trace values to create a resulting abstracted trace;</claim-text>
<claim-text>instructions on the computer-readable medium for casting a satisfiability problem to obtain a trace over said constraints; and</claim-text>
<claim-text>instructions on the computer-readable medium for concatenating one or more values to create a result showing a hit target in said initial design.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer program product in a computer-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein:
<claim-text>said instructions on the computer-readable medium for using simulation to populate one or more trace values to create a resulting abstracted trace further comprise instructions on the computer-readable medium for using simulation to populate one or more trace values to cut gates to create a resulting abstracted trace.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer program product in a computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein said instructions on the computer-readable medium for identifying said cut of said initial design including said one or more cut gates further comprise:
<claim-text>instructions on the computer-readable medium for requiring that said cut gates and said first gate set are a superset of said constraints and said targets.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer program product in a computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein said instructions on the computer-readable medium for computing said relation of said one or more values producible to said one or more cut gates in terms of said one or more primary inputs and said one or more state elements further comprise:
<claim-text>instructions on the computer-readable medium for existentially quantifying said primary inputs from said relation to result in a relation from said state elements to said cut gates.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
