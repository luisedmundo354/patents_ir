<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299218-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299218</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10195494</doc-number>
<date>20020716</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>CA</country>
<doc-number>2365433</doc-number>
<date>20011219</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>524</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707  2</main-classification>
<further-classification>707  4</further-classification>
<further-classification>707 10</further-classification>
<further-classification>707100</further-classification>
<further-classification>707102</further-classification>
</classification-national>
<invention-title id="d0e71">System and method for multiple-threaded access to a database</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6289334</doc-number>
<kind>B1</kind>
<name>Reiner et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6804663</doc-number>
<kind>B1</kind>
<name>Delo</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6834279</doc-number>
<kind>B1</kind>
<name>Chiang</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2002/0143751</doc-number>
<kind>A1</kind>
<name>Chow et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00005">
<othercit>Microsoft Press, Microsoft Press Computer Dictionary Third Edition, Microsoft Press, copyright 1997 by Microsoft Corporation, pp. 339 and 404.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
</references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707  2</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  4</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707 10</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707102</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>9</number-of-drawing-sheets>
<number-of-figures>9</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030112742</doc-number>
<kind>A1</kind>
<date>20030619</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Piper</last-name>
<first-name>Richard Matthew</first-name>
<address>
<city>Pakenham</city>
<country>CA</country>
</address>
</addressbook>
<nationality>
<country>CA</country>
</nationality>
<residence>
<country>CA</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Ellis</last-name>
<first-name>Stephen Edgar</first-name>
<address>
<city>Ottawa</city>
<country>CA</country>
</address>
</addressbook>
<nationality>
<country>CA</country>
</nationality>
<residence>
<country>CA</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Marks &amp; Clerk</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Mitchell</last-name>
<first-name>Richard J.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Alcatel Canada Inc.</orgname>
<role>03</role>
<address>
<city>Kanata</city>
<country>CA</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Pham</last-name>
<first-name>Hung</first-name>
<department>2168</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The invention provides a system and method of retrieving data associated with a file from a database by a field name into local memory. It comprises calculating an address reference for a storage location in the local memory for the data; fetching the data from the database; and utilizing the address reference to map the data to an address in the local memory. The address reference is an offset value from a base address of the storage location. Several files may be accessed using a cross reference table containing pointers to field tables. Entries in the cross reference table point to a field table. Each field table is a list of fields associated with the file. Each entry in the field table is a calculated offset value providing an address offset of a particular field from the base address of the file.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="215.48mm" wi="148.51mm" file="US07299218-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="206.42mm" wi="168.83mm" file="US07299218-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="219.37mm" wi="161.37mm" file="US07299218-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="213.95mm" wi="161.37mm" file="US07299218-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="222.00mm" wi="154.26mm" file="US07299218-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="219.03mm" wi="143.26mm" file="US07299218-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="228.01mm" wi="166.20mm" file="US07299218-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="215.82mm" wi="165.44mm" file="US07299218-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="207.94mm" wi="152.57mm" file="US07299218-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="150.11mm" wi="152.40mm" file="US07299218-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The field of the invention relates a system and method for accessing a database, in particular, network administrator requiring many individual accesses to a database relating to a communication network.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">In a communication network, a network administrator is a node associated with the network that is responsible for monitoring and configuring the operation of the network by instructing various nodes in the network to perform and to report tasks and status. Accordingly, the network administrator may have access to a database of information relating to all nodes in the network. As the number of nodes becomes large, for example, to 500,000, the amount of data accesses to the database by the administrator becomes large, requiring significant time and resources to process.</p>
<p id="p-0004" num="0003">Typically, for a network administrator, a relational database management system (RDBMS) is used to process queries by the administrator. The RDBMS comprises a computer, data storage devices, disk drives and database management software, and uses relational techniques for storing and retrieving information. The RDBMS accepts commands to store, retrieve, and delete data. A well-known set of commands is based on the Structured Query Language (SQL). The constructs of SQL allow a RDBMS to provide a response to a particular query with a particular set of data for a database. SQL however does not specify the actual method to find the requested information. The method in which the query is processed affects the overall time for retrieving the data. Efficient data retrievals minimize computer and disk access times, and therefore, optimize the computational cost of doing the query.</p>
<p id="p-0005" num="0004">Prior art systems access information from the database and copy retrieved information directly into a global shared buffer. Accesses to the global shared buffer populate a target data structure in the administrator. The population of the target data structure is performed at start-up of the administrator. Each access to the database is done sequentially, which collectively may require several hours to complete for a large network.</p>
<p id="p-0006" num="0005">Accordingly, there is a need for a dynamic and efficient method and system for retrieving data from a database after queries are entered.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0007" num="0006">In a first aspect, the invention provides a method of retrieving data associated with a file from a database by a field name into local memory. The method comprises obtaining an address reference for a location of the field name in the file, fetching the data from the database using the field name, and utilizing at least the address reference to map the data to an address in the local memory.</p>
<p id="p-0008" num="0007">The method may have the address reference utilizing an offset value of the location of the field name in the file from a beginning of the file. Further, the step of utilizing at least the address reference to map the data may further utilize a base address of the local memory.</p>
<p id="p-0009" num="0008">The method may have the data associated with a first SQL structure and the address reference associated with a second SQL structure linked to the first SQL structure.</p>
<p id="p-0010" num="0009">The method may have the file comprising at least one field, the field comprising at least the field name. Further the address reference may be stored in a field table, the field table comprising a list of the field(s).</p>
<p id="p-0011" num="0010">The method may have the database comprising the file and another file. Further, the field table may be accessed from a file cross reference table with the file cross reference table comprising an entry referring to the field table and with the entry allowing access to the field table.</p>
<p id="p-0012" num="0011">The method may allow data from another file to be retrieved and mapped into a second local memory independently of retrieval of the data from the file.</p>
<p id="p-0013" num="0012">The method may have the file comprising data on a node in a communication network, with the database containing another file relating to elements in the communication network and with the local memory being associated with a processor for a network administrator for the communication network.</p>
<p id="p-0014" num="0013">In a second aspect, a processing module for a query operating on a file in a database for a network administrator associated with a communication network and the database is provided. The processing module comprises local memory for storing results of the query and an address translation module. The translation module is adapted to retrieve an address reference for a location in the file of a target field associated with the query and is adapted to map the results of the query to an address in the local memory utilizing at least the address reference.</p>
<p id="p-0015" num="0014">The processing module may have the address translation module utilizing the address reference and a base address of the local memory to map the results of the query to the address in the local memory.</p>
<p id="p-0016" num="0015">The processing module may have the address translation module utilizing a file cross reference table. Further, the file cross reference table may comprise an entry referring to file, with the entry allowing access to a field table. Further, the field table may comprise a list of fields, with one entry in the list being associated with the target field. Further, the field table comprises an entry relating the target field to the address reference.</p>
<p id="p-0017" num="0016">The processing module may allow multiple queries to be processed on multiple threads.</p>
<p id="p-0018" num="0017">In other aspects of the invention, various combinations and subsets of the aspects described above are provided.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0019" num="0018">The foregoing and other aspects of the invention will become more apparent from the following description of specific embodiments thereof and the accompanying drawings which illustrate, by way of example only, the principles of the invention. In the drawings, where like elements feature like reference numerals (and wherein individual elements bear unique alphabetical suffixes):</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 1</figref> is the block diagram of a communication network, a database containing configuration information about nodes in the communication network and a network administrator associated with the database and the communication network, the network administrator utilizing an embodiment of the invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of an operator of the network administrator accessing tables stored in the database utilizing the embodiment of <figref idref="DRAWINGS">FIG. 1</figref>;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of SQL data structures associated with the database utilizing the embodiment of <figref idref="DRAWINGS">FIG. 1</figref>;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 4A</figref> is a block diagram of a mapping structure utilized in the embodiment in the network administrator of <figref idref="DRAWINGS">FIG. 3</figref>;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 4B</figref> is a block diagram of an example of the mapping structure associated with a SQL query executed in embodiment of <figref idref="DRAWINGS">FIG. 4A</figref>;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 4C</figref> is a block diagram of the mapping structure with a nesting structure utilized in the embodiment in the network administrator of <figref idref="DRAWINGS">FIG. 4A</figref>;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 4D</figref> is block diagram of the SQL data structure of <figref idref="DRAWINGS">FIG. 3</figref> with and a global SQL structure;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 4E</figref> is block diagram relating the SQL data structure of <figref idref="DRAWINGS">FIG. 3</figref> with the mapping structure of <figref idref="DRAWINGS">FIG. 4A</figref>; and</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of relationships between the data structures of <figref idref="DRAWINGS">FIGS. 4A</figref>, <b>4</b>B, <b>4</b>C and <b>4</b>D and a query entered by the operator of the network administrator for the embodiment of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0029" num="0028">The description which follows, and the embodiments described therein, are provided by way of illustrating an example, or examples, of particular embodiments of principles of the present invention. These examples are provided for the purpose of explanation, and not limitation, of those principles and of the invention. In the description which follows like elements are marked throughout the specification and the drawings with the same respective reference numerals.</p>
<p id="p-0030" num="0029">Referring to <figref idref="DRAWINGS">FIG. 1</figref>, network <b>100</b> is shown. Network <b>100</b> comprises a plurality of nodes <b>102</b> which are interconnected via links <b>104</b>. Network <b>100</b> may be an ATM network or another network which provides data communication routing. Within node <b>102</b>, a plurality of cards <b>106</b> collectively provide the functionality for switch <b>104</b>. Examples of cards <b>106</b> include line cards, control cards and fabric switching cards. Within each card <b>106</b>, a plurality of electrical and mechanical circuit <b>108</b> are provided which effect the functionality for each card <b>106</b>. It will be appreciated that node <b>102</b> may also be referred to as a communication switch, a network element or a switching element.</p>
<p id="p-0031" num="0030">Associated with network <b>100</b> is network administrator <b>110</b>. An operator of network administrator <b>110</b> can enter commands into network administrator <b>110</b> causing various link and switching configurations to be effected into network <b>100</b>. Network administrator <b>110</b> comprises a computer and appropriate software to process information requests from an operator and from ATM network <b>100</b>. Network administrator <b>110</b> has access to information relating to network <b>100</b> via database <b>112</b>. Database <b>112</b> contains a plurality of datafiles <b>114</b>, each of which contains information relating to aspects of network <b>100</b>. The operator accesses network administrator via terminal <b>116</b>. Network administrator may also be referred to as a network station.</p>
<p id="p-0032" num="0031">As network administrator goes through its start-up routine, it must access database <b>112</b> to retrieve information contained in datafiles <b>114</b>. In order to reduce the time required to access all of the information in datafiles <b>114</b>, the embodiment utilizes a multi-threaded access scheme in network administrator <b>110</b> for database <b>112</b>. Multi-threaded schemes, as are known in the art, provide independent threads to be spawned. Therein, each thread independently accesses database <b>112</b>, stores information in a global storage location and then transfers the data to a local memory location. Typically, threads are grouped together and thread groups will operate on a separate CPU (not shown) within network administrator <b>110</b>. Each CPU in network administrator <b>110</b> may also have its local memory as RAM. In providing multiple threads, network administrator <b>110</b> must ensure that the data retrieved by each thread is valid. It will be appreciated that multiple threads may be accessing the same datafile <b>114</b> in database <b>112</b> and one thread may write to a location in the global storage location which may cause data inconsistencies if the write operation is performed before another thread is able to read the location and transfer the data to its local memory.</p>
<p id="p-0033" num="0032">Accordingly, the embodiment does not utilize a global storage location and instead utilizes local memory for a local target data structure for thread. Data is retrieved by each thread directly into its local data structure.</p>
<p id="p-0034" num="0033">Referring to <figref idref="DRAWINGS">FIG. 2</figref>, network administrator <b>110</b>, containing the embodiment, is shown accessing database <b>112</b>. Within network administrator <b>110</b>, application software <b>200</b> operates, allowing the operator to access database <b>112</b>. Database <b>112</b> contains a series of datafiles <b>114</b>. Each datafile <b>114</b> contains information on aspects of network <b>100</b>. For example, datafile <b>114</b>A in database <b>112</b> is a table of all nodes <b>102</b> in network <b>100</b>. For each node <b>102</b>, datafile <b>114</b>A includes its node identification, its associated major node, its associated minor node, its domain, its external frequency and its source type. Application <b>200</b> is associated with threads <b>202</b> which have been spawned to instantiate separate database accesses. Each of application <b>200</b> and threads <b>202</b> may operate a separate CPU <b>204</b> having local RAM <b>206</b> in network administrator <b>110</b>. It will be appreciated that application software <b>200</b> and threads <b>202</b> operate together to provide access to database <b>112</b>. Accordingly, unless otherwise noted, any descriptions regarding the functionality of application software <b>200</b>, implicitly include the functionality of threads <b>202</b>, which operate within the application software.</p>
<p id="p-0035" num="0034">In using network administrator <b>110</b>, operator may require certain information about a node <b>102</b> within network <b>100</b>. The information may be stored within one or more datafiles <b>114</b>. In requesting the information, operator (or application software <b>200</b>) would generate a query for information. The query is formatted by application <b>200</b>, and aspects of the query are effected to retrieve relevant information from datafiles <b>114</b> and store the results in local RAM <b>206</b>. Accordingly, if the operator causes query <b>208</b> to be issued, namely “Select Node_id, ext_freq from node”, application software <b>200</b> will generate a thread to process an access to database <b>112</b> and its datafiles <b>114</b> to complete the query. In processing query <b>208</b>, information from a datafile <b>114</b> is extracted in rows, one row at a time per access and one value from each column will be returned per access time. In datafile <b>114</b>A, the values for “Node_id” are taken from the row “1, 2, . . . N” from column <b>212</b> and the values for “ext_freq” are taken from the row “Z, P . . . W” from column <b>214</b>. Accordingly, for set <b>210</b>, at the first data fetch, the extracted values for “Node_id” is “1” and the extracted value for “ext_freq” is “Z”. Next, at the second data fetch, the extracted values for “Node_id” is “2” and the extracted value for “ext_freq” is “P”. The sequential fetching continues until the last data fetch, where the extracted values for “Node_id” is “N” and the extracted value for “ext_freq” is “W”. The results of set <b>210</b> are stored in local RAM <b>206</b> a single column at a time, relating to the calling thread <b>202</b>. Accordingly, for each thread <b>202</b>, the results of its set <b>210</b> are dynamically mapped into its local RAM <b>206</b>.</p>
<p id="p-0036" num="0035">Referring to <figref idref="DRAWINGS">FIG. 3</figref> and as shown above, in the embodiment, queries <b>208</b> are constructed in SQL, a known industry standard. In the embodiment, an Informix (trade-mark of IBM) database engine is utilized which follows SQL standards. Initiation of query <b>208</b> causes the generation of a “sqlda” structure <b>300</b> and a “sqlvar” structure <b>302</b> and application software <b>200</b> allocates memory for the sqlda structure <b>300</b> and for an array of sqlvar structures <b>302</b> within the sqlda structure <b>300</b>. The structures are stored in local RAM for a thread <b>202</b>. The sqlda structure <b>300</b> contains information pertaining to a single query <b>208</b>. The sqlda structure <b>300</b> permits use of queries involving unknown field returns and database field requests. Sqlda structure <b>300</b> has number field <b>304</b> containing the number of fields associated with the query, and link field <b>306</b> which identifies a link, i.e. pointer, to a sqlvar structure <b>302</b>. A sqlvar structure <b>302</b> contains information relating to a single database field. The sqlvar structure <b>302</b> essentially is an array of elements containing information about the fields in the “select” clause of query <b>208</b>. Each sqlvar structure <b>302</b> has an identity field <b>308</b>, identifying the field of from the datafile <b>114</b> and an address pointer field <b>310</b>, containing a calculated address pointer to an address for the field in datafile <b>114</b> associated with that sqlvar structure <b>302</b> being accessed by query <b>208</b>.</p>
<p id="p-0037" num="0036">To illustrate use of the sqlda structure <b>300</b> and sqlvar structure <b>302</b>, an example is provided for query <b>208</b>, “Select Node_id, ext_freq from node”, where it has been entered into terminal <b>116</b>. In processing query <b>208</b>, the Informix API parses query <b>208</b> and establishes two fields, “node_id” and “ext_freq” as the target fields for data from the appropriate datafile <b>114</b>A. the Informix API builds the appropriate sqlda and sqlvar structures <b>300</b>, <b>302</b>. The Informix API then fills number field <b>304</b> of sqlda structure with “2”, and link field <b>306</b> with “sqlvar[0]”. For query <b>208</b>, as there are two fields which have to be accessed, two sqlvar structures <b>302</b> are generated, namely sqlvar[0] structure <b>302</b>A and sqlvar[1] structure <b>302</b>B. The Informix API also fills identity field <b>308</b>A with “node_id” and field <b>308</b>B with “ext_freq”.</p>
<p id="p-0038" num="0037">During runtime, application software <b>200</b> fills address field <b>310</b>A with an appropriately calculated address pointer which is generated from a base address for the data structure associated with the result for the query in local RAM <b>206</b> for “node” (here “&amp;AA”), adjusted by an address offset value (here “A”) to point the pointer to the “node_id” field in the data structure in local RAM <b>206</b>. Similarly, application software <b>200</b> fills address field <b>310</b>B with a calculated address pointer to point to the address for “ext_freq” field in the data structure in local RAM <b>206</b> (here, base address is “AA” and offset is “B”). A mapping structure <b>314</b> is accessed by application software <b>200</b> to populate sqlvar structure <b>302</b> with address values for field <b>310</b>. The use of mapping structure <b>314</b> and the address values for field <b>310</b> provide a dynamic mechanism of mapping a row for a datafile <b>114</b> into a template which is stored in local RAM <b>206</b> and is used by a thread <b>202</b> for its queries <b>208</b>.</p>
<p id="p-0039" num="0038">Referring to <figref idref="DRAWINGS">FIG. 4A</figref>, detail on mapping structure <b>314</b> is shown. Mapping structure <b>314</b> allows mapping of fields (e.g. fields <b>212</b> and <b>214</b>) of a datafile <b>114</b> (e.g. datafile <b>114</b>A) to an address offset value which can be used by sqlvar structure <b>302</b>. Mapping structure <b>314</b> consists of two types of data structures: cross-reference (Xref) table <b>400</b> and field table <b>402</b>. Xref table <b>400</b> contains a table name list <b>404</b> and address list <b>406</b>. Each entry in table name list <b>404</b> is one of the datafiles <b>114</b> in database <b>112</b>. For example, in table name list <b>404</b>, the entry for “node” corresponds to the “node” datafile <b>114</b>A. For each entry in table name list <b>404</b>, the corresponding entry in address list <b>406</b> provides an address identifying a memory location for a field table <b>402</b> related to, but not pointing directly to, that particular datafile <b>114</b>. For example, for entry “node” in table list <b>404</b>, the corresponding entry in address list <b>406</b> is “&amp;node XrefTable”, which provides an address to field table <b>402</b> as indicated by arrow <b>408</b>. Note that “&amp;node XrefTable” is not an address to the actual location of the “node” datafile <b>114</b>A. In the embodiment, mapping structure <b>314</b> is stored in memory accessible by application software <b>200</b>. In processing a query, each thread <b>202</b> can access mapping structure <b>314</b>, but preferably, cannot write to it. The mapping structure may be stored in the global address space for the software application <b>200</b>.</p>
<p id="p-0040" num="0039">Each field table <b>402</b> contains a name list <b>410</b> of field names contained its associated datafile <b>114</b>. As shown in <figref idref="DRAWINGS">FIG. 4A</figref>, for that example, in field table <b>402</b>, name list <b>410</b> comprises “Node_id, Major_node, Minor_node . . . Current_source”, corresponding to the field names of datafile <b>114</b>A. For each entry in name list <b>410</b>, there is a corresponding entry in offset list <b>412</b> providing an address offset value for entries for field name from the base location address of datafile <b>114</b>. An offset value is calculated at runtime of application software <b>200</b> which is used to provide a relative offset value to identify the local location of an entry originally provided from datafile <b>114</b>, but stored in a local data structure in local RAM <b>206</b> for a given thread <b>202</b>. Entries in the local data structure may have only selected entries from the original datafile <b>114</b>. The entries in the local data structure are not necessarily located at sequential locations. The offset value is a byte-numbered offset value. Further detail on the calculation of offset values is provided below. The final entry in the field table <b>402</b> contains the size of the data structure associated with the database table. This value is calculated at the same time as values for offset field <b>412</b>.</p>
<p id="p-0041" num="0040">Other fields in field table <b>402</b> include: a) FieldType <b>414</b> which contains the size of the data type associated with the field when the results are transferred to the local storage <b>206</b>; the value is set at compilation of the application software <b>200</b>; b) FieldLength <b>416</b> which contains the number of elements of FieldType <b>414</b>; c) AlignmentCorrection <b>418</b>, which contains a shift value, in bytes, needed to align value for the field name <b>410</b> when the results are transferred to the local storage <b>206</b>.</p>
<p id="p-0042" num="0041">The end of field table <b>402</b> is indicated by non-existent, logical row <b>420</b>, where each field is populated with an end-of-field value (“−1” or “end of table”).</p>
<p id="p-0043" num="0042">The field table <b>402</b> structure allows expansion for multiple Xref tables <b>400</b> for the same database table. This allows data from a single database table to be returned in a variety of different formats including data structures used by application <b>200</b>.</p>
<p id="p-0044" num="0043">Referring back to calculation of offsets <b>412</b>, in order to provide an accurate mapping for location of results in local RAM <b>206</b>, offsets <b>412</b> in Xref table <b>402</b> must be initialized with the correct offset value for each field member. Offsets <b>412</b> are calculated at runtime of application software <b>200</b> to minimize issues with translation of data sizes when going through the operating system associated with application software <b>200</b>. The offset value for the first entry in offset field <b>412</b>, corresponding to the first entry in name field <b>410</b> is set to “0”, as there is no offset from the beginning of the data structure in local RAM <b>206</b>. However, the initial offset value may be changed if there is a need to align the address of the location identified by the resulting base address to the data structure in local RAM <b>206</b>, modified by the offset value for the first entry. (Further detail on alignment is provided below.) For each subsequent entry in Xref table <b>402</b>, each offset value is calculated as follows:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0044">1. The offset value of the preceding entry is retrieved into a calculated offset value.</li>
        <li id="ul0002-0002" num="0045">2. Any previous alignment correction value is subtracted from the calculated offset value. The adjustment provides a base address of the previous field address.</li>
        <li id="ul0002-0003" num="0046">3. The calculated offset value is added to the value of the (field type value x field length value) of the entry.</li>
        <li id="ul0002-0004" num="0047">4. It is determined whether any nested structures are associated with the entry. If the entry exists perform a compiler-based word alignment on the calculated offset value using the alignment value for this entry in field table <b>402</b> and proceed to step <b>6</b>. Further detail on nested structures is provided below.</li>
        <li id="ul0002-0005" num="0048">5. Perform a word alignment on the calculated offset value using the data type value for the entry retrieved from the field table <b>402</b>.</li>
        <li id="ul0002-0006" num="0049">6. Insert the calculated offset value for the entry in field table <b>402</b>.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0045" num="0050">Referring back to alignment correction, alignment correction of data is required when there is a mismatch of data types between the database tables and the application variables. A misalignment causes a pointer misalignment of the data pointer for the variable associated with the local data structure relating to the set <b>210</b> stored in local RAM <b>206</b>. If there is improper address alignment, the information from datafile <b>114</b> will be inserted into the wrong memory address of for the local data structure in local RAM <b>206</b>.</p>
<p id="p-0046" num="0051">Word alignment of a variable is performed by the compiler of application software <b>200</b> utilizing the data type of a variable. Generally, at compile time, an address of a storage element is aligned to an address where the address of a storage element divided by the size of the variable is an integer (i.e. (&amp;dataRecord) % (sizeof(dataRecord))=0).</p>
<p id="p-0047" num="0052">Further, in order to provide an accurate mapping of datafiles to local data structures in local RAM <b>206</b>, a header file <b>421</b> is provided which contains tables <b>421</b>A . . . N. Header file <b>421</b> is accessible application software <b>200</b>. Header file <b>421</b> is a list of all field names for all datafiles <b>114</b>. Each field name is cross-referenced with the data type of the target variable for the local data structure to be used in local RAM <b>206</b>. Header file <b>421</b> has the fields listed in the same order as they appear in the data structure used in the local RAM <b>206</b>. A mapping of any nested data structures contained in the data structure must also be provided.</p>
<p id="p-0048" num="0053">Referring to <figref idref="DRAWINGS">FIG. 4B</figref>, an example of the use of mapping structure <b>314</b> is provided. For query <b>208</b>, “Select Node_id, Ext_Freq from node”, the “From” and “Select” clauses are scanned by application software <b>200</b>. For the “from” clause, it is scanned to identify the source datafile <b>114</b>, i.e. “node”. This allows application software <b>200</b> to make an address link to the correct entry in Xref table <b>400</b>, as shown by arrow <b>422</b>, associating “node” in query <b>208</b> to the “node” entry in table name field <b>404</b> of Xref table <b>400</b>. The corresponding entry in address list <b>406</b> (“&amp;nodeXRefTable”) provides a base address for the location of the corresponding field table <b>402</b>, as shown by arrow <b>424</b>. For the “select” clause, once the application software identifies the appropriate field table <b>402</b> for query <b>208</b>, the attributes of the “select” clause can be linked to their associated fields in field table <b>402</b>. Accordingly, for the attribute “node_id”, it is associated with the first entry in field table <b>402</b>, as indicated by arrow <b>426</b>. For the attribute “ext_freq”, it is associated with the fifth entry in field table <b>402</b>, as indicated by arrow <b>428</b>. Further, for each of attributes “node_id” and “ext_freq”, its offset value in field <b>412</b> (“0” and “12”, respectively) provides the offset value of an address for that attribute from the base address of the location of set <b>210</b> in local RAM <b>206</b>.</p>
<p id="p-0049" num="0054">Associated with field table <b>402</b> is field order return array <b>430</b>. Field order return array <b>430</b> provides an indexed list of field order values in list <b>432</b> related to field table <b>402</b> for entries in field table <b>402</b> which are being accessed by query <b>208</b>. The list can quickly be traversed to retrieve an index location for an attribute in field table <b>402</b> which has been targetted in a query <b>208</b>. For example, for the first attribute of the “select” clause for query <b>208</b> (“Node_id”), the first entry in field order array <b>430</b> (“0”), identifies the index location for the attribute in the associated field name table <b>412</b>, as shown by arrow <b>434</b>. Similarly, second attribute of the “select” clause (“ext_freq”) is associated with the second entry in field order array <b>430</b> (“4”), identifying the index location for the attribute in the associated field name table <b>412</b> (index value “4”), as shown by arrow <b>436</b>. The field order return array <b>430</b> may also be used for multiple queries that only differ by qualification or order clauses. To reuse the field order return table <b>430</b>, it is necessary that the field order for a subsequent query is identical to the previous query.</p>
<p id="p-0050" num="0055">Referring to <figref idref="DRAWINGS">FIG. 4C</figref> and again to nested structures, the embodiment provides a nesting structure to allow nesting of substructures with field table <b>402</b>. Nested structure alignment boundary table <b>437</b> provides a temporary mapping of data structures in the local RAM <b>206</b>. This allows nested structure alignment within local RAM <b>206</b> to be calculated ensuring correct mapping of a field name in datafile <b>114</b> to its namesake in data structure in local RAM <b>206</b>. Boundary table <b>330</b> lists the field name of datafile <b>114</b> that is associated with the first variable in any nested data structure in local RAM <b>206</b> and lists the data size to which the nested data structure must word align. Boundary table <b>437</b> is used to properly calculate the offset value for the field Xref tables.</p>
<p id="p-0051" num="0056">It will be appreciated that mapping structure <b>314</b> may be used in other embodiments which do not use SQL constructs, let alone Informix SQL constructs. Mapping structure <b>314</b> provides data-centric data mapping and data format conversion of data in datafiles <b>114</b> in database <b>112</b> to local structures in local RAM <b>206</b>. In the construct of the embodiment, as results of query <b>208</b> are retrieved from datafile <b>114</b> in database <b>112</b>, they can be stored at dynamic locations in local RAM <b>206</b>. For example, for query <b>208</b>, the first attribute (“node_id”) is retrieved from datafile <b>114</b> from database <b>112</b> into the memory block allocated to store the results in local RAM <b>206</b>. The information retrieved from datafile <b>114</b> for “node_id” will be stored at the location within a buffer space specified by the field table <b>402</b> offset value for “node_id”. This value is retrieved using the table value in row <b>432</b> in Field Return Order Array table <b>430</b> at index 0 as an index into the fields of field table <b>402</b>. This will produce the offset value of “0” for “node_id” and “12” for “ext_freq”. Accordingly, from a single call to fetch values from database <b>112</b> for “node_id” and “ext_freq”, the results are stored in the memory block allocated in local RAM <b>206</b> at 0 bytes and 12 bytes from the beginning of the memory block.</p>
<p id="p-0052" num="0057">In order to provide a standarized interface for mapping structure <b>314</b>, aspects of the Informix API are used to access the mapping structure <b>314</b>. In particular, to improve the efficiency of the embodiment, data retrieved from a datafile <b>114</b> is directly associated with the target variable in the data structure in the local RAM <b>206</b> that uses the data. To achieve this, a data pointer for each of the Informix sqlvar structures within the sqlda structure are provided by the embodiment with the correct address of the target variable. Accordingly, the memory location in the local RAM <b>206</b> of the target variable is bound to a single database field.</p>
<p id="p-0053" num="0058">Referring to <figref idref="DRAWINGS">FIG. 4D</figref>, to bind a target variable to a field in a table in datafile <b>114</b>, the embodiment performs the following steps.</p>
<p id="p-0054" num="0059">First, from SQL query <b>208</b>, the name of datafile <b>114</b> is determined to identify the corresponding field table <b>402</b>. To accomplish this identification, the attribute in “from” clause (“node”) can be used in Xref table <b>400</b> or alternatively, field table index <b>438</b> which contains a list of all datafiles <b>114</b> and an index value to an entry in Xref table <b>400</b> for a particular database table. This step is shown by arrow <b>440</b>.</p>
<p id="p-0055" num="0060">Next, SQL query <b>208</b> is described into a sqlda structure <b>300</b>. The sqlda structure <b>300</b> will return an ordered structure array of sqlvar structures <b>302</b> which contain the field names <b>308</b> relating to the attributes selected from targeted fields in datafile <b>114</b>. This step is shown where sqlda structure <b>300</b> is created and its number field is populated with the value “2”, relating to the number of attributes in the “select” clause in query <b>208</b>. Also, sqlvar structures <b>302</b> are each created and their identity fields <b>308</b> are populated. This step is shown by arrows <b>442</b>.</p>
<p id="p-0056" num="0061">Next, for each sqlvar structure <b>302</b>, each identity field value <b>308</b> is used with field table index <b>438</b> to build a field order return array <b>430</b>. This step is shown by arrows <b>444</b>.</p>
<p id="p-0057" num="0062">Next, for each sqlvar structure <b>302</b>, the values for each address pointer field <b>310</b> are calculated. From field order array <b>430</b>, an index value into the field table <b>402</b> for the corresponding sqlvar structure <b>302</b> is determined. This index is used with field table <b>402</b> to retrieve an offset value (412) corresponding to the database table field. This offset is added to the value of the base address of the data structure in local RAM <b>206</b> to determine the absolute offset of the corresponding field name. This is shown by arrows <b>446</b>.</p>
<p id="p-0058" num="0063">Finally, each absolute offset is copied into a global sqlvar structure <b>448</b> to a data pointer corresponding to the index value of the entry in field order return array <b>430</b> for that sqlvar structure <b>302</b>. This is shown by arrows <b>450</b>.</p>
<p id="p-0059" num="0064">Once a section of local RAM <b>206</b> for a thread <b>202</b> is bound to an sqlda structure <b>300</b>, all subsequent calls to a datafile <b>114</b> will return the information into the same locations in local RAM <b>206</b>. The field order return array <b>430</b> may also be reused on multiple queries to the same datafile <b>114</b>. However, the queries must maintain the same field list and may only differ by the where and/or order by clause. Reuse of entries in field order return array <b>430</b> requires that the field order does not differ between queries.</p>
<p id="p-0060" num="0065">Referring to <figref idref="DRAWINGS">FIGS. 4A</figref>, <b>4</b>B and <b>4</b>D another use of field order return array <b>430</b> is described. Field field return order array <b>430</b> contains field table <b>402</b> indexes for data retrieved from a datafile <b>114</b>. Each field value is returned from the datafile <b>114</b> to a memory location in local RAM <b>206</b> specified in a data pointer generated from the data pointer field <b>310</b> of a sqlvar structure <b>302</b>. As each member of sqlvar structure <b>302</b> is associated with a specific field for datafile <b>114</b> and that field is named in name field <b>308</b> of the sqlvar structure <b>302</b>, it is possible to ascertain which variable for the data structure for local RAM <b>206</b> will be used for each data pointer <b>310</b> in sqlvar structure <b>302</b>, by matching the contents of name field <b>308</b> of the sqlvar structure <b>302</b> to the corresponding entry in field lookup table <b>438</b>.</p>
<p id="p-0061" num="0066">Referring to <figref idref="DRAWINGS">FIGS. 4B and 4E</figref>, a description of the associations amongst database <b>112</b>, datafiles <b>114</b>, application software <b>200</b>, common memory <b>452</b>, mapping structure <b>314</b>, Xref table <b>400</b>, field name table <b>402</b>, SQL query <b>208</b>, sqlda structure <b>300</b>, sqlvar structure <b>302</b> and local RAM <b>206</b> is shown.</p>
<p id="p-0062" num="0067">As noted earlier, database <b>112</b> contains datafiles <b>114</b>. To facilitate accesses to datafiles <b>114</b>, application software has mapping structure <b>314</b> stored in a application global memory <b>452</b>. Global memory is associated with the application software <b>200</b>. Entries in Xref table <b>400</b> are linked to addresses of field name table <b>402</b> in common memory <b>452</b>, as shown by arrows <b>454</b>.</p>
<p id="p-0063" num="0068">In processing query <b>208</b>, sqlda structure <b>300</b> and sqlvar structure <b>302</b> are built by the Informix API. Next, application software <b>200</b> calculates values in data pointer field <b>310</b> of sqlvar structure <b>302</b>. The values are calculated to be an offset from a base address in local RAM <b>206</b> for thread <b>202</b> utilizing mapping structure <b>314</b>. For sqlvar <b>302</b>A, the offset for node_id is 0; for sqlvar <b>302</b>B, the offset for ext_freq is 12. Accordingly, in local RAM <b>206</b>, beginning at the base address, each entry is related to a sqlvar structure <b>302</b> and its sqlvar structure contains the calculated offset for the entry from the base address of local RAM <b>206</b> into the appropriate field.</p>
<p id="p-0064" num="0069">Accordingly, in accessing data from datafile <b>114</b>, application software can determine what attributes are necessary for a query <b>208</b>, then retrieve it from datafile <b>114</b>, then directly copy the value into the mapped location for the attribute in local RAM <b>206</b>.</p>
<p id="p-0065" num="0070">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, further detail on application <b>200</b> and threads <b>202</b> in network administrator <b>110</b> is shown. Application <b>200</b> comprises an Abstraction Module <b>502</b>, a database Session Object Manager Module <b>504</b>, a Database Session Object Module <b>506</b> and a Database Interface Module <b>508</b>. The modules provide a series of hierarchical layers allowing abstraction of information and processing between modules. Aspects of each module are described in turn, beginning with Database Interface Module <b>508</b>. Database Interface Module <b>508</b> contains information and functions necessary to access a field in any supported datafile <b>114</b> in database <b>112</b>. In Database Interface Module <b>508</b>, application <b>200</b> can execute any single table query for database <b>112</b> (such as query <b>208</b>), returning any number of fields into the local RAM <b>206</b> associated with that table. The functionality of the embodiment relating to mapping structure <b>314</b> described above occurs in Database Interface Module <b>508</b>. In the embodiment, each module is a software module, written in C++.</p>
<p id="p-0066" num="0071">Database Session Object Module <b>506</b> abstracts administrative details, such as statement and cursor management, from the database access process. Persistent data is stored in this module. At this level a single connection can be made and broken, queries can be executed and records can be retrieved without any knowledge of connection names, statement ids or sqlda structures. The information and data structures required to perform these tasks are stored within the session object.</p>
<p id="p-0067" num="0072">For Database Session Object Module <b>506</b>, a database session class contains all of the information required to make a single database connection, prepare and execute a query and retrieve information from the database. Most of the information stored in the class is used to provide argument values for the Database Interface Module <b>508</b> to provide an abstract view of the Informix API.</p>
<p id="p-0068" num="0073">The database session does allow all aspects of the connection and query to be contained in a locally defined class in a local format. The following Table A outlines the steps required to perform a specific task in the Database Session Object Module <b>506</b> and the Database Interface Module <b>508</b>.</p>
<p id="p-0069" num="0074">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="70pt" align="left"/>
<colspec colname="3" colwidth="84pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE A</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Database Session</entry>
<entry/>
</row>
<row>
<entry/>
<entry>Object Module</entry>
<entry>Database Interface</entry>
</row>
<row>
<entry>Task to Perform</entry>
<entry>506</entry>
<entry>Module 508</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Connect to database</entry>
<entry>Make call to open</entry>
<entry>Generate and save Unique</entry>
</row>
<row>
<entry/>
<entry>session and check</entry>
<entry>connection Id.</entry>
</row>
<row>
<entry/>
<entry>return code.</entry>
<entry>Make call to connect and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>check return code.</entry>
</row>
<row>
<entry>Prepare a query</entry>
<entry>Make a call to set</entry>
<entry>Generate and save a</entry>
</row>
<row>
<entry>for data fetch</entry>
<entry>session query and</entry>
<entry>unique cursor Id</entry>
</row>
<row>
<entry/>
<entry>check return code.</entry>
<entry>Generate and save a</entry>
</row>
<row>
<entry/>
<entry/>
<entry>unique statement Id</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Make a call to open</entry>
</row>
<row>
<entry/>
<entry/>
<entry>database cursor and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>save sqlda struct*.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Make a call to get</entry>
</row>
<row>
<entry/>
<entry/>
<entry>database table name</entry>
</row>
<row>
<entry/>
<entry/>
<entry>and save name.</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Make a call to set</entry>
</row>
<row>
<entry/>
<entry/>
<entry>column order and save</entry>
</row>
<row>
<entry/>
<entry/>
<entry>column order table and</entry>
</row>
<row>
<entry/>
<entry/>
<entry>table Id.</entry>
</row>
<row>
<entry>Retrieve first row</entry>
<entry>Make a call to</entry>
<entry>Bind sqlda struct to</entry>
</row>
<row>
<entry>returned from query.</entry>
<entry>get next row.</entry>
<entry>record memory buffer</entry>
</row>
<row>
<entry/>
<entry/>
<entry>(requires: table Id,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>column order table, sqlda</entry>
</row>
<row>
<entry/>
<entry/>
<entry>struct) Make a call to get</entry>
</row>
<row>
<entry/>
<entry/>
<entry>next row.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0070" num="0075">Several of the state member variables contained within the class may be programmed to detect possible errors. The other state member variables contained within the class are used by the Database Session Manager layer to allow the session manager to query the session status, and instruct the session to behave in a specific manner.</p>
<p id="p-0071" num="0076">Database Session Object Module <b>506</b> is limited to one active query per session object, making multiple session object management essential. This task is performed by the session manager object.</p>
<p id="p-0072" num="0077">Next, Database Session Object Module Manager <b>504</b> manages multiple concurrent database session while providing the functionality required to support multi-threaded database access. The functionality of Database Session Object Module Manager <b>504</b> is identical to that of the Database Session Object Module <b>506</b>. However, Database Session Object Module Manager <b>504</b> is able to control multiple sessions at once, allowing multiple queries <b>206</b> to be performed simultaneously. Each of these queries can then be accessed through Database Session Object Module Manager <b>504</b> using a session identifier associated with the query.</p>
<p id="p-0073" num="0078">When a new session is requested, Database Session Object Module Manager <b>504</b> will search through the session list until a free session is located. The free session will be allocated and a session identifier will be returned.</p>
<p id="p-0074" num="0079">Database Session Object Module Manager <b>504</b> controls a group of database session objects <b>506</b>. Each of the session objects can be assigned a command or query by the Database Session Object Module Manager <b>504</b>. Once a session has been assigned a task, the object is responsible for all aspects of that task until such time as another task is assigned. Further instructions related to the assigned task are forwarded by Database Session Object Module Manager <b>504</b> to the responsible session using the assigned session identifier.</p>
<p id="p-0075" num="0080">Next, thread management routines <b>510</b> simplify the use of thread control structures and critical section control for multi-threaded applications. Thread management organization is based on a dynamic list of thread control structures. These structures are used to synchronize thread initialization, execution and termination.</p>
<p id="p-0076" num="0081">The thread control structure contains all information required for initialization and management of a single thread. This structure is dynamically allocated and stored in a single linked list as requests for new threads are handled.</p>
<p id="p-0077" num="0082">The abstraction module <b>502</b> is contained within a single database access class. The abstraction module <b>502</b> contains database abstraction routines, which are a number overloaded functions contained within a database access class. Each frequently accessed database record has a set of methods which overload the basic functionality to suit the specific table requirements.</p>
<p id="p-0078" num="0083">It will be appreciated that the initialization of network administrator <b>110</b> can be performed on a single thread or on multiple threads using the data structures and modules defined above.</p>
<p id="p-0079" num="0084">It will be appreciated that the embodiment enables a data retrieval system in which the order of information being retrieved does not have to be known. The retrieved information is organized and stored depending on the field name of each field. Further, data can be stored in any memory buffer. The memory buffer can be switched to a different memory location.</p>
<p id="p-0080" num="0085">It is noted that those skilled in the art will appreciate that various modifications of detail may be made to the preferred embodiments described herein which would come within the scope of the invention as described in the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of providing rapid access to data stored in a database to permit said data to be loaded into an administrator computer for runtime storage, said method comprising:
<claim-text>creating multiple threads for a query to concurrently retrieve data corresponding to the query from said database, wherein said database contains a plurality of datafiles of information about a communication network;</claim-text>
<claim-text>retrieving data corresponding to the query and mapping, using a mapping structure, the retrieved data from said database into entries of local data structures stored in a local memory of the administrator computer, wherein each local data structure is associated with a respective thread,</claim-text>
<claim-text>wherein said mapping structure includes a cross reference table and a plurality of field tables,</claim-text>
<claim-text>wherein the cross reference table contains a list of the plurality of datafiles in said database and a list of addresses of the plurality of field tables,</claim-text>
<claim-text>wherein each field table contains a list of field names in each datafile.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said field tables map fields in a particular datafile of said database to an address offset value in relation to a base location address of that datafile.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method as claimed in <claim-ref idref="CLM-00002">claim 2</claim-ref> wherein said retrieved data is associated with a SQL structure.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said administrator is a network administrator node, and said datafiles contain information about a communication network.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method as claimed in <claim-ref idref="CLM-00004">claim 4</claim-ref> wherein:
<claim-text>said retrieved data relates to a node in said communication network;</claim-text>
<claim-text>said database further contains other data relating to elements in said communication network; and</claim-text>
<claim-text>said local memory is associated with a processor of the network administrator node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method as claimed in <claim-ref idref="CLM-00005">claim 5</claim-ref> wherein said query is performed during initiation of the communication network to obtain configuration data related to said elements.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method as claimed in <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein said configuration data relates to a node in the communication network.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method as claimed in <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein said method is executed as a series of steps by computer executable code operating on said processor.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method as claimed in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said query is processed by a plurality of separate threads spawned by said computer executable code.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method as claimed in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said query comprises SQL statements.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A system for providing rapid access to data stored in a database in a communication network to permit said data to be loaded into an administrator computer for runtime storage, said system comprising:
<claim-text>multiple processors;</claim-text>
<claim-text>multiple local memories; and</claim-text>
<claim-text>an application:</claim-text>
<claim-text>creating multiple threads for a query to concurrently retrieve data corresponding to the query from said database, wherein said database contains a plurality of datafiles of information about the communication network; and</claim-text>
<claim-text>retrieving data corresponding to the query and mapping, using a mapping structure, the retrieved data from said database into entries of local data structures stored in a local memory of the administrator computer, wherein each local data structure is associated with a respective thread, and</claim-text>
<claim-text>wherein said mapping structure includes a cross reference table and a plurality of field tables,</claim-text>
<claim-text>wherein the cross reference table contains a list of the plurality of datafiles in said database and a list of addresses of the plurality of field tables,</claim-text>
<claim-text>wherein each field table contains a list of field names in each datafile.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system as claimed in <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said field tables map fields in a particular datafile of said database to an address offset value in relation to a base location address of that datafile.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system as claimed in <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said retrieved data is associated with a SQL structure.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said administrator computer is a network administration node, and said datafiles contain information about a communication network.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system as claimed in <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein:
<claim-text>said retrieved data relates to a node in said communication network;</claim-text>
<claim-text>said database further contains other data relating to elements in said communication network; and</claim-text>
<claim-text>said local memory is associated with a processor of the network administrator node; and</claim-text>
<claim-text>said query is performed during initiation of the communication network to obtain configuration data related to said elements.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system as claimed in <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said query is processed by a plurality separate threads.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system as claimed in <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said query comprises SQL statements. </claim-text>
</claim>
</claims>
</us-patent-grant>
