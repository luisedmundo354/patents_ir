<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298168-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298168</doc-number>
<kind>B1</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11787813</doc-number>
<date>20070418</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>03</class>
<subclass>K</subclass>
<main-group>19</main-group>
<subgroup>003</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>326 10</main-classification>
<further-classification>326  9</further-classification>
<further-classification>326 11</further-classification>
</classification-national>
<invention-title id="d0e43">Method and apparatus for error mitigation of programmable logic device configuration memory</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5426378</doc-number>
<kind>A</kind>
<name>Ong</name>
<date>19950600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5646545</doc-number>
<kind>A</kind>
<name>Trimberger et al.</name>
<date>19970700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6812731</doc-number>
<kind>B1</kind>
<name>Trimberger</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7036059</doc-number>
<kind>B1</kind>
<name>Carmichael et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7250786</doc-number>
<kind>B1</kind>
<name>Trimberger</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>326 11</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00006">
<othercit>U.S. Appl. No. 11/184,375 by Trimberger on Jul. 19, 2005 filed by Xilinx, Inc.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>U.S. Appl. No. 11/184,376 by Trimberger on Jul. 19, 2005 filed by Xilinx, Inc.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>U.S. Appl. No. 11/184,498 by Trimberger on Jul. 19, 2005 filed by Xilinx, Inc.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>13</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>326  9- 12</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<division>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>11252682</doc-number>
<kind>00</kind>
<date>20051018</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>7236000</doc-number>
<kind>A </kind>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>11787813</doc-number>
</document-id>
</child-doc>
</relation>
</division>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Steiner</last-name>
<first-name>Glenn C.</first-name>
<address>
<city>Los Altos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Wallace</last-name>
<first-name>Michael</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Cartier</last-name>
<first-name>Lois D.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Xilinx, Inc.</orgname>
<role>02</role>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Tran</last-name>
<first-name>Anh Q.</first-name>
<department>2819</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and apparatus to reduce the probability of programmable logic device (PLD) failure due to single event upset (SEU) of configuration memory. A first portion of configuration memory cells are initially programmed with configuration data, leaving a second portion of configuration memory cells that are un-programmed. The programmed and un-programmed configuration memory cells are grouped into voting groups, where each un-programmed configuration memory cell of each voting group is programmed with the identical configuration data as contained within the originally programmed configuration memory cell of each voting group. The logic values of each configuration memory cell of each voting group are monitored by voting circuits, which enforce a triple modular redundancy (TMR) validation policy. The logical validation results are then applied to control points to mitigate PLD configuration memory errors caused by anomalous events such as neutron induced SEUs.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="161.21mm" wi="183.73mm" file="US07298168-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="249.00mm" wi="186.27mm" orientation="landscape" file="US07298168-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="217.17mm" wi="154.69mm" orientation="landscape" file="US07298168-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="203.20mm" wi="132.93mm" orientation="landscape" file="US07298168-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="253.75mm" wi="184.49mm" orientation="landscape" file="US07298168-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="169.76mm" wi="183.90mm" file="US07298168-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The present invention generally relates to programmable logic devices (PLDs), and more particularly to single event upset (SEU) error mitigation of configuration memory within those PLDs.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">PLDs are a well-known type of integrated circuit that may be programmed to perform specified logic functions. One type of PLD, the Field Programmable Gate Array (FPGA), typically includes an array of programmable tiles. These programmable tiles can include, for example, Input/Output Blocks (IOBs), Configurable Logic Blocks (CLBs), dedicated Random Access Memory Blocks (BRAM), multipliers, Digital Signal Processing blocks (DSPs), processors, clock managers, Delay Lock Loops (DLLs), Multi-Gigabit Transceivers (MGTs) and so forth.</p>
<p id="p-0004" num="0003">Each programmable tile typically includes both programmable interconnect and programmable logic. The programmable interconnect typically includes a large number of interconnect lines of varying lengths interconnected by Programmable Interconnect Points (PIPs). The programmable logic implements the logic of a user design using programmable elements that may include, for example, function generators, registers, arithmetic logic, and so forth.</p>
<p id="p-0005" num="0004">The programmable interconnect and the programmable logic are typically programmed by loading a stream of configuration data into internal configuration memory cells that define how the programmable elements are configured. The configuration data may be read from memory (e.g., from an external PROM) or written into the FPGA by an external device. The collective states of the individual memory cells then determine the function of the FPGA.</p>
<p id="p-0006" num="0005">Another type of PLD is the Complex Programmable Logic Device, or CPLD. A CPLD includes two or more “function blocks” connected together and to Input/Output (I/O) resources by an interconnect switch matrix. Each function block of the CPLD includes a two-level AND/OR structure similar to those used in Programmable Logic Arrays (PLAs) and Programmable Array Logic (PAL) devices. In some CPLDs, configuration data is stored on-chip in non-volatile memory. In other CPLDs, configuration data is stored on-chip in non-volatile memory, then downloaded to volatile memory as part of an initial configuration sequence.</p>
<p id="p-0007" num="0006">For all of these PLDs, the functionality of the device is controlled by data bits provided to the device for that purpose. The data bits can be stored in volatile memory (e.g., static memory cells, as in FPGAs and some CPLDs), in non-volatile memory (e.g., FLASH memory, as in some CPLDs), or in any other type of memory cell.</p>
<p id="p-0008" num="0007">Some PLDs, such as the Xilinx Virtex® FPGA, can be programmed to incorporate blocks with pre-designed functionalities, i.e., “cores”. A core can include a predetermined set of configuration bits that program the FPGA to perform one or more functions. Alternatively, a core can include source code or schematics that describe the logic and connectivity of a design. Typical cores can provide, but are not limited to, DSP functions, memories, storage elements, and math functions. Some cores include an optimally floor planned layout targeted to a specific family of FPGAs. Cores can also be parameterizable, i.e., allowing the user to enter parameters to activate or change certain core functionality.</p>
<p id="p-0009" num="0008">Programmable logic devices can be susceptible to functional failure under certain circumstances. The configuration memory cells, for example, that are used to program the PLD's functionality can inadvertently “flip”, or in other words, change their logic state. Such failures may be caused by single event upsets (SEUs), or other radiation induced errors, which can lead to functional failure.</p>
<p id="p-0010" num="0009">With the ever decreasing geometry size of semiconductor based configuration memory cells, the configuration memory cells are becoming more susceptible to SEU failures. In particular, neutron induced SEUs have a greater impact as geometries of the memory cells are reduced, since the relative size of the neutron with respect to the configuration memory cell grows. As such, neutrons that are incident to a silicon nucleus of a semiconductor device within a particular configuration memory cell may induce an alpha particle to be released by the semiconductor device. Once the alpha particle is released, its ionic polarization may be such that the logic state of the semiconductor device is “flipped”, or reversed, potentially causing soft failure (i.e., recoverable via reconfiguration), or catastrophic failure. Efforts continue, therefore, to mitigate such SEU based failures.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0011" num="0010">To overcome limitations in the prior art, and to overcome other limitations that will become apparent upon reading and understanding the present specification, various embodiments of the present invention include apparatus and methods for a programmable logic device that provide error mitigation through usage of unused configuration memory in a given programmable logic device (PLD).</p>
<p id="p-0012" num="0011">In accordance with one embodiment of the invention, an integrated circuit (IC) comprises a plurality of configuration memory cells and a plurality of voting circuits. Each of the voting circuits is coupled to a different subset of the configuration memory cells and each of the configuration memory cells is coupled to a plurality of the voting circuits. The IC further comprises a plurality of control points, where each control point is coupled to an output terminal of one of the voting circuits.</p>
<p id="p-0013" num="0012">In accordance with another embodiment of the invention, a method of reliably configuring a programmable logic device (PLD) comprises storing configuration data into a first portion of configuration memory cells existent within the PLD to define a logic function, identifying a second portion of configuration memory cells that are void of the configuration data that defines the logic function, and utilizing the second portion of configuration memory cells as redundant memory cells. The redundant memory cells are used to verify a validity of the configuration data stored within the first portion of configuration memory cells.</p>
<p id="p-0014" num="0013">In accordance with another embodiment of the invention, a method of mitigating configuration memory cell errors in a programmable logic device (PLD) comprises programming a first set of configuration memory cells to implement a logic function, identifying a second set of configuration memory cells that are not programmed for the logic function, programming a portion of the second set of configuration memory cells to reflect a logic state of a corresponding portion of configuration memory cells in the first set, comparing logic values of the portion of the second set of configuration memory cells to logic values of the corresponding portion of configuration memory cells in the first set, selecting a logic value from the compared logic values that conforms to a redundancy rule, and applying the selected logic value to a control point within the PLD to implement the logic function.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0015" num="0014">Various aspects and advantages of the invention will become apparent upon review of the following detailed description and upon reference to the drawings, in which:</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an integrated circuit (IC) that exemplifies a Field Programmable Gate Array (FPGA) architecture;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> illustrates an exemplary memory cell contained within a programmable logic device (PLD);</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> illustrates an exemplary memory cell voting circuit;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> illustrates an alternative memory cell voting circuit; and</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an exemplary flow diagram of a method used to reliably configure a PLD.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0021" num="0020">Generally, various embodiments of the present invention provide apparatus and methods of providing an error mitigation scheme to reduce the effects of single event upset (SEU) induced errors within programmable logic devices (PLDs). In particular, each PLD contains reconfigurable logic and interconnect resources whose functions are controlled via static memory cells. SEU upsets may occur which, in some instances, are effective to change the logic value contained within the memory cells. Since these memory cells can directly affect the particular logic function implemented by the reconfigurable logic and interconnect resources, functional failures within the PLD may be observed.</p>
<p id="p-0022" num="0021">The memory cells are often configured into configuration data arrays, whose contents may be accessed via address and data busses. Thus, for a given address, a data word containing multiple configuration bits intended for a portion of the configuration data array may be written to the configuration data array. Incrementing the address bus throughout the configuration data array address space and changing each data word in accordance with each address change, is effective to completely configure a PLD's configuration data array to implement a particular logic function.</p>
<p id="p-0023" num="0022">Unlike some other memory configurations, memory cells that define a logic function within a PLD are generally sensed in a continuous fashion. As such, if a memory cell undergoes a single event upset that is effective to “flip”, i.e., change, the logic state of the memory cell, then the logic function associated with that particular memory cell may be immediately affected, which may cause soft or catastrophic failure.</p>
<p id="p-0024" num="0023">Statistically, only a small percentage of the available configuration memory space is typically utilized for a given logic design within a PLD. For example, approximately 10% of the available configuration memory cells within a PLD may be utilized in a design implementation, which provides for an appreciable number of configuration memory cells that may be available for other use. As such, various embodiments in accordance with the present invention provide an apparatus and various methods to utilize the unused configuration memory cells to mitigate the effects of failures caused by SEUs, or any other mechanism that causes the logic state of a configured memory cell to flip.</p>
<p id="p-0025" num="0024">As noted above, advanced integrated circuits (ICs), such as FPGAs, can include several different types of programmable logic blocks in the array. For example, <figref idref="DRAWINGS">FIG. 1</figref> illustrates an IC that exemplifies FPGA architecture <b>100</b>, including a large number of different programmable tiles such as Multi-Gigabit Transceivers (MGTs) <b>101</b>, CLBs <b>102</b>, BRAMs <b>103</b>, IOBs <b>104</b>, configuration and clocking logic CONFIG/CLOCKS <b>105</b>, DSPs <b>106</b>, specialized I/O <b>107</b>, including configuration ports and clock ports, and other programmable logic <b>108</b>, such as digital clock managers, analog-to-digital converters, system monitoring logic, and so forth. Some FPGAs also include dedicated processor blocks PROC <b>110</b>, in which specific CPU related functionality may be utilized that is separate from the FPGA fabric.</p>
<p id="p-0026" num="0025">In some FPGAs, each programmable tile includes programmable interconnect element INT <b>111</b> having standardized connections to and from a corresponding interconnect element in each adjacent tile. Therefore, the programmable interconnect elements taken together implement the programmable interconnect structure for the illustrated FPGA. INT <b>111</b> also includes the connections to and from the programmable logic element within the same tile, as shown by the examples of blocks <b>102</b> and <b>104</b>.</p>
<p id="p-0027" num="0026">For example, a CLB <b>102</b> may include a Configurable Logic Element CLE <b>112</b> that may be programmed to implement user logic plus a single programmable interconnect element INT <b>111</b>. A BRAM <b>103</b> can include a BRAM logic element (BRL <b>113</b>) in addition to one or more programmable interconnect elements. Typically, the number of interconnect elements included in a tile depends on the height of the tile (as measured from right to left of <figref idref="DRAWINGS">FIG. 1</figref>). In the pictured embodiment, a BRAM tile has the same height as four CLBs, but other numbers (e.g., five) can also be used. A DSP tile <b>106</b> can include a DSP logic element (DSPL <b>114</b>) in addition to an appropriate number of programmable interconnect elements. An IOB <b>104</b> may include, for example, two instances of an input/output logic element IOL <b>115</b> in addition to one instance of the programmable interconnect element INT <b>111</b>.</p>
<p id="p-0028" num="0027">As will be clear to those of skill in the art, the actual I/O pads connected, for example, to the I/O logic element <b>115</b> are manufactured using metal layers above the various illustrated logic blocks, and typically are not confined to the area of the input/output logic element <b>115</b>.</p>
<p id="p-0029" num="0028">In the pictured embodiment, a columnar area near the center of the die (shown shaded in <figref idref="DRAWINGS">FIG. 1</figref>) is used for configuration, clock, and other control logic. Horizontal areas <b>109</b> extending from this column are used to distribute the clocks and configuration signals across the breadth of the FPGA.</p>
<p id="p-0030" num="0029">Some FPGAs utilizing the architecture illustrated in <figref idref="DRAWINGS">FIG. 1</figref> include additional logic blocks that disrupt the regular columnar structure making up a large part of the FPGA. The additional logic blocks can be programmable blocks and/or dedicated logic. For example, the processor block PROC <b>110</b> shown in <figref idref="DRAWINGS">FIG. 1</figref> may span several columns of CLBs and BRAMs.</p>
<p id="p-0031" num="0030">Note that <figref idref="DRAWINGS">FIG. 1</figref> is intended to illustrate only an exemplary FPGA architecture. The number of logic blocks in a column, the relative width of the columns, the number and order of columns, the type of logic blocks included in the columns, the relative size of the logic blocks, and the interconnect/logic implementations <b>102</b>, <b>103</b>, and <b>104</b> are purely exemplary. For example, in an actual FPGA more than one adjacent column of CLBs is typically included wherever the CLBs appear, to facilitate the efficient implementation of user logic.</p>
<p id="p-0032" num="0031">As discussed above, configuration of a PLD may be performed via memory cells that store configuration control data, where each memory cell stores a single bit of configuration control data. The configuration control data may be used to control the conductivity state of pass transistors in multiplexers, to serve as logic values in lookup tables, or to perform some other configuration function. The configuration control data bits can be stored in volatile memory (e.g., static memory cells, as in FPGAs and some CPLDs), in non-volatile memory (e.g., FLASH memory, as in some CPLDs), or in any other type of memory cell.</p>
<p id="p-0033" num="0032">Turning to <figref idref="DRAWINGS">FIG. 2</figref>, a schematic diagram of one embodiment of a configuration memory cell is exemplified. Pass gates <b>202</b> and <b>208</b> determine access to configuration memory cell <b>214</b>. In particular, pass gate <b>202</b> accepts signal ADDRESS, whose logic high level is effective to render pass gate <b>202</b> conductive if configuration memory cell <b>214</b> is addressed for either write or read access. Pass gate <b>208</b> may provide optional read/write enabling of configuration memory cell <b>214</b> and is similarly rendered conductive by signal RE/WE, whenever configuration memory cell <b>214</b> is to be read from or written to.</p>
<p id="p-0034" num="0033">In operation, configuration memory cell <b>214</b> is programmed with signal DATA when both ADDRESS and WE signals are active, e.g., asserted to a logic high level. Node <b>210</b> then receives signal DATA and through operation of the inverter network of inverters <b>204</b> and <b>206</b>, the logic value of signal DATA is maintained at node <b>210</b>. The logic value at node <b>210</b> is then routed to FPGA control point <b>216</b>, which is effective to configure a portion of the FPGA for a particular logic function. It should be noted that other memory configurations, such as capacitive storage, may be used to implement configuration memory cell <b>214</b> as a static configuration memory cell.</p>
<p id="p-0035" num="0034">The determination of whether configuration memory cell <b>214</b> is to be utilized for a particular design is generally determined by the PLD design tool. The design tools generally accept hardware design language (HDL) definitions, or schematics, which are then used to generate net lists to indicate point to point connectivity of reconfigurable logic and interconnect resources. From the net lists, additional tools will map the design to logic, determine the optimal placement of the logic, and then route signal paths between the logic. From this “place and route” operation, a configuration bit file is generated, which may be used to program the PLD.</p>
<p id="p-0036" num="0035">A computing station, for example, may be used to execute core synthesis tools to aid in the minimization and optimization of the equations extracted from the HDL files and/or schematics. A compiler, for example, may parse through the HDL behavioral source code to extract known functions, e.g., arithmetic functions, multiplexers, memories, etc. An optimization block, timing block, and an integrated software environment (ISE) block may then interoperate to formulate a design that is substantially dependent upon the intended PLD target's architecture and context. The context, for example, may influence inter-function optimizations such as replication, merging, re-timing, and pipelining. The context may be defined by the timing requirements and topology of the design.</p>
<p id="p-0037" num="0036">As discussed above, however, configuration memory cell <b>214</b> may be susceptible to SEUs, which may be induced by a neutron strike <b>212</b>, causing emission of alpha particles from within the semiconductor substrate of configuration memory cell <b>214</b>. The emission of the alpha particles may then be effective to flip the logic state at node <b>210</b> to its alternate binary logic state. That is to say, for example, that a logic “1” at node <b>210</b> could be flipped to a logic “0” in response to the SEU. Conversely, a logic “0” could be flipped to a logic “1”. It can be seen, therefore, that since the logic state of node <b>210</b> may be continuously sensed by FPGA control point <b>216</b>, any logic reversal at node <b>210</b> could cause a failure within its respective FPGA.</p>
<p id="p-0038" num="0037">Turning to <figref idref="DRAWINGS">FIG. 3</figref>, an alternative embodiment of a configuration memory cell is exemplified, whereby a voting circuit is employed to make use of redundant memory cells that may be available to provide a high reliability mode of operation. In particular, along with configuration memory cell <b>314</b>, redundant configuration memory cells <b>320</b> and <b>322</b> are utilized, such that if an incorrect logic state of configuration memory cell <b>314</b> is sensed, the logic state of configuration memory cell <b>320</b> and <b>322</b> is used to mitigate the error.</p>
<p id="p-0039" num="0038">In one embodiment, the logic values contained within redundant configuration memory cells <b>320</b> and <b>322</b> are written by the design tool that is used to program configuration memory cell <b>314</b>. In particular, signal DATA that is used to program memory cell <b>314</b> is also used to program the logic value contained within redundant configuration memory cells <b>320</b> and <b>322</b> once they have been identified as being unused for a particular design. Once programmed, configuration memory cells <b>314</b>, <b>320</b>, and <b>322</b> combine to form a triple modular redundancy (TMR) configuration, which is then used by voting circuit <b>318</b> to ensure that the correct logic value is provided to FPGA control point <b>316</b> even when one of the three configuration memory cells is subjected to an SEU. In particular, voting circuit <b>318</b> compares the logic state at configuration memory cell <b>314</b> with the logic states of redundant configuration memory cells <b>320</b> and <b>322</b>. By invoking a TMR algorithm, voting circuit <b>318</b> requires a majority vote between configuration memory cells <b>314</b>, <b>320</b>, and <b>322</b> in order to validate the logic state presented to FPGA control point <b>316</b>. Thus, if any one of the three configuration memory cells <b>314</b>, <b>320</b>, and <b>322</b> changes state (flips) due to an SEU, the value in the flipped memory cell is ignored, and the value stored in the other two memory cells is passed to FPGA control point <b>316</b>.</p>
<p id="p-0040" num="0039">Voting circuit <b>318</b> implements the majority rule Boolean function of equation (1),
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>D=A</i>&amp;<i>B|B</i>&amp;<i>C|C</i>&amp;<i>A,</i>  (1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
where D is the output of the voting circuit, A is the logic value contained within the first configuration memory cell, B is the logic value contained within the second configuration memory cell, C is the logic value contained within third configuration memory cell, “&amp;” is the logical AND operator, and “|” is the logical OR operator.
</p>
<p id="p-0041" num="0040">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="14pt" align="center"/>
<colspec colname="2" colwidth="77pt" align="center"/>
<colspec colname="3" colwidth="14pt" align="center"/>
<colspec colname="4" colwidth="77pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="4" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>A</entry>
<entry>B</entry>
<entry>C</entry>
<entry>D</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>0</entry>
<entry>0</entry>
<entry>0</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>0</entry>
<entry>1</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>1</entry>
<entry>0</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>0</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>0</entry>
<entry>0</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>0</entry>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1</entry>
<entry>0</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Thus, given a majority number of logic low valued configuration memory cells, i.e., 2 or more out of 3, an output logic value of “0” will be selected by the respective voting circuit as illustrated in Table 1. On the other hand, given a majority of logic high valued memory cells, i.e., 2 or more out of 3, an output logic value of “1” will be selected by the respective voting circuit as similarly illustrated in Table 1.
</p>
<p id="p-0042" num="0041">In some embodiments, voting circuit <b>318</b> also includes logic to correct the flipped value of one of the memory cells based on the value stored in the majority of the remaining memory cells. Such correction logic is well known in TMR circuitry.</p>
<p id="p-0043" num="0042">The number of configuration memory cells actually utilized by a given design implementation may include, for example, only 10% of the available configuration memory cells, which leaves a large percentage of configuration memory cells as redundant configuration memory cells. This condition is due to the fact that most configuration bits control interconnect multiplexers, whose control values are “don't care”, i.e., unused. Thus, <figref idref="DRAWINGS">FIG. 3</figref> may depict a situation, whereby configuration memory cell <b>314</b> impacts a given design implementation of a PLD, and configuration memory cells <b>320</b> and <b>322</b> constitute two of the many configuration memory cells that do not impact the design implementation. In such an instance, the reliability of the design implementation may be enhanced through the utilization of configuration memory cells <b>320</b> and <b>322</b> as redundant memory elements used to provide error mitigation of the flipped logic state of configuration memory cell <b>314</b>.</p>
<p id="p-0044" num="0043">Turning to <figref idref="DRAWINGS">FIG. 4</figref>, a voting control circuit is exemplified, which provides voting control for every three configuration memory cells as discussed above in relation to <figref idref="DRAWINGS">FIG. 3</figref>. It should be noted, however, that a voting circuit for any odd number of configuration memory cells, e.g., 3, 5, 7, 9, etc., may be used to achieve enhanced results as discussed in more detail below.</p>
<p id="p-0045" num="0044">As can be seen, voter circuits <b>418</b>-<b>430</b> each receive logic values from three configuration memory cells. Furthermore, two of the three logic values received by one voter circuit are also received by a neighboring voter circuit. For example, voter circuit <b>420</b> receives the logic values associated with configuration memory cells <b>402</b> C<b>0</b>, <b>404</b> C<b>1</b>, and <b>406</b> C<b>2</b>, and provides validated logic signal C<b>1</b>′ to the FPGA control point affecting logic element <b>434</b>. Neighboring voter circuit <b>422</b> receives the logic values associated with configuration memory cells <b>404</b> C<b>1</b>, <b>406</b> C<b>2</b>, and <b>408</b> C<b>3</b>, and provides validated logic signal C<b>2</b>′ to the FPGA control point affecting logic element <b>436</b>. Logic values for logic elements <b>432</b> and <b>438</b>-<b>444</b> may be similarly validated. For the purposes of the present exemplary description, “neighboring voter circuits” can be physically adjacent circuits (i.e., physically located next to one another), or conceptually adjacent circuits (e.g., utilizing shared memory cells programmed by bits appearing in adjacent positions in the configuration bit stream), or both.</p>
<p id="p-0046" num="0045">In a first embodiment, a particular design implementation may only utilize every third configuration memory cell. That is to say, for example, that for a given design implementation, out of configuration memory cells <b>402</b>-<b>414</b> (C<b>0</b>-C<b>6</b>), only configuration memory cells <b>404</b> C<b>1</b> and <b>410</b> C<b>4</b> may be utilized. In such an instance, configuration memory cells C<b>0</b>, C<b>2</b>, C<b>3</b>, and C<b>5</b> are considered redundant, since they are not needed to implement the design.</p>
<p id="p-0047" num="0046">The neighboring configuration memory cells C<b>0</b> and C<b>2</b> may then be programmed to contain the same logic value as configuration memory cell C<b>1</b> to form a configuration memory cell triplet input to voter circuit <b>420</b>. Neighboring configuration memory cells C<b>3</b> and C<b>5</b> may also be programmed to contain the same logic value as configuration memory cell C<b>4</b> to form another configuration memory cell triplet input to voter circuit <b>426</b>. Such a design is effective to render a TMR mode of operation, such that no further action is required for validation of logic signals C<b>1</b>′ and C<b>4</b>′.</p>
<p id="p-0048" num="0047">In a second embodiment, a particular design implementation may not necessarily utilize only every third configuration memory cell. In such an instance, therefore, certain neighboring configuration memory cells may be utilized in the same design and are thus not available as redundant configuration memory cells. Based upon their particular logic value and their neighbor's logic values, however, they may nevertheless be utilized in a TMR validated design implementation.</p>
<p id="p-0049" num="0048">For example, referring again to <figref idref="DRAWINGS">FIG. 4</figref>, configuration memory cells <b>402</b> C<b>0</b>, <b>404</b> C<b>1</b>, and <b>406</b> C<b>2</b> contribute to provide validated logic signal C<b>1</b>′ to control logic element <b>434</b>. If C<b>1</b> <b>404</b> is at a logic high value, then for proper TMR operation, C<b>0</b> <b>402</b> and C<b>2</b> <b>406</b> should also be at a logic high value. For a given design implementation, however, validated logic signal C<b>2</b>′ may also be required to control logic element <b>436</b>. The configuration memory cell triplet that contributes to the logic value of C<b>2</b>′ includes configuration memory cells C<b>1</b> <b>404</b>, C<b>2</b> <b>406</b>, and C<b>3</b> <b>408</b>. Configuration memory cells C<b>1</b> <b>404</b> and C<b>2</b> <b>406</b> should be a logic high level for proper TMR operation in providing validated logic signal C<b>1</b>′. Thus, if the required logic value of C<b>2</b>′ is also a logic high value and the logic value of configuration memory cell C<b>3</b> is a logic high value, then C<b>2</b>′ is a validated logic signal and as such, may continue to be used to control logic element <b>436</b>.</p>
<p id="p-0050" num="0049">Should the logic values of C<b>2</b>′ and C<b>3</b> not match up with the logic values of C<b>1</b> and C<b>2</b>, however, then TMR validation of output C<b>2</b>′ is not possible. In such an instance, a third embodiment can be used, in which a software algorithm is invoked to modify, or re-route, the original design implementation to “free up” a configuration memory cell. For example, given that C<b>1</b>′ controls logic element <b>434</b>, the design implementation may be altered to require, for example, that C<b>4</b>′ and logic element <b>440</b>, instead of C<b>2</b>′ and logic element <b>436</b>, be utilized in the design implementation so that proper TMR validation may be established as discussed above.</p>
<p id="p-0051" num="0050">Given that only 10% of configuration memory is utilized by the exemplary design, however, a fairly low probability exists that a given configuration memory cell is utilized, such that only a small percentage of the design would need to be re-routed to free up configuration memory cells for TMR validation. For example, given that any one configuration memory cell is used in defining the exemplary design, then the probability of a neighboring configuration memory cell being used for the exemplary design is 1/10.</p>
<p id="p-0052" num="0051">Furthermore, even when utilized, the probability that the logic value of the neighboring configuration memory cell is different is ½. Thus, the probability of the neighboring configuration memory cell being used for the exemplary design and having a different logic value is <b>1</b>/<b>10</b>* <b>1</b>/<b>2</b>= <b>1</b>/<b>20</b>. Similarly, the probability of a third configuration memory cell being both used in the exemplary design and different is also 1/20. Thus, if TMR is needed for every configuration bit used in the design, then re-routing is only required in <b>1</b>/<b>20</b>+ <b>1</b>/<b>20</b>= <b>1</b>/<b>10</b>, or 10%, of the original design implementation.</p>
<p id="p-0053" num="0052">In a fourth embodiment, TMR validated operation may not be required for all memory cells in the design. In such instances, it may be adequate to reduce the probability of the design being affected by an SEU. In this embodiment, TMR is applied where redundant memory cells are available, and voting circuits are left enabled when only two out of three cells contain the same value (simple majority); otherwise partial re-routing is performed.</p>
<p id="p-0054" num="0053">For example, in the circuit of <figref idref="DRAWINGS">FIG. 4</figref>, configuration memory cells <b>402</b> C<b>0</b>, <b>404</b> C<b>1</b>, and <b>406</b> C<b>2</b> contribute to validated logic signal C<b>1</b>′ to help control logic element <b>434</b>. If C<b>1</b> <b>404</b> is at a logic high value, then for simple majority operation, either of C<b>0</b> <b>402</b> or C<b>2</b> <b>406</b> should also be at a logic high value. For a given design implementation, however, voter circuit output C<b>2</b>′ may also be required to help control logic element <b>436</b>. The configuration memory cell triplet that contributes to the logic value of C<b>2</b>′ includes configuration memory cells C<b>1</b> <b>404</b>, C<b>2</b> <b>406</b>, and C<b>3</b> <b>408</b>. Given that configuration memory cells C<b>1</b> <b>404</b> and C<b>2</b> <b>406</b> are at a logic high value and that the required logic value of C<b>2</b>′ is also a logic high value, then the logic value of configuration memory cell C<b>3</b> is irrelevant. In this embodiment, C<b>2</b>′ is a logic signal that is validated by a simple majority algorithm and may continue to be used to help control logic element <b>436</b>. However, in this case the value provided by C<b>2</b>″ is not protected.</p>
<p id="p-0055" num="0054">Given that only 10% of configuration memory is utilized by the exemplary design, however, a low probability exists that another design iteration is required to free up redundant configuration memory cells for simple majority validation. For example, given that any one configuration memory cell is used in defining the exemplary design, then the probability of a neighboring configuration memory cell being used for the exemplary design is 1/10.</p>
<p id="p-0056" num="0055">Furthermore, the probability that the logic value of the neighboring configuration memory cell is different is ½. Thus, the probability of the neighboring configuration memory cell being used for the exemplary design and having a different logic value is <b>1</b>/<b>10</b>* <b>1</b>/<b>2</b>= <b>1</b>/<b>20</b>. Similarly, the probability of a third configuration memory cell being both used in the exemplary design and different is also 1/20. Thus, if a simple majority algorithm is utilized, then re-routing is only required in <b>1</b>/<b>20</b>* <b>1</b>/<b>20</b>= <b>1</b>/<b>400</b>, or 0.25%, of the original configuration design implementation. TMR would still be provided for 1−( 1/20+ 1/20)= 9/10, or 90%, of the original configuration design implementation.</p>
<p id="p-0057" num="0056">In a fifth embodiment, TMR validated operation may not be required for every bit in the entire design implementation. In such instances, it may be adequate to reduce the probability of the design being affected by an SEU. In this embodiment, TMR is applied where redundant memory cells are available, and is disabled where redundant memory cells are not available, optionally after attempting to re-implement the design as described above.</p>
<p id="p-0058" num="0057">For example, in some embodiments the voting circuits may be disabled for cases where re-routing does not yield the desired configuration output. Referring again to <figref idref="DRAWINGS">FIG. 4</figref>, in one embodiment, when voting circuit <b>420</b> is enabled, the output signal C<b>1</b>′ is a TMR logical result for the contents of memory cells <b>402</b>, <b>404</b>, and <b>406</b> (C<b>0</b>, C<b>1</b>, and C<b>2</b>). When voting circuit <b>420</b> is disabled, the output signal C<b>1</b>′ is the same as the contents of memory cell <b>404</b> (C<b>1</b>).</p>
<p id="p-0059" num="0058">Disabling each voting circuit of <figref idref="DRAWINGS">FIG. 4</figref>, however, would itself require a configuration memory cell for each voting circuit to be disabled, which effectively doubles the amount of configuration memory used. If, however, disabling of the voter circuits occurs using a coarse granularity of 10 or 100, then the number of configuration memory cells required to disable the voting circuits only increases by 10% or 1%, respectively.</p>
<p id="p-0060" num="0059">Given that only 10% of configuration memory is utilized by the exemplary design, a low probability exists that voting disabling is required for a particular voting circuit. For example, given that any one configuration memory cell is used in defining the exemplary design, then the probability of a neighboring configuration memory cell being used for the exemplary design is 1/10. Furthermore, even when utilized, the probability that the logic value of the neighboring configuration memory cell is different is ½. Thus, the probability of the neighboring configuration memory cell being used for the exemplary design and having a different logic value is <b>1</b>/<b>10</b>* <b>1</b>/<b>2</b>= <b>1</b>/<b>20</b>. Similarly, the probability of a third configuration memory cell being both used in the exemplary design and different is also 1/20. Thus, for a simple majority validation algorithm, disabling of voting is only required in <b>1</b>/<b>20</b>* <b>1</b>/<b>20</b>= <b>1</b>/<b>400</b>, or 0.25%, of the original design implementation.</p>
<p id="p-0061" num="0060">If the voting circuits are disabled in blocks of 100, then on average 10% of 100, or 10 configuration memory cells, would be unprotected. Since, in this example, disabling is done in blocks of 100 memory configuration cells, the proportion of unprotected configuration memory cells is 0.25%*10 or 2.5%. TMR would still be provided for (1−( 1/20+ 1/20)) %−2.5%, or 87.5%, of the original design implementation.</p>
<p id="p-0062" num="0061">It can be seen that by increasing the number of voting inputs from 3 to some higher odd number, such as 5, 7, etc., then the correction coverage using a voting algorithm is increased. Given a 5-input voting configuration, for example, a voting algorithm is effective to validate the exemplary design, even though 2 out of 5 configuration memory cells may have sustained a flipped logic state due to an SEU. Thus, whereas a 3-input voting algorithm may sustain a single SEU induced error and still maintain a validated design, a 5-input voting algorithm may sustain two SEU induced errors and still maintain a validated design.</p>
<p id="p-0063" num="0062">Similarly, a reduced probability exists such that the exemplary design needs to be re-routed when utilizing an increased number of voting inputs. Taking the 5-input voting configuration as discussed above, for example, one out of the five configuration memory cells may not qualify as redundant configuration memory cells for a particular design, because they may be used to implement the design. Those configuration memory cells may nevertheless be used in a validated design, provided that the remaining configuration memory cells can support the simple majority algorithm as discussed above. In other words, if the remaining configuration memory cells are not used in other designs, or if they are used in other designs, but their respective logic values are in agreement with one another, then the remaining configuration memory cells may be used by a simple majority algorithm to validate the exemplary design without the need for re-routing.</p>
<p id="p-0064" num="0063">Turning to <figref idref="DRAWINGS">FIG. 5</figref>, a flow diagram exemplifying a method of reliably configuring a PLD is illustrated. In step <b>504</b>, configuration data is programmed into a first set of configuration memory cells within the PLD. In one embodiment, the PLD design tool being utilized may direct the configuration data into adjacent and/or non-adjacent configuration memory cells as required. Once the configuration memory cells are programmed, a survey of the un-programmed configuration memory cells is taken as in step <b>506</b>. Any un-programmed configuration memory cells that are found to exist are then identified as being available for TMR.</p>
<p id="p-0065" num="0064">If configuration memory cell validation is possible as determined in step <b>508</b>, then voting groups are formed in step <b>510</b> from the programmed and un-programmed configuration memory cells as determined in steps <b>504</b> and <b>506</b>. Each voting group is configured to contain an odd number of configuration memory cells, whereby in one embodiment, a single programmed configuration memory cell is either grouped with un-programmed configuration memory cells, or with a combination of identically programmed and un-programmed configuration memory cells. Once each voting group is formed, the un-programmed configuration memory cells within each voting group are programmed in step <b>512</b> with the identical logic values that are contained within the programmed configuration memory cell voting group counterparts as formed in step <b>504</b>.</p>
<p id="p-0066" num="0065">If configuration memory cell validation is not possible, then a decision may be made as in step <b>520</b>, to re-implement all or part of the design. Such a re-implementation may be attempted, for example, in an effort to re-distribute the programmed configuration memory cells in a manner that is more conducive to validation. That is to say, for example, that the PLD design tool may attempt to create a distribution of programmed configuration memory cells that are physically, and/or logically, separated by un-programmed configuration memory cells. As such, un-programmed configuration memory cells may be strategically placed by the PLD design tool so that they may be more easily combined into voting groups with their programmed configuration memory cell counterparts. Voting circuitry may also be deactivated altogether as in step <b>522</b>, in which case, only the first set of configuration memory cells programmed in step <b>504</b> are used to program the PLD's control points.</p>
<p id="p-0067" num="0066">As discussed above, configuration memory errors are detected and mitigated by providing the correct configuration information to the PLD control points that define a particular design. The contents of the corrupted configuration memory cells may themselves be corrected through the use of block-wise CRC techniques, or through memory scrubbing procedures. Frequency of use of these techniques may be on the order of minutes, hours, or even days due to the low occurrence of SEUs in normal operating environments.</p>
<p id="p-0068" num="0067">Other aspects and embodiments of the present invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and illustrated embodiments be considered as examples only, with a true scope and spirit of the invention being indicated by the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of reliably configuring a programmable logic device (PLD), the method comprising:
<claim-text>storing configuration data into a first portion of configuration memory cells existent within the PLD to define a logic function;</claim-text>
<claim-text>identifying a second portion of configuration memory cells that are void of the configuration data that defines the logic function; and</claim-text>
<claim-text>utilizing the second portion of configuration memory cells as redundant memory cells, wherein the redundant memory cells are used to verify a validity of the configuration data stored within the first portion of configuration memory cells.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>re-routing the design prior to storing the configuration data to facilitate utilizing the second portion of configuration memory cells as redundant memory cells.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>deactivating the utilization of configuration memory cells as redundant memory cells in at least one portion of the PLD.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein storing configuration data into the first portion of configuration memory cells comprises storing configuration data into non-adjacent configuration memory cells.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein storing configuration data into the first portion of configuration memory cells comprises storing configuration data into adjacent and non-adjacent configuration memory cells.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein utilizing the second portion of configuration memory cells comprises:
<claim-text>grouping configuration memory cells of the first and second portions of configuration memory cells to form voting groups;</claim-text>
<claim-text>programming the second portion of configuration memory cells in each voting group with the same configuration data as the respective first portion of configuration memory cells in each voting group; and</claim-text>
<claim-text>comparing the configuration data of each configuration memory cell in each voting group to validate the configuration data of each configuration memory cell in the first portion.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein grouping the configuration memory cells comprises grouping the configuration memory cells into voting groups having an odd number of members.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein comparing the configuration data of each configuration memory cell in each voting group comprises requiring a majority agreement among the members for validation.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the configuration data of each configuration memory cell in each voting group has an identical value to the other configuration memory cells in the same voting group.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein for at least one of the voting groups, a majority of the memory cells in the voting group store a first value, and a minority of the memory cells in the voting group store a second value different from the first value.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A method of mitigating configuration memory cell errors in a programmable logic device (PLD), the method comprising:
<claim-text>programming a first set of configuration memory cells to implement a logic function;</claim-text>
<claim-text>identifying a second set of configuration memory cells that are not programmed for the logic function;</claim-text>
<claim-text>programming a portion of the second set of configuration memory cells to reflect a logic state of a corresponding portion of configuration memory cells in the first set;</claim-text>
<claim-text>comparing logic values of the portion of the second set of configuration memory cells to logic values of the corresponding portion of configuration memory cells in the first set;</claim-text>
<claim-text>selecting a logic value from the compared logic values that conforms to a redundancy rule; and</claim-text>
<claim-text>applying the selected logic value to a control point within the PLD to implement the logic function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:
<claim-text>re-routing the design to facilitate the programming the portion of the second set of configuration memory cells.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:
<claim-text>deactivating the programming the portion of the second set of configuration memory cells in at least one portion of the PLD.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
