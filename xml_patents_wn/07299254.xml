<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299254-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299254</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10720940</doc-number>
<date>20031124</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>751</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>50</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>708685</main-classification>
</classification-national>
<invention-title id="d0e53">Binary coded decimal addition</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>3629565</doc-number>
<kind>A</kind>
<name>Schmookler et al.</name>
<date>19711200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708685</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>3935438</doc-number>
<kind>A</kind>
<name>Grupe</name>
<date>19760100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>4001570</doc-number>
<kind>A</kind>
<name>Gooding et al.</name>
<date>19770100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>4118786</doc-number>
<kind>A</kind>
<name>Levine et al.</name>
<date>19781000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708685</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>4138731</doc-number>
<kind>A</kind>
<name>Kamimoto et al.</name>
<date>19790200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>4139894</doc-number>
<kind>A</kind>
<name>Reitsma</name>
<date>19790200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708714</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>4172288</doc-number>
<kind>A</kind>
<name>Anderson</name>
<date>19791000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>4559608</doc-number>
<kind>A</kind>
<name>Young et al.</name>
<date>19851200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>4638300</doc-number>
<kind>A</kind>
<name>Miller</name>
<date>19870100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>4707799</doc-number>
<kind>A</kind>
<name>Ishikawa et al.</name>
<date>19871100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>4718033</doc-number>
<kind>A</kind>
<name>Miller</name>
<date>19880100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>4799181</doc-number>
<kind>A</kind>
<name>Tague et al.</name>
<date>19890100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>4805131</doc-number>
<kind>A</kind>
<name>Adlietta et al.</name>
<date>19890200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>4866656</doc-number>
<kind>A</kind>
<name>Hwang</name>
<date>19890900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>5745399</doc-number>
<kind>A</kind>
<name>Eaton et al.</name>
<date>19980400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708673</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00016">
<othercit>M. Morris Mano and Charles R. Kime, Logic and Computer Design Fundamentals, (2001), pp. 129-132 and 145-147, second edition, Addison Wesley Longman, New Delhi.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>John F. Wakerly, Digital Design, Principles and Practices, pp. 441-443, 2001, third edition, Pearson Education Asia, New Delhi.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>Zvi Kohavri, Switching and Finite Automata Theory, pp. 138-144, 1978, second edition, Tata McGraw Hill, New Delhi.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>13</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>708685</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>15</number-of-drawing-sheets>
<number-of-figures>15</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050114423</doc-number>
<kind>A1</kind>
<date>20050526</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Alagarsamy</last-name>
<first-name>Neelamekakannan</first-name>
<address>
<city>Tamil Nadu</city>
<country>IN</country>
</address>
</addressbook>
<nationality>
<country>IN</country>
</nationality>
<residence>
<country>IN</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Balamurugan</last-name>
<first-name>Kulanthaivelu Veluchamy</first-name>
<address>
<city>Tamil Nadu</city>
<country>IN</country>
</address>
</addressbook>
<nationality>
<country>IN</country>
</nationality>
<residence>
<country>IN</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>England</last-name>
<first-name>Anthony V. S.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Steinberg</last-name>
<first-name>William</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Malzahn</last-name>
<first-name>D. H.</first-name>
<department>2193</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The binary coded decimal (BCD) adder circuit adds two BCD encoded operands, with an input carry bit, and produces a BCD encoded sum. The adder has three stages. The first stage receives two BCD encoded operands as inputs, groups the inputs into contiguous blocks of 4-bits each, computes an intermediate sum vector and carry vector without considering the input carry bit, and also computes propagation and generate functions for each 4-bit group. The second stage is a carry look ahead circuit which computes all carries from the input carry, and the propagate and generate functions of the 4-bit groups from the first stage. The third stage adjusts the intermediate sum vector with pre-correction factors which depend upon the input carry and the carries generated from the second stage and the carry vectors from the first stage.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="165.27mm" wi="249.68mm" file="US07299254-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="210.65mm" wi="141.14mm" orientation="landscape" file="US07299254-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="256.79mm" wi="174.67mm" orientation="landscape" file="US07299254-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="249.34mm" wi="162.73mm" orientation="landscape" file="US07299254-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="225.21mm" wi="122.43mm" file="US07299254-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="220.13mm" wi="131.06mm" file="US07299254-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="218.10mm" wi="117.01mm" file="US07299254-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="230.21mm" wi="166.12mm" file="US07299254-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="184.23mm" wi="131.40mm" file="US07299254-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="193.89mm" wi="134.79mm" file="US07299254-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="197.70mm" wi="150.11mm" file="US07299254-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="197.61mm" wi="152.74mm" orientation="landscape" file="US07299254-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="233.68mm" wi="134.70mm" orientation="landscape" file="US07299254-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="249.34mm" wi="164.93mm" orientation="landscape" file="US07299254-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="247.48mm" wi="123.78mm" orientation="landscape" file="US07299254-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="238.17mm" wi="125.14mm" orientation="landscape" file="US07299254-20071120-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The present invention relates to a binary coded decimal (BCD) addition, including an adder circuit.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">In BCD arithmetic, at least four binary bits are needed to represent the numbers from 0 to 9. There are sixteen possible bit combinations using four binary bits, but only ten (i.e, 0 to 9) are valid BCD digits. Traditionally, BCD adder circuits adjust the binary sum after the addition has been completed if the value is more than nine (i.e., 1001<sub>2</sub>). For example, whenever the unadjusted sum of two BCD digits produced a carry out (i.e., when the sum exceeds 1001<sub>2</sub>), the sum is corrected by adding 0110<sub>2</sub>.</p>
<p id="p-0004" num="0003">A known BCD adder, described in “Logic and Computer Design Fundamentals”, M Morris Mano and Charles R Kime, Pearson Educational Asia, second edition, 2001 is shown in <figref idref="DRAWINGS">FIG. 1</figref>. The BCD adder circuit <b>5</b> uses a four-bit binary adder <b>6</b> to add two BCD operands A(<b>3</b>) to A(<b>0</b>) and B(<b>3</b>) to B(<b>0</b>), and an input carry C<sub>in </sub>to produce an intermediate sum Z(<b>3</b>) to Z(<b>0</b>). The adder circuit <b>6</b> also includes two levels of logic gates <b>7</b>, <b>8</b>, <b>9</b> to calculate the BCD carry output Cout from the intermediate sum. If there is a BCD carry, a correction factor of 0110<sub>2 </sub>is added with the intermediate sum using a further binary adder <b>10</b>.</p>
<p id="p-0005" num="0004">The BCD adder circuit <b>5</b> shown in <figref idref="DRAWINGS">FIG. 1</figref> thus uses 10 levels of gates to perform a 4-bit addition. For a 16-bit adder circuit, the corresponding binary adder circuit requires 16 levels of gates. However the critical path is the generation of the carry Cout, and gate levels required to implement this is 22 for 16-bit BCD addition.</p>
<p id="p-0006" num="0005">Another BCD adder circuit is taught in U.S. Pat. No. 4,805,131 (Adlietta et al, assigned to Digital Equipment Corporation), issued on Feb. 14, 1989. The BCD adder of Adlietta et al has three stages. In the first stage, 0110<sub>2 </sub>is added with the input BCD operands without considering the input carry. In the second stage the sum and carry vectors are added using a carry look ahead network to generate final carry and propagate vectors. In the third stage a correction circuit adds 1010<sub>2 </sub>if needed.</p>
<p id="p-0007" num="0006">The logic terms in the calculation of a FINAL_CARRY vector increases as the number of bits of the BCD operands increases. Also, the carry vector calculated is propagated through every bit position. The bit terms of the FINAL_CARRY vector must propagate through every bit position. As the bit position increases from least significant bit position <b>0</b> through most significant bit position <b>15</b>, the number of logical terms required to produce the terms of the FINAL_CARRY vector also increases. Therefore, more sophisticated logic gates are required to produce the more significant bit terms and keep the number of logic levels and associated delay to a minimum.</p>
<p id="p-0008" num="0007">For 16-bit BCD addition the BCD adder circuit of Adlietta et al uses only 12 gate levels compared to 22 gate levels in the BCD adder circuit of <figref idref="DRAWINGS">FIG. 1</figref>. But the logic terms required for the implementation of the FINAL_CARRY of BCD adder of Adlietta et al is much higher. Also, when the number of bits of the BCD operands increase, the logic terms for calculating the FINAL_CARRY also increases, which makes the implementation complex for more than 16-bits. There also is no reusability, meaning extending similar structures when the number of bits of the input BCD operands increases.</p>
<p id="p-0009" num="0008">There remains a need for BCD addition circuits with lesser a number of gate levels as well as lesser number of logic terms without requiring any sophisticated logic gates. There is also a need to increase the reusability of logic gates in such adders.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0010" num="0009">The binary coded decimal (BCD) adder circuit adds two BCD encoded operands, with an input carry bit, and produces a BCD encoded sum. The adder includes three stages. The first stage receives two BCD encoded operands as inputs, groups the inputs into contiguous blocks of 4-bits each, computes an intermediate sum vector and carry vector without considering the input carry bit, and also computes propagation and generate functions for each 4-bit group. The second stage is a carry look ahead circuit which computes all carries from the input carry, and the propagate and generate functions of the 4-bit groups from the first stage. The third stage adjusts the intermediate sum vector with, pre-correction factors which depend upon the input carry and the carries generated from the second stage and the carry vectors from the first stage.</p>
<p id="p-0011" num="0010">This invention reduces the time required to perform a BCD addition by reducing in the number of gate levels of the critical path for adding two BCD operands of 16-bits each with an input carry to 12. Only 15 gate levels of delay arise for adding two 64-bit BCD encoded operands with an input carry. The gate levels thus increase only by three, from twelve to fifteen, when the input BCD operands bit size increases from sixteen to sixty-four.</p>
<p id="p-0012" num="0011">Since the BCD addition is carried out with 4-bit groups, the same logic structure can be extended to provide a 16-, 32- or 64-bit BCD adder with extra levels of carry look ahead circuit, which increases the reusability of the logic.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">DESCRIPTION OF DRAWINGS</heading>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> shows a known BCD adder circuit.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> shows a 16-bit BCD adder circuit embodying the invention.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3</figref> shows detail of the circuit of <figref idref="DRAWINGS">FIG. 2</figref> when an addition of a first group of bits is performed.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 4</figref> shows a circuit for calculating first intermediate sum and carry vectors.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 5</figref> shows a circuit for calculating second intermediate sum and carry vectors.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 6</figref> shows a circuit for calculating third intermediate sum and carry vectors.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 7</figref> shows a carry look ahead circuit.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 8</figref> shows a circuit for performing a SUM(<b>0</b>) correction.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 9</figref> shows a circuit for performing a SUM(<b>1</b>) correction.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 10</figref> shows a circuit for performing a SUM(<b>2</b>) correction.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 11</figref> shows a circuit for performing a SUM(<b>3</b>) correction.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 12</figref> shows a stage <b>1</b> circuit for a 64-bit BCD adder circuit.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 13</figref> shows a carry look ahead circuit for the 64-bit BCD adder circuit.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 14</figref> shows a sum correction circuit for the 64-bit BCD adder circuit.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="h-0006" num="0000">Overview</p>
<p id="p-0027" num="0026">The BCD addition of two operands each of n bits with an input carry bit will be described with reference to <figref idref="DRAWINGS">FIG. 2</figref>. A BCD adder circuit <b>12</b> generally has three stages, and the number of bits of the operands is n=16. The addition is performed after grouping the n-bits into contiguous (or successive) groups of 4-bits (i.e., bits <b>0</b>-<b>3</b>, bits <b>4</b>-<b>7</b>, bits <b>8</b>-<b>11</b>, bits <b>12</b>-<b>15</b>).</p>
<p id="p-0028" num="0027">The first stage, represented by four circuits <b>13</b>, <b>14</b>, <b>15</b>, <b>16</b>, generates intermediate sum and carry vectors and propagate and generate functions. The second stage has a carry look ahead circuit <b>17</b> to generate carries from the input carry, and the propagate and generate functions from the first stage. The third stage includes four circuits <b>18</b>, <b>19</b>, <b>20</b>, <b>21</b> that generate a final sum from the intermediate sum vectors based on pre-correction factors which depend on the input carry and the carries generated from carry look ahead circuit <b>17</b> and first stage circuits <b>13</b>, <b>14</b>, <b>15</b>, <b>16</b>.</p>
<p id="h-0007" num="0000">First Stage</p>
<p id="p-0029" num="0028">Consider the 16-bit BCD addition of two BCD encoded operands A(<b>15</b>) to A(<b>0</b>) and B(<b>15</b>) to B(<b>0</b>).</p>
<p id="p-0030" num="0029">The addition of first group of 4-bits A(<b>3</b>) to A(<b>0</b>) and B(3) to B(<b>0</b>) by the circuit <b>13</b> is explained with reference to <figref idref="DRAWINGS">FIGS. 3</figref>, <b>4</b>, <b>5</b> and <b>6</b>. The circuits <b>14</b>, <b>15</b>, <b>16</b> for the other three groups of 4-bit addition logic are of the same form.</p>
<p id="p-0031" num="0030">As shown in <figref idref="DRAWINGS">FIG. 3</figref>, three intermediate sum vectors FS[<b>3</b>:<b>0</b>], SS[<b>3</b>:<b>0</b>], and TS[<b>3</b>:<b>0</b>], (where “F”=first, “S”=second and “T”=third) and carry vectors FC[<b>4</b>:<b>0</b>], SC[<b>3</b>:<b>0</b>], TC<b>3</b> to TC<b>0</b> are calculated by sequential generator circuits <b>22</b>, <b>23</b>, <b>24</b>. The third sum and carry vectors TS[<b>3</b>:<b>0</b>] and TC<b>3</b> to TC<b>0</b> are provided to a respective sum correction circuit <b>18</b> of the third stage.</p>
<p id="p-0032" num="0031">The circuit <b>22</b> computes the first intermediate sum vector FS(<b>3</b>) to FS(<b>0</b>) and carry vector FC(<b>4</b>) to FC(<b>1</b>) by Half-Adders (XOR and AND gates) as shown in <figref idref="DRAWINGS">FIG. 4</figref>. The logical operations performed are:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0032">FS(<b>3</b>)=A(<b>3</b>) XOR B(<b>3</b>) (gate <b>37</b>)</li>
        <li id="ul0002-0002" num="0033">FS(<b>2</b>)=A(<b>2</b>) XOR B(<b>2</b>) (gate <b>35</b>)</li>
        <li id="ul0002-0003" num="0034">FS(<b>1</b>)=A(<b>1</b>) XOR B(<b>1</b>) (gate <b>33</b>)</li>
        <li id="ul0002-0004" num="0035">FS(<b>0</b>)=A(<b>0</b>) XOR B(<b>0</b>) (gate <b>31</b>)</li>
        <li id="ul0002-0005" num="0036">FC(<b>4</b>)=A(<b>3</b>) AND B(<b>3</b>) (gate <b>38</b>)</li>
        <li id="ul0002-0006" num="0037">FC(<b>3</b>)=A(<b>2</b>) AND B(<b>2</b>) (gate <b>36</b>)</li>
        <li id="ul0002-0007" num="0038">FC(<b>2</b>)=A(<b>1</b>) AND B(<b>1</b>) (gate <b>34</b>)</li>
        <li id="ul0002-0008" num="0039">FC(<b>1</b>)=A(<b>0</b>) AND B(<b>0</b>) (gate <b>32</b>)</li>
        <li id="ul0002-0009" num="0040">FC(<b>0</b>)=‘0’</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0033" num="0041">The second intermediate sum vector of the first stage SS(<b>3</b>) to SS(<b>0</b>) and carry vector SC(<b>3</b>) to SC(<b>2</b>) are calculated by the circuit <b>23</b>, including Half-Adders, as shown in detail in <figref idref="DRAWINGS">FIG. 5</figref>. The logical operations performed are:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0042">SS(<b>3</b>)=FS(<b>3</b>) XOR FC(<b>3</b>) (gate <b>43</b>)</li>
        <li id="ul0004-0002" num="0043">SS(<b>2</b>)=FS(<b>2</b>) XOR FC(<b>2</b>) (gate <b>41</b>)</li>
        <li id="ul0004-0003" num="0044">SS(<b>1</b>)=FS(<b>1</b>) XOR FC(<b>1</b>) (gate <b>39</b>)</li>
        <li id="ul0004-0004" num="0045">SS(<b>0</b>)=FS(<b>0</b>) XOR FC(<b>0</b>)=FS(<b>0</b>); since FC(<b>0</b>)=‘0’</li>
        <li id="ul0004-0005" num="0046">SC(<b>3</b>)=FS(<b>2</b>) AND FC(<b>2</b>) (gate <b>42</b>)</li>
        <li id="ul0004-0006" num="0047">SC(<b>2</b>)=FS(<b>1</b>) AND FC(<b>1</b>) (gate <b>40</b>)</li>
        <li id="ul0004-0007" num="0048">SC(<b>1</b>)=FS(<b>0</b>) AND ‘0’=‘0’; since FC(<b>0</b>)=‘0’</li>
        <li id="ul0004-0008" num="0049">SC(<b>0</b>)=‘0’</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0034" num="0050">The third intermediate sum vectors of the first stage TS(<b>3</b>) to TS(<b>0</b>) and a carry TC<b>3</b> are calculated by the circuit <b>24</b>, including Half-Adders, as shown in detail in <figref idref="DRAWINGS">FIG. 6</figref>. The logical operations performed are:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0051">TS(<b>3</b>)=SS(<b>3</b>) XOR SC(<b>3</b>) (gate <b>46</b>)</li>
        <li id="ul0006-0002" num="0052">TS(<b>2</b>)=SS(<b>2</b>) XOR SC(<b>2</b>) (gate <b>44</b>)</li>
        <li id="ul0006-0003" num="0053">TS(<b>1</b>)=SS(<b>1</b>) XOR SC(<b>1</b>)=SS(<b>1</b>); since SC(<b>1</b>)=‘0’</li>
        <li id="ul0006-0004" num="0054">TS(<b>0</b>)=SS(<b>0</b>) XOR SC(<b>0</b>)=FS(<b>0</b>); since SC(<b>0</b>)=‘0’ and SS(<b>0</b>)=FS(<b>0</b>)</li>
        <li id="ul0006-0005" num="0055">TC<b>3</b>=SS(<b>2</b>) AND SC(<b>2</b>) (gate <b>45</b>)</li>
        <li id="ul0006-0006" num="0056">TC<b>2</b>=SS(<b>1</b>) AND SC(<b>1</b>)=‘0’; since SC(<b>1</b>)=‘0’</li>
        <li id="ul0006-0007" num="0057">TC<b>1</b>=SS(<b>0</b>) AND SC(<b>0</b>)=‘0’; since SC(<b>0</b>)=‘0’</li>
        <li id="ul0006-0008" num="0058">TC<b>0</b>=‘0’</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0035" num="0059">Comparing <figref idref="DRAWINGS">FIGS. 4-6</figref>, it can be seen that the design has been optimized such that Half-Adder circuits reduce to XOR gates or even to being straight through in some instances.</p>
<p id="p-0036" num="0060">The propagate function P<b>3</b>-<b>0</b> and the generate function G<b>3</b>-<b>0</b> for the first group of 4-bits are calculated from the intermediate sum and carry vectors, by the combination logic shown in <figref idref="DRAWINGS">FIG. 3</figref> represented by gates <b>25</b>, <b>26</b>, <b>27</b>, <b>28</b>, <b>29</b>, <b>30</b>. The logical operations performed are:
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0000">
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0061">P<b>3</b>-<b>0</b>=TS(<b>3</b>) AND TS(<b>0</b>) (gate <b>30</b>)</li>
        <li id="ul0008-0002" num="0062">G<b>3</b>-<b>0</b>=(SS(<b>1</b>) AND (SS(<b>3</b>) OR SC(<b>3</b>))) OR (SS(<b>3</b>) AND (SS(<b>2</b>) OR SC(<b>2</b>))) OR FC(<b>4</b>) (gates <b>25</b>, <b>26</b>, <b>27</b>, <b>28</b>, <b>29</b>)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0037" num="0063">Thus the functions P<b>3</b>-<b>0</b> and G<b>3</b>-<b>0</b>, along with other 4-bit group propagate and generate functions P<b>7</b>-<b>4</b>, P<b>11</b>-<b>8</b>, P<b>15</b>-<b>12</b>, G<b>7</b>-<b>4</b>, G<b>11</b>-<b>8</b> and G<b>15</b>-<b>12</b>, are inputs to the second stage carry look ahead circuit <b>17</b>.</p>
<p id="h-0008" num="0000">Second Stage</p>
<p id="p-0038" num="0064">The second stage carry look ahead circuit <b>17</b>, calculates the carry values of all groups of 4-bits from the propagate and generate values of the first stage and the input carry bit C<b>0</b> as shown in <figref idref="DRAWINGS">FIG. 7</figref>.
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0000">
    <ul id="ul0010" list-style="none">
        <li id="ul0010-0001" num="0065">C<b>4</b>=G<b>3</b>-<b>0</b> OR (P<b>3</b>-<b>0</b> AND C<b>0</b>) (gates <b>47</b> and <b>57</b>)</li>
        <li id="ul0010-0002" num="0066">C<b>8</b>=G<b>7</b>-<b>4</b> OR (P<b>7</b>-<b>4</b> AND G<b>3</b>-<b>0</b>) OR (P<b>7</b>-<b>4</b> AND P<b>3</b>-<b>0</b> AND C<b>0</b>) (gates <b>48</b>, <b>49</b> and/or gate <b>58</b>)</li>
        <li id="ul0010-0003" num="0067">C<b>12</b>=G<b>1</b>-<b>8</b> OR (P<b>11</b>-<b>8</b> AND G<b>7</b>-<b>4</b>) OR (P<b>11</b>-<b>8</b> AND P<b>7</b>-<b>4</b> AND G<b>3</b>-<b>0</b>) OR (P<b>11</b>-<b>8</b> AND P<b>7</b>-<b>4</b> AND P<b>3</b>-<b>0</b> AND C<b>0</b>) (gates <b>50</b>, <b>51</b>, <b>52</b> and <b>59</b>)</li>
        <li id="ul0010-0004" num="0068">C<b>16</b>=G<b>15</b>-<b>12</b> OR (P<b>15</b>-<b>12</b> AND G<b>11</b>-<b>8</b>) OR (P<b>15</b>-<b>12</b> AND P<b>11</b>-<b>8</b> AND G<b>7</b>-<b>4</b>) OR (P<b>15</b>-<b>12</b> AND P<b>11</b>-<b>8</b> AND P<b>7</b>-<b>4</b> AND G<b>3</b>-<b>0</b>) OR (P<b>15</b>-<b>12</b> AND P<b>11</b>-<b>8</b> AND P<b>7</b>-<b>4</b> AND P<b>3</b>-<b>0</b> AND C<b>0</b>) (gates <b>53</b>, <b>54</b>, <b>55</b>, <b>56</b> and <b>60</b>)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0039" num="0069">These carries are provided to the third stage.</p>
<p id="p-0040" num="0070">The carry C<b>16</b> will be calculated only for a 16-bit BCD addition. If 32-bit or 64-bit BCD addition is required, then propagate function P<b>15</b>-<b>0</b> and generate function G<b>15</b>-<b>0</b> will be produced instead of C<b>16</b> to be provided as an input to the 64-bit carry look ahead network, shown in <figref idref="DRAWINGS">FIG. 13</figref>. The propagate and generate functions P<b>15</b>-<b>0</b> and G<b>15</b>-<b>0</b> are calculated as:
<ul id="ul0011" list-style="none">
    <li id="ul0011-0001" num="0000">
    <ul id="ul0012" list-style="none">
        <li id="ul0012-0001" num="0071">P<b>15</b>-<b>0</b>=P<b>15</b>-<b>12</b> AND P<b>11</b>-<b>8</b> AND P<b>7</b>-<b>4</b> AND P<b>3</b>-<b>0</b></li>
        <li id="ul0012-0002" num="0072">G<b>15</b>-<b>0</b>=G<b>15</b>-<b>12</b> OR (P<b>15</b>-<b>12</b> AND G<b>11</b>-<b>8</b>) OR (P<b>15</b>-<b>12</b> AND P<b>11</b>-<b>8</b> AND G<b>7</b>-<b>4</b>) OR (P<b>15</b>-<b>12</b> AND P<b>11</b>-<b>8</b> AND P<b>7</b>-<b>4</b> AND G<b>3</b>-<b>0</b>)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0041" num="0073">The values P<b>3</b>-<b>0</b>, P<b>7</b>-<b>4</b>, P<b>11</b>-<b>8</b> and P<b>15</b>-<b>12</b> are propagate functions and G<b>3</b>-<b>0</b>, G<b>7</b>-<b>4</b>, G<b>11</b>-<b>8</b> and G<b>15</b>-<b>12</b> are generate functions from the first stage circuits <b>13</b>,<b>14</b>,<b>15</b> and <b>16</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="h-0009" num="0000">Third Stage</p>
<p id="p-0042" num="0074">The third stage circuits <b>18</b>, <b>19</b>, <b>20</b>, <b>21</b> adjust the sum with pre-correction factors which depend on the carries generated from the first stage circuits <b>13</b>, <b>14</b>, <b>15</b>, <b>16</b>, the second stage carry look ahead circuit <b>17</b> and, in one case, the input carry C<b>0</b>.</p>
<p id="p-0043" num="0075">In general, the sum correction for a 4-bit block(say N down to N−3) adds first stage 4-bit sum vector TS[N:N−3] and a pre-correction factor. The pre-correction factor is one of the values of (TC<sub>N</sub>000)<sub>2 </sub>or (TC<sub>N</sub>001)<sub>2 </sub>or (TC<sub>N</sub>110)<sub>2 </sub>or (TC<sub>N</sub>111)<sub>2 </sub>which will be decided based on the carry C<sub>N−3 </sub>of previous 4-bits (N−4 down to N−7) and the carry C<sub>N+1 </sub>of current 4 bits(N down to N−3).</p>
<p id="p-0044" num="0076">For example, the general steps for sum correction block of bits <b>7</b> to <b>4</b> (where N=7) are:</p>
<p id="h-0010" num="0000">Step 1</p>
<p id="p-0045" num="0077">One of the values “TC<sub>7 </sub>0 0 0”, “TC<sub>7 </sub>0 0 1”, “TC<sub>7 </sub>1 1 0”, “TC<sub>7 </sub>1 1 1” will be selected by C<b>8</b> (Carry for bits <b>7</b> to <b>4</b>) and C<b>4</b> (carry of previous 4 bits i.e. bits <b>3</b> to <b>0</b>).
<ul id="ul0013" list-style="none">
    <li id="ul0013-0001" num="0000">
    <ul id="ul0014" list-style="none">
        <li id="ul0014-0001" num="0078">if C<b>8</b>=0 and C<b>4</b>=0=&gt;selection of TC<sub>7</sub>000. (TC<sub>7 </sub>is a single bit having value ‘1’ or ‘0’)</li>
        <li id="ul0014-0002" num="0079">if C<b>8</b>=0 and C<b>4</b>=1=&gt;selection of TC<sub>7</sub>001</li>
        <li id="ul0014-0003" num="0080">if C<b>8</b>=1 and C<b>4</b>=0=&gt;selection of TC<sub>7</sub>110</li>
        <li id="ul0014-0004" num="0081">if C<b>8</b>=1 and C<b>4</b>=1=&gt;selection of TC<sub>7</sub>111
<br/>
Step 2
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0046" num="0082">The above selected value will be added with first stage SUM vector TS[N:N−3].</p>
<p id="p-0047" num="0083">The first of the 4-bit group sum correction circuits, namely circuit <b>18</b>, will now be explained in detail.</p>
<p id="p-0048" num="0084">The inputs to the sum correction circuit <b>18</b> are the third intermediate sum vectors TS(<b>3</b>) to TS(<b>0</b>), the intermediate carry TC<b>3</b> from the first stage the input carry C<b>0</b> and the carry C<b>4</b> from the second stage carry look ahead circuit <b>17</b>.</p>
<p id="p-0049" num="0085">If the Pre-correction Factor (PF) is taken as PF(<b>3</b>) to PF(<b>0</b>), and the intermediate sum is TS(<b>3</b>) to TS(<b>0</b>), then the Final Sum will be obtained from the following steps, which have four levels of calculations.</p>
<p id="p-0050" num="0086">In the first level, a First Correction Sum vector FCS and a First Correction Carry vector FCC are calculated from the PF vector (PF(<b>3</b>) to PF(<b>0</b>)) and the TS vector (TS(<b>3</b>) to TS(<b>0</b>)) as shown in Table 1.</p>
<p id="p-0051" num="0087">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="105pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>First_Correction_Sum</entry>
<entry>First_Correction_Carry</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>FCS(3) = TS(3) XOR PF(3)</entry>
<entry>FCC(3) = TS(2) AND PF(2)</entry>
</row>
<row>
<entry/>
<entry>FCS(2) = TS(2) XOR PF(2)</entry>
<entry>FCC(2) = TS(1) AND PF(1)</entry>
</row>
<row>
<entry/>
<entry>FCS(1) = TS(1) XOR PF(1)</entry>
<entry>FCC(1) = TS(0) AND PF(0)</entry>
</row>
<row>
<entry/>
<entry>FCS(0) = TS(0) XOR PF(0)</entry>
<entry>FCC(0) = ‘0’</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0052" num="0088">In the second level, a Second Correction Sum SCS and a Second Correction Carry SCC are calculated from first level outputs FCS(<b>3</b>) to FCS(<b>0</b>) and FCC(<b>3</b>) to FCC(<b>3</b>) as shown in Table 2.</p>
<p id="p-0053" num="0089">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="105pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" rowsep="1">TABLE 2</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Second_Correction_Sum</entry>
<entry>Second_Correction_Carry</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SCS(3) = FCS(3) XOR FCC(3)</entry>
<entry>SCC(3) = FCS(2) AND FCC(2)</entry>
</row>
<row>
<entry/>
<entry>SCS(2) = FCS(2) XOR FCC(2)</entry>
<entry>SCC(2) = FCS(1) AND FCC(1)</entry>
</row>
<row>
<entry/>
<entry>SCS(1) = FCS(1) XOR FCC(1)</entry>
<entry>SCC(1) = FCS(0) AND FCC(0)</entry>
</row>
<row>
<entry/>
<entry>SCS(0) = FCS(0) XOR FCC(0)</entry>
<entry>SCC(0) = ‘0’</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0054" num="0090">In the third level, a Third Correction Sum TCS and Third Correction Carry TCC are calculated from second level outputs SCS(<b>3</b>) to SCS(<b>0</b>) and SCC(<b>3</b>) to SCC(<b>0</b>) as shown in Table 3.</p>
<p id="p-0055" num="0091">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="105pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" rowsep="1">TABLE 3</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Third_Correction_Sum</entry>
<entry>Third_Correction_Carry</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>TCS(3) = SCS(3) XOR SCC(3)</entry>
<entry>TCC(3) = SCS(2) AND SCC(2)</entry>
</row>
<row>
<entry/>
<entry>TCS(2) = SCS(2) XOR SCC(2)</entry>
<entry>TCC(2) = SCS(1) AND SCC(1)</entry>
</row>
<row>
<entry/>
<entry>TCS(1) = SCS(1) XOR SCC(1)</entry>
<entry>TCC(1) = SCS(0) AND SCC(0)</entry>
</row>
<row>
<entry/>
<entry>TCS(0) = SCS(0) XOR SCC(0)</entry>
<entry>TCC(0) = ‘0’</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0056" num="0092">In the fourth level, a final SUM vector is calculated from the third level outputs TCS(<b>3</b>) to TCS(<b>0</b>) and TCC(<b>3</b>) to TCC(<b>3</b>) as shown in Table 4.</p>
<p id="p-0057" num="0093">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" rowsep="1">TABLE 4</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Final_Sum</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SUM(3) = TCS(3) XOR TCC(3)</entry>
</row>
<row>
<entry/>
<entry>SUM(2) = TCS(2) XOR TCC(2)</entry>
</row>
<row>
<entry/>
<entry>SUM(1) = TCS(1) XOR TCC(1)</entry>
</row>
<row>
<entry/>
<entry>SUM(0) = TCS(0) XOR TCC(0)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0058" num="0094">As mentioned, the Pre-correction Factor PF(<b>3</b>) to PF(<b>0</b>) is, in part, dependent upon the carries C<b>0</b> and C<b>4</b>. The Pre-correction Factor PF(<b>3</b>) to PF(<b>0</b>) is given below for each of four cases:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>If the C4=‘0’ and C0=‘0’, the PF(3) to <i>PF</i>(0) is (TC3 0 0 0)  Case1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>If the C4=‘0’ and C0=‘1’, the PF(3) to <i>PF</i>(0) is (TC3 0 0 1)  Case2<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>If the C4=‘1’ and C0=‘0’, the PF(3) to <i>PF</i>(0) is (TC3 1 1 0)  Case3<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>If the C4=‘1’ and C0=‘1’, the PF(3) to <i>PF</i>(0) is (TC3 1 1 1)  Case4<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Case 1
</p>
<p id="p-0059" num="0095">The final SUM vector is obtained after substituting PF(<b>3</b>) to PF(<b>0</b>) values (TC<b>3</b> 0 0 1) in the First_Sum_Correction and First_Carry_Correction equations and then reducing the Second_Sum_Correction, Second_Carry_Correction, Third_Sum_Correction and Third_Carry_Correction equations. The finally reduced SUM vector is given below:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(3)=TS(3) XOR TC3  equ03<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(2)=TS(2)  equ02<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(1)=TS(1)  equ01<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(0)=TS(0)  equ00<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Case 2
</p>
<p id="p-0060" num="0096">The final SUM vector is obtained after substituting PF(<b>3</b>) to PF(<b>0</b>) values (TC<b>3</b> 0 0 1) in the First_Sum_Correction and First_Carry_Correction equations and then reducing the Second_Sum_Correction, Second_Carry_Correction, Third_Sum_Correction and Third_Carry_Correction equations. The finally reduced SUM vector is given below:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(3)=TS(3) XOR TC3 XOR (TS(0) AND TS(1) AND TS(2))  equ13<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(2)=(TS(0) AND TS(1)) XOR TS(2)  equ12<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(1)=TS(0) XOR TS(1)  equ11<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(0)=NOT TS(0)  equ10<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Case 3
</p>
<p id="p-0061" num="0097">The final SUM vector is obtained after substituting PF(<b>3</b>) to PF(<b>0</b>) values (TC<b>3</b> 1 1 0) in the First_Sum_Correction and First_Carry_Correction equations and then reducing the Second_Sum_Correction, Second_Carry_Correction, Third_Sum_Correction and Third_Carry_Correction equations. The finally reduced SUM vector is given below:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(3)=TS(3) XOR TC3 XOR (TS(1) OR TS(2))  equ23<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(2)=TS(1) XOR (NOT TS(2))  equ22<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(1)=NOT TS(1)  equ21<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(0)=TS(0)  equ20<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Case 4
</p>
<p id="p-0062" num="0098">The final SUM vector is obtained after substituting PF(<b>3</b>) to PF(<b>0</b>) values (TC<b>3</b> 1 1 1) in the First_Sum_Correction and First_Carry_Correction equations and then reducing the Second_Sum_Correction, Second_Carry_Correction, Third_Sum_Correction and Third_Carry_Correction equations. The finally reduced SUM vector is given below
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(3)=TS(3) XOR TC(3) XOR (TS(0) OR TS(1) OR TS(2))  equ33<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(2)=(TS(0) OR TS(1)) XOR(NOT TS(2))  equ32<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(1)=TS(0) XOR (NOT TS(1))  equ31<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SUM(0)=NOT TS(0)  equ30<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0063" num="0099">The implementation of SUM(<b>0</b>) correction circuit from equ00, equ10, equ20 and equ30 is shown in <figref idref="DRAWINGS">FIG. 8</figref>. The implementation of SUM(<b>1</b>) correction circuit from equ01, equ11, equ21 and equ31 is shown in <figref idref="DRAWINGS">FIG. 9</figref>. The implementation of SUM(<b>2</b>) correction circuit from equ02, equ12, equ22 and equ32 is shown in <figref idref="DRAWINGS">FIG. 10</figref>. The implementation of SUM(<b>3</b>) correction circuit from equ03, equ13, equ23 and equ33 is shown in <figref idref="DRAWINGS">FIG. 11</figref>.</p>
<p id="p-0064" num="0100">Clearly, there are equivalent circuits to those shown in <figref idref="DRAWINGS">FIGS. 8-11</figref> for each of the other sum correction circuits <b>19</b>, <b>20</b>, <b>21</b>, to generate SUM[<b>7</b>:<b>4</b>], SUM[<b>11</b>:<b>8</b>], and SUM[<b>15</b>:<b>12</b>] values.</p>
<p id="h-0011" num="0000">Final Sum</p>
<p id="p-0065" num="0101">The Final Sum of the BCD addition is the sequence of SUM[<b>15</b>:<b>12</b>], SUM[<b>11</b>:<b>8</b>], SUM[<b>7</b>:<b>4</b>], SUM [<b>3</b>:<b>0</b>]. A final carry, equal to C<b>16</b>, also results as an output.</p>
<p id="h-0012" num="0000">Critical Paths</p>
<p id="p-0066" num="0102">In the BCD addition circuit <b>12</b> as described, there are a number of critical paths in the three stages. Critical paths determine the number of logic levels required, and the speed at which addition can be performed.</p>
<p id="h-0013" num="0000">Critical Paths in the First Stage:</p>
<p id="p-0067" num="0103">CRITICAL_PATH<sub>—</sub>1—The path through circuits <b>22</b>, <b>23</b> and <b>24</b> which generates intermediate sum vector TS(<b>3</b>) to TS(<b>0</b>) from the BCD input operands A(<b>3</b>) to A(<b>0</b>) and B(<b>3</b>) to B(<b>0</b>) contains three XOR gates, and so the gate levels for this critical path is considered as 6.</p>
<p id="p-0068" num="0104">CRITICAL_PATH<sub>—</sub>2<i>a</i>—The path through circuits <b>22</b>, <b>23</b> and gates <b>26</b>, <b>28</b>, <b>30</b> from the BCD input operands to the generate function requires 7 gate levels.</p>
<p id="p-0069" num="0105">CRITICAL_PATH<sub>—</sub>2<i>b</i>—The path through circuits <b>22</b>, <b>23</b> and gates <b>25</b>, <b>27</b>, <b>30</b> from the BCD input operands to the generate function requires 7 gate levels.</p>
<p id="p-0070" num="0106">CRITICAL_PATH<sub>—</sub>2<i>c</i>—The path through circuits <b>22</b>, <b>23</b>, <b>24</b> and gate <b>29</b> from the BCD input operands to the propagate function requires 7 gate levels.</p>
<p id="h-0014" num="0000">Critical Paths in the Second Stage:</p>
<p id="p-0071" num="0107">CRITICAL_PATH<sub>—</sub>3—The carry look ahead circuit for 16-bit BCD addition (circuit <b>17</b> in <figref idref="DRAWINGS">FIG. 3</figref>) requires two gate levels of logic.</p>
<p id="h-0015" num="0000">Critical Paths in the Third Stage:</p>
<p id="p-0072" num="0108">CRITICAL_PATH<sub>—</sub>4—The SUM correction circuit's critical path (gates <b>77</b>, <b>78</b> and MUX <b>81</b> of <figref idref="DRAWINGS">FIG. 11</figref>) from first stage output intermediate sum vector to final SUM vector requires 6 levels of gates, of which 4 levels are calculated before receiving the carries from the carry look ahead circuit <b>17</b>.</p>
<p id="p-0073" num="0109">CRITICAL_PATH<sub>—</sub>5—The path from the carry look ahead output carries to the final SUM which has 2 gate levels (MUX <b>62</b> or MUX <b>66</b> or MUX <b>73</b> or MUX <b>81</b>).</p>
<p id="p-0074" num="0110">In the case of the 16-bit BCD adder circuit, the critical path is through SUM correction circuit and the path is CRITICAL_PATH<sub>—</sub>1 (6 gate levels)+CRITICAL_PATH<sub>—</sub>4 (6 gate levels). So the 16-bit BCD adder circuit has a delay of only 12 gate levels.</p>
<p id="p-0075" num="0111">In the case of a 64-bit or 32 bits BCD adder circuit, the critical path is through the Carry look ahead circuit and the path is CRITICAL_PATH<sub>—</sub>2<i>a </i>or CRITICAL_PATH<sub>—</sub>2<i>b </i>or CRITICAL_PATH<sub>—</sub>2<i>c </i>(all are 7 gate levels)+CRITICAL_PATH<sub>—</sub>3 (6 gate levels)+CRITICAL_PATH<sub>—</sub>5 (2 gate levels). Therefore, 64-bit or 32-bit BCD adder circuits have 15 gate levels of logic in the critical path.</p>
<p id="h-0016" num="0000">The 64-Bit Adder Circuit</p>
<p id="p-0076" num="0112">The 16-bit BCD adder of <figref idref="DRAWINGS">FIG. 2</figref> can be extended to a 32-bit or 64-bit form with extra carry look ahead network levels.</p>
<p id="p-0077" num="0113">A 64-bit BCD adder circuit includes three stages as discussed with reference to the 16-bit adder <b>12</b> shown in <figref idref="DRAWINGS">FIG. 2</figref>. As shown in <figref idref="DRAWINGS">FIG. 12</figref>, Stage <b>1</b> has sixteen logic circuits <b>90</b>, <b>92</b>, . . . , <b>118</b>, <b>120</b> of the type identified by numeral <b>13</b> in <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0078" num="0114">The circuits <b>90</b>-<b>120</b> receive contiguous 4-bit operands A[<b>3</b>:<b>0</b>] and B[<b>3</b>:<b>0</b>], A[<b>7</b>:<b>4</b>] and B[<b>7</b>:<b>4</b>], and so on, and generate respective intermediate sums TS[<b>3</b>:<b>0</b>], . . . TS[<b>63</b>:<b>60</b>], intermediate carries TC<b>3</b>, . . . , TC<b>63</b>, propagate functions P<b>3</b>-<b>0</b>, . . . , P<b>63</b>-<b>60</b>, and generate functions G<b>3</b>-<b>0</b>, . . . , G<b>63</b>-<b>60</b>.</p>
<p id="p-0079" num="0115">The second stage carry look ahead circuits are shown in <figref idref="DRAWINGS">FIG. 13</figref>. Five carry look ahead circuits <b>130</b>, <b>132</b>, <b>134</b>, <b>136</b>, <b>138</b> are required. These circuits are of the same for as the circuit <b>17</b> shown in <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0080" num="0116">The carry look ahead circuits are in two sub-stages: four circuits <b>130</b>, <b>132</b>, <b>134</b>, <b>136</b> coupled with the first stage circuits <b>90</b>-<b>120</b> to receive 4-bit propagate and generate functions, and a single circuit <b>138</b>, receiving 16-bit propagate and generate functions from the first sub-stage. The outputs from the second sub-stage to the third stage are the carries C<b>16</b>, C<b>32</b>, C<b>48</b>, and C<b>64</b>.</p>
<p id="p-0081" num="0117">The third stage, shown in <figref idref="DRAWINGS">FIG. 14</figref> has sixteen sum correction circuits <b>150</b>, <b>152</b>, . . . , <b>178</b>, <b>180</b>. Each of these circuits is implemented in the same manner as, for example, sum correction circuit <b>18</b> described with reference to <figref idref="DRAWINGS">FIGS. 8-11</figref>. Together, the sum correction circuits <b>150</b>-<b>180</b> calculate SUM[<b>3</b>:<b>0</b>] to SUM [<b>63</b>:<b>60</b>] giving the sum result of the operands A[<b>63</b>:<b>0</b>]+B[<b>63</b>:<b>0</b>]+C<sub>0</sub>. The final carry is the value C<b>64</b>.</p>
<p id="p-0082" num="0118">The 64-bit or 32-bit BCD adder requires six gate levels as shown in <figref idref="DRAWINGS">FIG. 13</figref> (circuits <b>130</b>, <b>132</b>, <b>134</b>, <b>136</b> and <b>138</b>) in the second stage critical path.</p>
<p id="p-0083" num="0119">The extension from 16-bit to 64-bit addition can be achieved with high reusability. A 64-bit adder circuit can be built by extending (i.e. reusing) the components of a 16-bit circuit four times, and adding only one extra level of a carry look ahead circuit.</p>
<p id="h-0017" num="0000">Conclusion</p>
<p id="p-0084" num="0120">The circuit described reduces the number of gate levels in the addition of two BCD-encoded operands with an input carry and makes the BCD addition fast.</p>
<p id="p-0085" num="0121">While the invention contemplates equal length blocks for the operands, the embodiment taught is 4-bit blocks. For the 16-bit adder, the blocks are of contiguous bits from the least to most significant bits. The use of 4-bit blocks is the most preferred, however, in that the fan-in and fan-out of carry look ahead logic is the least onerous to implement in hardware.</p>
<p id="p-0086" num="0122">Various alterations and modifications can be made to the techniques and arrangements described herein, as would be apparent to one skilled in the relevant art.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A binary coded decimal adder circuit for adding two operands and an input carry to give a sum comprising:
<claim-text>a first stage receiving said operands, grouping said operands into equal length blocks of contiguous bits and, for each said block, logically computing from said operands an intermediate sum vector, an intermediate carry vector, a propagate function and a generate function;</claim-text>
<claim-text>a second stage receiving said input carry and receiving from each said block of said first stage the respective propagate function and generate function, and carry look ahead computing therefrom carries for each said block and an output carry; and</claim-text>
<claim-text>a third stage, having the same number of blocks as said first stage, each third stage block receiving a respective intermediate sum vector, and logically adjusting said intermediate sum vector by pre-correction factors which depend upon a respective intermediate carry vector, at least two of the one of said second stage carries and said input carry; and</claim-text>
<claim-text>wherein outputs of said third stage logic blocks together represent said sum of operands.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The adder circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said blocks are 4-bits in length.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The adder circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said operands are of 16-bit length, and further wherein:
<claim-text>said first stage has a like logic circuit for each 4-bit block;</claim-text>
<claim-text>said second stage has a single carry look ahead logic circuit; and</claim-text>
<claim-text>said third stage has a like sum correction logic circuit for each 4-bit block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The adder circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said operands are of 64-bit length, and further wherein:
<claim-text>said first stage has a like logic circuit for each 4-bit block;</claim-text>
<claim-text>said second stage has a first carry look ahead level of four carry look ahead logic circuits providing partial carries to a second carry look ahead level of a single carry look ahead circuit; and</claim-text>
<claim-text>said third stage has a like sum correction circuit for each 4-bit block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The adder circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said pre-correction factors are calculated depending upon four cases of the logical combinations of two carries.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The adder circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein said pre-correction factors include the carry from the intermediate carry vector and a bit pattern depending upon the relevant one of said four cases.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The adder circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said intermediate sum vector and said intermediate carry vector are computed by three cascaded Half-Adder circuits.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The adder circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said pre-correction factors include one of four values decided on the basis of a carry from a preceding block and a carry from the current block.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A binary coded decimal adder circuit for adding two 4N-bit operands and an input carry to give a sum comprising:
<claim-text>a first stage receiving said operands, grouping said operands into N contiguous 4-bit length blocks and, for each said block, logically computing from said operands an intermediate sum vector, an intermediate carry vector, a propagate function and a generate function;</claim-text>
<claim-text>a second stage receiving said input carry and receiving from each said block of said first stage the respective propagate function and generate function, and carry look ahead computing therefrom carries for each said block and an output carry; and</claim-text>
<claim-text>a third stage, having the same number of blocks as said first stage, each third stage block receiving a respective intermediate sum vector, and logically adjusting said intermediate sum vector by pre-correction factors which depend upon a respective intermediate carry vector, at least two of the one of said second stage caries and said input carry; and</claim-text>
<claim-text>wherein outputs of said third stage logic blocks together represent said sum of operands.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The adder circuit of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein said pre-correction factors are calculated depending upon four cases of the logical combinations of two carries.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The adder circuit of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein said pre-correction factors include the carry from the intermediate carry vector and a bit pattern depending upon the relevant one of said four cases.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The adder circuit of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein said pre-correction factors are calculated from the carry C<sub>N−3 </sub>of the previous 4-bits and the carry C<sub>N+1 </sub>of the current 4-bits.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The adder circuit of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein said intermediate sum vector and said intermediate carry vector are computed by three cascaded Half-Adder circuits.</claim-text>
</claim>
</claims>
</us-patent-grant>
