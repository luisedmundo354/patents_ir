<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299225-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299225</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10304220</doc-number>
<date>20021126</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>452</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707  5</main-classification>
<further-classification>707  2</further-classification>
<further-classification>707  3</further-classification>
<further-classification>707  4</further-classification>
</classification-national>
<invention-title id="d0e53">High performance predicate push-down for non-matching predicate operands</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5386568</doc-number>
<kind>A</kind>
<name>Wold et al.</name>
<date>19950100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717162</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6032143</doc-number>
<kind>A</kind>
<name>Leung et al.</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6088524</doc-number>
<kind>A</kind>
<name>Levy et al.</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6345266</doc-number>
<kind>B1</kind>
<name>Ganguly et al.</name>
<date>20020200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6381616</doc-number>
<kind>B1</kind>
<name>Larson et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6385603</doc-number>
<kind>B1</kind>
<name>Chen et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6438541</doc-number>
<kind>B1</kind>
<name>Witkowski</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6578090</doc-number>
<kind>B1</kind>
<name>Motoyama et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719315</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6622138</doc-number>
<kind>B1</kind>
<name>Bellamkonda et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6748377</doc-number>
<kind>B1</kind>
<name>Attaluri</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2001/0037322</doc-number>
<kind>A1</kind>
<name>Lindsay et al.</name>
<date>20011100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2001/0051949</doc-number>
<kind>A1</kind>
<name>Carey et al.</name>
<date>20011200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2002/0016907</doc-number>
<kind>A1</kind>
<name>Grochowski et al.</name>
<date>20020200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2002/0069193</doc-number>
<kind>A1</kind>
<name>Beavin et al.</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2002/0078015</doc-number>
<kind>A1</kind>
<name>Ponnekanti</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2002/0112148</doc-number>
<kind>A1</kind>
<name>Wang et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2002/0120620</doc-number>
<kind>A1</kind>
<name>Chan et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2003/0135758</doc-number>
<kind>A1</kind>
<name>Turner</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713201</main-classification></classification-national>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2003/0187858</doc-number>
<kind>A1</kind>
<name>Kirk et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2004/0111713</doc-number>
<kind>A1</kind>
<name>Rioux</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717137</main-classification></classification-national>
</citation>
<citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2004/0128657</doc-number>
<kind>A1</kind>
<name>Ghiya et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717141</main-classification></classification-national>
</citation>
<citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2004/0268309</doc-number>
<kind>A1</kind>
<name>Grover et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717120</main-classification></classification-national>
</citation>
<citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2005/0015673</doc-number>
<kind>A1</kind>
<name>Plesko et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 38</main-classification></classification-national>
</citation>
<citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2005/0039124</doc-number>
<kind>A1</kind>
<name>Chu et al.</name>
<date>20050200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715531</main-classification></classification-national>
</citation>
<citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2005/0097084</doc-number>
<kind>A1</kind>
<name>Balmin et al.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</citation>
<citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2005/0097523</doc-number>
<kind>A1</kind>
<name>Uchida</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717136</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00027">
<othercit>“Type-Checking OQL Queries in the ODMG Type Systems” by Suad Alagic, ACM transactions on Database Systems, vol. 24, No. 3, Sep. 1999, pp. 319-360.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00028">
<othercit>“C How To Program” by H.M. Deitel/P.J. Deitel, 2<sup>nd </sup>edition, Prentice Hall 1994, 1992, pp. 61, 73-74, 122-125, 158, and 699-700.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00029">
<othercit>“Coping With Type Casts in C” by Michael Siff, Satish Chandra, Thomas Ball, Krishna Kunchithapadam, and Thomas Reps, Mathematics Department, Sarah Lawrence Colleg, Bronxville, NY 10708-5999; Bell Laboratories, Lucent Technologies, Naperville, IL 60566.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00030">
<othercit>“ORACLE7 The Complete Reference” by George Koch, Covers Versions 6 &amp; 7, pp. 147, 150-151, 738, 762, and 896-897.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00031">
<othercit>W. Zhang et al., “Speeding up Heterogeneous Data Access by Converting and Pushing down String Comparisons,” IEEE, 1999, 3 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>60</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707  2</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  3</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707103</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  6</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  4</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  5</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>3</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20040103082</doc-number>
<kind>A1</kind>
<date>20040527</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Tran</last-name>
<first-name>Brian T.</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Cheng</last-name>
<first-name>Hsiuying Y.</first-name>
<address>
<city>Fremont</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Guo</last-name>
<first-name>Shuanglin</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="004" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Malone</last-name>
<first-name>Patrick M.</first-name>
<address>
<city>Campbell</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="005" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Beavin</last-name>
<first-name>Thomas A.</first-name>
<address>
<city>Milpitas</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="006" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Wang</last-name>
<first-name>Xiazhen</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="007" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Li</last-name>
<first-name>Xun</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Gates &amp; Cooper LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Wong</last-name>
<first-name>Don</first-name>
<department>2163</department>
</primary-examiner>
<assistant-examiner>
<last-name>Dang</last-name>
<first-name>Thanh-Ha</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method, apparatus, and article of manufacture for improving the performance of evaluating predicates with non-matching operands by aggressively casting the input value to the data type of the target column before the data of the target column is accessed.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="144.10mm" wi="171.20mm" file="US07299225-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="176.36mm" wi="161.88mm" orientation="landscape" file="US07299225-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="219.88mm" wi="155.11mm" file="US07299225-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="217.68mm" wi="157.73mm" file="US07299225-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">This invention relates in general to database management systems performed by computers, and in particular, to the optimization of queries using a high performance predicate push-down for non-matching predicate operands.</p>
<p id="p-0004" num="0003">2. Description of Related Art</p>
<p id="p-0005" num="0004">Computer systems incorporating a Relational DataBase Management System (RDBMS) using a Structured Query Language (SQL) interface are well known in the art. The SQL interface has evolved into a standard language for the RDBMS and has been adopted as such by both the American Nationals Standard Institute (ANSI) and the International Standards Organization (ISO).</p>
<p id="p-0006" num="0005">In an RDBMS, predicates of SQL queries can be evaluated at various stages and the performance of the predicates can be significantly different depending on where and when they are evaluated. Generally speaking, better performance is obtained when the predicate is evaluated at an earlier stage.</p>
<p id="p-0007" num="0006">Without loss of generality, assume that the predicates are of the form “column operator expression,” which is abbreviated as “col op exp,” where:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0007">“col” represents an inner table column, also known as a target column;</li>
        <li id="ul0002-0002" num="0008">“exp” represents an input value, which could be a literal value, constant expression, column or column expression; and</li>
        <li id="ul0002-0003" num="0009">“op” represents a comparison operator, such as =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, etc.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0008" num="0010">Most, if not all, RDBMS attempt to “push down” predicates to a data manager or index manager for better performance. For example, consider a query against a 10,000 row table with predicate P1 whose filter factor is 1%. In the prior art, P1 may be evaluated only after all 10,000 rows are fetched, which results in P1 being evaluated 10,000 times, i.e., once for each row. Alternatively, P1 could be used to determine a search range in a B-tree index, which results in only 100 rows being fetched (i.e., 1% of the rows).</p>
<p id="p-0009" num="0011">For predicates with non-matching operands, such as type, length, or CCSID (Coded Character Set ID), the operands are “cast” to a common data type, length and CCSID before the comparison takes place. The term “cast” in this context refers to a conversion between data types. In the prior art, depending on the data types of both operands in the predicate, either or both the target column and the input value may be “cast-up” to a common data type before the operator of the predicate is performed.</p>
<p id="p-0010" num="0012">One prior art approach is to always cast-up the “smaller” operand to match the “larger” one. The cast-up could be performed on the input value, target column, or both. For example, in a predicate comprised of “integer_col op smallint_exp,” the input value “smallint_exp” may be cast-up to “integer,” the data type of the target column “integer_col.” In another example, in a predicate comprised of “smallint_col op integer_exp,” each target column “smallint_col” may be cast-up to “integer,” the data type of the input value “integer_exp.” In yet another example, in a predicate comprised of “decimal(5,3)_col op decimal(7,1)_exp,” both operands maybe cast-up to the data type “decimal(9,3).”</p>
<p id="p-0011" num="0013">Although this is easy to implement, always casting up the smaller operand may cause excessive data conversions, for example, when the operand being cast-up is a target column. In this situation, the system has to convert every row it retrieves from the inner table. This is an enormous amount of data conversion overhead, which could significantly slow down performance, especially when predicates involve a large number of table accesses.</p>
<p id="p-0012" num="0014">This can be best described by means of an example. Assume that the SALARY column of the EMPLOYEE table is an “integer” data type, and the following SQL query is executed:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SELECT*FROM EMPLOYEE E WHERE E.SALARY&gt;70000.00<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0013" num="0015">Casting the SALARY column to “float” results in a data conversion for each row fetched. It would be desirable if, in this example, the data conversion takes place only once for the entire query. This requires that, instead of casting up the SALARY column, the input value “70000.00” be cast-down to “integer,” which works since there is a corresponding value in the integer domain for 70000.00, i.e., 70000. However, this is not a safe conversion in general, since certain floating point numbers may not fall in the range of a 4-byte integer.</p>
<p id="p-0014" num="0016">Thus, there is a need in the art for a technique that obtains aggressive predicate push down with reduced casts, which is accomplished by the present invention. Specifically, the present invention supports “cast-down,” which allows casts such as “integer” to “smallint,” “char(32)” to “varchar(16),” etc., as well as cast-up. Using a cast-up or cast-down, the present invention always casts the input value to the data type of the target column, which significantly reduces the overhead involved in data conversions.</p>
<p id="p-0015" num="0017">Moreover, instead of blindly making judgments that an attempt to cast “integer” to “smallint” will fail, the present invention permits the RDBMS to perform the cast and then to determine from the result whether the cast will succeed or fail. For example, a cast of the string “database” of type “varchar(15)” to type “char(10)” will succeed.</p>
<p id="p-0016" num="0018">Further, even failed casts can improve the performance of the RDBMS. For example, in a predicate comprised of “decimal(2,1)_col=1234.5,” a cast failure indicates that the predicate is always false, which leads the RDBMS to skip the table access. Thus, the RDBMS can properly identify and evaluate failed casts, which significantly reduces the overhead of data conversions.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0017" num="0019">To overcome the limitations in the prior art described above, and to overcome other limitations that will become apparent upon reading and understanding the present specification, the present invention discloses a method, apparatus, and article of manufacture for improving the performance of evaluating predicates with non-matching operands by aggressively casting the input value to the data type of the target column before the data of the target column is accessed.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0018" num="0020">Referring now to the drawings in which like reference numbers represent corresponding parts throughout:</p>
<p id="p-0019" num="0021"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an exemplary computer hardware and software environment that could be used with an embodiment of the present invention; and</p>
<p id="p-0020" num="0022"><figref idref="DRAWINGS">FIGS. 2 and 3</figref> are flowcharts illustrating a method of optimizing a query in a computer system, the query being performed by the computer system to retrieve data from a database stored on the computer system, according to the preferred embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
<p id="p-0021" num="0023">In the following description of the preferred embodiment, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration a specific embodiment in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural and functional changes may be made without departing from the scope of the present invention.</p>
<heading id="h-0005" level="1">Hardware Environment</heading>
<p id="p-0022" num="0024"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an exemplary computer hardware and software environment that could be used with an embodiment of the present invention. In the exemplary environment, a computer system <b>100</b> is comprised of one or more processors connected to one or more data storage devices <b>102</b> and <b>104</b>, such as disk drives, that store one or more relational databases.</p>
<p id="p-0023" num="0025">An interface <b>106</b>, such as TCP/IP™, IMS/DB/DC™, CICS™, TSO™, WINDOWS™ or other similar interface, is used to connect a client computer <b>108</b> to the computer <b>100</b>, in order that client computer <b>108</b> may transmit electrical signals to and from the computer system <b>100</b> that represent commands for performing various search and retrieval functions, termed queries, against the databases. In the present invention, these queries conform to the Structured Query Language (SQL) standard, and invoke functions performed by a Relational DataBase Management System (RDBMS). In the preferred embodiment of the present invention, the RDBMS comprises the DB2™ product offered by I.B.M. Corporation for the MVS™, UNIX™, or WINDOWS™ operating systems. Those skilled in the art will recognize, however, that the present invention has application to any RDBMS.</p>
<p id="p-0024" num="0026">As illustrated in <figref idref="DRAWINGS">FIG. 1</figref>, the RDBMS includes three major components: a Lock Manager module <b>110</b>, Systems Services module <b>112</b>, and Database Services module <b>114</b>. The Lock Manager module <b>110</b> handles locking services, because the RDBMS treats data as a shared resource, thereby allowing any number of users to access the same data simultaneously, and thus concurrency control is required to isolate users and to maintain data integrity. The Systems Services module <b>112</b> controls the overall RDBMS execution environment, including managing log data sets <b>106</b>, gathering statistics, handling startup and shutdown, and providing management support.</p>
<p id="p-0025" num="0027">At the heart of the RDBMS architecture is the Database Services module <b>114</b>. The Database Services module <b>114</b> contains several submodules, including the Relational Database System (RDS) <b>116</b>, the Data Manager <b>118</b>, and the Index Manager <b>120</b>, as well as other components, such as an SQL compiler/interpreter <b>122</b>. These submodules support the functions of the SQL language, i.e., definition, access control, retrieval, and update of user and system data.</p>
<p id="p-0026" num="0028">Generally, each of the components, modules, and submodules of the RDBMS comprise instructions and/or data, and are embodied in or retrievable from a computer-readable device, medium, signal or carrier, e.g., a memory, a data storage device, a remote device coupled to the computer <b>100</b> by a data communications device, etc. Moreover, these instructions and/or data, when read, executed, and/or interpreted by the computer <b>100</b>, cause the computer <b>100</b> to perform the steps necessary to implement and/or use the present invention.</p>
<p id="p-0027" num="0029">Thus, the present invention may be implemented as a method, apparatus, or article of manufacture using standard programming and/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term “article of manufacture,” or alternatively, “computer program carrier,” as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope of the present invention.</p>
<p id="p-0028" num="0030">Those skilled in the art will recognize that any combination of the above components, or any number of different components, including computer programs, peripherals, and other devices, may be used to implement the present invention, so long as similar functions are performed thereby.</p>
<heading id="h-0006" level="1">Operation of the Preferred Embodiment</heading>
<p id="p-0029" num="0031">The present invention improves the performance of evaluating predicates with non-matching operands by aggressively casting the input value to the data type of the target column before the data of the target column is accessed.</p>
<p id="p-0030" num="0032">Consider the following example. Assume that the predicate of a two table join is comprised of “T<sub>inner</sub>, C<sub>inner</sub>=T<sub>outer</sub>, C<sub>outer</sub>” wherein T<sub>inner </sub>is an inner table, C<sub>inner </sub>is a column of the inner table, T<sub>outer </sub>is an outer table, and C<sub>outer </sub>is a column of the outer table, and in which C<sub>inner </sub>and C<sub>outer </sub>have different data types. Moreover, assume that T<sub>inner </sub>has 10,000 rows and T<sub>outer </sub>has 3,000 rows.</p>
<p id="p-0031" num="0033">In the prior art, if C<sub>outer </sub>can be cast to the data type of the target column C<sub>inner</sub>, it will involve 3,000 casts (for each row of T<sub>outer</sub>). On the other hand, if C<sub>outer </sub>cannot be cast to the data type of the target column C<sub>inner</sub>, then C<sub>inner </sub>needs to be cast to the data type of the input value C<sub>outer </sub>(for each row of T<sub>inner </sub>and T<sub>outer</sub>). This casting of the target column will result in 30,000,000 casts (10,000*3,000) only on T<sub>inner </sub>and 30,003,000 casts (30,000,000+3,000) on both T<sub>inner </sub>and T<sub>outer</sub>.</p>
<p id="p-0032" num="0034">With the present invention, C<sub>outer </sub>is cast to the data type of C<sub>inner </sub>only once before T<sub>inner </sub>is accessed. Therefore, no cast is needed on C<sub>inner</sub>. Consequently, the total number of casts (3000) is dramatically reduced, as compared to the prior art approach.</p>
<p id="p-0033" num="0035">Generally, in the technique of the present invention, the input value is cast to the data type of the target column before accessing the target table. Depending on the data types of the input value and target column, the cast could be a cast-up or cast-down.</p>
<p id="p-0034" num="0036">A cast-up should never fail. Therefore, no special handling is needed before the predicate is pushed down to the Data Manager <b>118</b> or Index Manager <b>120</b>. Prior art implementations will suffice.</p>
<p id="p-0035" num="0037">However, a cast-down is more complicated. In some cases, the cast-down could be successful, for example, a cast-down of a 4-byte “integer” value of “1” to a 2-byte “smallint” value of “1”. In many other cases, however, a cast-down could be problematic, due to overflow, underflow, or loss of precision errors.</p>
<p id="p-0036" num="0038">Consider an example that casts “decimal_col” to “smallint”:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0039">An overflow error occurs if the value of the decimal_col is larger than MAX_SMALLINT (“32767”).</li>
        <li id="ul0004-0002" num="0040">An underflow error occurs if the value of the decimal_col is smaller than MIN_SMALLINT (“−32768”)</li>
        <li id="ul0004-0003" num="0041">A loss of precision error occurs when the decimal digits are truncated when cast from “decimal_col” to “smallint.” For example, a loss of precision results when a decimal “123.65” is truncated to “123.”</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0037" num="0042">If the RDBMS detects any type of error during the cast, based on a comparison operator of the predicate and the error symptom, then the RDBMS pre-processes the predicate and replaces it with an appropriately revised predicate. If the revised predicate is “FALSE,” then the target table access is skipped, or if the revised predicate is “TRUE,” then the predicate evaluation is skipped; otherwise, the revised predicate is pushed down to the data manager or index manager.</p>
<p id="p-0038" num="0043">The following describes how errors in the cast-down are handled by the RDBMS.
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0044">A. If the operator is “=” (EQUAL), then the predicate is replaced by “FALSE,” and table access is skipped. Example: the predicate comprises “smallint_col=decimal_col,” and the value of the decimal_col is larger than MAX_SMALLINT (“32767”).</li>
        <li id="ul0006-0002" num="0045">B. If the operator is “&lt;&gt;” (NOT EQUAL), then the predicate is to be replaced by “TRUE, ” predicate evaluation is skipped and all records of target table are fetched. Example: the predicate comprises “smallint_col&lt;&gt;decimal_col,” and the value of the decimal_col is larger than MAX_SMALLINT (“32767”).</li>
        <li id="ul0006-0003" num="0046">C. If the operator is “&gt;” (GREATER THAN), “&gt;=” (GREATER THAN OR EQUAL TO), “&lt;” (LESS THAN) or “&lt;=” (LESS THAN OR EQUAL TO), then the predicate is replaced by a revised predicate based on the error symptom of the cast.
        <ul id="ul0007" list-style="none">
            <li id="ul0007-0001" num="0047">1. Case 1: Overflow Error
            <ul id="ul0008" list-style="none">
                <li id="ul0008-0001" num="0048">If the operator is “&gt;” or “&gt;=,” then the predicate is replaced by “FALSE.” Example: the predicate comprises “smallint_col&gt;decimal_col,” and the value of decimal_col is larger than MAX_SMALLINT (“32767”).</li>
                <li id="ul0008-0002" num="0049">If the operator is “&lt;” or “&lt;=,” then the predicate is replaced by “TRUE.” Example: the predicate comprises “smallint_col&gt;decimal_col,” and the value of the decimal_col is larger than MAX_SMALLINT (“32767”).</li>
            </ul>
            </li>
            <li id="ul0007-0002" num="0050">2. Case 2: Underflow Error
            <ul id="ul0009" list-style="none">
                <li id="ul0009-0001" num="0051">If the operator is “&gt;” or “&gt;=,” then the predicate is replaced by “TRUE.” Example: the predicate comprises “smallint_col&gt;decimal_col,” and the value of decimal_col is smaller than MIN_SMALLINT (“−32768”).</li>
                <li id="ul0009-0002" num="0052">If the operator is “&lt;” or “&lt;=,” then the predicate is replaced by “FALSE.” Example: the predicate comprises “smallint_col&lt;decimal_col,” and the value of decimal_col is smaller than MIN_SMALLINT (“−32768”).</li>
            </ul>
            </li>
            <li id="ul0007-0003" num="0053">3. Case 3: Loss of Precision Error
            <ul id="ul0010" list-style="none">
                <li id="ul0010-0001" num="0054">If the operator is “&gt;” or “&lt;=,” then the input value is rounded down to the data type of the target column. If an underflow error occurs during the round down, then the predicate is handled in the same way as Case 2 above. Instead of the original predicate, the revised predicate is pushed down to the data manager or index manager. Example: the predicate is comprised of “smallint_col&gt;decimal_col(10,2),” and the “decimal” value is cast to “smallint.”</li>
                <li id="ul0010-0002" num="0055">If the input decimal value is “123.65,” then a loss of precision error occurs due to truncation. In this case, the input value is rounded down to “123,” and the “smallint” value “123” is used as the input value to compare with “smallint_col.”</li>
                <li id="ul0010-0003" num="0056">If the input decimal value is “−32768.3,” then it is rounded down to “−32769,” which is smaller than MIN_SMALLINT (−32768). The predicate is replaced by “TRUE” if the operator is “&gt;,” or “FALSE” if the operator is “&lt;=.”</li>
                <li id="ul0010-0004" num="0057">If the operator is “&lt;” or “&gt;=,” then the input value is rounded up to the data type of the target column. If an overflow error occurs during the round up, then the predicate is handled in the same way as Case 1 above. Instead of the original predicate, the revised predicate is pushed down to the data manager or index manager. Example: the predicate is comprised of “smallint_col&lt;decimal_col,” and the “decimal” value is cast to “smallint.”</li>
                <li id="ul0010-0005" num="0058">If the input decimal value is “123.65,” then a loss of precision error occurs due to truncation. In this case, the input value is rounded up to “124” and the “smallint” value “124” is used as the input value to compare with the “smallint_col.”</li>
                <li id="ul0010-0006" num="0059">If the input decimal value is “32767.3,” then it is rounded up to “32768,” which is larger than MAX_SMALLINT (32767). The predicate is replaced by “TRUE” if operator is “&lt;” or “FALSE” if operator is “&gt;=.”</li>
            </ul>
            </li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0039" num="0060">With the support of cast-down, input values of all data types can be aggressively cast to the data type of the target column, except for one case: when the input value is “float” and the target column is “decimal(p,s)” with p&gt;15. The imprecise representation of the “float” data type makes the mapping between “float” data and “decimal” data be 1-to-n if the precision of the “decimal” data is beyond what the “float” type can represent (i.e., p&gt;15). That is, when mapping from “float” type to “decimal” type, the digits after the 15th digit of “decimal” data become insignificant. For example, a “float” value of 1.0e+0 is considered to be “equal” to “decimal” value 1.000 . . . 0001, 1.000 . . . 0002, . . . , or 1.000 . . . 0009, if the last digit of the “decimal” value in this example is beyond the 15<sup>th </sup>digit.</p>
<p id="p-0040" num="0061">The approach to solve this problem is to add an extra range predicate that can be pushed down to the Data Manager <b>118</b> or Index Manager <b>120</b> to screen out the rows of the inner column table before evaluating the original predicate. This extra range predicate is indexable, sargable, and highly selective. As a result, the Index Manager <b>120</b> is able to use it to construct very narrow start and stop keys to restrict the range of rows to be retrieved, so that only a few of rows are fetched. The evaluation time of the original predicate would be significantly reduced.</p>
<p id="p-0041" num="0062">Consider the following example, where is the predicate is comprised of “decimal_col=float_col” and the “decimal_col” is defined as “decimal (17,16).” In addition to the original predicate, an indexable and sargable range predicate is added as:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>decimal_col BETWEEN (CAST (float_col AS DECIMAL)−δ) AND<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(CAST (float_col AS DECIMAL)+δ)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0042" num="0063">Where δ is a small constant in the “decimal_col” data type. Since a cast from “float” to “decimal” is a problematic cast, an overflow or underflow error can occur. If an overflow or underflow error occurs, the predicate is handled in the same way, as either Case 1 or Case 2 above.</p>
<heading id="h-0007" level="1">Logic of the Preferred Embodiment</heading>
<p id="p-0043" num="0064"><figref idref="DRAWINGS">FIGS. 2 and 3</figref> are flowcharts illustrating a method of optimizing a query in a computer system, the query being performed by the computer system to retrieve data from a database stored on the computer system, according to the preferred embodiment of the present invention.</p>
<p id="p-0044" num="0065">Referring to <figref idref="DRAWINGS">FIG. 2</figref>, Block <b>200</b> represents the RDBMS evaluating the query, wherein the query is comprised of at least one predicate having a first operand comprising an input value, an operator and a second operand comprising a target column.</p>
<p id="p-0045" num="0066">Block <b>202</b> is a decision block that represents the RDBMS determining whether an attempt is being made to cast-down a “float” input to a “decimal” target column, when the “decimal” target column has a precision greater than 15. If so, control transfers to Block <b>204</b>; otherwise, control transfers to Block <b>206</b>.</p>
<p id="p-0046" num="0067">Block <b>204</b> represents the RDBMS adding a range predicate when casting down a “float” input value to a “decimal” target column, when the “decimal” target column has a precision greater than 15. The range predicate is used to construct start and stop keys to restrict a range of rows to be retrieved, so that only a few of the rows are fetched. Thereafter, control transfers to Block <b>218</b>.</p>
<p id="p-0047" num="0068">Block <b>206</b> represents the RDBMS casting down the input value to a data type of the target column before the target column is accessed, when the evaluated query has non-matching first and second operands in the predicate.</p>
<p id="p-0048" num="0069">Block <b>208</b> is a decision block that represents the RDBMS determining whether an error occurred when the input value is cast-down, wherein the error is selected from a group comprising overflow, underflow, or loss of precision errors. If so, control transfers to Block <b>206</b>; otherwise, control transfers to Block <b>218</b>.</p>
<p id="p-0049" num="0070">The logic in the following Blocks comprises detecting the error during the cast-down, based on the operator of the predicate and the error, and then processing the predicate, i.e., not accessing the target column when the predicate is false, not evaluating the predicate when the predicate is true, and pushing down the predicate when the predicate is neither true nor false. This logic is described in more detail below.</p>
<p id="p-0050" num="0071">Block <b>210</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is an “EQUAL” (=) operator. If so, control transfers to Block <b>212</b>; otherwise, control transfers to Block <b>214</b>.</p>
<p id="p-0051" num="0072">Block <b>212</b> represents the RDBMS identifying the predicate as false, and not accessing the target column, when an operator of the predicate is an “EQUAL” operator. Thereafter, control transfers to Block <b>218</b>.</p>
<p id="p-0052" num="0073">Block <b>214</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is a “NOT EQUAL” (&lt;&gt;) operator. If so, control transfers to Block <b>216</b>; otherwise, control transfers to <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0053" num="0074">Block <b>216</b> represents the RDBMS identifying the predicate as true, not evaluating the predicate, and fetching all rows of the target column, when an operator of the predicate is a “NOT EQUAL” operator. Thereafter, control transfers to Block <b>218</b>.</p>
<p id="p-0054" num="0075">Block <b>218</b> represents the RDBMS executing the query.</p>
<p id="p-0055" num="0076">Referring to <figref idref="DRAWINGS">FIG. 3</figref>, this logic is performed when an operator of the predicate is a “GREATER THAN” (&gt;), “GREATER THAN OR EQUAL TO” (&gt;=), “LESS THAN” (&lt;) or “LESS THAN OR EQUAL TO” (&lt;=) operator.</p>
<p id="p-0056" num="0077">Block <b>300</b> is a decision block that represents the RDBMS determining whether an overflow error occurred. If so, control transfers to Block <b>302</b>; otherwise, control transfers to Block <b>310</b>.</p>
<p id="p-0057" num="0078">Block <b>302</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is a “GREATER THAN” (&gt;), or “GREATER THAN OR EQUAL TO” (&gt;=) operator. If so, control transfers to Block <b>304</b>; otherwise, control transfers to Block <b>306</b>.</p>
<p id="p-0058" num="0079">Block <b>304</b> represents the RDBMS identifying the predicate as false when the error is an overflow error and the operator of the predicate is a “GREATER THAN” or “GREATER THAN OR EQUAL TO” operator. Thereafter, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0059" num="0080">Block <b>306</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is a “LESS THAN” (&lt;) or “LESS THAN OR EQUAL TO” (&lt;=) operator. If so, control transfers to Block <b>308</b>; otherwise, control transfers to Block <b>310</b>.</p>
<p id="p-0060" num="0081">Block <b>308</b> represents the RDBMS identifying the predicate as true when the error is an overflow error and the operator of the predicate is a “LESS THAN” or “LESS THAN OR EQUAL TO” operator. Thereafter, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0061" num="0082">Block <b>310</b> is a decision block that represents the RDBMS determining whether an underflow error occurred. If so, control transfers to Block <b>312</b>; otherwise, control transfers to Block <b>320</b>.</p>
<p id="p-0062" num="0083">Block <b>312</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is a “GREATER THAN” (&gt;) or “GREATER THAN OR EQUAL TO” (&gt;=) operator. If so, control transfers to Block <b>314</b>; otherwise, control transfers to Block <b>316</b>.</p>
<p id="p-0063" num="0084">Block <b>314</b> represents the RDBMS identifying the predicate as true when the error is an underflow error and the operator of the predicate is a “GREATER THAN” or “GREATER THAN OR EQUAL TO” operator. Thereafter, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0064" num="0085">Block <b>316</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is a “LESS THAN” (&lt;) or “LESS THAN OR EQUAL TO” (&lt;=) operator. If so, control transfers to Block <b>318</b>; otherwise, control transfers to Block <b>320</b>.</p>
<p id="p-0065" num="0086">Block <b>318</b> represents the RDBMS identifying the predicate as false when the error is an underflow error and the operator of the predicate is a “LESS THAN” or “LESS THAN OR EQUAL TO” operator. Thereafter, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0066" num="0087">Block <b>320</b> is a decision block that represents the RDBMS determining whether a loss of precision error occurred. If so, control transfers to Block <b>322</b>; otherwise, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0067" num="0088">Block <b>322</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is a “GREATER THAN” (&gt;) or “LESS THAN OR EQUAL TO” (&lt;=) operator. If so, control transfers to Block <b>324</b>; otherwise, control transfers to Block <b>326</b>.</p>
<p id="p-0068" num="0089">Block <b>324</b> represents the RDBMS rounding down the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “GREATER THAN” or “LESS THAN OR EQUAL TO” operator. Moreover, this Block represents the RDBMS identifying the predicate as true when the rounding down causes an underflow error and the operator of the predicate is a “GREATER THAN” operator. Further, this Block represents the RDBMS identifying the predicate as false when the rounding down causes an underflow error and the operator of the predicate is a “LESS THAN OR EQUAL TO” operator. Thereafter, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0069" num="0090">Block <b>326</b> is a decision block that represents the RDBMS determining whether an operator of the predicate is a “LESS THAN” (&lt;) or “GREATER THAN OR EQUAL TO” (&gt;=) operator. If so, control transfers to Block <b>328</b>; otherwise, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0070" num="0091">Block <b>328</b> represents the RDBMS rounding up the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “LESS THAN” or “GREATER THAN OR EQUAL TO” operator. Moreover, this Block represents the RDBMS identifying the predicate as true when the rounding up causes an underflow error and the operator of the predicate is a “GREATER THAN OR EQUAL TO” operator. Further, this Block represents the RDBMS identifying the predicate as false when the rounding up causes an underflow error and the operator of the predicate is a “LESS THAN” operator. Thereafter, control returns to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<heading id="h-0008" level="1">CONCLUSION</heading>
<p id="p-0071" num="0092">This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the present invention. For example, any type of computer, such as a mainframe, minicomputer, or personal computer, could be used with the present invention. In addition, any software program using predicates could benefit from the present invention.</p>
<p id="p-0072" num="0093">In summary, the present invention discloses a method, apparatus, and article of manufacture for improving the performance of evaluating predicates with non-matching operands by aggressively casting the input value to the data type of the target column before the data of the target column is accessed.</p>
<p id="p-0073" num="0094">The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of optimizing a query in a computer system comprising the steps of:
<claim-text>(a) evaluating the query, wherein the query is comprised of at least one predicate having a first operand comprising an input value, an operator and a second operand comprising a target column;</claim-text>
<claim-text>(b) casting down the input value to a data type of the target column before the target column is accessed, when the evaluated query has non-matching first and second operands in the predicate;</claim-text>
<claim-text>(c) detecting when an error occurs when the input value is cast-down, and then processing the predicate based on the detected error and the operator associated with the predicate; and</claim-text>
<claim-text>(d) performing the query in the computer system to retrieve data from a database in order to present the data to a user.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the error is an overflow, underflow, or loss of precision error.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing step further comprises the step of not accessing the target column when the predicate is false.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing step further comprises the step of not evaluating the predicate when the predicate is true.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing step further comprises the step of pushing down the predicate when the predicate is neither true nor False.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false, and nor accessing the target column, when the operator of the predicate is an “equal” operator.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true, not evaluating the predicate, and fetching all rows of the target column, when the operator of the predicate is a “not equal” operator.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing step further comprises the step of replacing the predicate with a revised predicate based on the error, when the operator of the predicate is a “greater than,” “greater than or equal to,” “less tan” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the error is an overflow error and the operator of the predicate is a “greater than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true when the error is an overflow error and the operator of the predicate is a “less than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true when the error as an underflow error and the operator of the predicate is a “greater than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the error is an underflow error and the operator of the predicate is a “less than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing step further comprises the step of rounding down the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “greater than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true when the rounding down causes an underflow error and the operator of the predicate is a “greater than” operator.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the rounding down causes an underflow error and the operator of the predicate is a “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing step further comprises the step of rounding up the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “less than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true when the rounding up causes an underflow error and the operator of the predicate is a “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the rounding up causes an underflow error and the operator of the predicate is a “less than” operator.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the processing step further comprises the step of adding a range predicate when casting down a “float” input value to a “decimal” target column, when the “decimal” target column has a precision greater than 15.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the range predicate is used to construct start and stop keys to restrict a range of rows to be retrieved, so that only a few of rows are fetched.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. A computer-implemented apparatus for optimizing a query, comprising:
<claim-text>(a) a computer system;</claim-text>
<claim-text>(b) logic, performed by the computer system, for;
<claim-text>(1) evaluating the query, wherein the query is comprised of at least one predicate having a first operand comprising an input value, an operator and a second operand comprising a target column;</claim-text>
<claim-text>(2) casting down the input value to a data type of the target column before the target column is accessed, when the evaluated query is has non-matching first and second operands in the predicate;</claim-text>
<claim-text>(3) detecting when an error occurs when the input value is cast-down, and then processing the predicate based on the detected error and the operator associated with the predicate; and</claim-text>
<claim-text>(4) performing the query to retrieve data from a database in order to present the data to a user.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The apparatus of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the error is an overflow, underflow, or loss of precision error.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The apparatus of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the logic for processing further comprises logic for not accessing the target column when the predicate is false.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The apparatus of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the logic for processing further comprises logic for not evaluating the predicate when the predicate is true.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The apparatus of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the logic for processing further comprises logic for pushing down the predicate when the predicate is neither true nor false.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The apparatus of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as false, and nor accessing the target column, when the operator of the predicate is an “equal” operator.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The apparatus of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as true, not evaluating the predicate, and fetching all rows of the target column, when the operator of the predicate is a “not equal” operator.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The apparatus of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the logic for processing further comprises logic for replacing the predicate with a revised predicate based on the error, when the operator of the predicate is a “greater than,” “greater than or equal to,” l“less than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as false when the error is an overflow error and the operator of the predicate is a “greater than” or “greater than or equal to” Operator.</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as true when the error is an overflow error and the operator of the predicate is a “less than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as true when the error is an underflow error and the operator of the predicate is a “greater than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as false when the error is an underflow error and the operator of the predicate is a “less than” or “less than or equal” operator.</claim-text>
</claim>
<claim id="CLM-00033" num="00033">
<claim-text>33. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the logic for processing further comprises logic for rounding down the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “greater than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00034" num="00034">
<claim-text>34. The apparatus of <claim-ref idref="CLM-00033">claim 33</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as true when the rounding down causes an underflow error and the operator of the predicate is a “greater than” operator.</claim-text>
</claim>
<claim id="CLM-00035" num="00035">
<claim-text>35. The apparatus of <claim-ref idref="CLM-00033">claim 33</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as false when the rounding down causes an underflow error and the operator of the predicate is a “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00036" num="00036">
<claim-text>36. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the logic for processing further comprises logic for rounding up the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “less than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00037" num="00037">
<claim-text>37. The apparatus of <claim-ref idref="CLM-00036">claim 36</claim-ref>, wherein the logic for further comprises logic for identifying the predicate as true when the rounding up causes an underflow error and the operator of the predicate is a “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00038" num="00038">
<claim-text>38. The apparatus of <claim-ref idref="CLM-00036">claim 36</claim-ref>, wherein the logic for processing further comprises logic for identifying the predicate as false when the rounding up causes an underflow error and the operator of the predicate is a “less than” operator.</claim-text>
</claim>
<claim id="CLM-00039" num="00039">
<claim-text>39. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the logic for processing further comprises logic for adding a range predicate when casting down a “float” input value to a target column, when the “decimal” target column has a precision greater than 15.</claim-text>
</claim>
<claim id="CLM-00040" num="00040">
<claim-text>40. The apparatus of <claim-ref idref="CLM-00039">claim 39</claim-ref>, wherein the range predicate is used to construct start and stop keys to restrict a range of rows to be retrieved, so that only a few of rows are fetched.</claim-text>
</claim>
<claim id="CLM-00041" num="00041">
<claim-text>41. An article of manufacture comprising a computer-readable media tangibly embodying instructions that, when read and executed by a computer system, results in the computer system performing a method for optimizing a query, the method comprising the steps of:
<claim-text>(a) evaluating the query, wherein the query is comprised of at least one predicate having a first operand comprising an input value, an operator and a second operand comprising a target column;</claim-text>
<claim-text>(b) casting down the input value to a data type of the target column before the target column is accessed, when the evaluated query is has non-matching first and second operands in the predicate;</claim-text>
<claim-text>(c) detecting when an error occurs when the input value is cast-down, and then processing the predicate based on the detected error and the operator associated with the predicate; and</claim-text>
<claim-text>(d) performing the query in the computer system to retrieve data from a database in order to present the data to a user.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00042" num="00042">
<claim-text>42. The article of manufacture of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the error is an overflow, underflow, or loss of precision error.</claim-text>
</claim>
<claim id="CLM-00043" num="00043">
<claim-text>43. The article of manufacture of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the processing step further comprises the step of not accessing the target column when the predicate is false.</claim-text>
</claim>
<claim id="CLM-00044" num="00044">
<claim-text>44. The article of manufacture of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the processing step further comprises the step of not evaluating the predicate when the predicate is true.</claim-text>
</claim>
<claim id="CLM-00045" num="00045">
<claim-text>45. The article of manufacture of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the processing step further comprises the step of pushing down the predicate when the predicate is neither true nor false.</claim-text>
</claim>
<claim id="CLM-00046" num="00046">
<claim-text>46. The article of manufacture of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false, and not accessing the target column, when the operator of the predicate is an “equal” operator.</claim-text>
</claim>
<claim id="CLM-00047" num="00047">
<claim-text>47. The article of manufacture of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true, not evaluating the predicate, and fetching all rows of the target column, when the operator of the predicate is a “not equal” operator.</claim-text>
</claim>
<claim id="CLM-00048" num="00048">
<claim-text>48. The article of manufacture of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the processing step further comprises the of replacing the predicate with a revised predicate based on the error, when the operator of the predicate is a “greater than,” “greater than or equal to,” “less than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00049" num="00049">
<claim-text>49. The article of manufacture of <claim-ref idref="CLM-00048">claim 48</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the error is an overflow error and the operator of the predicate is a “greater than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00050" num="00050">
<claim-text>50. The article of manufacture of <claim-ref idref="CLM-00048">claim 48</claim-ref>, wherein die processing step further comprises the step of identifying the predicate as true when the error is an overflow error and the operator of the predicate is a “less than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00051" num="00051">
<claim-text>51. The article of manufacture of <claim-ref idref="CLM-00048">claim 48</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true when the error is an underflow error and the operator of the predicate is a “greater than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00052" num="00052">
<claim-text>52. The article of manufacture of <claim-ref idref="CLM-00048">claim 48</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the error is an underflow error and the operator of the predicate is a “less dun” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00053" num="00053">
<claim-text>53. The article of manufacture of <claim-ref idref="CLM-00048">claim 48</claim-ref>, wherein the processing step further comprises the step of rounding down the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “greater than” or “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00054" num="00054">
<claim-text>54. The article of manufacture of <claim-ref idref="CLM-00053">claim 53</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true when the rounding down causes an underflow error and the operator of the predicate is a “greater than” operator.</claim-text>
</claim>
<claim id="CLM-00055" num="00055">
<claim-text>55. The article of manufacture of <claim-ref idref="CLM-00053">claim 53</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the rounding down causes an underflow error and the operator of the predicate is a “less than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00056" num="00056">
<claim-text>56. The article of manufacture of <claim-ref idref="CLM-00048">claim 48</claim-ref>, wherein the processing step further comprises the step of rounding up the input value to a data type of the target column when the error is a loss of precision error and the operator of the predicate is a “less than” or “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00057" num="00057">
<claim-text>57. The article of manufacture of <claim-ref idref="CLM-00056">claim 56</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as true when the rounding up causes an underflow error and the operator of the predicate is a “greater than or equal to” operator.</claim-text>
</claim>
<claim id="CLM-00058" num="00058">
<claim-text>58. The article of manufacture of <claim-ref idref="CLM-00056">claim 56</claim-ref>, wherein the processing step further comprises the step of identifying the predicate as false when the rounding up causes an underflow error and the operator of the predicate is a “less than” operator.</claim-text>
</claim>
<claim id="CLM-00059" num="00059">
<claim-text>59. The article of manufacture of <claim-ref idref="CLM-00048">claim 48</claim-ref>, wherein the processing step further comprises the step of adding a range predicate when casting down a “float” input value to a “decimal” target column, when the “decimal” target column has a precision greater than 15.</claim-text>
</claim>
<claim id="CLM-00060" num="00060">
<claim-text>60. The article of manufacture of <claim-ref idref="CLM-00059">claim 59</claim-ref>, wherein the range predicate is used to construct start and stop keys to restrict a range of rows to be retrieved, so that only a few of rows are fetched.</claim-text>
</claim>
</claims>
</us-patent-grant>
