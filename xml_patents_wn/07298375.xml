<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07298375-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07298375</doc-number>
<kind>B1</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10846821</doc-number>
<date>20040514</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>410</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>09</class>
<subclass>G</subclass>
<main-group>5</main-group>
<subgroup>37</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>T</subclass>
<main-group>1</main-group>
<subgroup>20</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>14</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>345561</main-classification>
<further-classification>345506</further-classification>
<further-classification>345522</further-classification>
</classification-national>
<invention-title id="d0e53">Arithmetic logic units in series in a graphics pipeline</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6173366</doc-number>
<kind>B1</kind>
<name>Thayer et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711129</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6333744</doc-number>
<kind>B1</kind>
<name>Kirk et al.</name>
<date>20011200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345506</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6466222</doc-number>
<kind>B1</kind>
<name>Kao et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345558</main-classification></classification-national>
</citation>
</references-cited>
<number-of-claims>29</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>345506</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345522</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345561</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>712221</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>712223</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>15</number-of-figures>
</figures>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Hutchins</last-name>
<first-name>Edward A.</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Nvidia Corporation</orgname>
<role>02</role>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Tung</last-name>
<first-name>Kee M.</first-name>
<department>2628</department>
</primary-examiner>
<assistant-examiner>
<last-name>Nguyen</last-name>
<first-name>Hau H</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">An arithmetic logic stage in a graphics pipeline is described. The arithmetic logic stage includes a plurality of series-coupled scalar arithmetic logic units, each unit for performing an arithmetic logic operation on a set of input operands and for producing a result based thereon.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="252.56mm" wi="204.55mm" file="US07298375-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="186.52mm" wi="88.65mm" file="US07298375-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="214.04mm" wi="141.73mm" file="US07298375-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="207.43mm" wi="162.81mm" file="US07298375-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="205.06mm" wi="175.09mm" file="US07298375-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="165.27mm" wi="139.87mm" file="US07298375-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="272.37mm" wi="196.09mm" file="US07298375-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="265.85mm" wi="205.91mm" file="US07298375-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="193.72mm" wi="89.83mm" file="US07298375-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="263.65mm" wi="190.08mm" file="US07298375-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="87.80mm" wi="132.33mm" file="US07298375-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="201.17mm" wi="158.83mm" file="US07298375-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="180.59mm" wi="113.45mm" file="US07298375-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCES TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This Application is related to U.S. patent application Ser. No. 10/846,788 by E. Hutchins et al., filed on May 14, 2004, entitled “Arithmetic Logic Unit Temporary Registers,”, assigned to the assignee of the present invention, and hereby incorporated by reference in its entirety.</p>
<p id="p-0003" num="0002">This Application is related to U.S. patent application Ser. No. 10/846,728 by E. Hutchins et al., filed on May 14, 2004, entitled “An Arithmetic Logic Unit and Method for Processing Data in a Graphics Pipeline,”, assigned to the assignee of the present invention, and hereby incorporated by reference in its entirety.</p>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0004" num="0003">The present invention is generally related to processors. More particularly, embodiments of the present invention are directed towards low power processors used in, for example, graphics applications.</p>
<heading id="h-0003" level="1">BACKGROUND ART</heading>
<p id="p-0005" num="0004">The generation of three-dimensional graphical images is of interest in a variety of electronic games and other applications. Computer graphics generally consists of instructions implemented via a graphics processing unit (GPU) executed on a computer system. The GPU can be envisioned as a pipeline through which pixel data pass. The data are used to define the image to be produced and displayed. The instructions are used to specify the calculations and operations needed to modify the data to produce rendered images that have a three-dimensional appearance.</p>
<p id="p-0006" num="0005">In the initial stages of the pipeline, the desired image is composed using geometric shapes referred to as geometric primitives. In subsequent stages, effects such as texture, fog, and shading are added in order to enhance the realism of the image, and anti-aliasing and blending functions are also applied so that the rendered image will have a smoother and more realistic appearance. The results of the pipeline operations are stored in the frame buffer as pixels. The pixel values can be later read from the frame buffer and used to generate a display on a computer screen.</p>
<p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. 1</figref> illustrates one example of a conventional pipeline architecture, which is a “deep” pipeline having stages dedicated to performing specific functions. A transform stage <b>105</b> performs geometrical calculations of primitives and may also perform a clipping operation. A setup/raster stage <b>110</b> rasterizes the primitives. A texture address <b>115</b> stage and texture fetch <b>120</b> stage are utilized for texture mapping. A fog stage <b>130</b> implements a fog algorithm. An alpha test stage <b>135</b> performs an alpha test. A depth test <b>140</b> performs a depth test for culling occluded pixels. An alpha-blend stage <b>145</b> performs an alpha-blend color combination algorithm. A memory write stage <b>150</b> writes the output of the pipeline to memory.</p>
<p id="p-0008" num="0007">There is an increasing interest in rendering three-dimensional graphical images in wireless phones, personal digital assistants (PDAs), and other devices where cost and power consumption are important design considerations. However, the conventional deep pipeline architecture requires a significant chip area, resulting in greater cost than desired. Additionally, a deep pipeline consumes significant power. As a result of cost and power considerations, the conventional deep pipeline architecture illustrated in <figref idref="DRAWINGS">FIG. 1</figref> is considered unsuitable for wireless phones, PDAs and other such devices.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0009" num="0008">Therefore, a processor architecture suitable for graphics processing applications but with reduced power and size requirements would be advantageous. Embodiments in accordance with the present invention provide this and other advantages.</p>
<p id="p-0010" num="0009">An arithmetic logic stage in a graphics pipeline is described. The arithmetic logic stage includes a plurality of series-coupled scalar arithmetic logic units (ALUs), each ALU for performing an arithmetic logic operation on a set of input operands and for producing a result based thereon. In one implementation, there are four ALUs in the arithmetic logic stage. In another embodiment, the result is software-programmable for storage into a temporary register of an ALU and/or delivery to a downstream pipeline unit.</p>
<p id="p-0011" num="0010">In one embodiment, a pixel packet of a pixel comprises rows of pixel information, and each scalar ALU has a two clock cycle latency per row. In one such embodiment, the ALUs are software configurable for single clock cycle throughput per row.</p>
<p id="p-0012" num="0011">In another embodiment, the set of input operands include four input operands. In one such embodiment, each input operand is 20 bits wide and the result is 10 bits wide. In another such embodiment, the arithmetic logic operation is of the form (a*b “op” c*d), where a, b, c and d are the input operands and where “op” represents a software-programmable operation.</p>
<p id="p-0013" num="0012">In yet another embodiment, the set of input operands are software-selectable from either a pipeline register, a temporary register or a constant value.</p>
<p id="p-0014" num="0013">In various embodiments according to the present invention, pixel packets are associated with pixels. Each pixel packet includes a number of rows of pixel information, and each scalar ALU is software-programmable to simultaneously process a different row of pixel information. Alternatively, the ALUs are software-programmable to simultaneously process rows of a number of pixels.</p>
<p id="p-0015" num="0014">In the ALU stage, some number of the scalar ALUs can be programmed to operate simultaneously to implement a particular graphics functionality, while another of the ALUs is programmed to operate simultaneously to implement a different graphics functionality.</p>
<p id="p-0016" num="0015">In summary, embodiments of the present invention provide an ALU stage in a graphics pipeline that consists of a number of series-coupled ALUs. In general, the graphics functions of the pipeline all pass through the same group of ALUs. That is, each ALU can perform any of a variety of graphics functions that may be required by the graphics pipeline. Furthermore, each of the ALUs can operate simultaneously with the other ALUs to perform the same graphics function or a different graphics function on pixel data. Moreover, one or more pixels can be processed simultaneously by the ALUs. Also, the ALUs operate on scalar values rather than vector values. As such, the width of the graphics pipeline can be reduced and the pixel data formatted accordingly. That is, rather than working on a full width of pixel data associated with a pixel in a frame, the pixel data can be separated into rows of pixel data. By maintaining a narrow pipeline, graphics processing is made more efficient for typical usage patterns, an advantage in devices such as PDAs where power conservation is important. These and other objects and advantages of the various embodiments of the present invention will be recognized by those of ordinary skill in the art after reading the following detailed description of the embodiments that are illustrated in the various drawing figures.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE FIGURES</heading>
<p id="p-0017" num="0016">The accompanying drawings, which are incorporated in and form a part of this specification, illustrate embodiments of the present invention and, together with the description, serve to explain the principles of the invention:</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram of a prior art pipeline for three-dimensional graphics.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 2A</figref> is a block diagram of one example of a system upon which embodiments in accordance with the present invention may be implemented.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 2B</figref> is a block diagram of another example of a system upon which embodiments in accordance with the present invention may be implemented.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of a pipeline architecture used by a programmable graphics processor in accordance with one embodiment of the present invention.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 4A</figref> is a data flow diagram showing the processing of a pixel packet in a pipeline in accordance with one embodiment of the present invention.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 4B</figref> is a data flow diagram illustrating the relationship between pixel data in a pipeline and an instruction executed by an arithmetic logic unit (ALU) in accordance with one embodiment of the present invention.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 4C</figref> illustrates one embodiment of an instruction executed by an ALU in accordance with the present invention.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 4D</figref> provides further information regarding an operand field that is included in an instruction executed by an ALU in accordance with one embodiment of the present invention.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 5A</figref> is a block diagram of an exemplary ALU in a graphics pipeline in accordance with embodiments of the present invention.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 5B</figref> is a data flow diagram of an exemplary ALU in accordance with embodiments of the present invention.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 5C</figref> is a block diagram showing four series-coupled ALUs in accordance with one embodiment of the present invention.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart <b>600</b> of an exemplary process for processing graphics data according to one embodiment of the present invention.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 7</figref> illustrates the interleaving of rows of pixel packets in accordance with one embodiment of the present invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 8</figref> is a data flow diagram showing the flow of data in an ALU with local temporary registers in accordance with one embodiment of the present invention.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart of a method for processing data in an ALU with temporary registers in accordance with one embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0033" num="0032">The drawings referred to in the description should not be understood as being drawn to scale except if specifically noted.</p>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0034" num="0033">Reference will now be made in detail to the various embodiments of the present invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with these embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the spirit and scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be understood that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail so as not to unnecessarily obscure aspects of the present invention.</p>
<p id="p-0035" num="0034">Some portions of the detailed descriptions that follow are presented in terms of procedures, logic blocks, processing, and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present-application, a procedure, logic block, process, or the like, is conceived to be a self-consistent sequence of steps or instructions leading to a desired result. The steps are those utilizing physical manipulations of physical quantities. Usually, although not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in a computer system. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as transactions, bits, values, elements, symbols, characters, fragments, pixels, or the like.</p>
<p id="p-0036" num="0035">It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as “generating,” “fetching,” “receiving,” “operating,” “performing,” “processing,” “implementing” or the like, refer to actions and processes (e.g., flowcharts <b>600</b> and <b>900</b> of <figref idref="DRAWINGS">FIGS. 6 and 9</figref>, respectively) of a computer system or similar electronic computing device. The computer system or similar electronic computing device manipulates and transforms data represented as physical (electronic) quantities within the computer system memories, registers or other such information storage, transmission or display devices. The present invention is well suited to use with other computer systems.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 2A</figref> is a block diagram of a system <b>200</b> upon which embodiments in accordance with the present invention may be implemented. System <b>200</b> shows the components of an execution platform for implementing certain software-based-functionality of embodiments in accordance with the present invention. As depicted in <figref idref="DRAWINGS">FIG. 2A</figref>, the system <b>200</b> includes a microprocessor <b>202</b> coupled to a graphics processor <b>205</b> via a host interface <b>201</b>. The host interface <b>201</b> translates data and commands passing between the microprocessor <b>202</b> and the graphics processor <b>205</b> into their respective formats. Both the microprocessor <b>202</b> and the graphics processor <b>205</b> are coupled to a memory <b>207</b> via a memory controller <b>206</b>. In the system <b>200</b> embodiment, the memory <b>207</b> is a shared memory, whereby the memory <b>207</b> stores instructions and data for both the microprocessor <b>202</b> and the graphics processor <b>205</b>. Access to the shared memory <b>207</b> is through the memory controller <b>206</b>. The shared memory <b>206</b> also includes a video frame buffer for storing pixel data that drives a coupled display <b>208</b>.</p>
<p id="p-0038" num="0037">As described above, certain processes and steps of the present invention are realized, in one embodiment, as a series of instructions (e.g., a software program) that reside within computer-readable memory (e.g., memory <b>207</b>) of a computer system (e.g., system <b>200</b>) and are executed by the microprocessor <b>202</b> and graphics processor <b>205</b> of system <b>200</b>. When executed, the instructions cause the system <b>200</b> to implement the functionality of embodiments of the present invention as described below.</p>
<p id="p-0039" num="0038">As shown in <figref idref="DRAWINGS">FIG. 2A</figref>, system <b>200</b> includes the basic components of a computer system platform that implements functionality in accordance with embodiments of the present invention. Accordingly, system <b>200</b> can be implemented as, for example, a number of different types of portable handheld electronic devices. Such devices can include, for example, portable phones, personal digital assistants (PDAs), handheld gaming devices, or virtually any other type of device with display capability where there is an interest in rendering three-dimensional graphical images at low cost and low power. In such embodiments, components would be included that are designed to add peripheral buses, specialized communications components, support for specialized input/output (I/O) devices, and the like.</p>
<p id="p-0040" num="0039">Additionally, it should be appreciated that although the components of <figref idref="DRAWINGS">FIG. 2A</figref> are depicted as discrete components, several of the components can be implemented as a single integrated circuit device (e.g., a single integrated circuit die) configured to take advantage of the high levels of integration provided by modern semiconductor fabrication processes. For example, in one embodiment, the microprocessor <b>202</b>, host interface <b>201</b>, graphics processor <b>205</b>, and memory controller <b>206</b> are fabricated as a single integrated circuit die.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 2B</figref> shows a system <b>220</b> in accordance with an alternative embodiment of the present invention. System <b>220</b> is substantially similar to system <b>200</b> of <figref idref="DRAWINGS">FIG. 2A</figref>. System <b>220</b>, however, utilizes a microprocessor <b>202</b> having a dedicated system memory <b>227</b>, and a graphics processor <b>205</b> having a dedicated graphics memory <b>226</b>. In the system <b>220</b> embodiment, the system memory <b>227</b> stores instructions and data for processes/threads executing on the microprocessor <b>202</b>, and graphics memory <b>226</b> stores instructions and data for those processes/threads executing on the graphics processor <b>205</b>. The graphics memory <b>226</b> stores pixel data in a frame buffer that drives the display <b>208</b>. As with computer system <b>220</b> of <figref idref="DRAWINGS">FIG. 2A</figref>, one or more of the components of system <b>220</b> can be integrated as a single integrated circuit die.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of a pipeline <b>300</b> used by a graphics processor <b>205</b> (<figref idref="DRAWINGS">FIGS. 2A and 2B</figref>) in accordance with one embodiment of the present invention. In the present embodiment, pipeline <b>300</b> includes a setup stage <b>305</b>, a raster stage <b>310</b>, a gatekeeper stage <b>320</b>, a data fetch stage <b>330</b>, an Arithmetic Logic Unit (ALU) stage <b>340</b>, and a data write stage <b>355</b>. The function of each of these stages is described in general; however, it is appreciated that embodiments in accordance with the present invention are not limited to the functions described herein.</p>
<p id="p-0043" num="0042">Setup stage <b>305</b> of <figref idref="DRAWINGS">FIG. 3</figref> receives instructions and graphics primitives from a host, such as a software application running on system <b>200</b> or <b>250</b> of <figref idref="DRAWINGS">FIGS. 2A and 2B</figref>, respectively. In general, setup stage <b>305</b> calculates vertex parameters needed by raster stage <b>310</b>. In one embodiment, setup stage <b>305</b> performs functions associated with the geometrical three-dimensional to two-dimensional transformation of coordinates, clipping, and setup. The setup stage <b>305</b> takes vertex information (e.g., x, y, z, color, texture attributes, etc.) and applies a user-defined view transform to calculate screen space coordinates for each geometrical primitive (hereinafter described as triangles because primitives are typically implemented as triangles), which are then sent to the raster stage <b>310</b> to draw a given triangle. A vertex buffer <b>308</b> may be included to provide a buffer for vertex data used by setup stage <b>305</b>.</p>
<p id="p-0044" num="0043">In general, raster stage <b>310</b> translates triangles to pixels using interpolation. Raster stage <b>310</b> receives data from setup stage <b>305</b> regarding triangles that are to be rendered (e.g., converted into pixels). Raster stage <b>310</b> determines which pixels correspond to which triangle including computation of parameters associated with each pixel, processes each pixel of a given triangle, and determines shader processing operations that need to be performed on a pixel as part of the rendering, such as color, texture, and fog operations.</p>
<p id="p-0045" num="0044">Raster stage <b>310</b> generates a “pixel packet” for each pixel of a triangle that is to be processed. A pixel packet is, in general, a set of descriptions used for calculating an instance of a pixel value for a pixel in a frame of a graphical display. A pixel packet is associated with each pixel in each frame. Each pixel is associated with a particular (x,y) location in screen coordinates.</p>
<p id="p-0046" num="0045">Each pixel packet includes a payload of pixel attributes required for processing (e.g., color, texture, depth, fog, [x,y] location, etc.) and sideband information (pixel attribute data is provided by the data fetch stage <b>330</b>). In one embodiment, the sideband information includes a kill bit. If the kill bit is set somewhere in the pipeline <b>300</b>, then the pixel packet will proceed through the remainder of the pipeline <b>300</b> without active processing. The kill bit is used to designate a pixel packet that is associated with a pixel that will not be rendered in a graphical display (e.g., it will not be rendered on the display screen).</p>
<p id="p-0047" num="0046">The sideband information may include information in addition to a sequence number and kill bit; refer to the discussion of <figref idref="DRAWINGS">FIG. 4A</figref> below for other examples of sideband information. A pixel packet may contain one row of data or it may contain multiple rows of data. A row is generally the width of the pipeline bus.</p>
<p id="p-0048" num="0047">In one embodiment, raster stage <b>310</b> of <figref idref="DRAWINGS">FIG. 3</figref> calculates barycentric coordinates for each pixel packet. The use of barycentric coordinates improves dynamic range, which permits using fixed-point calculations that require less power than floating point calculations.</p>
<p id="p-0049" num="0048">As each pixel of a triangle is walked through raster stage <b>310</b>, raster stage <b>310</b> generates pixel packets for further processing which are received by gatekeeper stage <b>320</b>. Gatekeeper stage <b>320</b> performs a data flow control function. In one embodiment, gatekeeper stage <b>320</b> has an associated scoreboard <b>325</b> for scheduling, load balancing, resource allocation, and hazard avoidance of pixel packets as well as recirculation. Scoreboard <b>325</b> tracks the entry and retirement of pixels. Pixel packets entering gatekeeper stage <b>320</b> set the scoreboard <b>325</b>, and the scoreboard <b>325</b> is reset as the pixel packets drain out of pipeline <b>300</b>.</p>
<p id="p-0050" num="0049">Gatekeeper <b>320</b> and scoreboard <b>325</b> provide several benefits. Scoreboard <b>325</b> can track pixel packets that are capable of being processed by ALUs <b>350</b>, along with those pixel packets that have their kill bit set. For example, if there are no valid pixel packets, the ALUs may be turned off (e.g., not clocked) to save power.</p>
<p id="p-0051" num="0050">A data fetch stage <b>330</b> fetches data for pixel packets passed on by gatekeeper <b>320</b>. Such data may include color information, any depth information, and any texture information for each pixel packet. In one embodiment, data fetch stage <b>330</b> also manages a local texture/fog cache <b>332</b>, a depth cache <b>333</b>, and a color cache <b>334</b>. Fetched data is placed into an appropriate field in the pixel packet prior to sending the pixel packet on to the next stage. In one embodiment, the kill bit is set in data fetch stage <b>330</b> as a result of a z-fetch.</p>
<p id="p-0052" num="0051">From the data fetch stage <b>330</b>, pixel packets enter an ALU stage <b>340</b>. In one embodiment, the ALU stage <b>340</b> includes multiple ALUs <b>350</b> configured to execute shader programming related to three-dimensional graphics operations such as, but not limited to, texture combine (texture environment), stencil, fog, alpha blend, alpha test, and depth test.</p>
<p id="p-0053" num="0052">In the example of <figref idref="DRAWINGS">FIG. 3</figref>, there are four (4) ALUs <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, and <b>350</b>-<b>3</b>. In one embodiment, the ALUs are series-coupled scalar units. While 4 ALUs <b>350</b> are illustrated, in other implementations, ALU stage <b>340</b> may incorporate a different number of ALUs <b>350</b>.</p>
<p id="p-0054" num="0053">In the present embodiment, each ALU <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, and <b>350</b>-<b>3</b> executes an instruction, each instruction for performing an arithmetic operation on operands that correspond to the contents of the pixel packets; refer to the discussion of <figref idref="DRAWINGS">FIGS. 4A through 4D</figref> below. In some embodiments, an ALU uses temporarily stored values from previous operations; refer to <figref idref="DRAWINGS">FIG. 8</figref> below.</p>
<p id="p-0055" num="0054">Continuing with reference to <figref idref="DRAWINGS">FIG. 3</figref>, an example of an arithmetic operation performed by ALUs <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, and <b>350</b>-<b>3</b> is a scalar arithmetic operation of the form (a*b)+(c*d), where a, b, c, and d are operand values that are obtained from a pixel packet. Each ALU <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, and <b>350</b>-<b>3</b> can perform other mathematical operations. Examples of other mathematical operations are provided in conjunction with the discussion of <figref idref="DRAWINGS">FIG. 4C</figref> below (specifically, see Table 1 for examples).</p>
<p id="p-0056" num="0055">In some embodiments, each ALU <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, and <b>350</b>-<b>3</b> of <figref idref="DRAWINGS">FIG. 3</figref> determines whether to generate a kill bit based on a test, such as a comparison of a*b and c*d (e.g., kill if a*b not equal to c*d). An individual ALU <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, and <b>350</b>-<b>3</b> can be disabled (e.g., not clocked) with regard to processing a pixel packet if the kill bit is set in a pixel packet. In one embodiment, a clock-gating mechanism is used to disable ALU <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b> or <b>350</b>-<b>3</b> when a kill bit is detected in any row of a pixel packet. As a result, after a kill bit is generated for a row of a pixel packet, the ALUs <b>350</b>-<b>0</b>, <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, and <b>350</b>-<b>3</b> do not waste power on the row of the pixel packet as it propagates through ALU stage <b>340</b>. However, note that a pixel packet with a kill bit set still propagates onwards, permitting it to be accounted for by data write stage <b>355</b> and scoreboard <b>325</b>. This permits all pixel packets to be accounted for by scoreboard <b>325</b>, even those pixel packets marked by a kill bit.</p>
<p id="p-0057" num="0056">The output of the ALU stage <b>340</b> goes to the data write stage <b>355</b>. The data write stage <b>355</b> stores pipeline results in a write buffer <b>360</b> or in a frame buffer in memory (e.g., memory <b>207</b> of <figref idref="DRAWINGS">FIG. 2A</figref> or memory <b>226</b> of <figref idref="DRAWINGS">FIG. 2B</figref>). Data write stage <b>355</b> indicates retired writes to gatekeeper stage <b>320</b> for scoreboarding. Optionally, pixel packets/data can be recirculated from the data write stage back to the gatekeeper <b>320</b> if further processing of the data is needed.</p>
<p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. 4A</figref> is a data flow diagram showing processing of a pixel packet <b>400</b> in accordance with one embodiment of the present invention. As mentioned above, a pixel packet is, in general, a set of descriptions for a pixel in a graphical display. In the present embodiment, each pixel packet <b>400</b> includes sideband information <b>410</b> and payload information <b>420</b>. In one such embodiment, payload information <b>420</b> includes, for example, color information, depth information, and texture information for the pixel that is associated with pixel packet <b>400</b>.</p>
<p id="p-0059" num="0058">In the present embodiment, sideband information <b>410</b> includes a “type” field of one or more bits. There may be different types of data packets flowing through the pipeline <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>. The type field is used to identify packet <b>400</b> as a pixel packet containing pixel data. Alternately, the type field can identify packet <b>400</b> as a programming packet, used to update programmable state (such as instruction tables or constant register values) within the graphics pipeline.</p>
<p id="p-0060" num="0059">In the present embodiment, sideband information <b>410</b> of <figref idref="DRAWINGS">FIG. 4A</figref> also includes an indicator flag referred to herein as an “even/odd” (e/o) field. In one embodiment, the e/o field is a single bit in length. The purpose of the e/o bit is described further in conjunction with <figref idref="DRAWINGS">FIGS. 7 and 8</figref> below.</p>
<p id="p-0061" num="0060">In the present embodiment, sideband information of <figref idref="DRAWINGS">FIG. 4A</figref> also includes a “kill” field. In one embodiment, the kill field is a single bit in length. As mentioned above, if the kill bit is set somewhere in the pipeline <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>, then the pixel packet will proceed through the remainder of the pipeline <b>300</b> without active processing by each pipeline stage.</p>
<p id="p-0062" num="0061">In the present embodiment, the sideband information <b>410</b> of <figref idref="DRAWINGS">FIG. 4A</figref> includes a “sequence” field. In one embodiment, the sequence field is three (3) bits in length. The sequence bits link the pixel packet <b>400</b> to an instruction that is to be applied to the pixel packet in the ALU stage <b>340</b>; refer to <figref idref="DRAWINGS">FIG. 4B</figref> below.</p>
<p id="p-0063" num="0062">Continuing with reference to <figref idref="DRAWINGS">FIG. 4A</figref>, in the present embodiment, the payload portion <b>420</b> of pixel packet <b>400</b> is separated into one or more “rows” <b>0</b>, <b>1</b>, . . . , N in raster stage <b>310</b> of <figref idref="DRAWINGS">FIG. 3</figref>. That is, the payload portion <b>420</b> may consist of a single row, or it may consist of a group of rows.</p>
<p id="p-0064" num="0063">In one embodiment, the payload portion of each row holds up to 80 bits of pixel data. In one such embodiment, the pixel data in each row is represented using 4 sets of 20-bit values. For example, row <b>0</b> include 4 sets of pixel data P<b>0</b>.<b>0</b>, P<b>0</b>.<b>1</b>, P<b>0</b>.<b>2</b> and P<b>0</b>.<b>3</b>, each 20 bits in length. Each of the sets of 20-bit values may represent one or more instances or attributes of pixel data. Examples of pixel attributes that may be included in a 20-bit set of pixel data include, but are not limited to: 16-bit Z depth values; 16-bit (s,t) texture coordinates and a 4-bit level of detail value; a pair of color values in S1.8 format; or packed 5555 RGBA (red, green, blue, alpha) values, each five (5) bits in length.</p>
<p id="p-0065" num="0064">The sideband information <b>410</b> for pixel packet <b>400</b> is associated with each row or rows formed from the payload portion <b>420</b>. In one embodiment, each row includes the sideband information <b>410</b> and 80 bits of pixel data, as illustrated in <figref idref="DRAWINGS">FIG. 4A</figref>.</p>
<p id="p-0066" num="0065">Each row of pixel packet <b>400</b> is processed in succession in pipeline <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref> with each new clock cycle. For example, row <b>0</b> starts down pipeline <b>300</b> on a first clock, followed by row <b>1</b> on the next clock, and so on. Once all of the rows associated with pixel packet <b>400</b> are loaded into pipeline <b>300</b>, rows associated with the next pixel packet are loaded into pipeline <b>300</b>. As will be seen, in one embodiment, rows of pixel data for one pixel packet are interleaved with rows of pixel data from the next pixel packet and designated as “even” and “odd,” respectively. By interleaving rows of pixel packets in this fashion, stalls in the pipeline <b>300</b> can be avoided, and data through is increased. This is discussed further in conjunction with <figref idref="DRAWINGS">FIG. 7</figref> below.</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 4B</figref> is a data flow diagram illustrating the relationship between a row <b>421</b> of pixel data in a pipeline (e.g., pipeline <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>) and an instruction <b>430</b> executed by an ALU (e.g., in ALU stage <b>340</b> of <figref idref="DRAWINGS">FIG. 3</figref>) in accordance with one embodiment of the present invention. <figref idref="DRAWINGS">FIG. 4B</figref> illustrates a single row <b>421</b> that includes 4 sets of pixel data <b>422</b>, <b>423</b>, <b>424</b> and <b>425</b> and sideband information <b>410</b>. In one embodiment, each set of pixel data <b>422</b>-<b>25</b> is 20 bits in length. In the present embodiment, the sequence number SEQ in the sideband information <b>410</b> points to an instruction <b>430</b> to be executed by an ALU.</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 4C</figref> illustrates one embodiment of an instruction <b>430</b> executed by an ALU (e.g., in ALU stage <b>340</b> of <figref idref="DRAWINGS">FIG. 3</figref>) in accordance with the present invention. In the present embodiment, instruction <b>430</b> includes an operation (op) code <b>432</b>; <b>4</b> designations <b>434</b> of sources for the operands identified as “a,” “b,” “c” and “d;” and a designation of where to place the result (result destination <b>436</b>).</p>
<p id="p-0069" num="0068">In one embodiment, the op code <b>432</b> is a 4-bit value that identifies the particular operation to be performed on the row of pixel data in an ALU. That is, instruction <b>430</b> is associated with a particular row of pixel data (e.g., pixel row <b>421</b>) by the sequence number in the sideband information <b>410</b> for that row, and the op code <b>432</b> in instruction <b>430</b> identifies the type of operation to be performed on that row. Table 1 is a listing of example operations that can be executed by an ALU in accordance with embodiments of the present invention.</p>
<p id="p-0070" num="0069">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 1</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Example Operations Performed by an ALU on Pixel Data</entry>
</row>
<row>
<entry>According to One Embodiment</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Name</entry>
<entry>Operation</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>MAD</entry>
<entry>r = a*b + c*d</entry>
</row>
<row>
<entry/>
<entry>MBA</entry>
<entry>r = a*b &amp; c*d</entry>
</row>
<row>
<entry/>
<entry>MBO</entry>
<entry>r = a*b | c*d</entry>
</row>
<row>
<entry/>
<entry>MBX</entry>
<entry>r = a*b {circumflex over ( )} c*d</entry>
</row>
<row>
<entry/>
<entry>MUL</entry>
<entry>r(lo) = a*b r(hi) = c*d</entry>
</row>
<row>
<entry/>
<entry>MIN</entry>
<entry>r = min (a*b, c*d)</entry>
</row>
<row>
<entry/>
<entry>MAX</entry>
<entry>r = max (a*b, c*d)</entry>
</row>
<row>
<entry/>
<entry>SNE</entry>
<entry>r = a*b != c*d ? 1:0</entry>
</row>
<row>
<entry/>
<entry>SEQ</entry>
<entry>r = a*b == c*d ? 1:0</entry>
</row>
<row>
<entry/>
<entry>SLT</entry>
<entry>r = a*b &lt; c*d ? 1:0</entry>
</row>
<row>
<entry/>
<entry>SLE</entry>
<entry>r = a*b &lt;= c*d ? 1:0</entry>
</row>
<row>
<entry/>
<entry>KNE</entry>
<entry>kill if a*b != c*d</entry>
</row>
<row>
<entry/>
<entry>KEQ</entry>
<entry>kill if a*b == c*d</entry>
</row>
<row>
<entry/>
<entry>KLT</entry>
<entry>kill if a*b &lt; c*d</entry>
</row>
<row>
<entry/>
<entry>KLE</entry>
<entry>kill if a*b &lt;= c*d</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0071" num="0070">The values of “a,” “b,” “c” and “d” in the instructions in Table 1 correspond to the input operands specified by the instruction <b>430</b>. This is described further in conjunction with <figref idref="DRAWINGS">FIG. 4D</figref>, below.</p>
<p id="p-0072" num="0071">In the present embodiment, the result destination <b>436</b> identifies where the result (e.g., the value “r” in Table 1) of an operation performed by an ALU is to be written. The result of an ALU operation can be written to a pipeline register for the next stage of the pipeline <b>300</b> (<figref idref="DRAWINGS">FIG. 3</figref>), and/or the result can be written to a temporary register that is integral to the ALU (e.g., for use with a subsequent row). This is described further in conjunction with <figref idref="DRAWINGS">FIGS. 5A and 8</figref>, below.</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. 4D</figref> provides further information regarding an operand field <b>434</b> that is included in an instruction <b>430</b> (<figref idref="DRAWINGS">FIG. 4C</figref>) executed by an ALU in accordance with one embodiment of the present invention. In the present embodiment, each operand <b>434</b> includes a “cc” field <b>442</b>, a mode field <b>444</b>, and a register number field <b>446</b>. In one embodiment, the cc field <b>442</b> is a one-bit value that identifies, for example, whether the value of the operand is to be clamped or formatted, e.g., negated or used in its complement form (e.g., a value “x” has a complement of 1−x).</p>
<p id="p-0074" num="0073">In one embodiment, the register number field <b>446</b> is a 3-bit value that identifies the source of the value for the operand <b>434</b>. There is an operand <b>434</b> for each of the operands “a,” “b,” “c” and “d.” Referring back to <figref idref="DRAWINGS">FIG. 4B</figref>, a row of pixel data can include 4 20-bit values (e.g., sets of pixel data <b>422</b>-<b>425</b>). In one embodiment, each of these sets of pixel data resides in a pipeline register in the pipeline <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>. The pipeline registers are referred to as R<b>0</b>, R<b>1</b>, R<b>2</b> and R<b>3</b>. The register number <b>446</b> identifies which of the pipeline registers contains which operand value. For example, the register number <b>446</b> in the operand <b>434</b> that is associated with “a” can identify R<b>1</b> as the source for the value of “a.” Each of the other operand values (e.g., b, c and d) is determined in a similar fashion. In addition to the 4 attribute registers R<b>0</b>, R<b>1</b>, R<b>2</b> and R<b>3</b>, additional encodings of the register number fields indicate whether other registers (e.g., the temporary registers <b>523</b> and the constant registers <b>522</b> of <figref idref="DRAWINGS">FIG. 5B</figref>) are to be addressed.</p>
<p id="p-0075" num="0074">In one embodiment, the mode field <b>444</b> of <figref idref="DRAWINGS">FIG. 4D</figref> is a 3-bit value that identifies where in a set of pixel data the value of each operand can be found. As mentioned above, each of the sets of pixel data <b>422</b>-<b>425</b> (<figref idref="DRAWINGS">FIG. 4B</figref>) may represent one or more instances of pixel data, such as 4 5-bit RGBA values. The mode <b>444</b> identifies which segment of data in a set of pixel data <b>422</b>, <b>423</b>, <b>424</b> or <b>425</b> is to be used as the value of the operand <b>434</b>. That is, in the present embodiment, the particular set of pixel data <b>422</b>, <b>423</b>, <b>424</b> or <b>425</b> is identified by the register number <b>446</b>, and a particular data segment within the identified set of pixel data is identified by the mode <b>444</b>. For example, the register number <b>446</b> in the operand <b>434</b> for “a” can identify R<b>1</b> as the source for the value of “a,” and the mode <b>444</b> in the same operand <b>434</b> identifies which segment of bits (e.g., the high 10 bits) is the value of “a.” Each of the other operand values (e.g., b, c and d) is determined in a similar fashion. Table 2 below lists the various data segments in a set of pixel data and a respective mode <b>444</b> according to one embodiment of the present invention.</p>
<p id="p-0076" num="0075">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 2</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Example Modes for Identifying Particular Data</entry>
</row>
<row>
<entry>in a Set of Data According to One Embodiment</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="105pt" align="center"/>
<colspec colname="2" colwidth="112pt" align="left"/>
<tbody valign="top">
<row>
<entry>Mode</entry>
<entry>Data</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>000</entry>
<entry>All bits (16 or 20 bits)</entry>
</row>
<row>
<entry>001</entry>
<entry>High 10 bits</entry>
</row>
<row>
<entry>010</entry>
<entry>Low 10 bits</entry>
</row>
<row>
<entry>011</entry>
<entry>First 5 bits</entry>
</row>
<row>
<entry>100</entry>
<entry>Second 5 bits</entry>
</row>
<row>
<entry>101</entry>
<entry>Third 5 bits</entry>
</row>
<row>
<entry>110</entry>
<entry>Fourth 5 bits</entry>
</row>
<row>
<entry>111</entry>
<entry>Constant</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0077" num="0076">As indicated by Table 2, one of the modes identifies that the operand value is a constant. In one embodiment, if the operand is identified as a constant, the 3-bit value in the register number field <b>446</b> identifies a value for the constant. Constant values associated with the range of 3-bit values can be established in advance. For example, a 3-bit value of 000 can be used to indicate a constant value of zero; a 3-bit value of 001 can be used to indicate a constant value of 0.25; a 3-bit value of 010 can be used to indicate a constant value of 0.50; and so on.</p>
<p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. 5A</figref> is a block diagram of an exemplary ALU <b>350</b> in a graphics pipeline <b>300</b> in accordance with embodiments of the present invention. ALU <b>350</b> is used for processing incoming pixel data <b>540</b>. As mentioned above, in one embodiment, the incoming pixel data <b>540</b> is a row of a pixel packet that, in general, includes one or more sets of pixel data that describe attributes of a pixel in a frame of a graphical display. In one embodiment of the invention, ALU <b>350</b> is one of a plurality of series-coupled ALUs in the ALU stage <b>340</b> (<figref idref="DRAWINGS">FIG. 3</figref>). Each of the series-coupled ALUs operates concurrently on a different row of pixel data. The rows of pixel data being operated on by the series-coupled ALUs may be associated with the same pixel packet (hence, the same pixel) or with different pixel packets (hence, different pixels).</p>
<p id="p-0079" num="0078">Significantly, in one embodiment, ALU <b>350</b> is a scalar unit (in contrast to a unified vector unit). Accordingly, ALU <b>350</b> operates on scalar data elements that are traveling together in the pipeline <b>300</b> as a row of pixel data. As noted above in the discussion of <figref idref="DRAWINGS">FIG. 4A</figref>, in one embodiment, each row of pixel data includes a payload of 80 bits of pixel data.</p>
<p id="p-0080" num="0079">In the present embodiment, incoming pixel data <b>540</b> represents one row of pixel data for a pixel in a frame of a graphical display. The incoming pixel data <b>540</b> is received from a preceding pipeline stage <b>510</b> of the pipeline <b>300</b>. Depending on the placement of ALU <b>350</b> in the ALU stage <b>340</b> of <figref idref="DRAWINGS">FIG. 3</figref>, the preceding pipeline stage <b>510</b> may be the data fetch stage <b>330</b> or another ALU. In the latter case, the incoming pixel data <b>540</b> is the outgoing pixel data of the other ALU. In one embodiment of the invention, 4 scalar ALUs are series-coupled to form the ALU stage <b>340</b>.</p>
<p id="p-0081" num="0080">As described by <figref idref="DRAWINGS">FIG. 4A</figref> above, the incoming pixel data <b>540</b> of <figref idref="DRAWINGS">FIG. 5A</figref> (e.g., a row of a pixel packet) includes sideband information and payload information. In one embodiment of the invention, the payload information of the incoming pixel data <b>540</b> is resident in the pipeline register <b>521</b> (actually, one or more pipeline registers). In addition to the pipeline register <b>521</b>, ALU <b>350</b> includes a temporary register <b>523</b> (actually, one or more temporary registers) and a constant value register <b>522</b> (actually, one or more constant value registers). The temporary register <b>523</b> can be used to store a result from a previous operation performed by ALU <b>350</b>. A result stored in the temporary register <b>523</b> can then be used in the execution of a subsequent operation performed by ALU <b>350</b> within a given grouping of pixel packet rows, e.g., for a subsequent row. The constant value register <b>522</b> can be used to store constant values that can be used in operations performed by ALU <b>350</b>. Constant values are loaded by using programming packets <b>421</b> as described in conjunction with <figref idref="DRAWINGS">FIGS. 4A and 4B</figref> above.</p>
<p id="p-0082" num="0081">After the incoming pixel data <b>540</b> of <figref idref="DRAWINGS">FIG. 5A</figref> is pipelined into the pipeline register <b>521</b>, the operand selector <b>530</b> selects operand values from the group of registers consisting of the pipeline register <b>521</b>, the constant register <b>522</b> and the temporary register <b>523</b>. In one embodiment of the invention, the operand selector <b>530</b> selects 4 scalar operand values (e.g., a, b, c and d) from that group of registers. Operand selector <b>530</b> may be a crossbar or some number of multiplexers that enable the 4 operand values to be selected from any of the registers <b>521</b>, <b>522</b> and/or <b>523</b>.</p>
<p id="p-0083" num="0082">The scalar operand values are sent to the unpacker/formatter unit <b>532</b>. The packer/formatter unit <b>532</b> formats the operands in a desired data format. The details of unpacking and formatting will be described in conjunction with <figref idref="DRAWINGS">FIG. 5B</figref>.</p>
<p id="p-0084" num="0083">Continuing with reference to <figref idref="DRAWINGS">FIG. 5A</figref>, the selected operands are then sent to the ALU circuitry <b>535</b> where an arithmetic operation can be performed on the operands to generate a result value. In one embodiment of the invention, the arithmetic operation performed in the ALU circuitry <b>535</b> is in the form of (a*b) “op” (c*d), where “op” refers to a software programmable operation and “*” refers to a multiplication operation. The result value of the operation is then sent to a packer <b>533</b> to be packed into the format used in the outgoing row of pixel data <b>545</b>.</p>
<p id="p-0085" num="0084">The repacked result value is then sent to an outgoing pixel data selector <b>566</b>, which may include a demultiplexer. In one embodiment, the repacked result value is 10 bits wide. In essence, the result of the arithmetic operation optionally replaces some portion of the incoming pixel data <b>540</b> to form the outgoing pixel data <b>545</b>. The outgoing pixel data selector <b>566</b> forms the outgoing pixel data <b>545</b> by selecting values from the incoming pixel data <b>540</b> (those values that are not being replaced) and the result value. In general, the incoming pixel data <b>540</b> can be combined with the result value generated from the ALU circuitry <b>533</b>, with the result value optionally replacing or overwriting a selected value in the incoming pixel data <b>540</b>.</p>
<p id="p-0086" num="0085">The ALU <b>350</b> can update one scalar value of the incoming pixel data <b>540</b> to generate the outgoing pixel data <b>545</b>. Accordingly, the resulting outgoing pixel data <b>545</b> can include one new value. In addition, the result value generated by the ALU circuitry <b>535</b> can be recirculated to the temporary register <b>523</b> where it can be used in subsequent operations (e.g., used as an operand in subsequent arithmetic operations on subsequent rows of a group of pixel packets).</p>
<p id="p-0087" num="0086">However, there can be instances in which the incoming pixel data <b>540</b> is not modified to include the result value. In some instances, the incoming pixel data <b>540</b> passes through ALU <b>350</b> without being operated on, or the incoming pixel data <b>540</b> may simply be multiplied by one (1) in ALU <b>350</b>. In other instances, ALU <b>350</b> may determine a result value, but the result value may not replace any of the values in the incoming pixel data <b>540</b>. For example, the result value may simply be written to the temporary registers <b>523</b>.</p>
<p id="p-0088" num="0087">The outgoing pixel data <b>545</b> is then sent to the following pipeline stage <b>515</b>. In one embodiment of the invention, depending on the placement of ALU <b>350</b> in the series-coupled ALUs in the ALU stage <b>340</b> (<figref idref="DRAWINGS">FIG. 3</figref>), the following pipeline stage <b>515</b> may be another ALU or it may be the data write stage <b>355</b>.</p>
<p id="p-0089" num="0088">To summarize, all or some of the incoming pixel data <b>540</b> may pass through an ALU without being modified. Per ALU, the result of an ALU operation may be used to update one pixel attribute in a row of pixel data. The modified pixel attribute is combined with the other (unmodified) data in the incoming pixel data <b>540</b> and pipelined to the next stage of pipeline <b>300</b> (e.g., to the next ALU, or to the data write stage). The result of an ALU operation can also be written to one of the temporary registers <b>523</b>. With 4 ALUs, 4 pixel attributes may be updated in the ALU stage <b>340</b> of <figref idref="DRAWINGS">FIG. 3</figref>. If further processing of a pixel is desired, the pixel data can be recirculated to the gatekeeper stage <b>320</b> of the pipeline <b>300</b> (refer to <figref idref="DRAWINGS">FIG. 3</figref>).</p>
<p id="p-0090" num="0089">In the present embodiment, a row of pixel data is pipelined into ALU <b>350</b> of <figref idref="DRAWINGS">FIG. 5A</figref> each clock cycle. In one implementation, it takes two (2) clock cycles for a row of pixel data to pass through ALU <b>350</b> (the ALU has a latency of 2 clock cycles). However, during each clock cycle, a row of pixel data is being operated on by ALU <b>350</b>, thereby providing a throughput per clock cycle. Accordingly, a row of pixel data is pipelined out of ALU <b>350</b> each clock cycle. Thus, although each ALU has a latency of 2 clock cycles, each ALU has a throughput of 1 row of pixel data per clock cycle. Note that, for an embodiment in which there are 4 series-coupled ALUs, it takes eight (8) clock cycles for a row of pixel data to travel through the ALU stage <b>340</b> of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0091" num="0090">In one embodiment of the invention, the ALU circuitry <b>535</b> of <figref idref="DRAWINGS">FIG. 5A</figref> can detect operations that result in mathematical identities (e.g., multiplying by zero or one). For example, the operation c*d, if “c” or “d” is zero, would result in a value of zero. When the ALU circuitry <b>535</b> discovers an operation that results in a mathematical identity, the ALU <b>350</b> shuts off (e.g., gates off) the portion of the circuitry associated with the operation, and forwards the result without actually performing the mathematical operation.</p>
<p id="p-0092" num="0091"><figref idref="DRAWINGS">FIG. 5B</figref> is a data flow diagram of an exemplary ALU <b>350</b> in accordance with embodiments of the present invention. As stated above, the ALU stage <b>340</b> includes a plurality of scalar ALUs. In one embodiment of the invention, the ALUs are coupled sequentially. Depending on the placement in the series-coupled ALUs, the outgoing pixel information of a first ALU can be used as the incoming pixel information of a second ALU. With ALUs coupled in series, each ALU of the ALU stage <b>340</b> can perform a different operation or a different graphics function simultaneously.</p>
<p id="p-0093" num="0092">For example, consider an example of a fog calculation performed using 4 ALUs. A fog calculation may be represented as: (fog_fraction)*color+(1−fog_fraction)*(fog_color). The value of fog_fraction can be represented using operand “a” read from one of the pipeline registers <b>521</b>. The value of color can be represented using operand “b” read from another of the pipeline registers <b>521</b>. The value of (1−fog_fraction) can be represented using operand “c” read from yet another of the pipeline registers <b>521</b> (actually, the value of fog can be read from the pipeline register, and then the complement is determined and used). The value of fog_color can be represented using operand “d” read from one more of the pipeline registers <b>521</b> or from one or more of the constant registers <b>522</b>. Three of the 4 ALUs can perform the fog calculation (one ALU for each of the colors red, green and blue) for one pixel. The fourth ALU can be used to perform an alpha test, for example, on the same pixel or perhaps some other type of operation on a different pixel. Thus, in one clock cycle on 4 different ALUs, different graphics functions are performed, perhaps on different pixels. Importantly, the pixel data is packed and provided to the ALUs and the instructions for operating on the pixel data are specified in such a way that each of the ALUs is doing something useful on each clock cycle.</p>
<p id="p-0094" num="0093">As stated above, an ALU (e.g., ALU <b>350</b> of <figref idref="DRAWINGS">FIG. 5B</figref>) executes an instruction <b>430</b> that identifies an operation to be performed on pixel data in a pixel row. A row of pixel data (e.g., pixel row <b>421</b> of <figref idref="DRAWINGS">FIG. 4B</figref>) enters ALU <b>350</b> each clock cycle. In one embodiment of the invention, incoming pixel data <b>540</b> includes payload information <b>420</b> and sideband information <b>410</b>. In one embodiment of the invention, the payload information <b>420</b> is stored in the pipeline register <b>521</b> (the pipeline registers R<b>0</b>, R<b>1</b>, R<b>2</b> and R<b>3</b> are collectively referred to as the pipeline register <b>521</b>). As mentioned in conjunction with <figref idref="DRAWINGS">FIG. 4A</figref>, in one embodiment, the payload portion <b>420</b> of a row of pixel data is 80 bits wide, separated into 4 sets of pixel data <b>421</b>-<b>425</b>, each 20 bits wide. In such an embodiment, each of the pipeline registers <b>521</b> (R<b>0</b>, R<b>1</b>, R<b>2</b>, R<b>3</b>) is 20 bits wide and holds one set of pixel data from a row of pixel data. In general, the width of each pipeline register R<b>0</b>, R<b>1</b>, R<b>2</b> and R<b>3</b> corresponds to the width of each set of pixel data in the payload portion <b>420</b> of a row of pixel data.</p>
<p id="p-0095" num="0094">Included in the sideband information <b>410</b> of <figref idref="DRAWINGS">FIG. 5B</figref> is an operation sequence number (e.g., sequence identifier) that instructs the ALU <b>350</b> to perform a particular instruction <b>430</b>. In one embodiment of the invention, the instruction <b>430</b> is retrieved from an instruction table in memory (e.g., memory <b>207</b> or graphics memory <b>226</b> of <figref idref="DRAWINGS">FIGS. 2A and 2B</figref>, respectively). The instruction <b>430</b> provides to the operand selector <b>530</b> the locations of the operands (e.g., using the register number <b>446</b> as described above in conjunction with <figref idref="DRAWINGS">FIG. 4D</figref>).</p>
<p id="p-0096" num="0095">The operand selector <b>530</b> of <figref idref="DRAWINGS">FIG. 5B</figref> selects a plurality of operands from the various registers (e.g., pipeline register <b>521</b>, temporary register <b>523</b> [T<b>0</b>.<b>0</b>, T<b>0</b>.<b>1</b>, T<b>1</b>.<b>0</b>, T<b>1</b>.<b>1</b> are collectively referred to as the temporary registers <b>523</b>] and constant registers <b>522</b> [C<b>1</b> and C<b>2</b> are collectively referred to as the constant registers <b>522</b>]) according to the instruction <b>430</b>. In one embodiment of the invention, any of the operands can come from any of the registers. In one embodiment of the invention, the operand selector <b>530</b> is a crossbar selector comprising a stage of multiplexers for selecting the source of the operands.</p>
<p id="p-0097" num="0096">The operands (e.g., a, b, c, d) are then sent to the unpacker/formatter <b>532</b> to be unpacked and formatted into a desired data format. The operand values could be in various formats when selected by the operand selector <b>530</b> (refer to the discussion of <figref idref="DRAWINGS">FIG. 4A</figref> above). In one embodiment of the invention, the unpacker/formatter <b>532</b> formats the operands into a signed 1.8 (S1.8) format. The S1.8 format is a base 2 number with an 8-bit fraction that is in the range of (−2 to +2). The S1.8 format permits a higher dynamic range for calculations in which the result can optionally be clamped to a value between 0 and 1. For example, in calculations having a result in the range of 0 to 1, the S1.8 format permits the operands used in the ALU circuitry <b>535</b> to have an increased dynamic range, resulting in improved precision of calculations.</p>
<p id="p-0098" num="0097">In addition to formatting the data into a desired format, the unpacker/formatter <b>532</b> of <figref idref="DRAWINGS">FIG. 5B</figref> can also select a negative value (−x), or a complement value (1−x) for each of the operands (where “x” is an operand). The instruction <b>430</b> instructs the unpacker/formatter <b>532</b> to select the operand value, a negative operand value or a complement of an operand value. In one embodiment of the invention, the unpacker/formatter <b>532</b> includes a stage of multiplexers for selecting the operand, a complement operand value or a negative operand value.</p>
<p id="p-0099" num="0098">The operands are then processed by the ALU circuitry <b>535</b>. In one embodiment of the invention, the operation performed in the ALU circuitry <b>535</b> is in the form of (a*b) “op” (c*d) where “op” is specified according to the instruction <b>430</b> (refer to the discussion of <figref idref="DRAWINGS">FIG. 4C</figref> above). As stated above, the ALU circuitry <b>535</b> can detect mathematical identities and can determine the value of the mathematical identity without actually performing the calculation.</p>
<p id="p-0100" num="0099">The result “r” from the ALU circuitry <b>535</b> of <figref idref="DRAWINGS">FIG. 5A</figref> is then sent through a clamp <b>570</b> where the result can be clamped to a value within a specified range (in one embodiment, the range is 0 to 1). The instruction <b>430</b> specifies whether the result will be clamped or not. In one embodiment of the invention, the clamp <b>570</b> includes a multiplexer for selecting the result value or a clamped value.</p>
<p id="p-0101" num="0100">The result value “r” is then sent through a packer <b>533</b> to be packed into the data format used for the operand that it will optionally be replaced by the result in the outgoing pixel data <b>545</b>. The packed result value is sent to the outgoing pixel data selector <b>566</b>. The outgoing pixel data selector <b>566</b> is driven by the instruction <b>430</b> to generate an outgoing row of pixel data <b>545</b>. In one embodiment of the invention, depending on the operation being performed, ALU <b>350</b> returns up to a 10-bit result value. In this embodiment of the invention, the payload information <b>420</b> (80 bits) of the incoming pixel data <b>540</b> is combined with the result value (up to 10 bits) to generate an outgoing pixel packet of 80 bits, wherein up to a 10-bit value of the payload <b>420</b> is replaced with the similarly sized result value. Note that for the MUL opcode, a 20-bit result can be written (high and low 10-bit values at the same time).</p>
<p id="p-0102" num="0101">In one embodiment of the invention, the outgoing pixel data selector <b>566</b> includes a demultiplexer for forming the outgoing row of pixel data <b>545</b> from the incoming pixel data <b>540</b> (e.g., from the payload <b>420</b>) and the result value. The outgoing pixel data <b>545</b> (which may include the result value) is then sent to a following ALU stage or subsequent ALU.</p>
<p id="p-0103" num="0102">In one embodiment of the invention, perhaps in response to a kill bit being set, ALU <b>350</b> does not perform any operations on the incoming pixel data. In this embodiment, the payload <b>420</b> of the incoming pixel data is sent through the ALU to the following pipeline stage or subsequent ALU. In one such embodiment, the ALU circuitry <b>535</b> is powered down to reduce power consumption. In effect, the kill bit acts as an enabling bit. If the kill bit is set, a data latch is not enabled, and power is saved because no power is consumed to transition the latch.</p>
<p id="p-0104" num="0103">In one embodiment of the invention, the result value of an operation is recirculated into the temporary registers <b>523</b> so that it can be used in subsequent operations. This is described further in conjunction with <figref idref="DRAWINGS">FIG. 8</figref> below.</p>
<p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. 5C</figref> is a block diagram showing four series-coupled ALUs <b>350</b>-<b>1</b>, <b>350</b>-<b>2</b>, <b>350</b>-<b>3</b> and <b>350</b>-<b>4</b> in accordance with one embodiment of the present invention. ALU <b>350</b>-<b>1</b> receives incoming pixel data (e.g., a row of pixel data) from the data fetch stage <b>330</b>. Outgoing pixel data from ALU <b>350</b>-<b>1</b> is the incoming pixel data for ALU <b>350</b>-<b>2</b>, and so on through ALU <b>350</b>-<b>3</b> and <b>350</b>-<b>4</b>. The output pixel data from ALU <b>350</b>-<b>4</b> is input to the data write stage <b>355</b>.</p>
<p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart <b>600</b> of an exemplary process for processing graphics data according to one embodiment of the present invention. Although specific steps are disclosed in flowchart <b>600</b>, such steps are exemplary. That is, the present invention is well suited to performing various other steps or variations of the steps recited in flowchart <b>600</b>. It is appreciated that the steps in flowchart <b>600</b> may be performed in an order different than presented and that the steps in flowchart <b>600</b> are not necessarily performed in the sequence illustrated.</p>
<p id="p-0107" num="0106">In the present embodiment, the step <b>610</b> includes generating a first set of pixel data, the first set of pixel data comprising payload information comprising a plurality of scalar pixel attribute values and sideband information comprising a processing sequence identifier corresponding to a software programmable instruction for a first operation to be performed.</p>
<p id="p-0108" num="0107">Step <b>615</b> includes sending the first set of pixel data to an ALU stage comprising a plurality of scalar ALUs for processing the first set of pixel data based on the instruction. In one embodiment of the invention, the ALU stage includes 4 scalar ALUs.</p>
<p id="p-0109" num="0108">Step <b>620</b> includes selecting a set of operands to be processed at a first ALU. In one embodiment of the invention, 4 scalar values (e.g., a, b, c, d) are used as operands.</p>
<p id="p-0110" num="0109">Optional step <b>625</b> includes selecting a negative value or a complement value of an operand value. In one embodiment of the invention, an instruction, indicated in the sideband information, instructs the ALU to perform step <b>625</b> or not.</p>
<p id="p-0111" num="0110">Step <b>630</b> includes processing the operands and generating a result value therefrom.</p>
<p id="p-0112" num="0111">Optional step <b>635</b> includes clamping the result value within a range of values. In one embodiment of the invention, the instruction determines if the result is clamped or not.</p>
<p id="p-0113" num="0112">Optional step <b>640</b> includes sending the result value to a temporary register accessible by the first ALU. In one embodiment of the invention, the instruction determines if the result value is recirculated to a temporary register.</p>
<p id="p-0114" num="0113">Step <b>645</b> includes sending pixel data to a pipeline register in a second ALU or some other stage of the graphics pipeline. In one embodiment of the invention, the first ALU combines the first set of pixel data with the result value to generate a second set of pixel data. The second set of pixel data can be sent to a subsequent ALU, or to a following graphics pipeline stage such as a data write stage. In one embodiment of the invention, there are 4 scalar ALUs. Each of the ALUs can update one scalar value of the first set of pixel data. As a result of propagating through the 4 ALUs, the first set of pixel data could have no new values, one new value, two new values, three new values or four new values. In the case an ALU does not return a result value, the ALU circuitry is powered down to reduce power consumption.</p>
<p id="p-0115" num="0114">In summary, the use of a number of series-coupled ALUs in accordance with particular embodiments of the present invention provide a number of advantages. In general, the graphics functions of the pipeline all pass through the same group of ALUs. That is, each ALU can perform any of a variety of graphics functions that may be required by the graphics pipeline. Furthermore, each of the ALUs can operate simultaneously with the other ALUs to perform the same graphics function or a different graphics function on pixel data. Moreover, one or more pixels can be processed simultaneously by the ALUs. Also, the ALUs operate on scalar values rather than vector values. As such, the width of the graphics pipeline can be reduced and the pixel data formatted accordingly. That is, rather than working on a full width of pixel data associated with a pixel in a frame, the pixel data can be separated into rows of pixel data. By maintaining a narrow pipeline, graphics processing is made more efficient for typical usage cases, an advantage in devices such as PDAs where power conservation is important.</p>
<p id="p-0116" num="0115"><figref idref="DRAWINGS">FIG. 7</figref> illustrates an interleaving of rows of pixel packets in accordance with one embodiment of the present invention. As described in conjunction with <figref idref="DRAWINGS">FIG. 4A</figref> above, a pixel packet <b>400</b> (specifically, the payload portion <b>420</b> of a pixel packet) can be divided into multiple rows. According to the present embodiment, the rows associated with one pixel are interleaved with the rows of another pixel as they propagate through the pipeline. In the example of <figref idref="DRAWINGS">FIG. 7</figref>, row <b>0</b> of pixel <b>1</b> is interleaved between rows <b>0</b> and <b>1</b> of pixel <b>0</b>, Similarly, row <b>1</b> of pixel <b>0</b> is interleaved between rows <b>0</b> and <b>1</b> of pixel <b>1</b>, and so on. The interleaved rows are sent into and through pipeline <b>300</b> in the order of interleaving. Therefore, in general for any given frame, a portion of the data for one pixel (e.g., pixel <b>1</b>) is sent into and through pipeline <b>300</b> (<figref idref="DRAWINGS">FIG. 3</figref>) before the entirety of the data for the preceding (e.g., pixel <b>0</b>) is sent into and through pipeline <b>300</b>.</p>
<p id="p-0117" num="0116">In one embodiment, as described above in conjunction with <figref idref="DRAWINGS">FIG. 4B</figref>, an indicator flag or even/odd (e/o) bit is included in the sideband information <b>420</b> that is associated with each pixel row. For example, when the rows from two pixels are interleaved, the pixel rows associated with pixel <b>0</b> can be identified by setting the e/o bit to zero (0), while the pixel rows associated with pixel <b>1</b> can be identified by setting the e/o bit to one (1).</p>
<p id="p-0118" num="0117">In the present embodiment, for any given frame, only the rows associated with two pixels (e.g., pixel <b>0</b> and pixel <b>1</b>) are interleaved. However, in other embodiments, rows for more than two pixels can be interleaved. The number of bits in the e/o field of the sideband information <b>420</b> can be increased, depending on the number of pixels having rows that are interleaved. For example, if pixel rows for 4 pixels are interleaved, the e/o field can be increased to 2 bits. The extent of interleaving may be based on the latency of one ALU.</p>
<p id="p-0119" num="0118">Interleaving pixel rows as described above avoids stalls in the pipeline <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>, in particular in the ALU stage <b>340</b>. In one implementation according to embodiments of the present invention, there is a 2 clock cycle latency associated with each of the ALUs <b>350</b>. That is, it can take 2 clock cycles for a particular row of pixel data to travel through an ALU <b>350</b>. However, on occasion, there can be a need to use a result that is generated using one row of pixel data with another row of pixel data in the same ALU.</p>
<p id="p-0120" num="0119">For example, at clock cycle N, ALU <b>350</b> may perform an operation using the data associated with pixel <b>0</b> row <b>0</b>, generating a result “r.” The result “r” may be needed at clock cycle N+1 for an operation that will be performed using the data associated with pixel <b>0</b> row <b>1</b>. However, because of the 2 clock cycle latency associated with ALU <b>350</b>, the result “r” would not be available at the next clock cycle (cycle N+1). Instead, the result “r” is not available until clock cycle N+2. To avoid stalling pipeline <b>300</b> (that is, to avoid delaying the processing of pixel <b>0</b> row <b>1</b> until the result “r” is available), a row of pixel data for another pixel (e.g., row <b>0</b> of pixel <b>1</b>) is pipelined into ALU <b>350</b> and operated on by ALU <b>350</b> in clock cycle N+1. At the next clock cycle (cycle N+2), the pixel data for pixel <b>0</b> row <b>1</b> is pipelined into the ALU <b>350</b> and the result “r” is available. Accordingly, at clock cycle N+2, ALU <b>350</b> can perform an operation using the result “r” and the pixel <b>0</b> row <b>1</b> pixel data.</p>
<p id="p-0121" num="0120">Note that the pixel data for pixel <b>1</b> row <b>0</b> will overwrite any information in the ALU <b>350</b> pipeline registers. In one embodiment, the result “r” is persisted from clock cycle to the next by writing it to a temporary register that is local to the ALU <b>350</b> but different from the pipeline registers (see <figref idref="DRAWINGS">FIGS. 5A and 5B</figref> above). The use of temporary registers is described further in conjunction with <figref idref="DRAWINGS">FIG. 8</figref> below.</p>
<p id="p-0122" num="0121">The sequence of events described above is summarized in Table 3, which provides an example of some of the processing that can occur in an ALU along a timeline of clock cycles in accordance with one embodiment of the present invention. The example above, summarized by Table 3, describes a result being written to a temporary register. In actuality, the writing of a result to a temporary register is optional. That is, the result may not be written to a temporary register if it is not needed for a subsequent operation. Also, as discussed above, the result can optionally be written to the pipeline register for the next pipeline stage. In one embodiment, the destination <b>436</b> of the result of an ALU operation is specified according to instruction <b>430</b> of <figref idref="DRAWINGS">FIG. 4C</figref>.</p>
<p id="p-0123" num="0122">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 3</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Example of Pixel Data Being Operated on by an ALU and Written</entry>
</row>
<row>
<entry>to a Temporary Register According to One Embodiment</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Clock</entry>
<entry/>
</row>
<row>
<entry/>
<entry>Cycle</entry>
<entry>ALU Activity</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>N</entry>
<entry>Receive data for pixel 0 row 0 at pipeline</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register(s) of the ALU (e/o = 0);</entry>
</row>
<row>
<entry/>
<entry/>
<entry>First operation performed on pixel 0 row 0</entry>
</row>
<row>
<entry/>
<entry/>
<entry>data, generating a first result (r1).</entry>
</row>
<row>
<entry/>
<entry>N + 1</entry>
<entry>Write r1 to first temporary register of ALU;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Receive data for pixel 1 row 0 at pipeline</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register(s) of the ALU (e/o = 1);</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Second operation performed on pixel 1 row</entry>
</row>
<row>
<entry/>
<entry/>
<entry>0 data, generating a second result (r2).</entry>
</row>
<row>
<entry/>
<entry>N + 2</entry>
<entry>Write r2 to second temporary register of</entry>
</row>
<row>
<entry/>
<entry/>
<entry>ALU;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Receive data for pixel 0 row 1 at pipeline</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register(s) of the ALU (e/o = 0);</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Third operation performed on pixel 0 row 1</entry>
</row>
<row>
<entry/>
<entry/>
<entry>data and also using r1, generating a third</entry>
</row>
<row>
<entry/>
<entry/>
<entry>result (r3).</entry>
</row>
<row>
<entry/>
<entry>N + 3</entry>
<entry>Write r3 to third temporary register of ALU;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Receive data for pixel 1 row 1 at pipeline</entry>
</row>
<row>
<entry/>
<entry/>
<entry>register(s) of the ALU (e/o = 1);</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Fourth operation performed on pixel 1 row</entry>
</row>
<row>
<entry/>
<entry/>
<entry>1 data and also using r2, generating a third</entry>
</row>
<row>
<entry/>
<entry/>
<entry>result (r4).</entry>
</row>
<row>
<entry/>
<entry>Etc.</entry>
<entry>Etc.</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0124" num="0123">In the example of Table 3, mention is made of first, second and third temporary registers. In one embodiment, there are 4 temporary registers. In such an embodiment, two of the temporary registers are associated with one set of pixel data (e.g., “even” pixel <b>0</b>) and are active for that pixel, and the other two temporary registers are associated with the other set of pixel data (e.g., “odd” pixel <b>1</b>) and are active for that pixel. The e/o bit of <figref idref="DRAWINGS">FIG. 4B</figref>, along with the register number <b>446</b> (<figref idref="DRAWINGS">FIG. 4D</figref>) or the destination <b>436</b> specified in the instruction <b>430</b> of <figref idref="DRAWINGS">FIG. 4C</figref>, is used to control which of the temporary registers the result of an ALU operation is read from or written to. By performing this temporary register multiplexing automatically based on the e/o bit of <figref idref="DRAWINGS">FIG. 4B</figref>, software is shielded from knowledge of this latency-hiding mechanism.</p>
<p id="p-0125" num="0124"><figref idref="DRAWINGS">FIG. 8</figref> is a data flow diagram showing the flow of data in an ALU <b>350</b> with local temporary registers in accordance with one embodiment of the present invention. As described above, ALU <b>350</b> can include elements other than those shown in <figref idref="DRAWINGS">FIG. 8</figref> (refer to <figref idref="DRAWINGS">FIGS. 5A and 5B</figref> above, for instance). The example of <figref idref="DRAWINGS">FIG. 8</figref> illustrates a case in which 4 temporary registers T<b>0</b>.<b>0</b>, T<b>0</b>.<b>1</b>, T<b>1</b>.<b>0</b> and T<b>1</b>.<b>1</b> are used; however, the present invention is not so limited. In general, the number of temporary registers is a design decision. In one embodiment, 4 temporary registers are used because 4 temporary registers are considered adequate when the rows of two pixels are interleaved.</p>
<p id="p-0126" num="0125">In one embodiment, the width of each of the temporary registers T<b>0</b>.<b>0</b>, T<b>0</b>.<b>1</b>, T<b>1</b>.<b>0</b> and T<b>1</b>.<b>1</b> is 20 bits. In general, the width of the temporary register corresponds to the width of the sets of pixel data <b>422</b>-<b>425</b> of <figref idref="DRAWINGS">FIG. 4B</figref>.</p>
<p id="p-0127" num="0126">In the present embodiment, a row of pixel data is received at pipeline registers <b>804</b> from a preceding (e.g., upstream) stage <b>801</b> in the pipeline <b>300</b>. The preceding pipeline stage <b>801</b> may be another ALU in the ALU stage <b>340</b>, or it may be the data fetch stage <b>330</b> (<figref idref="DRAWINGS">FIG. 3</figref>). In the example of <figref idref="DRAWINGS">FIG. 8</figref>, there are 4 pipeline registers; however, the present invention is not so limited.</p>
<p id="p-0128" num="0127">As previously described herein, ALU circuitry <b>803</b> operates on the data in the pipeline registers <b>804</b> to generate a result “r.” The result “r” is optionally written to the next pipeline stage <b>802</b> of pipeline <b>300</b>. Specifically, as described previously herein, the result “r” optionally replaces (overwrites) one of the pixel attribute values in the pipeline registers <b>804</b> (R<b>0</b>, R<b>1</b>, R<b>2</b> and R<b>3</b>) before the contents of the pipeline registers are processed in the next pipeline stage <b>802</b>.</p>
<p id="p-0129" num="0128">According to the present embodiment of the present invention, the result “r” is also written to one of the temporary registers T<b>0</b>.<b>0</b>, T<b>0</b>.<b>1</b>, T<b>1</b>.<b>0</b> or T<b>1</b>.<b>1</b>. In one embodiment, an indicator flag (e.g., the e/o bit of <figref idref="DRAWINGS">FIG. 4B</figref>), along with the destination <b>436</b> specified in the instruction <b>430</b> of <figref idref="DRAWINGS">FIG. 4C</figref>, is used to control which of the temporary registers the result of an ALU operation is written to. The indicator flag (e.g., e/o bit) controls multiplexing logic (e.g., a multiplexer) that routes the result “r” to the proper temporary register.</p>
<p id="p-0130" num="0129">Continuing with reference to <figref idref="DRAWINGS">FIG. 8</figref>, for a subsequent operation using “r,” an indicator flag (e.g., the e/o bit of <figref idref="DRAWINGS">FIG. 4B</figref>), along with the register number <b>446</b> of <figref idref="DRAWINGS">FIG. 4D</figref>, is used to control which of the temporary registers the result of an ALU operation is read from. The indicator flag (e.g., e/o bit) controls multiplexing logic (e.g., a multiplexer) that reads the result “r” from the proper temporary register.</p>
<p id="p-0131" num="0130">As described in conjunction with <figref idref="DRAWINGS">FIG. 7</figref> and Table 3 above, the rows of pixel data for a number of different pixels (e.g., 2 pixels, P<b>0</b> and P<b>1</b>) are interleaved. As a result, in one embodiment, the value of the indicator flag essentially toggles back and forth between 0 and 1 each clock cycle. Accordingly, in such an embodiment, a different set of temporary registers are made active and used each clock cycle until the processing of pixels <b>0</b> and <b>1</b> in ALU <b>350</b> is completed. For example, at clock cycle N (and at every other clock cycle thereafter until processing of pixel <b>0</b> is completed in ALU <b>350</b>), the temporary registers associated with pixel <b>0</b> are used (e.g., T<b>0</b>.<b>0</b> and T<b>0</b>.<b>1</b>), and at clock cycle N+1 (and at every other clock cycle thereafter until processing of pixel <b>1</b> is completed in ALU <b>350</b>), the temporary registers associated with pixel <b>1</b> are used (e.g., T<b>1</b>.<b>0</b> and T<b>1</b>.<b>1</b>).</p>
<p id="p-0132" num="0131"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart <b>900</b> of a method for processing data in an ALU with temporary registers in accordance with one embodiment of the present invention. Although specific steps are disclosed in flowchart <b>900</b>, such steps are exemplary. That is, the present invention is well suited to performing various other steps or variations of the steps recited in flowchart <b>900</b>. It is appreciated that the steps in flowchart <b>900</b> may be performed in an order different than presented and that the steps in flowchart <b>900</b> are not necessarily performed in the sequence illustrated. In one embodiment, flowchart <b>900</b> is implemented as program instructions executed by graphics processor <b>205</b> (<figref idref="DRAWINGS">FIGS. 2A and 2B</figref>).</p>
<p id="p-0133" num="0132">In step <b>901</b> of <figref idref="DRAWINGS">FIG. 9</figref>, a first set of pixel data is received at a pipeline register coupled to the arithmetic circuitry of an ALU. The first set of pixel data is received from a stage that precedes the ALU in a graphics pipeline. The stage may be another ALU in the graphics pipeline. In one embodiment, the first set of pixel data corresponds to one part of a row of pixel data. In one such embodiment, the first set of pixel data is 20 bits in length. In another such embodiment, the row of pixel data includes a total of four sets of pixel data, each of which is received into a respective pipeline register coupled to the ALU.</p>
<p id="p-0134" num="0133">In another embodiment, the first set of pixel data is associated with one row of a pixel packet for a first pixel. In such an embodiment, the first set of pixel data is identified as being associated with the first pixel using an indicator flag (e.g., an e/o bit).</p>
<p id="p-0135" num="0134">In step <b>902</b>, a first operation is performed by the ALU using the first set of pixel data. Examples of operations are listed in Table 1 above.</p>
<p id="p-0136" num="0135">In step <b>903</b>, a result of the first operation is written to a first temporary register within the ALU. In one embodiment, in which the first set of pixel data is associated with one row of a pixel packet for a first pixel, and in which the first set of pixel data is identified as being associated with the first pixel using an indicator flag (e.g., an e/o bit), the first temporary register is selected from a plurality of temporary registers according to the value of the indicator flag.</p>
<p id="p-0137" num="0136">In step <b>904</b>, a second set of pixel data is received into the pipeline register. In one embodiment, in which the first set of pixel data is associated with one row of a pixel packet for a first pixel, the second set of pixel data is associated with a second row of the pixel packet for the first pixel.</p>
<p id="p-0138" num="0137">In step <b>905</b>, the result of the first operation and the second set of pixel data is used by the ALU in a second operation.</p>
<p id="p-0139" num="0138">In one embodiment, the first and second sets of pixel data are interleaved in the pipeline with a third set of pixel data and a fourth set of pixel data. In such an embodiment, the third and fourth sets of pixel data are associated with a first row and a second row of a pixel packet for a second pixel. The third set of pixel data is received into the pipeline register after the first set of pixel data but before the second set of pixel data. A third operation can be performed using the third set of pixel data, with the result written to a second temporary register that is selected from the plurality of temporary registers according to the value of the indicator flag. The result of the third operation can then be used in a subsequent fourth operation along with the fourth set of pixel data.</p>
<p id="p-0140" num="0139">In summary, the use of ALU temporary registers in accordance with particular embodiments of the present invention allows a result generated using one set of pixel data to be used with a subsequent set of pixel data in the same ALU. The result can be persisted in the ALU through multiple clock cycles, until the subsequent set of pixel data is available at the ALU. Consequently, the occurrence of stalls that might otherwise occur in the ALU is avoided.</p>
<p id="p-0141" num="0140">Embodiments of the present invention are thus described. While the present invention has been described in particular embodiments, it should be appreciated that the present invention should not be construed as limited by such embodiments, but rather construed according to the below claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. An arithmetic logic stage in a graphics pipeline, said arithmetic logic stage comprising:
<claim-text>a plurality of series-coupled scalar arithmetic logic units, each unit of said plurality of units for performing a respective arithmetic logic operation on a set of input operands and for producing a result based thereon, wherein said set of input operands comprise four input operands and wherein said arithmetic logic operation is of the form [a*b “op” c*d], wherein a, b, c and d are said input operands and wherein further “op” represents an operation to be performed on said input operands by an arithmetic logic unit;</claim-text>
<claim-text>wherein said arithmetic logic unit receives information comprising a pointer to an instruction to be executed by said arithmetic logic unit and wherein said instruction selects said operation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein a pixel packet of a pixel comprises rows of pixel information and wherein each scalar arithmetic logic unit has a two clock cycle latency per row.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. An arithmetic logic stage as described in <claim-ref idref="CLM-00002">claim 2</claim-ref> that is software-configurable for single clock cycle throughput per row.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein each input operand is 20 bits wide and wherein said result is 10 bits wide.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said plurality of series-coupled scalar arithmetic logic units comprises four series-coupled scalar arithmetic logic units.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said set of input operands are software selectable from a set comprising a pipeline register, a temporary register and a constant value.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein pixel packets are associated with pixels and each pixel packet comprises a plurality of rows of pixel information and wherein each scalar arithmetic logic unit is software-programmable to simultaneously process a different row of pixel information.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein pixel packets are associated with pixels and each pixel packet comprises a plurality of rows of pixel information and wherein said plurality of series coupled scalar arithmetic logic units are software-programmable to simultaneously process rows of a plurality of pixels.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein first and second scalar arithmetic logic units are software programmable to operate simultaneously to implement a first graphics functionality while a third scalar arithmetic logic unit is software programmable to operate simultaneously to implement a second graphics functionality different from said first graphics functionality.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said result is software-programmable for storage into a temporary register of each scalar arithmetic logic unit and is further software-programmable to be provided to a downstream pipeline stage.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. An arithmetic logic stage as described in <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein a pixel packet is associated with each pixel, wherein said pixel packet comprises a plurality of rows of pixel data and wherein a row of pixel data comprises said pointer and values for said operands.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A graphics pipeline comprising:
<claim-text>a raster stage for generating pixel packets for respective pixels;</claim-text>
<claim-text>a data fetch stage coupled to said raster stage and for fetching pixel data for storage in said pixel packets, wherein said pixel packets each comprise one or more rows of pixel data, said one or more rows each comprising sets of pixel data; and</claim-text>
<claim-text>an arithmetic logic unit (ALU) stage coupled to said data fetch stage and comprising a plurality of scalar ALUs coupled in series, each of said ALUs for concurrently performing a respective operation on operands selected from said pixel packets and for producing a result, wherein said operation is of the form [a*b “op” c*d] wherein a, b, c and d are said operands and wherein further “op” represents an operation to be performed on said operands by an ALU; wherein said ALU receives information comprising a pointer to an instruction to be executed by said ALU and wherein said instruction selects said operation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The graphics pipeline of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein each of said ALUs has a two clock cycle latency per row.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The graphics pipeline of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein each of said ALUs is software-configurable for single clock cycle throughput per row.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The graphics pipeline of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein said operands are four operands.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The graphics pipeline of <claim-ref idref="CLM-00015">claim 15</claim-ref> wherein each of said operands is 20 bits wide and wherein said result is 10 bits wide.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The graphics pipeline of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein said plurality of scalar ALUs comprises four ALUs.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The graphics pipeline of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein said ALUs are software-programmable to concurrently process a different row of pixel data.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The graphics pipeline of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein said ALUs are software-programmable to concurrently process rows of a plurality of pixels.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The graphics pipeline of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein a first plurality of said ALUs are software-programmable to operate simultaneously to implement a particular graphics functionality, while a second plurality of said ALUs are software-programmable to operate simultaneously to implement a different graphics functionality.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The graphics pipeline of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein a row of pixel data comprises said pointer and values for said operands.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A method for processing data in a graphics pipeline, said method comprising:
<claim-text>generating pixel packets for respective pixels;</claim-text>
<claim-text>fetching pixel data that is included in said pixel packets, wherein said pixel packets each comprise one or more rows of pixel data, said one or more rows each comprising sets of pixel data; and</claim-text>
<claim-text>receiving rows of pixel data at a plurality of scalar arithmetic logic units (ALUs) coupled in series, each of said ALUs for concurrently performing a respective operation on operands selected from said pixel packets and for producing a result, wherein said operation is of the form [a*b “op” c*d], wherein a, b, c and d are said operands and wherein further “op” represents an operation to be performed on said operands by an ALU; wherein said ALU receives information comprising a pointer to an instruction to be executed by said ALU and wherein said instruction selects said operation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein each of said ALUs has a two clock cycle latency per row and wherein further each of said ALUs is software-configurable for single clock cycle throughput per row.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein said operands are four operands and wherein further each of said operands is 20 bits wide and said result is 10 bits wide.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein said plurality of scalar ALUs comprises four ALUs.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein said ALUs are software-programmable to concurrently process a different row of pixel data.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein said ALUs are software-programmable to concurrently process rows of a plurality of pixels.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein a first plurality of said ALUs are software-programmable to operate simultaneously to implement a particular graphics functionality, while a second plurality of said ALUs are software-programmable to operate simultaneously to implement a different graphics functionality.</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein a row of pixel data comprises said pointer and values for said operands.</claim-text>
</claim>
</claims>
</us-patent-grant>
