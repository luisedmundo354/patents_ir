<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299472-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299472</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10345050</doc-number>
<date>20030115</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>739</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>3</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>719310</main-classification>
</classification-national>
<invention-title id="d0e53">System and method for dynamically determining notification behavior of a monitoring system in a network environment</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5388189</doc-number>
<kind>A</kind>
<name>Kung</name>
<date>19950200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5497434</doc-number>
<kind>A</kind>
<name>Wilson</name>
<date>19960300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5655081</doc-number>
<kind>A</kind>
<name>Bonnell et al.</name>
<date>19970800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5825917</doc-number>
<kind>A</kind>
<name>Suzuki</name>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5828882</doc-number>
<kind>A</kind>
<name>Hinckley</name>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719318</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5987514</doc-number>
<kind>A</kind>
<name>Rangarajan</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6005979</doc-number>
<kind>A</kind>
<name>Chang et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6009192</doc-number>
<kind>A</kind>
<name>Klassen et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6021262</doc-number>
<kind>A</kind>
<name>Cote et al.</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 48</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6493755</doc-number>
<kind>B1</kind>
<name>Hansen et al.</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6546432</doc-number>
<kind>B2</kind>
<name>Couturier et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719318</main-classification></classification-national>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6983464</doc-number>
<kind>B1</kind>
<name>Bhattacharya et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719318</main-classification></classification-national>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2002/0087643</doc-number>
<kind>A1</kind>
<name>Parsons et al.</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709206</main-classification></classification-national>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2002/0116541</doc-number>
<kind>A1</kind>
<name>Parker et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709318</main-classification></classification-national>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>WO</country>
<doc-number>WO 96/35994</doc-number>
<kind>A1</kind>
<date>19961100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00016">
<othercit>International Search Reported for PCT/US03/01144 mailed Aug. 20, 2003.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00017">
<othercit>Wu, et al., “Alarm Correlation Engine (ACE)” Network Operations and Management Symposium, pp. 733-742, Feb. 15-20, 1998.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00018">
<othercit>International Search Report for PCT/US02/28994, Dec. 4, 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00019">
<othercit>Robert W. Floyd &amp; Louis Steinberg, “<i>An adaptive algorithm for spatial gray scale</i>” SID 75 Digest: 36-37, 1975.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00020">
<othercit>Paul Heckbert, “<i>Color image quantization for frame buffer display</i>” Computer Graphics, 16(3):297-307, Jul. 1982.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00021">
<othercit>C. E. Shannon, “<i>A mathematical theory of communication</i>” The Bell System Technical Journal, 27(3): 379-423, Jul. 1948.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00022">
<othercit>C. E. Shannon, “<i>A mathematical theory of communication, Part III</i>.” The Bell System Technical Journal, pp. 623-656, Jul. 1948.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00023">
<othercit>T. A. Welch, “<i>A technique for high-performance data compression</i>” Computer, 17(6): 8-19, Jun. 1984.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00024">
<othercit>Jacob Ziv, “<i>Coding theorems for individual sequences</i>” IEEE Transactions on Information Theory, 24(4): 405-412, Jul. 1978.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00025">
<othercit>Jacob Ziv &amp; Abraham Lempel, “<i>A universal algorithm for sequential data compression</i>” IEEE Transactions on Information Theory, 24(3): 337-343, May 1977.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00026">
<othercit>Jacob Ziv &amp; Abraham Lempel, “<i>Compression of individual sequences via variable-rate coding</i>”IEEE Transactions on Information Theory, 24(5): 530-536, Sep. 1978.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>13</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>719318</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>719310</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60349424</doc-number>
<kind>00</kind>
<date>20020118</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60349344</doc-number>
<kind>00</kind>
<date>20020118</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60348692</doc-number>
<kind>00</kind>
<date>20020115</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20030167353</doc-number>
<kind>A1</kind>
<date>20030904</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>de Bonet</last-name>
<first-name>Jeremy S.</first-name>
<address>
<city>North Andover</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Stiers</last-name>
<first-name>Todd A.</first-name>
<address>
<city>Berkeley</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Annison</last-name>
<first-name>Jeffrey R.</first-name>
<address>
<city>Clayton</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Sprinkle IP Law Group</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>MobiTV, Inc.</orgname>
<role>02</role>
<address>
<city>Emeryvile</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Thomson</last-name>
<first-name>William</first-name>
<department>2194</department>
</primary-examiner>
<assistant-examiner>
<last-name>Truong</last-name>
<first-name>LeChi</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Embodiments of the present invention provide a system and method for dynamically controlling the notification behavior of a system. One embodiment of the present invention can include a system for controlling notification behavior of a system comprising a notification program stored on a computer-readable memory. The notification program can be executable by a computer processor to determine a first notification mode based on a set of configuration parameters and a first-system state. The notification program can be further executable to determine if a notification should be sent out based a set of configuration parameters associated with first notification mode and, if a notification should be sent out, communicate the notification over a network. The notification program can also receive an updated configuration parameter associated with the first notification mode and send out a new notification based on the updated configuration parameter.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="168.91mm" wi="134.45mm" file="US07299472-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="169.76mm" wi="138.18mm" file="US07299472-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="236.22mm" wi="157.82mm" file="US07299472-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="192.28mm" wi="135.97mm" file="US07299472-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims priority under 35 U.S.C. § 119(e) to U.S. Provisional Patent Application No. 60/348,692, entitled “Mechanism for Dynamically Determining the Notification Behavior of a Complex System,” by de Bonet et al., filed Jan. 15, 2002, U.S. Provisional Patent Application No. 60/349,424, entitled “Network Proxy Platform that Simultaneously Supports Data Transformation, Storage, and Manipulation for Multiple Protocols” by de Bonet et al., filed on Jan. 18, 2002, U.S. Provisional Patent Application No. 60/349,344 entitled “Modular Plug-In Transaction Processing Architecture” by de Bonet et al., filed Jan. 18, 2002, which are hereby fully incorporated by reference herein. Additionally, U.S. patent application Ser. No. 10/342,113, entitled “Method and System of Performing Transactions Using Shared Resources and Different Applications,” by de Bonet et al., filed Jan. 14, 2003 is incorporated by reference herein.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">TECHNICAL FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">Embodiments of the invention relate generally to notification systems. More particularly, embodiments of the present invention relate to systems and methods for determining the notification behavior of a system.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">Over the past several decades remote monitoring of complex hardware, software and physical systems has become more commonplace. The proliferation of remote monitoring has been facilitated by the increased sophistication and speed of digital communications media. In typical remote monitoring systems, a centralized management server receives notifications regarding the status of various monitored components from software agents installed on those components. Typically, the software agents will send out status notifications at the same frequency and in the same manner regardless of the state of the monitored component. Thus, whether a component is functioning properly or exhibiting an error, the software agent associated with that component will send out notifications at the same frequency. In a large system, this can lead to an overabundance of notifications.</p>
<p id="p-0005" num="0004">In order to provide a more manageable set of notifications to an operator, many prior art systems employ a network management station (“NMS”) at the centralized management server that provides a common human interface for receiving the notifications and allowing the operator to select which notifications to view. The operator can configure the NMS to display only a subset of the notifications received so that the operator does not have to view every notification received by the centralized management server.</p>
<p id="p-0006" num="0005">While the NMS can reduce the number notifications viewed, the notifications are still sent from the software agents. If the software agents send a large number of notifications, the notifications may require a large amount of bandwidth, saturating and slowing the network conducting the notifications. Moreover, if the operator configures the NMS to display too many notifications, he or she might be conditioned to ignore the alarms. If, on the other hand, the operator configures the NMS to filter out too many of the received notifications, he or she may never see important notifications, again missing alarm conditions.</p>
<p id="p-0007" num="0006">One example of a common system displaying the inadequacies of prior art notification systems is a computer network employing simple network management protocol (“SNMP”) to monitor network components. SNMP was developed in the 1980's as a simple protocol that could be implemented to manage a variety of heterogeneous systems. Originally, SNMP was intended as a stopgap measure until a more robust protocol could be developed. However, the wide adoption of SNMP made it the de facto standard for internetwork management.</p>
<p id="p-0008" num="0007">SNMP generally works on a server agent architecture with agents capable of using the SNMP protocol installed on each monitored component, in some cases as a portion of the firmware. The agent can send notifications, known as SNMP traps, to advise the centralized management server when one or more conditions at the monitored component has been met. In typical SNMP systems, an SNMP trap is sent every time this set of conditions is met.</p>
<p id="p-0009" num="0008">In many prior art systems, the software agent will be configured to send out an SNMP trap with the monitored component's status information regardless of whether the component is functioning properly or whether the component is malfunctioning. This can lead to the software agent communicating a large volume of SNMP traps to the centralized management server. The operator, through an NMS, will then determine which SNMP traps to view. If the operator chooses to view a large number of the SNMP traps, he or she may miss alarm conditions due to information overload. Conversely, if the operator sets the NMS to filer too many SNMP traps, the operator may never see an SNMP trap indicating an alarm at a monitored component.</p>
<p id="p-0010" num="0009">To reduce the number of SNMP traps sent, some prior art systems define several levels for notification behavior. Examples of such levels include a level in which all alarm messages, but no other notifications, are sent by the software agents, a level in which all SNMP traps are sent by the software agents, or a midlevel in which both SNMP traps indicating normal operation and alarm conditions are sent by the software agent according to some predefined rule. However, these systems only provide a course control that is typically applied to all the software agents (or SNMP traps of those agents). They do not allow fine control for tuning a particular SNMP trap to send out notifications at, for example, different frequencies or for adjusting the behavior of the particular SNMP trap depending on the status of the component being monitored by the SNMP trap.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0011" num="0010">Embodiments of the present invention provide a system and method for determining notification behavior of a system that substantially reduces or eliminates the disadvantages associated with previously-developed notification systems and methods. More particularly, embodiments of the present invention provide a system and method for dynamically controlling the notification behavior of a system. One embodiment of the present invention can include a system for controlling notification behavior of a system comprising a notification program stored on a computer-readable memory. The notification program can be executable by a computer processor to determine a first notification mode based on a set of configuration parameters and a first system state. The notification program can be further executable to determine if a notification should be sent out based a set of configuration parameters associated with first notification mode and, if a notification should be sent out, communicate the notification over a network. The notification program can also receive an updated configuration parameter associated with the first notification mode and send out a new notification based on the updated configuration parameter.</p>
<p id="p-0012" num="0011">In one embodiment of the present invention, the notification program can determine if a notification should be sent out under the first notification mode based on the time the last notification associated with the first notification mode was sent out and a frequency parameter for the notification mode.</p>
<p id="p-0013" num="0012">In another embodiment of the present invention, the notification program can determine if a notification should be sent out under a notification mode based on the number of previous consecutive notifications that have been sent out for that notification mode.</p>
<p id="p-0014" num="0013">Another embodiment of the present invention can include a method for controlling the notification behavior of a system, including the steps of: (i) determining a first notification mode based on a set of configuration parameters and a first system state; (ii) determining if a notification should be sent out based on the set of configuration parameters and the first notification mode; and (iii) if so, communicating a notification over a network. This embodiment of the present can further comprise: (iv) receiving an updated configuration parameter associated with the first notification mode; (v) determining a new notification mode based on a new system state and the set of configuration parameters; and (vi) if the new notification mode is determined to be the first notification mode, determining if a new notification should be sent out based on the updated set of configuration parameters; and (vii) sending out a new notification.</p>
<p id="p-0015" num="0014">In one embodiment of the present invention, the step of determining if a notification should be sent out based on a set of configuration parameters and the first notification mode can be based on the time the last notification associated with the first notification mode was sent out and a frequency parameter.</p>
<p id="p-0016" num="0015">In another embodiment of the present invention, the step of determining if a notification should be sent out under a notification mode can be based on the number of previous consecutive notifications that have been sent under that notification mode.</p>
<p id="p-0017" num="0016">Embodiments of the present invention provide advantages over prior art notification systems by allowing the notification characteristics of multiple notification modes to be defined. This allows an operator to tune the notification characteristics of embodiments of the present invention to prevent information overload while ensuring that sufficient alarm notifications are received.</p>
<p id="p-0018" num="0017">Embodiments of the present invention provide another advantage over prior art systems and methods of determining notification behavior by allowing configuration parameters associated with various notification modes to be dynamically changed during execution of the remote agent thereby allowing the notification behavior of the system to be dynamically turned.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0019" num="0018">A more complete understanding of the present invention and the advantages thereof may be acquired by referring to the following description, taken in conjunction with the accompanying drawings in which like reference numbers indicate like features and wherein:</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 1</figref> is a diagrammatic representation of a system according to one embodiment of the present invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 2</figref> is a diagrammatic representation of a set of configuration parameters defining multiple notification modes according to one embodiment of the present invention; and</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 3</figref> illustrates a flow chart for a method of controlling notification behavior according to one embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0023" num="0022">Preferred embodiments of the present invention are illustrated in the figures, like numerals being used to refer to like and corresponding parts of the various drawings. Embodiments of the present invention provide a system and method to manage the notification behavior of a system. One embodiment of the present invention can define multiple notification modes, each exhibiting different notification behavior, based on the state of a component being monitored. For example, embodiments of the present invention can define notification modes such that notifications that indicate a problem state in a monitored component can be sent out more frequently than notifications that indicate that the monitored component is functioning properly. A number of notification modes can be defined to provide various gradations of notification behavior depending on the state of the monitored component. Moreover, the manner in which a particular notification is sent out can also be controlled. Thus, for example, important notifications can be sent to an operator's pager whereas less important notifications can be sent in some other manner (e.g. email).</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 1</figref>, is a diagrammatical representation of a system <b>100</b> in which one embodiment of the present invention can be implemented. System <b>100</b> can comprise a management system <b>110</b> that can include a management computer processor <b>112</b>, a management computer readable memory <b>114</b> (e.g. RAM, ROM, magnetic storage device, optical storage device, and/or any other computer readable memory known in the art) and a management system network adaptor <b>116</b> (e.g. modem, Ethernet card or any other network communication device known in the art). Management System <b>110</b> can further include a management program <b>115</b> stored on computer-readable memory <b>114</b> that is executable by management processor <b>112</b>. Management program <b>115</b> can receive and process multiple notifications from various software agents over network <b>120</b>. Moreover, management program <b>115</b> can include an NMS to allow an operator to limit the number of notifications he or she views. Although shown as a single physical unit in <figref idref="DRAWINGS">FIG. 1</figref>, it should be noted that the functionality of management System <b>110</b> can be distributed.</p>
<p id="p-0025" num="0024">In addition to management system <b>110</b>, system <b>100</b> can include multiple monitoring systems (e.g. monitoring system <b>130</b>, monitoring system <b>160</b> and monitoring system <b>170</b>). Although only shown for monitoring System <b>130</b>, each monitoring system can include a computer processor <b>132</b> and a computer-readable memory <b>134</b> (e.g. RAM, ROM, magnetic storage device, optical storage device, and/or any other computer readable memory known in the art). Moreover, each monitoring system can include a network adaptor device <b>139</b> (e.g. Ethernet Card Modem or any other network communications device known in the art). A notification program <b>140</b> can reside at computer-readable memory <b>134</b>. In the embodiment shown in <figref idref="DRAWINGS">FIG. 1</figref>, notification program <b>140</b> can contain a monitoring portion <b>145</b> and a notification portion <b>150</b>. Monitoring portion <b>145</b> can receive data regarding the state of a monitored component, and based on this data, notification portion <b>140</b> can send notifications to management system <b>110</b> via network <b>120</b>. In another embodiment, notification program <b>140</b> can be separate from the program that determines the system state or can be implemented in any other suitable manner as would be understood by one of ordinary skill in the art (e.g. as a software component of larger software package, a function larger software package, a separate program, a portion of another program).</p>
<p id="p-0026" num="0025">The monitored components can include components of the monitoring system, such as hardware or software components, or may include external components. For example, in the system of <figref idref="DRAWINGS">FIG. 1</figref>, notification program <b>140</b> of monitoring system <b>130</b> can determine the system state of one or components of monitoring system <b>130</b>. In fact, notification program <b>140</b> can be implemented, in one embodiment of the present invention, as firmware on the monitored component (e.g. firmware on a hard drive). As another example, notification program <b>140</b> of monitoring system <b>170</b> can receive data from pressure gauge <b>175</b> to determine the system state of a pressure chamber. Other examples of monitored components can include hardware components, such as hard drives, memory, network adapters or any other hardware, software or mechanical system capable of being automatically monitored by a program.</p>
<p id="p-0027" num="0026">In operation, notification program <b>140</b> can determine the system state for a component being monitored. For example, notification program <b>140</b> of monitoring system <b>170</b> can, through monitoring portion <b>145</b>, can determine the pressure of a chamber through pressure gauge <b>175</b>. Similarly, monitoring portion <b>145</b> in monitoring system <b>130</b> can determine, for example, the saturation of RAM in monitoring system <b>130</b> (i.e. can determine the amount of memory being used). Based on this state information, notification program <b>140</b> can determine a notification mode that corresponds to the system state. Each notification mode can define the notification behavior for a particular system state.</p>
<p id="p-0028" num="0027">For example, monitoring system <b>170</b> can define a first notification mode for a pressure between zero and 1,000 psi (e.g. a low-pressure mode), a second notification mode for a pressure from 1,000 psi to 9,000 psi (e.g. a normal-pressure mode), and a third notification mode for a pressure from 9,000 psi to 10,000 psi (e.g. a high-pressure mode). Each notification mode can define how frequently and how many times a notification for a particular system state is sent out.</p>
<p id="p-0029" num="0028">Continuing with the previous example, the first notification mode (the low-pressure notification mode), corresponding to a pressure of less than 1,000 psi, can be configured to send out notifications every five minutes for a maximum of six consecutive notifications. The second notification mode (the normal-pressure notification mode), corresponding to a pressure of 1,000 to 9,000 psi, can be configured to send out notifications every two minutes for a maximum of 8 consecutive notifications, and the third notification mode (the high-pressure notification mode), corresponding to a pressure of greater than 9,000 psi, can be configured to send out notifications every 10 seconds without limit.</p>
<p id="p-0030" num="0029">If the notification mode changes because the system state changes (e.g. the pressure goes from 800 psi to 3000 psi), a new notification can be sent out based on the new notification mode. As an example, if, at minute five, notification program <b>140</b> sends out a notification based on the first notification mode, and, at minute six, notification program <b>140</b> of system <b>170</b> determines that the pressure has changed to 3,000 psi, the notification program <b>140</b> can send out a new notification in accordance with the second notification mode. If at minute seven the pressure changes back to the below 1,000 psi, corresponding to the first notification mode, notification program <b>140</b> can send out a new notification in accordance with the first notification mode. Alternatively, because five minutes (i.e. the frequency of the first notification mode) have not passed since the last notification under the first notification mode was sent out, system <b>170</b> may delay sending out the new notification until the five minutes pass.</p>
<p id="p-0031" num="0030">Notification program <b>140</b> can send out notifications in a variety of manners including email, pager, fax or SNMP trap and embodiments of notification program <b>140</b> can send notifications associated with different notification modes in different formats. For example, notifications program <b>140</b> could send high-priority notifications to an operator's pager, but send lower priority notifications to the operator's email address.</p>
<p id="p-0032" num="0031">In one embodiment of the present invention, management program <b>115</b> can send updated configuration parameters to the monitoring systems thereby dynamically altering the notification behavior of a monitored system. For example, rather than having a frequency of every five minutes for the first notification mode of monitoring system <b>170</b>, management program <b>115</b> can change the frequency parameter for the first notification mode to 3 minutes. This can be done while notification program <b>140</b> is running, resulting in a dynamic update to the notification behavior of monitoring system <b>170</b>.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 2A</figref> is a diagrammatic representation of a notification type <b>198</b> with configuration parameters that can be used by notification program <b>140</b> to determine if a notification should be sent according to the state of a monitored component. Each notification program <b>140</b> can utilize several notification types, with notification modes defined for each notification type. The notification type can represent the function for sending out a notification for a particular type of system state. For example, monitoring system <b>170</b> could have two notification types, one for notifications regarding pressure and one for notifications regarding temperature, with each notification type having several notification modes. As another example, each notification type can represent different types of SNMP traps implemented at the same monitored component(s).</p>
<p id="p-0034" num="0033">The configuration parameters for each notification type can include a status parameter <b>200</b> and a count parameter <b>205</b>. The status parameter indicates the notification mode (e.g. notification mode <b>210</b>-<b>1</b>, notification mode <b>210</b>-<b>1</b> or notification mode <b>210</b>-<b>3</b>) that is associated with the current state of the component being monitored for notification type <b>198</b>. The appropriate notification mode for a system state can be determined from one or more threshold parameters. In the embodiment of <figref idref="DRAWINGS">FIG. 2A</figref>, each notification mode is associated with a “min” parameter <b>215</b> and a “max” parameter <b>220</b>. Other threshold parameters can be used and in some cases the notification modes may only be associated with a single threshold parameter, rather than multiple threshold parameters as shown in <figref idref="DRAWINGS">FIG. 2A</figref>.</p>
<p id="p-0035" num="0034">Each notification mode can further be associated with a frequency parameter <b>230</b>, a repeats parameter <b>235</b> and a last-sent parameter <b>240</b>. The frequency parameter can determine how much time must lapse between notifications sent for a particular mode. Thus, for example, frequency parameter <b>230</b>-<b>1</b> will indicate the frequency at which notifications according to notification mode <b>210</b>-<b>1</b> can be sent. The last sent parameter <b>240</b> can indicate the time that a notification was last sent for the respective notification mode and the repeats parameter <b>235</b> can indicate the number of consecutive times that a notification according to the associated notification mode can be sent. For each notification type, a count parameter <b>205</b> can keep track of how many consecutive times a notification according to the current notification mode (indicated by status parameter <b>200</b>) has been sent.</p>
<p id="p-0036" num="0035">In addition, the configuration parameters can include an action parameter <b>245</b> that indicates the type of notification to be sent (e.g. SNMP trap, email, page, dialog box, telephone call, fax print out, SMS chat or other notification mechanism known in the art). In the embodiment of <figref idref="DRAWINGS">FIG. 2A</figref>, each notification for a notification type <b>198</b> is sent using the same notification method as determined by action parameter <b>245</b>. In the embodiment of <figref idref="DRAWINGS">FIG. 2B</figref>, on the other hand, each notification mode can be associated with a different notification action.</p>
<p id="p-0037" num="0036">Assuming, for the sake of explanation, that a particular notification program <b>140</b> monitors the amount of RAM being used by a network component, notification program <b>140</b> can define a notification type associated with monitoring RAM saturation and further defining multiple notification modes, including a light-usage mode <b>210</b>-<b>1</b>, a medium-usage mode <b>210</b>-<b>2</b>, and a heavy-usage mode <b>210</b>-<b>3</b>. The names of the modes can be stored in the respective mode parameter <b>250</b>. In this example, light-usage mode can have a min parameter equal or greater than to 0% and a max parameter equal to or less than 20%, medium-usage mode <b>210</b>-<b>2</b> can have a min parameter <b>215</b>-<b>2</b> greater than 20% and a max parameter <b>220</b>-<b>2</b> equal to or less than 70% and the heavy usage mode <b>210</b>-<b>3</b> can have a min parameter <b>215</b>-<b>3</b> of 70% and a max parameter <b>220</b>-<b>3</b> of 100%. Thus, depending on the percentage of RAM used by the network component, the different notification modes will govern the notification behavior of notification program <b>140</b>.</p>
<p id="p-0038" num="0037">In operation, notification program <b>140</b> can determine the status of the component being monitored by comparing the performance data of the monitored component to the threshold parameter or parameters for the notification modes. For example, if the performance measurements indicate that 15% of the RAM of the monitored component is being used, this is within the threshold parameters <b>215</b>-<b>1</b> and <b>220</b>-<b>1</b> of light-usage mode <b>210</b>-<b>1</b>. Therefore, notification program <b>140</b> can determine that the system state corresponds to light-usage mode <b>210</b>-<b>1</b> and set the status parameter <b>200</b> equal to the mode parameter <b>250</b>-<b>1</b>. Additionally, if the status has changed since the last measurement was taken, notification program <b>140</b> can reset count parameter <b>205</b> to zero.</p>
<p id="p-0039" num="0038">Assuming, for the sake of example, that the notification mode has remained the same between measurements of the system's state (i.e. the previously determined system state and the current system state correspond to the same notification mode), notification program <b>140</b> can determine if a notification should be sent out under the current notification mode (e.g. light-usage mode <b>210</b>-<b>1</b>), based on frequency parameter <b>230</b>-<b>1</b> and last-sent parameter <b>240</b>-<b>1</b>. If, for example, the frequency parameter <b>230</b>-<b>1</b> of light-usage mode <b>210</b>-<b>1</b> is set to 10 seconds and the time at which the last notification under parameter <b>240</b>-<b>1</b>, was greater than 10 seconds ago, notification program <b>140</b> can, in one embodiment of the present invention send out a notification. In another embodiment of the present invention, notification program <b>140</b> can further determine if the number of notifications sent out under notification mode <b>210</b>-<b>1</b> (e.g. as indicated by count parameter <b>205</b>), exceeds the number of allowed repeats indicated by repeats parameter <b>235</b>-<b>1</b>. If the number of notifications does not exceed the allowed number of repeats, notification program <b>140</b> can send out a notification and increment the value of count parameter <b>205</b>.</p>
<p id="p-0040" num="0039">In the foregoing example, the notification program <b>140</b> determined that the notification mode did not change. If however, notification program <b>140</b> determines that the notification mode changes since the last system measurement (e.g. goes from light-usage mode <b>210</b>-<b>1</b> to medium-usage mode <b>210</b>-<b>2</b>), notification program <b>140</b> can reset count parameter <b>205</b> to zero. In one embodiment notification program <b>140</b> can then send out a notification under medium-usage mode <b>210</b>-<b>2</b>. Alternatively, notification program <b>140</b> can determine if enough time has passed since the last notification has been sent out under medium-usage mode <b>210</b>-<b>2</b> to send out a new notification under medium-usage mode <b>210</b>-<b>2</b> by, for example, comparing the difference between the current time and the value of last sent parameter <b>240</b>-<b>2</b> to frequency parameter <b>230</b>-<b>2</b>. If enough time has passed, notification program <b>240</b> can send out a new notification under medium-usage mode <b>210</b>-<b>2</b>.</p>
<p id="p-0041" num="0040">In one embodiment of the present invention, the notification modes can be updated by management program <b>115</b>. In this embodiment, management program <b>115</b> can push out new configuration parameters to notification program <b>140</b>. For example, if an operator wishes to receive a light-usage RAM notification more often, management program <b>115</b> can communicate a new frequency parameter <b>230</b>-<b>1</b> to notification program <b>140</b>. Frequency parameter <b>230</b>-<b>1</b> can be updated during execution. When notification program <b>140</b> next determines the notification should be sent out under light-usage mode <b>210</b>-<b>1</b>, notification program <b>140</b> can base this decision on the new or updated frequency parameter <b>230</b>-<b>1</b>. In other cases, management program <b>115</b> can communicate multiple new configuration parameters to notification program <b>140</b> and can define new notification modes for a notification type. Thus, in addition to controlling the notification behavior of a system based on the system state, one embodiment of the present invention can allow for dynamic updates to the notification behavior.</p>
<p id="p-0042" num="0041">It should be noted that while in <figref idref="DRAWINGS">FIG. 2A</figref> and <figref idref="DRAWINGS">FIG. 2B</figref> the set of configuration parameters associated with each notification mode are shown together, they can be stored in different locations or accessed at different times during the execution of notification program <b>140</b>. Moreover, each notification program <b>140</b> may define several notification types. For example, if notification program <b>140</b> monitors both CPU usage and memory usage, the notification program may define a RAM usage notification function and a CPU usage notification function, each defining their own notification modes. Based on the system state of the monitored component, notification program <b>140</b> can call the various notification types to send notifications regarding the RAM usage and the CPU usage. This allows notifications regarding different aspects of the same or different monitored component to be sent separately.</p>
<p id="p-0043" num="0042">Moreover, in the embodiments of <figref idref="DRAWINGS">FIG. 2A</figref> and <figref idref="DRAWINGS">FIG. 2B</figref>, multiple notification modes are defined for notification type <b>198</b>. However, in one embodiment of the present invention, a single notification mode may be defined for notification type <b>198</b>. In this case, the notification mode can act as a “heartbeat” notification that can be sent according to frequency parameter <b>230</b>. The notification can be, for example, a “System Okay” notification. If management program <b>115</b> does not receive this heartbeat notification, this can indicate that the system state of the monitored component no longer corresponds to a “system okay” notification mode, indicating a problem with the component, or it can indicate a problem with notification program <b>140</b>, the network connection or other communications issue. The frequency of the heartbeat notification can be adjustable through frequency parameter <b>230</b>. Additionally, the form of notification sent (e.g. SNMP trap, email, fax, etc.) can also be controlled through an action parameter <b>245</b> associated with notification type <b>198</b> or the notification mode.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 3</figref> illustrates a flow chart for controlling the notification behavior of a system according to one embodiment of the present invention. At step <b>302</b>, notification program <b>140</b> can perform the tasks necessary to determine a system state such as monitoring a component for various performance parameters such as CPU usage, RAM usage, ASP queuing and other performance parameters known in the art (e.g. via monitoring portion <b>145</b>) or receiving a system state or system state data from another program. At step <b>305</b>, notification program <b>140</b> can determine a notification mode based on the system state and, for example, a set of configuration parameters. Continuing with the previous example, the system state may indicate that 15% of the RAM is being used, indicating a light-usage mode for the notification type corresponding to RAM monitoring.</p>
<p id="p-0045" num="0044">Notification program <b>140</b>, at step <b>315</b>, can then determine if the notification mode is the same as the previous notification mode or if a new notification mode has been entered. Notification program <b>140</b> can also check to ensure that a notification for the notification mode has not been sent too many times (step <b>325</b>). In one embodiment of the present invention, this can be done by comparing count parameter <b>205</b> for the notification type to the repeats parameter for a particular notification mode. If, for example, the notification mode is the light-usage mode, repeats parameter <b>235</b>-<b>1</b> can be compared to count parameter <b>205</b>. If the value of counts parameter <b>205</b> is equal to that of repeats parameter <b>235</b>-<b>1</b>, in one embodiment of the present invention, notification program <b>140</b> will not send out a notification and control can pass to step <b>345</b>. If, however, the value of counts parameter <b>205</b> is less than repeats parameter <b>235</b>-<b>1</b>, control can pass to step <b>330</b>.</p>
<p id="p-0046" num="0045">At step <b>330</b>, notification program <b>140</b> can check if a notification under the notification mode has been sent out too recently to repeat by, for example, comparing the difference in the current time and the value of the last-sent parameter <b>240</b> for the notification mode to the frequency parameter <b>230</b> for the notification mode. Again using the previous example, notification program <b>140</b> can subtract the value of the last-sent parameter <b>240</b>-<b>1</b> from the current time and compare this to the value of frequency parameter <b>230</b>-<b>1</b>. If the last notification under the light-usage mode was not sent out too recently, as determined at step <b>330</b>, notification program <b>140</b>, at step <b>335</b>, can send a notification according to action parameter <b>245</b>.</p>
<p id="p-0047" num="0046">In one embodiment of the present invention, step <b>330</b> can occur even if a new notification mode was entered as determined at step <b>315</b>. Therefore, notification program <b>140</b>, in one embodiment of the present invention, may not immediately send out a notification even if notification program <b>140</b> determines that the system state corresponds to a new notification mode. At step <b>340</b>, notification program <b>140</b> can increment the count parameter <b>205</b> for the notification type and update the last-sent parameter for the notification mode if a notification is sent out. Notification program <b>140</b> can optionally repeat the process of <figref idref="DRAWINGS">FIG. 3</figref> (step <b>345</b>).</p>
<p id="p-0048" num="0047">Table 1 includes an example of pseudo-code for implementing one embodiment of the process of <figref idref="DRAWINGS">FIG. 3</figref>. The code of table 1 is provided by way of example only and is not limiting of the present invention. Notification program <b>140</b> can be implemented using any suitable programming language and structure, as would be understood by those of ordinary skill in the art.</p>
<p id="p-0049" num="0048">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>function main_loop( . . . ) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>while( program_running ) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// monitor system</entry>
</row>
<row>
<entry/>
<entry>. . . </entry>
</row>
<row>
<entry/>
<entry>// determine the system state</entry>
</row>
<row>
<entry/>
<entry>system_state = CheckSystem( );</entry>
</row>
<row>
<entry/>
<entry>// potentially send an notification</entry>
</row>
<row>
<entry/>
<entry>reporting the system state</entry>
</row>
<row>
<entry/>
<entry>NotificationFunction(″SYSTEM-STATE″,</entry>
</row>
<row>
<entry/>
<entry>system_state);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry>function NotificationFunction</entry>
</row>
<row>
<entry/>
<entry>(notification_type, mode) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// if we've entered a new mode then</entry>
</row>
<row>
<entry/>
<entry>the count is no longer relevant</entry>
</row>
<row>
<entry/>
<entry>if (GetVariable(notfication_type +</entry>
</row>
<row>
<entry/>
<entry>″::STATUS″) != mode) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>SetVariable(notification_type +</entry>
</row>
<row>
<entry/>
<entry>″::COUNT″, 0);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry>// keep track of the latest mode</entry>
</row>
<row>
<entry/>
<entry>SetVariable(notification_type +</entry>
</row>
<row>
<entry/>
<entry>″::STATUS″, mode);</entry>
</row>
<row>
<entry/>
<entry>// check if the notification hasn't</entry>
</row>
<row>
<entry/>
<entry>been repeated too many times</entry>
</row>
<row>
<entry/>
<entry>if (GetVariable(notification type +</entry>
</row>
<row>
<entry/>
<entry>″::COUNT″) &lt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>GetVariable(notification_type+mode +</entry>
</row>
<row>
<entry/>
<entry>″::REPEATS″)) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// check if the notification was reported too recently</entry>
</row>
<row>
<entry/>
<entry>if (</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>(Date() - GetVariable(notification_type+mode +</entry>
</row>
<row>
<entry/>
<entry>″::LASTSENT″))</entry>
</row>
<row>
<entry/>
<entry>&gt; GetVariable(notification_type+mode +</entry>
</row>
<row>
<entry/>
<entry>″::FREQUENCY″)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// actually send the notification</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>DoNotification(GetVariable-</entry>
</row>
<row>
<entry/>
<entry>(notification_type + ″::ACTION″),</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>notification, mode);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>// do some bookkeeping</entry>
</row>
<row>
<entry/>
<entry>IncrementVariable(notification_type +</entry>
</row>
<row>
<entry/>
<entry>″::COUNT″);</entry>
</row>
<row>
<entry/>
<entry>SetVariable(notification_type+mode +</entry>
</row>
<row>
<entry/>
<entry>″::LASTSENT″, Date());</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0050" num="0049">In this embodiment of the present invention, a notification type can be called as a function of a main program that is capable of calling one or more notification types. With reference to <figref idref="DRAWINGS">FIG. 3</figref>, notification program <b>140</b>, at step <b>302</b>, can perform the tasks necessary to determine a system state, such as monitoring a component for various performance parameters such as CPU usage, RAM usage, ASP queuing and other performance parameters known in the art (e.g. via monitoring portion <b>145</b>) or receiving a system state or system state data from another program. At step <b>305</b>, notification program <b>140</b> can determine a notification mode for a system state. For example, the system state may indicate that 15% of the RAM is being used. The “system_state” variable, at step <b>305</b>, can be set equal to a particular notification mode based on the threshold parameters for each notification mode of an underlying notification type (e.g. the system_state variable can be set equal to light-usage if the RAM usage is 15%).</p>
<p id="p-0051" num="0050">Notification program <b>140</b> can call a notification function using the value of the system_state variable as input to that notification function. If notification program <b>140</b> defines a notification type as “SYSTEM-STATE” to send notifications regarding RAM usage, notification program <b>140</b> can call a notification function using the SYSTEM-STATE as an input for the notification type and the system_state variable as the input for the notification mode.</p>
<p id="p-0052" num="0051">As step <b>315</b>, notification program <b>140</b> can determine if a new mode has been entered by comparing the status parameter <b>200</b> to the input mode value (i.e. to the value of the system_state variable). If a new mode has been entered, then notification program <b>140</b> can set the count parameter <b>205</b> for the “SYSTEM-STATE” notification type to zero. Notification program <b>140</b> can then set the status parameter <b>200</b> for the “SYSTEM-STATE” notification type to the value of the mode variable, (e.g. the value of the system_state variable). It should be noted that other notification types can be called (e.g. “SYSTEM-STATE2”) depending on the performance characteristics being monitored.</p>
<p id="p-0053" num="0052">Notification program <b>140</b> can also check to ensure that a notification for the notification mode has not been sent too many times(step <b>325</b>). In one embodiment of the present invention, this can be done by comparing count parameter <b>205</b> for the notification type to the repeats parameter for a particular notification mode. For example, if the notification mode is the light-usage mode, as determined by the system_state variable, repeats parameter <b>235</b>-<b>1</b> can be compared to count parameter <b>205</b>. If the value of counts parameter <b>205</b> is equal to that of repeats parameter <b>235</b>-<b>1</b>, notification program <b>140</b> will not send out a notification. If, however, the value of counts parameter <b>205</b> is less than repeats parameter <b>235</b>-<b>1</b>, control can pass to step <b>330</b>.</p>
<p id="p-0054" num="0053">At step <b>330</b>, notification program <b>140</b> can check if a notification under the notification mode has been sent out too recently to repeat by, for example, comparing the difference in the current time and the value of the last-sent parameter <b>240</b> for the notification mode to the frequency parameter <b>230</b> for the notification mode. Again using the previous example, notification program <b>140</b> can subtract the value of the last-sent parameter <b>240</b>-<b>1</b> from the current time and compare this to the value of frequency parameter <b>230</b>-<b>1</b>. If the last notification under the light-usage mode not been sent out too recently, as determined at step <b>330</b>, notification program <b>140</b>, at step <b>335</b>, can send a notification according to action parameter <b>245</b>. At step <b>340</b>, notification program <b>140</b> can increment the count parameter <b>205</b> for the notification type and update the last-sent parameter for the notification mode. If however, a notification is not sent at step <b>335</b>, notification program <b>140</b> can exit the “SYSTEM-STATE” notification type and return to the main loop.</p>
<p id="p-0055" num="0054">As another example of one embodiment of the present invention in operation, assume the notification type called “SYSTEM-STATE2” has three notification modes: OKAY, THROTTLE and ERROR. The configuration parameters that define the behavior of the SYSTEM-STATE2 notification type can be as follows:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0055">SYSTEM-STATE2::STATUS</li>
        <li id="ul0002-0002" num="0056">SYSTEM-STATE2::COUNT</li>
        <li id="ul0002-0003" num="0057">SYSTEM-STATE2::ACTION=SNMPTRAP</li>
        <li id="ul0002-0004" num="0058">SYSTEM-STATE2::OKAY::FREQUENCY=0</li>
        <li id="ul0002-0005" num="0059">SYSTEM-STATE2::OKAY::REPEATS=1</li>
        <li id="ul0002-0006" num="0060">SYSTEM-STATE2::OKAY::LAST SENT</li>
        <li id="ul0002-0007" num="0061">SYSTEM-STATE2::THROTTLE::FREQUENCY=30</li>
        <li id="ul0002-0008" num="0062">SYSTEM-STATE2::THROTTLE::REPEATS=1</li>
        <li id="ul0002-0009" num="0063">SYSTEM-STATE2::THROTTLE::LAST SENT</li>
        <li id="ul0002-0010" num="0064">SYSTEM-STATE2::ERROR::FREQUENCY=0</li>
        <li id="ul0002-0011" num="0065">SYSTEM-STATE2::ERROR::REPEATS:=INFINITE</li>
        <li id="ul0002-0012" num="0066">SYSTEM-STATE2::ERROR::LAST SENT</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0056" num="0067">When the notification mode “SYSTEM-STATE2::OKAY” is called, an SNMP trap is sent once per status change (i.e. “SYSTEM-STATE2::OKAY::REPEATS”=1) without restriction on how often it will be sent (i.e. “SYSTEM-STATE2::OKAY::FREQUENCY”=0). When “SYSTEM-STATE2::THROTTLE” is called, an SNMP trap will be sent at a maximum rate of once every 30 seconds. The trap will only be sent once per status change. If “SYSTEM-STATE2::ERROR” is called, an SNMP trap is sent as often and as rapidly as they are triggered because frequency equals zero and repeats equals infinite. In one embodiment of the present invention, notifications under the ERROR mode can represent the highest priority notifications for the SYSTEM-STATE2 notification type as they are the least restricted.</p>
<p id="p-0057" num="0068">Table 2 provides an example timeline for the “SYSTEM-STATE2” notification modes.</p>
<p id="p-0058" num="0069">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="98pt" align="center"/>
<colspec colname="3" colwidth="84pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE 2</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>TIME</entry>
<entry>SYSTEM-STATE2::STATUS</entry>
<entry>Notification Sent</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35pt" align="char" char="."/>
<colspec colname="2" colwidth="98pt" align="center"/>
<colspec colname="3" colwidth="84pt" align="center"/>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>OK</entry>
<entry>YES</entry>
</row>
<row>
<entry>1</entry>
<entry>THROTTLE</entry>
<entry>YES</entry>
</row>
<row>
<entry>2</entry>
<entry>OK</entry>
<entry>YES</entry>
</row>
<row>
<entry>3</entry>
<entry>ERROR</entry>
<entry>YES</entry>
</row>
<row>
<entry>4</entry>
<entry>THROTTLE</entry>
<entry>NO (FREQ = 30)</entry>
</row>
<row>
<entry>5</entry>
<entry>OK</entry>
<entry>YES</entry>
</row>
<row>
<entry>6</entry>
<entry>OK</entry>
<entry>NO (REPEAT = 1)</entry>
</row>
<row>
<entry>.</entry>
<entry>.</entry>
<entry>.</entry>
</row>
<row>
<entry>.</entry>
<entry>.</entry>
<entry>.</entry>
</row>
<row>
<entry>.</entry>
<entry>.</entry>
<entry>.</entry>
</row>
<row>
<entry>28</entry>
<entry>ERROR</entry>
<entry>YES</entry>
</row>
<row>
<entry>29</entry>
<entry>ERROR</entry>
<entry>YES</entry>
</row>
<row>
<entry>30</entry>
<entry>ERROR</entry>
<entry>YES (No FREQ. or</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Repeats Limits)</entry>
</row>
<row>
<entry>31</entry>
<entry>OK</entry>
<entry>YES</entry>
</row>
<row>
<entry>32</entry>
<entry>THROTTLE</entry>
<entry>YES (30 seconds has</entry>
</row>
<row>
<entry/>
<entry/>
<entry>passed since last</entry>
</row>
<row>
<entry/>
<entry/>
<entry>TRHOTTLE sent out at</entry>
</row>
<row>
<entry/>
<entry/>
<entry>t = 1)</entry>
</row>
<row>
<entry>33</entry>
<entry>THROTTLE</entry>
<entry>NO (30 seconds has</entry>
</row>
<row>
<entry/>
<entry/>
<entry>not passed since last</entry>
</row>
<row>
<entry/>
<entry/>
<entry>THROTTLE)</entry>
</row>
<row>
<entry>34</entry>
<entry>OK</entry>
<entry>YES</entry>
</row>
<row>
<entry>35</entry>
<entry>OK</entry>
<entry>NO (Repeats = 1)</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0059" num="0070">In the example of Table 2, notification program <b>140</b> can determine the notification mode to which system state corresponds every second beginning at zero seconds. Using the psuedocode of Table 1 and substituting SYSTEM-STATE2 for SYSTEM-STATE, notification program <b>140</b> can set variable system_state equal to OKAY (step <b>305</b>).</p>
<p id="p-0060" num="0071">Notification program <b>140</b> can then call the “SYSTEM-STATE2” notification type using OKAY as the notification mode. Since this is the first notification of this notification type, the count parameter <b>205</b> can be reset to zero and the notification can be sent out (step <b>335</b>). At t=1, notification program <b>140</b> can determine that the system state corresponds to the notification mode THROTTLE (step <b>305</b>), call the “SYSTEM-STATE2” notification type, determine that a new mode has been entered, reset the count parameter <b>205</b> and send out a notification (step <b>335</b>) as no previous notification of this type has been sent out.</p>
<p id="p-0061" num="0072">At t=2, notification program <b>140</b> can determine that the system state corresponds to the notification mode OKAY (step <b>305</b>) and call the notification function using the notification type SYSTEM-STATE2 with OKAY as the notification mode. At step <b>315</b>, since this is a new notification mode compared to the last measurement, notification program <b>140</b> can reset the count parameter <b>205</b> to zero and update the status parameter <b>200</b> to reflect the OKAY mode. Because the frequency parameter corresponding to the OKAY mode is set to zero, and the number of repeats is set to 1, monitoring system <b>140</b> can send out a notification (step <b>335</b>) indicating a system state of OKAY.</p>
<p id="p-0062" num="0073">Skipping now to t=4, monitoring system <b>140</b> can determine that the system state corresponds to a notification mode of THROTTLE (step <b>305</b>). At step <b>315</b>, notification program <b>140</b> can determine that this is a new notification mode as the previous notification mode indicated by status parameter <b>200</b> being equal to ERROR (from t=3). Notification program <b>140</b> can reset the count parameter <b>205</b> to zero and set the status parameter <b>200</b> to THROTTLE. Notification program <b>140</b>, at step <b>325</b>, can check if the notification under the THROTTLE notification mode has been repeated too many times. However, in this case the count is equal to zero as this is an new notification mode. At step <b>330</b>, notification program <b>140</b> can determine if the last notification sent under the THROTTLE notification mode has been sent too recently. In this case, the current time, which is equal to 4 seconds, minus the value of the last-sent parameter <b>240</b> (i.e. 1 second) is less than the value of the frequency parameter <b>230</b>, which is set at 30 seconds. Therefore, no notification will be sent out under the THROTTLE notification mode at t=4. Since no notification was sent, notification program <b>140</b> will not increment count parameter <b>205</b> or change last-sent parameter <b>240</b>.</p>
<p id="p-0063" num="0074">As illustrated in Table 2, the notification mode does not change between t=5 and t=6. The system state at both of these times corresponds to a notification mode of OKAY. At t=5, a notification will be sent out because there are no restrictions on the frequency of notifications sent under the OKAY mode and this is a new notification mode. Once the notification is sent under the OKAY notification mode, notification program <b>140</b> can then increment count parameter <b>205</b>. At t=6, however, the notification will not be sent out because a new notification mode has not been entered and the repeats parameter <b>235</b> is set to 1. In other words, notification program <b>140</b> will determine that the value of count parameter <b>205</b>, having been incremented at t=5, is not less than the value of repeats parameter <b>235</b> (step <b>325</b>) for the OKAY mode.</p>
<p id="p-0064" num="0075">At times t=28-30, monitoring system <b>140</b> can determine that the system state corresponds to a notification mode of ERROR. In each of these cases, an error notification can be sent out as there are no limits on the frequency or number of consecutive notifications that can be sent out under the ERROR mode.</p>
<p id="p-0065" num="0076">At the time t=32, notification program <b>140</b> can determine that the system state corresponds to a notification mode of THROTTLE (step <b>305</b>) and call the “SYSTEM-STATE2” notification type using THROTTLE as the mode. Notification program <b>140</b> can then determine that this is a new notification mode compared to the previous notification mode, reset count parameter <b>205</b> to zero and status parameter <b>200</b> to THROTTLE. Since count parameter is equal to zero, the value of repeats parameter <b>235</b> does not restrict the sending of a notification. Moreover, since the last notification under the Throttle notification mode was sent at the time t=1, the frequency parameter <b>230</b>, which was set to 30 seconds, will not restrict the sending of a notification. Therefore, at step <b>335</b>, notification program <b>140</b> can send a notification according to the THROTTLE notification mode. Additionally, notification program <b>140</b> can increment count parameter <b>205</b> and set the last-sent parameter to 32, starting a new 30 second period.</p>
<p id="p-0066" num="0077">It should be noted that, in the embodiment of Table 2, since the action parameter <b>210</b> was set to SNMP trap, each of the notifications generated will be sent as an SNMP trap. In other embodiments of the present invention, the notifications can be sent in other formats such as email, pager, fax, telephone, chat session, dialogue box or other notification method known in the art.</p>
<p id="p-0067" num="0078">In addition to determining if a notification should be sent out based on a set of notification modes, embodiments of notification program <b>140</b> can receive dynamic updates to the notification modes. Management program <b>115</b> can determine if the configuration parameters for the notification program <b>140</b> need to be updated. This can occur even if no notification was sent out at step <b>335</b> because, for example, the number of previous notifications met or exceeded the repeat parameter as determined at step <b>320</b>, or the last notification corresponding to the current notification mode was sent out too recently as determined at step <b>325</b>. If management program <b>115</b> determines that updated configuration parameters should be sent to notification program <b>140</b>, management program <b>115</b> can send out one or more update configuration parameters. Updates, in one embodiment of the present invention, can be performed via SNMP. In another embodiment of the present invention, notification program <b>140</b> can present an interface through which configuration parameters can be adjusted. At step <b>345</b>, one embodiment of the present invention can repeat steps <b>305</b>-<b>345</b> using the updated configuration parameters.</p>
<p id="p-0068" num="0079">In summary, notification program <b>140</b> can determine a notification mode based on the system state of a component being monitored and a set of configuration parameters. Notification program <b>140</b> can then determine if a notification should be sent out based the number of previous consecutive notifications that correspond to the same notification mode and/or the time at which the last notification under the current notification mode was sent out and a frequency parameter. Because both the repeats parameter and frequency parameter can be updated, the number of consecutive notifications corresponding to a particular notification mode and how often those notifications are sent can be dynamically adjusted by an operator.</p>
<p id="p-0069" num="0080">Embodiments of the present invention provide an advantage over prior art systems by allowing the operator to configure notification program <b>140</b> to send out notifications of different priorities with different frequencies. This can reduce information overloading and bandwidth requirements as the overall number of notifications can be reduced, while priority notifications can still be sent out frequently. Moreover, the notification behavior of a notification program can be dynamically tuned without requiring the notification program to be reinstalled.</p>
<p id="p-0070" num="0081">Although the present invention has been described in detail herein with reference to the illustrative embodiments, it should be understood that the description is by way of example only and is not to be construed in a limiting sense. It is to be further understood, therefore, that numerous changes in the details of the embodiments of this invention and additional embodiments of this invention will be apparent to, and may be made by, persons of ordinary skill in the art having reference to this description. It is contemplated that all such changes and additional embodiments are within the spirit and true scope of this invention as claimed below.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A system for dynamically controlling notification behavior, comprising:
<claim-text>a network;</claim-text>
<claim-text>a monitoring system further comprising:
<claim-text>a monitoring system computer processor;</claim-text>
<claim-text>a monitoring system network interface device electrically connected to the monitoring system computer processor to communicate data to the network;</claim-text>
<claim-text>a monitoring system computer readable memory containing a notification program executable by the monitoring system computer processor to:
<claim-text>load a set of configuration parameters;</claim-text>
<claim-text>determine if a first notification should be sent based on said set of configuration parameters and a system state of one or more components being monitored by said monitoring system;</claim-text>
<claim-text>if the first notification should be sent, communicate said first notification over said network;</claim-text>
<claim-text>receive an update to at least one configuration parameter of the set of configuration parameters during execution; and</claim-text>
<claim-text>send out at an additional notification based on the update to the at least one configuration parameter, resulting in a change in the notification behavior of the monitoring system during execution thereof; and</claim-text>
</claim-text>
</claim-text>
<claim-text>a management system further comprising:
<claim-text>a management system computer processor;</claim-text>
<claim-text>a management system network interface device electrically connected to the management system computer processor to communicate data to the network;</claim-text>
<claim-text>a management system computer readable memory containing a management program executable by the management system computer processor to:
<claim-text>receive the first notification from the monitoring system over the network; and</claim-text>
<claim-text>communicate one or more new or updated configuration parameters to the monitoring system for automatically dynamically updating the notification behavior of the monitoring system over the network.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said set of configuration parameters defines at least two notification modes for a notification type.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein for each notification mode, said set of configuration parameters further comprises:
<claim-text>a frequency parameter defining a frequency of sending notifications; and</claim-text>
<claim-text>a repeats parameter defining a number of times of sending consecutive notifications.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The system of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein for each notification mode, said set of configuration parameters further comprises a last sent parameter defining the time a notification for the associated notification mode was last sent out.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The system of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein for each notification mode, said set of configuration parameters further comprises at least one threshold parameter.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The system of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein said set of configuration parameters further comprises an action parameter defining an action to be taken when a notification is sent out.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein said monitoring software is further executable to send out said first notification as an SNMP trap based on said action parameter.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein said set of configuration parameters further comprises a status parameter defining the notification mode under which the first notification is sent out.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said set of configuration parameters further comprises a count parameter indicating the number of consecutive notifications sent out under at least one notification mode of said at least two notification modes.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the notification program is further executable to determine if the first notification should be sent based on the time a previous notification was sent out under the first notification mode and a frequency parameter associated with the first notification mode.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein said updated configuration parameter is an updated frequency parameter associated with said first notification mode.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the notification program is further executable to determine if the additional notification should be sent based on the time the first notification was sent out and the updated frequency parameter.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the notification program is further executable to determine if the first notification should be sent out based on the set of configuration parameters and the first notification mode by:
<claim-text>determining if a number of consecutive notifications associated with the first notification mode exceeds a preset value.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
