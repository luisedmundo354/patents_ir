<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299249-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299249</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11462646</doc-number>
<date>20060804</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>JP</country>
<doc-number>2005-236552</doc-number>
<date>20050817</date>
</priority-claim>
</priority-claims>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707201</main-classification>
</classification-national>
<invention-title id="d0e61">Apparatus, system, and program for determining consistency of a database</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>JP</country>
<doc-number>08-249222</doc-number>
<date>19960900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>JP</country>
<doc-number>2001-142765</doc-number>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>13</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>16</number-of-drawing-sheets>
<number-of-figures>19</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20070043775</doc-number>
<kind>A1</kind>
<date>20070222</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Mori</last-name>
<first-name>Shigeko</first-name>
<address>
<city>Kanagawa</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Teshima</last-name>
<first-name>Ichiroh</first-name>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
<nationality>
<country>JP</country>
</nationality>
<residence>
<country>JP</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Kunzler &amp; McKenzie</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Mofiz</last-name>
<first-name>Apu</first-name>
<department>2161</department>
</primary-examiner>
<assistant-examiner>
<last-name>Padmanabhan</last-name>
<first-name>Kavita</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The invention efficiently determines consistency of a database by a system including a reading section that sequentially reads from the respective segment data included in the database pointers to other segment data, an address recording section that records storage addresses of segment data from which the pointers have been read by the reading section, and a pointer recording section that records the pointers read by the reading section. Then, when segment data is updated in an area in which the pointer reading has been completed, a storage address recorded in the address recording section is modified and a pointer recorded in the pointer recording section is modified. Then, it is determined that the database is consistent on condition that the respective storage addresses recorded in the address recording section coincide with the respective pointers recorded in the pointer recording section.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="238.68mm" wi="160.36mm" file="US07299249-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="108.97mm" wi="176.19mm" file="US07299249-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="239.10mm" wi="160.95mm" file="US07299249-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="231.14mm" wi="178.05mm" file="US07299249-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="206.76mm" wi="134.20mm" orientation="landscape" file="US07299249-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="58.50mm" wi="168.91mm" file="US07299249-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="240.37mm" wi="69.60mm" orientation="landscape" file="US07299249-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="239.86mm" wi="141.82mm" file="US07299249-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="53.51mm" wi="121.16mm" file="US07299249-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="206.76mm" wi="68.41mm" orientation="landscape" file="US07299249-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="236.14mm" wi="144.02mm" file="US07299249-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="236.90mm" wi="167.39mm" orientation="landscape" file="US07299249-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="235.29mm" wi="110.83mm" orientation="landscape" file="US07299249-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="234.61mm" wi="119.63mm" orientation="landscape" file="US07299249-20071120-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="255.27mm" wi="154.77mm" orientation="landscape" file="US07299249-20071120-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="217.00mm" wi="166.62mm" file="US07299249-20071120-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="214.97mm" wi="158.58mm" file="US07299249-20071120-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCES TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This patent application claims priority to a Japanese Patent Application No. 2005-236552 filed on Aug. 17, 2005, the entire contents of which are incorporated herein by reference for all purposes.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">1. Field of the Invention</p>
<p id="p-0004" num="0003">The present invention relates to a system, a method and a program for determining consistency of a database.</p>
<p id="p-0005" num="0004">2. Description of the Related Art</p>
<p id="p-0006" num="0005">In order to determine consistency of a database, it has conventionally been necessary to compare a storage address of each segment data included in the database and each pointer included in the database and to determine whether they coincide with each other. For example, such a consistency determination is implemented and used in a database management system developed by the present applicant. See, for example, “IMS High Performance Pointer Checker User's Guide, URL publibfi.boulder.ibm.com/cgi-bin/bookmgr/BOOKS/fabp lb 10/CCONTENTS”.</p>
<p id="p-0007" num="0006">Here, when a database is updated between starting reading any one of the pointers and completely reading all the pointers, the segment data addresses may be compared with the pointers before and after updating. For this reason, during processing the determination of consistency, it has conventionally been general to stop updating a database or to perform exclusive control for access to at least a part of a database. See, for example, Japanese Published Patent Application No. 8-249222.</p>
<p id="p-0008" num="0007">However, when the data size of a database is large, the updating may be stopped or delayed for a long time so that the user's convenience may be reduced. In contrast, a technique for determining consistency without stopping the updating is proposed as disclosed, for example, in Japanese Published Patent Application No. 2001-142765.</p>
<p id="p-0009" num="0008">According to a technique disclosed in Japanese Published Patent Application No. 2001-142765, a consistency verifying apparatus takes out data for use in consistency verification from a database file without performing exclusive control. Then, the consistency verifying apparatus repeats the process for performing the consistency verification using the taken-out data by a predetermined number of times, and determines whether the database file is consistent based on the verification result of the process and a preset condition for determining the consistency. Therefore, it is considered that, according to this technique, a possibility of satisfying the consistency can be evaluated, but it is not possible to surely determine the consistency. From a different viewpoint, the number of times for performing the consistency verification should be increased to surely determine the consistency, which would result in a longer processing time.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0010" num="0009">Therefore, it is an object of the present invention to provide a system, a method, and a program that can solve the foregoing problems.</p>
<p id="p-0011" num="0010">To solve the problems, the present invention provides a system for determining consistency of a database, which comprises a reading section that sequentially reads from the respective segment data included in the database pointers to other segment data, an address recording section that records storage addresses of segment data from which the pointers have been read by the reading section, a pointer recording section that records the pointers read by the reading section, an address modifying section that modifies a storage address recorded in the address recording section when segment data is updated in an area in which the pointer reading has been completed, a pointer modifying section that modifies a pointer recorded in the pointer recording section when segment data is updated in an area in which the pointer reading has been completed, and a determination section that determines that the database is consistent on condition that the respective storage addresses recorded in the address recording section coincide with the respective pointers recorded in the pointer recording section. The present invention further provides a program making an information processing apparatus function as the system, and a method for determining consistency of a database by means of the system.</p>
<p id="p-0012" num="0011">According to the present invention, it is possible to more effectively determine consistency of a database than ever before.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0013" num="0012">The above and other objects and features and advantages of the present invention will become more apparent from the following description of the presently preferred exemplary embodiments of the invention taken in conjunction with the accompanying drawings, in which:</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic diagram showing a database system;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 2</figref> is a view showing an exemplary data structure of a hierarchical database;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 3</figref> is a functional block diagram showing functions of a database management system;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 4</figref> is a view showing an exemplary data structure of a history recording section;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 5</figref> is a view showing an exemplary storage address recorded in an address recording section;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 6</figref> is a view showing an exemplary pointer recorded in a pointer recording section;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 7</figref> is a view showing a flow of a process for modifying a storage address and a pointer to determine consistency;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 8</figref> is a view showing an exemplary storage address after reordering;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 9</figref> is a view showing an exemplary pointer after reordering;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 10</figref> is a view showing a flow of a process for recording an update history;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 11</figref> is a view showing details of a process in S<b>840</b> shown in <figref idref="DRAWINGS">FIG. 10</figref>;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIGS. 12A and 12B</figref> are views showing an exemplary process in which segment data is added;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIGS. 13A and 13B</figref> are views showing an exemplary process in which segment data is deleted;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIGS. 14A and 14B</figref> are views showing an exemplary process in which segment data is divided;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 15</figref> is a view showing an exemplary process for determining consistency of segment data updated after the consistency determination; and</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 16</figref> is a view showing an exemplary hardware configuration of an information processing apparatus functioning as a database management system.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0030" num="0029">The invention will now be described based on the preferred embodiments, which do not intend to limit the scope of the present invention, but exemplify the invention. All of the features and the combinations thereof described below are not necessarily essential to the invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic diagram showing a database system <b>10</b>. The database system <b>10</b> includes a hierarchical database <b>20</b> and a database management system <b>30</b>. The hierarchical database <b>20</b> includes a plurality of segment data. Further, each segment data has pointers for other segment data. The database management system <b>30</b> according to the present embodiment determines a consistency of the hierarchical database <b>20</b> by respectively comparing pointers and storage addresses of segment data.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 2</figref> is a view exemplary showing data structure of the hierarchical database <b>20</b>. The hierarchical database <b>20</b> records a plurality of segment data represented by segment data <b>200</b>-<b>1</b> to <b>200</b>-<b>4</b>. The segment data <b>200</b>-<b>1</b> is pointed to by a Root Anchor Point (RAP) showing a route part of the segment data. The segment data <b>200</b>-<b>1</b> includes a prefix <b>210</b>-<b>1</b> and a data portion <b>220</b>-<b>1</b>. Further, a storage address of the segment data <b>200</b>-<b>1</b> is <b>1000</b>. Here, a storage address means a position (RBA: Relative Byte Address) of a first address of the segment data <b>200</b>-<b>1</b>, in which the first address is compared with a predetermined base address of the hierarchical database <b>20</b>.</p>
<p id="p-0033" num="0032">The prefix <b>210</b>-<b>1</b> includes a pointer <b>230</b>-<b>1</b> pointing to <b>1100</b> that is a storage address of the segment data <b>200</b>-<b>2</b> and a pointer <b>240</b>-<b>1</b> pointing to a storage address of another segment data. The segment data <b>200</b>-<b>2</b> includes a prefix <b>210</b>-<b>2</b> and a data portion <b>220</b>-<b>2</b>. The prefix <b>210</b>-<b>2</b> includes a pointer <b>230</b>-<b>2</b> pointing to <b>2000</b> that is a storage address of the segment data <b>200</b>-<b>4</b> and a pointer <b>240</b>-<b>2</b> pointing to a storage address of further another segment data.</p>
<p id="p-0034" num="0033">The segment data <b>200</b>-<b>4</b> includes a prefix <b>210</b>-<b>4</b> and a data portion <b>220</b>-<b>4</b>. The segment data <b>200</b>-<b>4</b> is located at a terminal part of a series of hierarchical structure beginning with the segment data <b>200</b>-<b>1</b>. For this reason, the prefix <b>210</b>-<b>4</b> does not have pointers pointing to any segment data. The prefix <b>210</b>-<b>4</b> may really include a predetermined data (e.g., Null data) that does not show any address as a pointer <b>230</b>-<b>4</b> and a pointer <b>240</b>-<b>4</b>.</p>
<p id="p-0035" num="0034">In this manner, the hierarchical database <b>20</b> has a hierarchical structure in which segment data can be sequentially accessed by tracing a pointer recorded in the prefix of each segment data. Therefore, in a state where the consistency is preserved, a value of a pointer coincides with a storage address of segment data pointed to by the pointer. The database management system <b>30</b> according to the present embodiment can determine the consistency of the hierarchical database <b>20</b> by comparing these pointers and storage addresses.</p>
<p id="p-0036" num="0035">The segment data within the hierarchical database <b>20</b> may be updated at any time according to an instruction from a user. In the example of <figref idref="DRAWINGS">FIG. 2</figref>, there is shown with dotted lines connection relation of pointers when the segment data <b>200</b>-<b>3</b> is added between the segment data <b>200</b>-<b>2</b> and the segment data <b>200</b>-<b>4</b>. That is to say, according to this addition process, the segment data <b>200</b>-<b>2</b> records a pointer pointing to the segment data <b>200</b>-<b>3</b> and the segment data <b>200</b>-<b>3</b> records a pointer pointing to the segment data <b>200</b>-<b>4</b>.</p>
<p id="p-0037" num="0036">In the past, when such an updating process occurs while determining consistency of a database, the consistency could not be determined correctly in some cases. For example, when the database is being updated, the segment data <b>200</b>-<b>3</b> may already be recorded in the hierarchical database <b>20</b> while the pointer <b>230</b>-<b>2</b> may still point to the segment data <b>200</b>-<b>4</b>. In such a case, since the pointer and the storage address do not coincide with each other, it may be determined that the consistency is lost. In contrast, the database management system <b>30</b> according to the present embodiment can appropriately determine the consistency even though the hierarchical database <b>20</b> is updated during the consistency determination.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 3</figref> is a functional block diagram showing functions of the database management system <b>30</b>. The database management system <b>30</b> has a reading section <b>300</b>, a scan pointer recording section <b>305</b>, an address recording section <b>310</b>, a pointer recording section <b>320</b>, an address modifying section <b>330</b>, a pointer modifying section <b>340</b>, a segment data updating section <b>350</b>, a history recording section <b>360</b>, and a determination section <b>370</b>. The reading section <b>300</b> sequentially reads pointers from the respective segment data included in the hierarchical database <b>20</b>, which point to other segment data. Specifically, the reading section <b>300</b> first reads the pointer <b>1100</b> to the segment data <b>200</b>-<b>2</b> from the segment data <b>200</b>-<b>1</b>. Next, the reading section <b>300</b> reads the pointer <b>2000</b> to the segment data <b>200</b>-<b>4</b> from the segment data <b>200</b>-<b>2</b>. A similar process is repeatedly performed in a direction from the beginning to the end of the hierarchical database <b>20</b>.</p>
<p id="p-0039" num="0038">The scan pointer recording section <b>305</b> is an example of a read address recording section of the present invention, which records addresses already read by the reading section <b>300</b>. Then, the scan pointer recording section <b>305</b> sequentially updates the address value in a predetermined ascending or descending order starting from a first address from which the reading is started as the reading section <b>300</b> performs the reading. This address value is referred to as a scan pointer. The address recording section <b>310</b> sequentially records storage addresses of the segment data from which the reading section <b>300</b> reads the pointers, with the advance of the reading process by the reading section <b>300</b>. The pointer recording section <b>320</b> sequentially records the pointers read by the reading section <b>300</b> with the advance of the reading process by the reading section <b>300</b>.</p>
<p id="p-0040" num="0039">The address modifying section <b>330</b> modifies the storage address recorded in the address recording section <b>310</b> when the segment data is updated in an area in which the pointer reading has been completed. Whether or not the area in which the pointer reading has been completed is updated can be determined by means of a history recorded in the history recording section <b>360</b>. Similarly, the pointer modifying section <b>340</b> modifies the pointer recorded in the pointer recording section <b>320</b> when the segment data is updated in an area in which the pointer reading has been completed.</p>
<p id="p-0041" num="0040">The segment data updating section <b>350</b> updates the segment data in the hierarchical database <b>20</b> according to an instruction of a user received from the outside. This updating may be performed even when the consistency is being determined. The history recording section <b>360</b> determines whether the segment data is located in the area in which the pointer reading has been completed when the segment data updating section <b>350</b> updates the segment data. For example, the history recording section <b>360</b> may determine that the segment data is located in the area in which the pointer reading has been completed, on condition that the storage address of the segment data is nearer to the beginning than the address recorded in the scan pointer recording section <b>305</b>. On condition that the segment data is located in the area in which the pointer reading has been completed, the history recording section <b>360</b> records its update history.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 4</figref> shows an exemplary data structure of the history recording section <b>360</b>. The second and third lines in the data structure of <figref idref="DRAWINGS">FIG. 4</figref> show an update history for an addition process for the segment data described in <figref idref="DRAWINGS">FIG. 2</figref>. Further, an update history in the 3000 ths addresses is additionally shown in order to explain a deletion process for the segment data.</p>
<p id="p-0043" num="0042">The history recording section <b>360</b> has a storage address recording area <b>400</b> to record a storage address of segment data to be updated. Further, the history recording section <b>360</b> has a pointer-before-modification recording area <b>410</b> that is an example of a first area according to the present invention and a pointer-after-modification recording area <b>420</b> that is an example of a second area according to the present invention. Whenever segment data is updated, the history recording section <b>360</b> records a storage address of the segment data in the storage address recording area <b>400</b>, records a pre-modification value of a pointer included in the segment data in the pointer-before-modification recording area <b>410</b>, and record a post-modification value of a pointer included in the segment data in the pointer-after-modification recording area <b>420</b>.</p>
<p id="p-0044" num="0043">For example, when a pointer <b>2000</b> has been modified into a pointer <b>1200</b> in the segment data of address <b>1100</b>, the history recording section <b>360</b> records <b>1100</b> in the storage address recording area <b>400</b>, records <b>2000</b> in the pointer-before-modification recording area <b>410</b>, and records <b>1200</b> in the pointer-after-modification recording area <b>420</b>. Further, when a pointer <b>3100</b> has been modified into a pointer <b>3200</b> in the segment data of address <b>3000</b>, the history recording section <b>360</b> records <b>3000</b> in the storage address recording area <b>400</b>, records <b>3100</b> in the pointer-before-modification recording area <b>410</b>, and records <b>3200</b> in the pointer-after-modification recording area <b>420</b>.</p>
<p id="p-0045" num="0044">Further, when segment data has been added, the history recording section <b>360</b> records pointer absence information, which indicates that no pointer is included, in the pointer-before-modification recording area <b>410</b> in association with a storage address of the added segment data. This pointer absence information may be Null data having a predetermined value such as zero or minus one. Further, the history recording section <b>360</b> records a pointer included in the added segment data pointing to another segment data in the pointer-after-modification recording area <b>420</b> in association with the storage address of the added segment data.</p>
<p id="p-0046" num="0045">For example, when segment data of address <b>1200</b> has been added, the history recording section <b>360</b> records <b>1200</b> in the storage address recording area <b>400</b>, records Null in the pointer-before-modification recording area <b>410</b>, and records address <b>2000</b> in the pointer-after-modification recording area <b>420</b>.</p>
<p id="p-0047" num="0046">Further, when segment data has been deleted, the history recording section <b>360</b> records a pointer pointing to another segment data, which the segment data has had before the deletion, in the pointer-before-modification recording area <b>410</b> in association with a storage address of the deleted segment data. Also, the history recording section <b>360</b> records pointer absence information in the pointer-after-modification recording area <b>420</b> in association with the storage address of the deleted segment data.</p>
<p id="p-0048" num="0047">For example, when the segment data of address <b>3100</b> has been deleted, the history recording section <b>360</b> records <b>3100</b> in the storage address recording area <b>400</b>, records <b>3200</b> in the pointer-before-modification recording area <b>410</b>, and records Null in the pointer-after-modification recording area <b>420</b>.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 5</figref> shows exemplary storage addresses recorded in the address recording section <b>310</b>. The address recording section <b>310</b> sequentially records storage addresses of segment data from which pointers have been read by the reading section <b>300</b>, with the advance of a reading process by the reading section <b>300</b>. That is to say, the address recording section <b>310</b> records <b>1000</b>, <b>1100</b>, and <b>2000</b> in this sequence. After that, on condition that the segment data <b>200</b>-<b>3</b> has been added to the hierarchical database <b>20</b>, the address modifying section <b>330</b> additionally records address <b>1200</b> in the address recording section <b>310</b>.</p>
<p id="p-0050" num="0049">Specifically, the address modifying section <b>330</b> first retrieves pointer absence information from the pointer-before-modification recording area <b>410</b> in the history recording section <b>360</b>. When the pointer absence information is recorded in the pointer-before-modification recording area <b>410</b>, the address modifying section <b>330</b> adds a storage address corresponding to the area to the address recording section <b>310</b>. The address modifying section <b>330</b> may record the storage address in association with an addition flag (e.g., zero) indicating that the segment data of the address has been added.</p>
<p id="p-0051" num="0050">Further, on condition that the segment data of address <b>3100</b> has been deleted from the hierarchical database <b>20</b>, the address modifying section <b>330</b> excludes the address <b>3100</b> from the address recording section <b>310</b>. Specifically, the address modifying section <b>330</b> retrieves pointer absence information from the pointer-after-modification recording area <b>420</b> in the history recording section <b>360</b>. When the pointer absence information is recorded in the pointer-after-modification recording area <b>420</b>, the address recording section <b>310</b> excludes a storage address corresponding to the area from the address recording section <b>310</b>. In detail, the address modifying section <b>330</b> may record the storage address in the address recording section <b>310</b> in association with a deletion flag (e.g., one) indicating that the storage address has been deleted, in order to exclude the storage address from the address recording section <b>310</b>.</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. 6</figref> shows exemplary pointers recorded in the pointer recording section <b>320</b>. The pointer recording section <b>320</b> sequentially records pointers read from each segment data in association with a storage address of the segment data. For example, the pointer recording section <b>320</b> records “<b>1100</b> <b>1000</b>” as the pointer <b>1100</b> is read from the segment data of address <b>1000</b>. After that, on condition that a pointer in the segment data <b>200</b>-<b>2</b> has been modified, the pointer modifying section <b>340</b> excludes a pointer before modification from the pointer recording section <b>320</b> and adds a pointer after modification to the pointer recording section <b>320</b>.</p>
<p id="p-0053" num="0052">Specifically, the pointer modifying section <b>340</b> first reads pointers from the pointer-before-modification recording area <b>410</b> in the history recording section <b>360</b>. Next, the pointer modifying section <b>340</b> adds each of the read pointers to the pointer recording section <b>320</b> in association with a deletion flag (e.g., one) indicating that the pointer has been deleted, in order to excludes the pointer from the pointer recording section <b>320</b>. Further, the pointer modifying section <b>340</b> reads pointers from the pointer-after-modification recording area <b>420</b> in the history recording section <b>360</b>. Then, the pointer modifying section <b>340</b> adds each of the read pointers to the pointer recording section <b>320</b> in association with an addition flag (e.g., zero) indicating that the pointer has been added.</p>
<p id="p-0054" num="0053">More particularly, since the pointer <b>2000</b> is modified into the pointer <b>1200</b> in the segment data of address <b>1100</b>, the pointer <b>2000</b> is recorded in association with a deletion flag and the pointer <b>1200</b> is recorded in association with an addition flag. Further, since a pointer pointing to the address <b>2000</b> is newly added in the segment data of address <b>1200</b>, the pointer <b>2000</b> is recorded in association with an addition flag.</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 7</figref> shows a flow of a process for modifying a storage address and a pointer to determine consistency. The reading section <b>300</b> sets segment data having an address next to an address recorded in the scan pointer recording section <b>305</b> to a lock state so that the segment data can be read and written exclusively (S<b>700</b>). Next, the reading section <b>300</b> reads a pointer from the segment data having the next address in the lock state (S<b>710</b>). Further, the reading section <b>300</b> records the address to be read in the scan pointer recording section <b>305</b> in the lock state (S<b>715</b>). Then, the reading section <b>300</b> unlocks the lock state (S<b>720</b>).</p>
<p id="p-0056" num="0055">Next, the address recording section <b>310</b> records a storage address of the segment data from which the reading section <b>300</b> has read a pointer (S<b>730</b>). Further, the pointer recording section <b>320</b> records the pointer read by the reading section <b>300</b> (S<b>740</b>). The above-mentioned process is repeated until pointers are read from all the segment data (S<b>750</b>).</p>
<p id="p-0057" num="0056">When all the segment data have been read (S<b>750</b>: YES), the address modifying section <b>330</b> modifies a storage address recorded in the address recording section <b>310</b> on condition that segment data is updated in an area in which the pointer reading has been completed (S<b>760</b>). For example, the address modifying section <b>330</b> may record a storage address of the deleted segment data in the address recording section <b>310</b> in association with a deletion flag indicating that the segment data has been deleted.</p>
<p id="p-0058" num="0057">Further, the pointer modifying section <b>340</b> modifies a pointer recorded in the pointer recording section <b>320</b> on condition that the segment data is updated in the area in which the pointer reading has been completed (S<b>770</b>). For example, the pointer modifying section <b>340</b> may record the deleted pointer in the pointer recording section <b>320</b> in association with a deletion flag indicating that the pointer been deleted.</p>
<p id="p-0059" num="0058">Next, the address modifying section <b>330</b> reorders a plurality of storage addresses recorded in the address recording section <b>310</b> in ascending or descending order according to their address values on condition that a storage address has been added to the address recording section <b>310</b>(S<b>780</b>). In this way, it is possible to easily compare a storage address with a pointer in the following step S<b>790</b>.</p>
<p id="p-0060" num="0059">Note that the address recording section <b>310</b> records storage addresses in ascending or descending order according to their address values as the scan pointer is updated in the ascending or descending order. Therefore, it is preferable that the address modifying section <b>330</b> does not reorder the storage addresses if no storage address is added. As a result, it is possible to improve process efficiency by omitting useless reordering.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 8</figref> shows exemplary storage addresses after the reordering process. The address <b>1200</b> is arranged next to the address <b>1100</b> by the reordering process.</p>
<p id="p-0062" num="0061">Returning to <figref idref="DRAWINGS">FIG. 7</figref>, it is also preferable that the pointer modifying section <b>340</b> reorders a plurality of pointers recorded in the pointer recording section <b>320</b> in ascending or descending order according to their values, in which added or excluded pointers are included. A direction or order of the reordering by the address modifying section <b>330</b> should be the same as that of the pointer modifying section <b>340</b>. That is to say, when the address modifying section <b>330</b> reorders addresses in ascending order, the pointer modifying section <b>340</b> also reorders pointers in ascending order. When the address modifying section <b>330</b> reorders addresses in descending order, the pointer modifying section <b>340</b> also reorders pointers in descending order.</p>
<p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. 9</figref> shows exemplary pointers after the reordering process. The pointer <b>1200</b> is arranged next to the pointer <b>1100</b>. Further, the pointer <b>2000</b> that has been already read, the pointer <b>2000</b> that is associated with a deletion flag, and the pointer <b>2000</b> that is newly added are continuously arranged.</p>
<p id="p-0064" num="0063">Returning to <figref idref="DRAWINGS">FIG. 7</figref>, on condition that the storage address recorded in the address recording section <b>310</b> coincides with the pointer recorded in the pointer recording section <b>320</b>, the determination section <b>370</b> determines that the hierarchical database <b>20</b> is consistent (S<b>790</b>). Specifically, the determination section <b>370</b> excludes a pointer associated with a deletion flag and other pointers having the same value as that of the pointer from the plurality of pointers recorded in the pointer recording section <b>320</b>. In the example of <figref idref="DRAWINGS">FIG. 9</figref>, since the pointer “<b>2000</b> <b>1100</b>” is recorded in association with a deletion flag, it is excluded from the pointers to be compared. Instead, the pointer “<b>2000</b> <b>1200</b>” associated with an addition flag becomes an object to be compared.</p>
<p id="p-0065" num="0064">Similarly, the determination section <b>370</b> excludes an address associated with a deletion flag and other addresses having the same value as that of the address from the plurality of storage addresses recorded in the address recording section <b>310</b>. Since segment data between address <b>1000</b> and address <b>2000</b> are not deleted, no address is excluded in the example of <figref idref="DRAWINGS">FIG. 8</figref>. Then, the determination section <b>370</b> uses a storage address of the added segment data as an object to be compared. In <figref idref="DRAWINGS">FIG. 8</figref>, the address <b>1200</b> is added as an object to be compared.</p>
<p id="p-0066" num="0065">The determination section <b>370</b> sequentially reads one by one from the beginning and compares storage addresses recorded in the address recording section <b>310</b> and pointers recorded in the pointer recording section <b>320</b>. That is to say, the determination section <b>370</b>, for example, reads the address <b>1000</b> from the address recording section <b>310</b> and the pointer “<b>1000</b> RAP” from the pointer recording section <b>320</b>, and compares them. In this case, since both have the same value 1000, it is determined that consistency is preserved. Further, the determination section <b>370</b> reads the address <b>1100</b> from the address recording section <b>310</b> and the pointer “<b>1100</b> <b>1000</b>” from the pointer recording section <b>320</b>, and compares them. Also, in this case, since both have the same value <b>1100</b>, it is determined that consistency is preserved.</p>
<p id="p-0067" num="0066">The determination section <b>370</b> sequentially reads and compares addresses and pointers in this manner, and determines that the hierarchical database <b>20</b> is consistent when each comparison has shown accordance. On the other hand, the determination section <b>370</b> determines that the hierarchical database <b>20</b> is not consistent when one of the pointers does not coincide with any storage address. In this case, the determination section <b>370</b> may preferably output the pointer in association with an address of the segment data including the pointer. That is to say, for example, the determination section <b>370</b> outputs the pointer “<b>1100</b> <b>1200</b>” when the pointer <b>1100</b> does not coincide with any address. In this way, it is possible to easily identify a specific point at which an access failure has occurred.</p>
<p id="p-0068" num="0067">Next, a detailed process for recording the update history by the history recording section <b>360</b> will be described with reference to <figref idref="DRAWINGS">FIGS. 10 to 14</figref>. <figref idref="DRAWINGS">FIG. 10</figref> shows a flow of the process for recording the update history. Whenever the hierarchical database <b>20</b> is updated, the database management system <b>30</b> performs the following on condition that a series of updating processes for the hierarchical database <b>20</b> have been completed and thus the next updating process can be performed. First, the history recording section <b>360</b> acquires a scan pointer from the scan pointer recording section <b>305</b> (S<b>800</b>). Next, the history recording section <b>360</b> determines whether an effective value is set in the scan pointer in order to determine whether consistency is being determined (S<b>810</b>).</p>
<p id="p-0069" num="0068">When an effective value is not set in the scan pointer (S<b>810</b>: NO), the history recording section <b>360</b> terminates the process. On the other hand, when an effective value is set in the scan pointer (S<b>810</b>: YES), the history recording section <b>360</b> determines whether there is segment data with a prefix modified by the updating (S<b>820</b>). When such segment data does not exist (S<b>820</b>: NO), the history recording section <b>360</b> terminates the process.</p>
<p id="p-0070" num="0069">On the other hand, when segment data with an updated prefix exists (S<b>820</b>: YES), it is determined whether the updated segment data is recorded at the same address as or prior to the scan pointer (S<b>830</b>). When the updated segment data resides in an area that is nearer to the beginning than the scan pointer (S<b>830</b>: YES), the history recording section <b>360</b> records the update history (S<b>840</b>) and returns the process to S<b>820</b>.</p>
<p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. 11</figref> shows details of processing in S<b>840</b> shown in <figref idref="DRAWINGS">FIG. 10</figref>. The history recording section <b>360</b> determines an update type indicating how the hierarchical database <b>20</b> is updated (S<b>900</b>). When the update type is addition of segment data (S<b>900</b>: addition of segment data), the history recording section <b>360</b> records a history of adding the segment data (S<b>920</b>). That is to say, the history recording section <b>360</b> records a storage address of the segment data in the storage address recording area <b>400</b>, records pointer absence information in the pointer-before-modification recording area <b>410</b>, and records a value of a pointer newly generated in the segment data in the pointer-after-modification recording area <b>420</b>.</p>
<p id="p-0072" num="0071">On the other hand, when the update type is content modification of the existing segment data (S<b>900</b>: modification of segment data), the history recording section <b>360</b> determines whether the update type is a split update that splits off a part of a certain segment data to make another segment data (S<b>960</b>). When it is not the split update (S<b>960</b>: NO), the history recording section <b>360</b> records an update history of the prefix. That is to say, for example, the history recording section <b>360</b> records a storage address of segment data to be updated in the storage address recording area <b>400</b>, records a value of a pointer before modification included in the segment data in the pointer-before-modification recording area <b>410</b>, and records a value of the pointer after modification in the pointer-after-modification recording area <b>420</b>.</p>
<p id="p-0073" num="0072">On the other hand, when it is the split update (S<b>960</b>: YES), the history recording section <b>360</b> determines whether the prefix is modified in the split update (S<b>980</b>). When it is the modification of prefix, the history recording section <b>360</b> records an update history of the prefix in the split update (S<b>990</b>). On the other hand, when it is not the modification of prefix (S<b>980</b>: NO), the history recording section <b>360</b> records an update history of a data portion in the split update. Details of a method for recording the update history in the split update will be described with reference to <figref idref="DRAWINGS">FIG. 14</figref>.</p>
<p id="p-0074" num="0073"><figref idref="DRAWINGS">FIGS. 12A and 12B</figref> show an exemplary process in which segment data is added. <figref idref="DRAWINGS">FIG. 12A</figref> shows the hierarchical database <b>20</b> before adding segment data. The hierarchical database <b>20</b> includes segment data <b>200</b>-<b>5</b> having a storage address of <b>1000</b> and segment data <b>200</b>-<b>6</b> having a storage address of <b>1200</b>. The segment data <b>200</b>-<b>5</b> includes a pointer to the segment data <b>200</b>-<b>6</b> in the prefix.</p>
<p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. 12B</figref> shows the hierarchical database <b>20</b> and the history recording section <b>360</b> after adding segment data. When segment data <b>200</b>-<b>7</b> is added between the segment data <b>200</b>-<b>5</b> and the segment data <b>200</b>-<b>6</b>, the segment data updating section <b>350</b> modifies the pointer to the segment data <b>200</b>-<b>6</b> included in the segment data <b>200</b>-<b>5</b> into a storage address of the segment data <b>200</b>-<b>7</b>. Then, the segment data updating section <b>350</b> generates a pointer to the segment data <b>200</b>-<b>6</b> in the segment data <b>200</b>-<b>7</b>.</p>
<p id="p-0076" num="0075">As a result, the hierarchical database <b>20</b> includes the newly added segment data <b>200</b>-<b>7</b> in an area having a storage address of <b>1100</b>. Then, the segment data <b>200</b>-<b>5</b> includes a pointer (i.e., <b>1100</b>) to the segment data <b>200</b>-<b>7</b> in place of the pointer (i.e., <b>1200</b>) to the segment data <b>200</b>-<b>6</b>, and the segment data <b>200</b>-<b>7</b> includes the pointer (i.e., <b>1200</b>) to the segment data <b>200</b>-<b>6</b>.</p>
<p id="p-0077" num="0076">Further, since the pointer in the segment data <b>200</b>-<b>5</b> has been modified from <b>1200</b> to <b>1100</b>, the history recording section <b>360</b> records <b>1000</b> that is a storage address of the segment data <b>200</b>-<b>5</b> in the storage address recording area <b>400</b>, records <b>1200</b> that is a storage address of the segment data <b>200</b>-<b>6</b> in the corresponding pointer-before-modification recording area <b>410</b>, and records <b>1100</b> that is a storage address of the segment data <b>200</b>-<b>7</b> in the corresponding pointer-after-modification recording area <b>420</b> (corresponding to the processing in S<b>970</b>).</p>
<p id="p-0078" num="0077">Further, since the segment data <b>200</b>-<b>7</b> has been newly added, the history recording section <b>360</b> records <b>1100</b> that is a storage address of the segment data <b>200</b>-<b>7</b> in the storage address recording area <b>400</b>, records pointer absence information (e.g., NULL) in the corresponding pointer-before-modification recording area <b>410</b>, and records <b>1200</b> that is a storage address of the segment data <b>200</b>-<b>6</b> in the corresponding pointer-after-modification recording area <b>420</b> (corresponding to the processing in S<b>920</b>).</p>
<p id="p-0079" num="0078"><figref idref="DRAWINGS">FIGS. 13A and 13B</figref> show an exemplary process in which segment data is deleted. <figref idref="DRAWINGS">FIG. 13A</figref> shows the hierarchical database <b>20</b> before deleting segment data. The hierarchical database <b>20</b> includes segment data <b>200</b>-<b>5</b> having a storage address of <b>1000</b>, segment data <b>200</b>-<b>6</b> having a storage address of <b>1200</b>, and segment data <b>200</b>-<b>7</b> having a storage address of <b>1100</b>. The segment data <b>200</b>-<b>5</b> includes a pointer to the segment data <b>200</b>-<b>7</b> in the prefix and the segment data <b>200</b>-<b>7</b> includes a pointer to the segment data <b>200</b>-<b>6</b> in the prefix.</p>
<p id="p-0080" num="0079"><figref idref="DRAWINGS">FIG. 13B</figref> shows the hierarchical database <b>20</b> and the history recording section <b>360</b> after deleting the segment data. When the segment data <b>200</b>-<b>7</b> between the segment data <b>200</b>-<b>5</b> and the segment data <b>200</b>-<b>6</b> is deleted, the segment data updating section <b>350</b> modifies the pointer to the segment data <b>200</b>-<b>7</b> included in the segment data <b>200</b>-<b>5</b> into a storage address of the segment data <b>200</b>-<b>6</b>.</p>
<p id="p-0081" num="0080">As a result, the hierarchical database <b>20</b> does not include the deleted segment data <b>200</b>-<b>7</b>. Further, the segment data <b>200</b>-<b>5</b> includes a pointer (i.e., <b>1200</b>) to the segment data <b>200</b>-<b>6</b> in place of the pointer (i.e., <b>1100</b>) to the segment data <b>200</b>-<b>7</b>.</p>
<p id="p-0082" num="0081">Further, since the pointer in the segment data <b>200</b>-<b>5</b> has been modified from <b>1100</b> to <b>1200</b>, the history recording section <b>360</b> records a storage address of the segment data <b>200</b>-<b>5</b> in the storage address recording area <b>400</b>, records a storage address of the segment data <b>200</b>-<b>7</b> in the corresponding pointer-before-modification recording area <b>410</b>, and records a storage address of the segment data <b>200</b>-<b>6</b> in the corresponding pointer-after-modification recording area <b>420</b> (corresponding to the processing in S<b>970</b>).</p>
<p id="p-0083" num="0082">Further, since the segment data <b>200</b>-<b>7</b> has been deleted, the history recording section <b>360</b> records a storage address of the segment data <b>200</b>-<b>7</b> in the storage address recording area <b>400</b>, records a storage address of the segment data <b>200</b>-<b>6</b> in the corresponding pointer-before-modification recording area <b>410</b>, and records pointer absence information in the corresponding pointer-after-modification recording area <b>420</b> (corresponding to the processing in S<b>940</b>).</p>
<p id="p-0084" num="0083"><figref idref="DRAWINGS">FIGS. 14A and 14B</figref> show an exemplary process in which segment data is split. <figref idref="DRAWINGS">FIG. 14A</figref> shows the hierarchical database <b>20</b> before splitting segment data. Since a state before splitting is generally equal to <figref idref="DRAWINGS">FIG. 13A</figref>, its description is omitted. <figref idref="DRAWINGS">FIG. 14B</figref> shows the hierarchical database <b>20</b> and the history recording section <b>360</b> after splitting the segment data. With reference to <figref idref="DRAWINGS">FIGS. 14A and 14B</figref>, a process for splitting one segment data into one or more other segment data by the segment data updating section <b>350</b> will be described.</p>
<p id="p-0085" num="0084">The segment data updating section <b>350</b> splits off a part of segment data <b>200</b>-<b>7</b> having a pointer pointing to segment data <b>200</b>-<b>6</b> to make new segment data <b>200</b>-<b>8</b>. At this time, the segment data updating section <b>350</b> adds a pointer pointing to the segment data <b>200</b>-<b>8</b> to the segment data <b>200</b>-<b>7</b>, and adds a split flag indicating that a part of the segment data <b>200</b>-<b>7</b> has been split off.</p>
<p id="p-0086" num="0085">The history recording section <b>360</b> records <b>1100</b> that is a storage address of the segment data <b>200</b>-<b>7</b> in the storage address recording area <b>400</b> when the segment data <b>200</b>-<b>7</b> is split. Then, the history recording section <b>360</b> records a pointer which the segment data <b>200</b>-<b>7</b> has had before splitting in the pointer-before-modification recording area <b>410</b> in association with the storage address of the segment data <b>200</b>-<b>7</b>. That is to say, the history recording section <b>360</b> records <b>1200</b> that is a pointer pointing to the segment data <b>200</b>-<b>6</b> in the pointer-before-modification recording area <b>410</b>.</p>
<p id="p-0087" num="0086">Further, the history recording section <b>360</b> records a pointer pointing to the segment data <b>200</b>-<b>6</b>, a split flag indicating that the segment data <b>200</b>-<b>7</b> has been split, and a pointer pointing to the split-off segment data <b>200</b>-<b>8</b>, in the pointer-after-modification recording area <b>420</b> (corresponding to the processing in S<b>990</b>). Here, it is desirable that the pointer pointing to the split-off segment data <b>200</b>-<b>8</b> is recorded at a predetermined record position in the pointer-after-modification recording area <b>420</b> so that it is distinguished from other pointers. That is to say, in the example of <figref idref="DRAWINGS">FIG. 14B</figref>, address <b>1400</b> is recorded in a predetermined ending area in the pointer-after-modification recording area <b>420</b>.</p>
<p id="p-0088" num="0087">Since the segment data <b>200</b>-<b>8</b> has been added to the hierarchical database <b>20</b>, the history recording section <b>360</b> also records that fact. Specifically, the history recording section <b>360</b> records <b>1400</b> that is a storage address of the segment data <b>200</b>-<b>8</b> in the storage address recording area <b>400</b>, records pointer absence information in the corresponding pointer-before-modification recording area <b>410</b>, and records a split-off flag indicating that the segment data is split-off data in the corresponding pointer-after-modification recording area <b>420</b> (corresponding to the processing in S<b>995</b>).</p>
<p id="p-0089" num="0088">When segment data is split, the pointer modifying section <b>340</b> operates the pointer recording section <b>320</b>, for example, as described below. Specifically, on condition that a split flag is recorded in the pointer-after-modification recording area <b>420</b>, the pointer modifying section <b>340</b> first reads a storage address of the split-off segment data from the pointer-after-modification recording area <b>420</b>. Here, the storage address of the split-off segment data can be read from a predetermined record position in the pointer-after-modification recording area <b>420</b>. Then, the pointer modifying section <b>340</b> records the read storage address in the pointer recording section <b>320</b> as an added pointer in association with a predetermined addition flag. In this way, the segment data newly added by the splitting can also be considered in the consistency determination.</p>
<p id="p-0090" num="0089">As described above with reference to <figref idref="DRAWINGS">FIGS. 10 to 14</figref>, the database management system <b>30</b> can instantly determine whether segment data to be updated is located at an already read address by comparing a scan pointer and an address value. When the segment data located at the already read address is updated, a history of the updating is recorded in the history recording section <b>360</b>. Since the amount of processing of these processes is small, they do not significantly increase the load of the database management system <b>30</b>. Therefore, the database management system <b>30</b> can assign a lot of computing power to a normal transaction for the hierarchical database <b>20</b>.</p>
<p id="p-0091" num="0090">In a case where computing power of the database management system <b>30</b> significantly exceeds computing power necessary for a normal transaction, the database management system <b>30</b> may perform processing for modifying a storage address and a pointer (S<b>760</b> and S<b>770</b>) whenever segment data is updated. In this case, the history recording section <b>360</b> does not have to accumulate a modification history of segment data. Therefore, it is possible to save a storage capacity in the database management system. Furthermore, since the modification of a storage address and a pointer (S<b>760</b> and S<b>770</b>) may not be performed after all segment data have been read (S<b>750</b>: YES), it is possible to reduce post-processing time necessary after the segment data have been read.</p>
<p id="p-0092" num="0091">As described above with reference to <figref idref="DRAWINGS">FIGS. 1 to 14</figref>, the database management system <b>30</b> records an update history of a pointer that is updated during processing for the consistency determination in the form capable of identifying its updated contents. Then, when an area in which pointer reading has been completed is updated, the pointer and address values are modified based on the updated contents. In this way, even though the hierarchical database <b>20</b> is updated during processing for the consistency determination, it is possible to appropriately determine consistency.</p>
<p id="p-0093" num="0092">Further, the updated pointer and address values are reordered along with pointers and addresses already read in advance of consistency determination. As a result, consistency can be determined by sequentially reading and comparing the recorded pointers and addresses from the beginning. In this way, it is possible to perform consistency determination with the same level of efficiency as the conventional technique.</p>
<p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. 15</figref> shows an exemplary process for determining consistency of segment data updated after consistency determination. It exemplifies a process for determining whether consistency is preserved when some segment data is updated in the state where the hierarchical database <b>20</b> is consistent. According to this process, it can be determined whether consistency is preserved by determining consistency on only the updated part and thus a process for determining consistency can be improved still more.</p>
<p id="p-0095" num="0094">The database management system <b>30</b> may regularly performs the following process on condition that the determination section <b>370</b> has determined that the hierarchical database <b>20</b> is consistent. The history recording section <b>360</b> determines whether the prefix of some segment data has been updated in the consistent state (S<b>1500</b>). If the prefix has been updated (S<b>1500</b>: YES), the address recording section <b>310</b> further records a storage address of the segment data added or deleted by the updating in addition to the storage addresses already recorded to determine consistency (S<b>1510</b>). This storage address may be recorded by the address modifying section <b>330</b> based on the update history recorded in the history recording section <b>360</b>.</p>
<p id="p-0096" num="0095">Next, the pointer recording section <b>320</b> further records the pointer modified by the updating (S<b>1520</b>). Specifically, this pointer may be recorded by the pointer modifying section <b>340</b> based on the update history recorded in the history recording section <b>360</b>.</p>
<p id="p-0097" num="0096">The determination section <b>370</b> compares the respective pointers after modification recorded in the pointer recording section <b>320</b> after the database has been determined to be consistent and the respective storage addresses of the added segment data recorded in the address recording section <b>310</b> after the database has been determined to be consistent (S<b>1530</b>). Further, the determination section <b>370</b> compares the respective pointers after modification recorded in the pointer recording section <b>320</b> after the database has been determined to be consistent and the respective addresses sequentially recorded by the address recording section <b>310</b> before the consistency determination to determine consistency (S<b>1540</b>). However, any storage address recorded in association with a deletion flag is excluded from the comparison.</p>
<p id="p-0098" num="0097">If each of the pointers coincides with any storage address before or after the consistency determination (S<b>1550</b>: YES), the determination section <b>370</b> determines that the consistency of the hierarchical database <b>20</b> is preserved (S<b>1560</b>). On the other hand, if at least one pointer does not coincide with any storage address (S<b>1550</b>: NO), the determination section <b>370</b> determines that the consistency of the hierarchical database <b>20</b> has been lost (S<b>1570</b>).</p>
<p id="p-0099" num="0098">As described above, according to the process shown in <figref idref="DRAWINGS">FIG. 15</figref>, it is possible to confirm that consistency of the hierarchical database <b>20</b> is preserved by determining consistency on only updated elements once consistency has been determined. As a result, a process for determining consistency can be improved still more.</p>
<p id="p-0100" num="0099"><figref idref="DRAWINGS">FIG. 16</figref> shows an exemplary hardware configuration of an information processing apparatus <b>500</b> functioning as the database management system <b>30</b>. In <figref idref="DRAWINGS">FIG. 15</figref>, the information processing apparatus <b>500</b> is assumed to be a large-scale general purpose computer referred to as a mainframe. The information processing apparatus <b>500</b> includes a main memory <b>502</b>, at least one central processing unit <b>504</b>, a memory controller <b>506</b>, a channel subsystem <b>508</b>, at least one control unit <b>510</b>, and one or more I/O devices <b>512</b><i>a </i>to <b>512</b><i>d. </i></p>
<p id="p-0101" num="0100">The main memory <b>502</b> stores data and programs input from the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d</i>. When the main memory <b>502</b> is addressed by the central processing unit <b>504</b> or the channel subsystem <b>508</b>, it sends data stored at the specified address to the central processing unit <b>504</b> or the channel subsystem <b>508</b>. The main memory <b>502</b> can access the data stored therein at high speed to enable fast operations of the central processing unit <b>504</b>.</p>
<p id="p-0102" num="0101">The central processing unit <b>504</b> plays the main role of controlling the entire information processing apparatus <b>500</b>, and executes, e.g., at least one operating system <b>505</b>. The operating system <b>505</b> controls program execution and input/output processing in the information processing apparatus <b>500</b>. For example, the operating system <b>505</b> may control the execution of another program running on the central processing unit <b>504</b>, or may control data transfer to or from each of the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d. </i></p>
<p id="p-0103" num="0102">The memory controller <b>506</b> is connected to the central processing unit <b>504</b> via a bus <b>514</b> capable of performing two-way or one-way communication. The memory controller <b>506</b> is also connected to the main memory <b>502</b> via a bus <b>516</b>, and is connected to the channel subsystem <b>508</b> via a bus <b>518</b>. The memory controller <b>506</b> may temporarily retain or queue an access request received from the central processing unit <b>504</b> or the channel subsystem <b>508</b>, and send the access request to the main memory <b>502</b> at predetermined timing.</p>
<p id="p-0104" num="0103">The channel subsystem <b>508</b> is connected to each controller <b>510</b> via a data transfer path <b>520</b>. The channel subsystem <b>508</b> controls data transfer between the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d </i>and the main memory <b>502</b>. Since this reduces processing load on the central processing unit <b>504</b> for communicating with the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d</i>, it is possible to execute arithmetic operations by the central processing unit <b>504</b> in parallel with input/output operations by the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d</i>, so that the information processing apparatus <b>500</b> can be efficiently operated.</p>
<p id="p-0105" num="0104">The channel subsystem <b>508</b> transfers data to or from the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d </i>via at least one channel path <b>522</b>. Each channel path <b>522</b> has a channel <b>524</b> provided in the channel subsystem <b>508</b>. Also, each channel path <b>522</b> has at least one controller <b>510</b> and data transfer path <b>520</b>. Note here that the data transfer path <b>520</b> may be a serial link based on ESCON (Enterprise Systems Connection Architecture), for example. Alternatively, the data transfer path <b>520</b> may be a parallel OEMI or a fiber channel.</p>
<p id="p-0106" num="0105">The controller <b>510</b> controls at least one of the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d</i>. For example, the controller <b>510</b> may control data transfer timing for the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d</i>. The controller <b>510</b> is connected with at least one of the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d </i>via a bus <b>526</b>. The controller <b>510</b> can be connected with up to <b>256</b> I/O devices.</p>
<p id="p-0107" num="0106">Each of the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d </i>transfers data to or from the main memory <b>502</b> via the controller <b>510</b>, the channel subsystem <b>508</b>, and the memory controller <b>506</b>. In this configuration, the I/O device <b>512</b><i>a </i>is a magnetic tape drive, and the I/O device <b>512</b><i>d </i>is a hard disk drive. Alternatively or additionally, the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d </i>may be a display, a keyboard, a printer, a communication device, a sensor, or any other storage device. As an example, at least one of the I/O devices <b>512</b><i>a </i>to <b>512</b><i>d </i>may be connected to and access the hierarchical database <b>20</b>.</p>
<p id="p-0108" num="0107">A program provided to the information processing apparatus <b>500</b> is stored in a recording medium such as a tape recording medium <b>535</b> and is provided by a user. The program is read by the I/O device <b>512</b><i>a </i>and is stored into the main memory <b>502</b> via the channel subsystem <b>508</b>. Then, the program stored into the main memory <b>502</b> is installed into the I/O device <b>512</b><i>d </i>(hard disk drive) via the channel subsystem <b>508</b>. Since the operations that the program causes the information processing apparatus <b>500</b> to perform are the same as those in the database management system <b>30</b> described with reference to <figref idref="DRAWINGS">FIGS. 1 to 15</figref>, their descriptions will be omitted.</p>
<p id="p-0109" num="0108">The program described above may be stored in an external storage medium. The storage medium may be a flexible disk, a CD-ROM, an optical recording medium such as a DVD or a PD, a magneto-optical recording medium such as an MD, or a semiconductor memory such as an IC card. Alternatively, a storage device such as a hard disk or a RAM provided in a server system connected to a private communication network or the Internet may be used as a recording medium from which the program may be provided to the information processing apparatus <b>500</b> via the network.</p>
<p id="p-0110" num="0109">While the present invention has been described with reference to the preferred embodiments, the technical scope of the present invention is not limited thereto. It should be understood by those skilled in the art that various modifications or improvements can be added to the above preferred embodiments. It is apparent from the appended claims that such modified or improved embodiments fall within the technical scope of the present invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. An apparatus for determining consistency of a database, comprising:
<claim-text>a reading section that sequentially reads, from respective segment data included in said database, pointers to other segment data;</claim-text>
<claim-text>an address recording section that records storage addresses of segment data from which the pointers have been read by said reading section;</claim-text>
<claim-text>a pointer recording section that records the pointers read by said reading section;</claim-text>
<claim-text>an address modifying section that modifies a storage address recorded in said address recording section when segment data is updated in an area in which the pointer reading has been completed;</claim-text>
<claim-text>a pointer modifying section that modifies a pointer recorded in said pointer recording section when segment data is updated in an area in which the pointer reading has been completed; and</claim-text>
<claim-text>a determination section that determines that said database is consistent on condition that the respective storage addresses recorded in said address recording section coincide with the respective pointers recorded in said pointer recording section.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>a history recording section that has first and second areas for recording pointer values in response to updating segment data in the area in which the pointer reading has been completed, the first area recording a pre-modification value of a pointer included in the segment data, the second area recording a post-modification value of the pointer included in the segment data,</claim-text>
<claim-text>wherein said pointer modifying section excludes the pointer recorded in the first area of said history recording section from said pointer recording section and adds the pointer recorded in the second area of said history recording section to said pointer recording section.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The apparatus of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>a read address recording section that records an address read by said reading section and sequentially updates the address value in a predetermined order, either ascending or descending, starting from a beginning address from which reading should be started,</claim-text>
<claim-text>wherein when segment data is updated, said history recording section determines that the segment data is located in an area in which the pointer reading has been completed on condition that a storage address of the segment data is in advance of said read address.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The apparatus of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein
<claim-text>said pointer modifying section adds a pointer recorded in the first area of said history recording section to said pointer recording section in association with a deletion flag indicating that the pointer has been deleted, in order to exclude the pointer from said pointer recording section, and</claim-text>
<claim-text>said determination section compares each of the pointers recorded in said pointer recording section with each of the addresses recorded in said address recording section, excluding the pointer associated with said deletion flag and one or more pointers having the same value as that pointer.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The apparatus of <claim-ref idref="CLM-00004">claim 4</claim-ref> wherein
<claim-text>said pointer modifying section reorders the plurality of pointers recorded in said pointer recording section, along with the added or deleted pointers, in ascending or descending order in accordance with their pointer values, and</claim-text>
<claim-text>said determination section compares the plurality of reordered pointers with each of the addresses recorded in said address recording section.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The apparatus of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein
<claim-text>in response to adding segment data, said history recording section records pointer absence information, which indicates that no pointer is included, in the first area and a pointer included in the added segment data pointing to another segment data in the second area in association with a storage address of the added segment data,</claim-text>
<claim-text>in response to deleting segment data, said history recording section records a pointer pointing to another segment data, which the deleted segment data has had before the deletion, in the first area and said pointer absence information in the second area in association with a storage address of the deleted segment data, and</claim-text>
<claim-text>said address modifying section adds a storage address corresponding to the first area to said address recording section when said pointer absence information is recorded in said first area and excludes a storage address corresponding to said second area from said address recording section when said pointer absence information is recorded in said second area.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein
<claim-text>said address modifying section records a storage address corresponding to said second area in said address recording section in association with a deletion flag indicating that said storage address has been deleted in order to exclude said storage address from said address recording section when said pointer absence information is recorded in said second area, and</claim-text>
<claim-text>said determination section compares each of the storage address recorded in said address recording section with each of the pointers recorded in said pointer recording section, excluding the storage address associated with said deletion flag and any other storage address having the same value as that storage address.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein
<claim-text>said address modifying section reorders the plurality of storage addresses recorded in said address recording section in one of ascending and descending order according to their address values on condition that a storage address has been added to said address recording section, and</claim-text>
<claim-text>said determination section compares the plurality of reordered address values with each of the pointers recorded in said pointer recording section.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The apparatus of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein
<claim-text>when one segment is split into one or more other segment data, said history recording section records a pointer in said first area, which the split segment data has had before splitting and records said pointer, a split flag indicating that said one segment data has been split, pointers pointing to said other segment data in the second area, in association with a storage address of the split segment data, and</claim-text>
<claim-text>said pointer modifying section adds the pointers pointing to said other segment data recorded in said second area to said pointer recording section on condition that said split flag is recorded in said second area.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein
<claim-text>on condition that said determination section determines that said database is consistent,</claim-text>
<claim-text>said pointer recording section further records, when a segment of the segment data is updated in the consistent state, a pointer modified by that updating,</claim-text>
<claim-text>said address recording section further records, when a segment of the segment data is updated in the consistent state, a storage address of the segment data added or deleted by that updating, and</claim-text>
<claim-text>said determination section determines that the consistency of said database is preserved on condition that the modified pointers recorded in said pointer recording section after being determined that said database is consistent coincide with the respective storage addresses of the added segment data recorded in said address recording section after being determined that said database is consistent.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The apparatus of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein
<claim-text>said determination section determines that the consistency of said database is preserved on condition that the respective modified pointers recorded in said pointer recording section after being determined that said database is consistent coincide with the addresses sequentially recorded in said address recording section to determine the consistency of the addresses recorded in said address recording section after determining the consistency.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A computer program product comprising a computer readable medium having computer usable program code programmed for determining consistency of a database, the operations of the computer program product comprising:
<claim-text>modifying a storage address recorded in an address recording section in response to updating segment data in an area in which a database pointer reading has been completed, wherein the reading section sequentially reads database pointers to other segment data from respective segment data included in the database pointers;</claim-text>
<claim-text>modifying a pointer recorded in a pointer recording section in response to updating segment data in an area in which the database pointer reading has been completed, wherein the pointer recording section records the database pointers read by the reading section; and</claim-text>
<claim-text>determining that the database is consistent on condition that the respective storage addresses recorded in an address recording section coincide with the respective pointers recorded in the pointer recording section, wherein the address recording section records storage addresses of segment data from which the database pointers have been read by the reading section.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A system for determining consistency of a database, the system comprising:
<claim-text>a data storage device storing a database; and</claim-text>
<claim-text>a data management system in communication with the database of the data storage device, the data management system comprising:
<claim-text>a reading section that sequentially reads, from respective segment data included in the database, pointers to other segment data;</claim-text>
<claim-text>an address recording section that records storage addresses of segment data from which the pointers have been read by the reading section;</claim-text>
<claim-text>a pointer recording section that records the pointers read by the reading section;</claim-text>
<claim-text>an address modifying section that modifies a storage address recorded in the address recording section when segment data is updated in an area in which the pointer reading has been completed;</claim-text>
<claim-text>a pointer modifying section that modifies a pointer recorded in the pointer recording section when segment data is updated in an area in which the pointer reading has been completed; and</claim-text>
<claim-text>a determination section that determines that the database is consistent on condition that the respective storage addresses recorded in the address recording section coincide with the respective pointers recorded in the pointer recording section.</claim-text>
</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
