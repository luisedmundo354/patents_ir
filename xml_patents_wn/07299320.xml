<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299320-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299320</doc-number>
<kind>B2</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11467425</doc-number>
<date>20060825</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711147</main-classification>
<further-classification>711154</further-classification>
<further-classification>711202</further-classification>
<further-classification>719312</further-classification>
</classification-national>
<invention-title id="d0e51">Message based inter-process for high volume data</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6341338</doc-number>
<kind>B1</kind>
<name>Dennis</name>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6877048</doc-number>
<kind>B2</kind>
<name>Bilak et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2002/0013889</doc-number>
<kind>A1</kind>
<name>Schuster et al.</name>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2002/0053004</doc-number>
<kind>A1</kind>
<name>Pong</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2002/0059503</doc-number>
<kind>A1</kind>
<name>Dennis</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2003/0208660</doc-number>
<kind>A1</kind>
<name>van de Waerdt</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00007">
<othercit>Tanenbaum, “Structured Computer Organization, Third Edition,” Section 1.4 Hardware, Software, and Multilevel Machines, p. 11, “Hardware and software are logically equivalent.”, 1990.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00008">
<othercit>IBM Technical Disclosure Bulletin, “Dynamic Storage Pool Manager,” vol. 28, Iss. No. 4, pp. 1684-1686, Sep. 1, 1985.</othercit>
</nplcit>
<category>cited by examiner</category>
</citation>
<citation>
<nplcit num="00009">
<othercit>Dice et al., “Mostly Lock-Free Malloc,” pp. 163-174, ACM, Jun. 2002.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>42</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711147</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711154</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711202</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>719312</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>10608337</doc-number>
<kind>00</kind>
<date>20030630</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>7124255</doc-number>
<kind>A </kind>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>11467425</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20060288174</doc-number>
<kind>A1</kind>
<date>20061221</date>
</document-id>
</related-publication>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Nace</last-name>
<first-name>Eric</first-name>
<address>
<city>Fairbanks</city>
<state>AL</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Patiejunas</last-name>
<first-name>Kestutis</first-name>
<address>
<city>Sammamish</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="003" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Bejarano</last-name>
<first-name>Dario Bazan</first-name>
<address>
<city>Sammamish</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Shook, Hardy &amp; Bacon L.L.P.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Elmore</last-name>
<first-name>Stephen C.</first-name>
<department>2185</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">An interprocess communications platform enables individual processes to request and exchange data in a shared memory space, mediated by a communications engine. Processes, such as applications or other software running under an operating system or in a network, register to blocks of a shared memory space via an administrative memory space which tracks pointers, handles and other indicators of memory areas populated by individual processes. When one process requests access to a variable, pointer or other data generated by another process, the request is mediated by the communications engine. The communications engine may locate the target data belonging to the other process in the shared memory space, via a lookup of relative addressing in a separate administrative memory space. The communications engine, memory management objects and other resources may then lock the portion of the shared memory space allocated to the target process to permit the requesting process to access the data. Data may therefore be exchange between given processes while maintaining data integrity, and also may be cached in the shared memory space or elsewhere by the communications engine to further increase efficiency. Available memory in the shared memory space may be managed using the so-called buddy system or other heap or other management techniques. No named pipes or similar mechanisms under an operating system need be invoked.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="185.00mm" wi="231.99mm" file="US07299320-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="216.24mm" wi="156.46mm" file="US07299320-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="237.57mm" wi="193.12mm" orientation="landscape" file="US07299320-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="254.51mm" wi="204.89mm" orientation="landscape" file="US07299320-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="244.01mm" wi="174.24mm" file="US07299320-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="228.09mm" wi="199.56mm" file="US07299320-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION</heading>
<p id="p-0002" num="0001">This application is a continuation of application Ser. No. 10/608,337, filed Jun. 30, 2003 now U.S. Pat. No. 7,124,255, from which application priority is thereby claimed.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</heading>
<p id="p-0003" num="0002">Not applicable.</p>
<heading id="h-0003" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0004" num="0003">The invention relates to the field of computing, and more particularly to software platforms designed to enable applications or other processes executing in a shared memory space to exchange data on an a secure and efficient basis.</p>
<heading id="h-0004" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0005" num="0004">The task of permitting applications or other software processes to exchange or share data on a live basis represents a long-standing challenge in the field of computing science. Word processing, networking, database or data mining and other applications or other processes may need to operate or most optimally operate on a common data set. For instance, customer resource management (CRM) platforms of a corporation, government or other organization may benefit from enabling transaction data to be updated and synchronized after a customer service representative has updated an account via a call center workstation. Data mining applications may benefit from dynamic linkage to sales data or supply chain packages. Other software systems may benefit from dynamic data linkage.</p>
<p id="p-0006" num="0005">However, under most operating systems the memory space of various application processes may typically be isolated from, and not by themselves equipped to exchange data with, each other. Permitting individual processes to access, operate on and store common data while maintaining data coherency and avoiding memory contention and other problems may be a non-trivial task. A network or other facility deploying distributed or otherwise interacting software may nevertheless have to provide some mechanism to exchange data on a dynamic basis.</p>
<p id="p-0007" num="0006">In certain known approaches, for instance the arrangement shown in <figref idref="DRAWINGS">FIG. 1</figref>, a fixed memory map may be configured to be shared by a set of processes, with variables from the various processes being mapped into that fixed space. Individual processes may then identify and operate on variables of interest. However, a static block approach may suffer from certain disadvantages. For one, the caching of any data or variable within a shared memory block can only be done by individual applications, increasing the coding complexity of those applications. Moreover, in network and other applications, the data being exchanged between various processes may differ widely in size, priority and other characteristics. For example, when a large number of processes attempt to access or manipulate another process, reliance upon a unified set of shared variables may prove inefficient or impossible. Timing, caching and other interactive complexities may degrade or overwhelm the system under such an approach as multiple processes contend for different variables or introduce dependencies or other problems.</p>
<p id="p-0008" num="0007">Operating systems and other higher-level platforms have for their part afforded some solutions to the need for inter-process communication (IPC). For processes running under the Microsoft Windows™ NT, 2000 or related operating systems, for example, it is possible to open communication structures referred to as “pipes”, which permit a public channel for communication between processes. However, difficulties or limitations may remain. For example, such pipes created at the operating system level may not persist after the participating processes terminate. Moreover while such pipes permit data to be communicated between processes, the data transmitted via the pipe does not persist after it is sent. Maintaining a cache or other structure may therefore be difficult or impossible. Moreover, when using named pipes the bandwidth required to transmit a given set of data may scale linearly with the size of the data, which may degrade the performance of video, database or other bandwidth-dependent processes. Other problems exist.</p>
<heading id="h-0005" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0009" num="0008">The invention overcoming these and other problems in the art relates in one regard to a system and method for interprocess communications, in which individual processes register a shared memory space on a dynamic basis. Processes may communicate with each other or with remote entities via the resulting effective data channel, with caching and other features supported by the shared memory scheme. Processes at start up may register a unique memory block to a memory manager in an administrative shared memory space. The memory manager in the administrative shared memory may use a heap management algorithm such as a buddy system or other allocation algorithm to allocate memory to processes. A communications engine may map a logical address for the memory block to physical memory within its address space on a dynamic basis. Because processes requesting data may begin to receive the data stream by redirection of a pointer or other memory locator to the assigned memory block, data channel transmission does not scale in transmission time or bandwidth according to the size of the data requested. The caching for the communications engine and other processes may be managed by memory managers in the administrative shared memory block as a byproduct of generic memory allocation. Because only the communications engine and a single other process will only ever share any one registered shared memory block and because data is managed in a coherent manner overall, the resulting communications platform as well as individual processes are consequently easier to debug, and the potential for memory corruption is reduced. Efficiency is increased because the amount of contention on any shared memory block is again reduced as there at most two processes vying for memory resources (as opposed to N processes and a single shared memory block as is commonly used) and each shared memory block is assigned its own memory manager in administrative shared memory. The invention may provide application programming interfaces (APIs) to create another level of data integrity since this may keep the communication engine or other process from writing directly to a shared memory block. An API may also allow processes to exchange data, but may not necessarily rely upon or execute at the operating system level of a host machine.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0010" num="0009">The invention will be described in conjunction with the following drawings, in which like elements are labeled by like numerals and in which:</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a fixed shared memory scheme, according to a known architecture.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 2</figref> illustrates an architecture in which interprocess communications may be supported, according to an embodiment of the invention.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 3</figref> illustrates an example of computer code which may implement calls to processes, according to an embodiment of the invention.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a flowchart of a setup or rendezvous phase of overall interprocess communication, according to an embodiment of the invention.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 5</figref> illustrates a flowchart of a communications phase of overall interprocess communication, according to an embodiment of the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0007" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> illustrates an architecture in which an interprocess communications platform according to an embodiment of the invention may operate. As shown in the illustrated embodiment, a shared memory space <b>104</b> may be accessed by a global set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . containing an arbitrary number of software applications, threads, objects, modules, routines or other executing or executable processes. The shared memory space <b>104</b> may be or include the logical or physical memory space of a microprocessor or other logical or programmable device, or of a collection of clients or other resources, such as a network address space.</p>
<p id="p-0017" num="0016">According to the illustrated embodiment, each process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may have at least one memory block in a set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . uniquely assigned or mapped to it. The set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may also communicate with an administrative memory <b>106</b>. In embodiments, the administrative memory <b>106</b> may reside in a named address block separate from shared memory space <b>104</b> or be otherwise protected to prevent overflows, overwrites or other corruption of the contents of administrative memory <b>106</b>.</p>
<p id="p-0018" num="0017">The architecture as shown may also include a communications engine <b>108</b> communicating with each process <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . and corresponding memory block <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . as well as with administrative memory <b>106</b>. The communications engine <b>108</b> may also in embodiments as illustrated communicate with a network <b>110</b>, which may be or include for instance, a local area network (LAN), wide area network (WAN), metropolitan area network (MAN), the Internet, or other local or remote network resources.</p>
<p id="p-0019" num="0018">Communications engine <b>108</b> may in one regard mediate the exchange of data between any process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . with one or more other processes in the same global set of processes, with other processes or network requests located in or received from network <b>110</b>, or with clients or entities elsewhere. Communications engine <b>108</b> may in embodiments be or include resources separate or independent from any underlying operating system under which the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may run. Communications engine <b>108</b> may coordinate and service interprocess communication requests on a dynamic basis, in conjunction with administrative shared memory <b>106</b>, the shared memory space <b>104</b> and other resources. According to the invention in one regard, the communications engine <b>108</b> may generate the administrative memory <b>106</b> itself upon initiation or at other times.</p>
<p id="p-0020" num="0019">When the administrative shared memory <b>106</b> is operating, communications engine <b>108</b> may configure and instantiate a set of memory management objects <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . in the administrative memory <b>106</b>. The set of memory management objects <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . may execute in the context of communications engine <b>108</b> and/or the context of the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . to manage communications in and via the shared memory space <b>104</b>. Communications engine <b>108</b> and the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may dynamically allocate memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . or partitions of those blocks as needed through the set of memory managers <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . in administrative memory <b>106</b>. In embodiments, a unique memory manager from the set of memory managers <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . may be assigned to each process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . , and/or to each memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . , to reduce the chance of corruption and memory contention in the shared memory space <b>104</b>.</p>
<p id="p-0021" num="0020">When a process within the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . terminates on a planned or unplanned basis, the set of memory managers <b>118</b><i>a</i>, <b>118</b><i>b </i>and the remaining running processes in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may terminate access to and release the memory block or blocks within memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . which had been locked by the terminating process.</p>
<p id="p-0022" num="0021">More specifically, when a given process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . is initiated, in embodiments that process may communicate with administrative memory <b>106</b> in a rendezvous or setup phase. During that phase, the requesting process within the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may request the creation or allocation of a memory block within the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . in the shared memory space <b>104</b>. If the administrative memory space <b>106</b> is locked, full or otherwise unable to provide access, the requesting process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may enter a wait state or otherwise delay the rendezvous process. When a block within shared memory space <b>104</b> becomes available, the requesting process may place a lock on that portion of shared memory space <b>104</b> to install or initiate a new memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . That newly allocated memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . associated with the requesting process may be configured and managed by a unique memory manager in the set of memory managers <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . resident in administrative memory <b>106</b>.</p>
<p id="p-0023" num="0022">Other data <b>116</b> related to the newly-generated shared memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . may also be loaded into administrative memory <b>106</b>, which data may include for instance file handles, variables, address offset or other memory mapping data and other information related to the requesting process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . and its corresponding memory block. When configuration is complete, the requesting process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may communicate with and operate on its corresponding memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . to read and write data, such as variables, arrays, tables or other content.</p>
<p id="p-0024" num="0023">In general, because other data <b>116</b> such as file handles, variables, memory mapping and other data for each process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . is published or available in administrative memory <b>106</b>, processes in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . or others may generate a session to communicate with each other via the shared memory <b>104</b>, mediated by communications engine <b>108</b>.</p>
<p id="p-0025" num="0024">The communications engine <b>108</b> may or may not register its own shared memory block, but may typically request that the set of memory managers <b>118</b><i>a</i>, <b>188</b><i>b </i>. . . in administrative memory <b>106</b> dynamically grow or contract memory blocks within the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . on a global basis depending on the demands and communication activity of active processes in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . Individual processes in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may themselves also dynamically grow or contract the memory blocks within the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . registered to them based on communication needs.</p>
<p id="p-0026" num="0025">Communications engine <b>108</b> may access and duplicate any files, handles, variables, memory mapping or other data from administrative shared memory <b>106</b> to support coherent communications between the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . or other resources. With access to address translation, memory mapping or other data for each process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . , the set of memory managers <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . in administrative memory <b>106</b> may ensure coherency in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . The communications engine <b>108</b> working with the set of memory managers <b>118</b><i>am </i><b>118</b><i>b </i>. . . in administrative memory <b>106</b> may reduce or manage dependencies between data or processes, as well as reduce memory contention or data corruption in the overall shared memory space <b>104</b>.</p>
<p id="p-0027" num="0026">Because individual processes in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . are not required to attempt to synchronize memory activity but instead may rely upon session-based exchanges via communications engine <b>108</b> and the set of memory managers <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . executing in administrative memory <b>106</b>, the coding or testing requirements of those processes may be reduced.</p>
<p id="p-0028" num="0027">The set of memory managers <b>118</b><i>a</i>, <b>118</b><i>b </i>in administrative memory <b>106</b> may provide an interface to the shared memory space <b>104</b> through various mechanisms, which may include for instance presenting APIs or dynamic link library (dll) hooks or other access points to the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . Using those APIs, dlls or other interfaces, each process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may generate a call to initiate a session with another process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . , with a process in network <b>110</b>, or other local or remote processes as mediated through the communications engine <b>108</b>.</p>
<p id="p-0029" num="0028">An example of computer code generating a call to initiate a session is illustrated in <figref idref="DRAWINGS">FIG. 3</figref>. As shown in that figure, a message-based session may be initiated by a process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . or other entity via communications engine <b>108</b>, administrative memory <b>106</b> and other resources. Although specific languages, routines or other code characteristics are illustrated, it will be appreciated that different types of code or instruction may be used.</p>
<p id="p-0030" num="0029">Aspects of overall communications processing according to an embodiment of the invention is illustrated in <figref idref="DRAWINGS">FIG. 4</figref>, including a rendezvous or setup phase. In step <b>402</b>, processing may begin. In step <b>404</b>, the communications engine <b>108</b> or a process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . or other entity may initiate an attempt to access administrative memory <b>106</b>. In step <b>406</b>, a determination may be made whether administrative memory <b>106</b> is locked. If the administrative memory <b>106</b> is locked, processing may proceed to step <b>408</b>, in which the process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . , communications engine <b>108</b> or other entity may enter a wait state, and then return to step <b>404</b>.</p>
<p id="p-0031" num="0030">If the determination in step <b>406</b> is that administrative <b>106</b> is not locked, in step <b>410</b> the process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . , communications engine <b>108</b> or other requesting entity may place a lock on the administrative memory <b>106</b> to register a block or other unit of memory. It may be noted in one regard that in embodiments, the API, dll or other interface into which the requesting process or other entity calls may support or perform some or all tasks described as being executed by that process or entity.</p>
<p id="p-0032" num="0031">In step <b>412</b>, a new or newly registered memory block within the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . may be secured or generated (if not preexisting) by administrative memory <b>106</b> and other resources. In step <b>414</b>, handles to notification events, such as file openings or others, variables and other data related to the newly generated memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . and its associated process may be generated. In step <b>416</b>, handles and other data associated with that process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . and the corresponding memory block may be loaded or stored in administrative shared memory <b>106</b>.</p>
<p id="p-0033" num="0032">In step <b>418</b>, a flag may be set in administrative memory <b>106</b> or elsewhere that the new memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . is registered. In step <b>420</b>, the communications engine <b>108</b> may be signaled that the newly registered process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may be available for interprocess communication.</p>
<p id="p-0034" num="0033">In step <b>422</b>, handles, variables and other data associated with the new memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . may be cached or duplicated by communications engine <b>108</b> or other resources. In step <b>424</b>, a memory manager in the set of memory management objects <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . may be assigned to the newly generated memory block within the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . . In step <b>426</b>, the administrative memory <b>106</b> may be unlocked. In step <b>428</b>, processing may end, repeat, return to a prior point or take other action.</p>
<p id="p-0035" num="0034">Aspects of overall communications processing according to an embodiment of the invention is illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, including process-to-process communications and other actions. In step <b>502</b>, processing may begin. In step <b>504</b>, the communications engine <b>108</b>, a process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . or another entity may request a memory block or sub-block from one of the memory management objects in the set of memory management objects <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . to effectuate a communications channel. In step <b>506</b>, a determination may be made whether one or more memory block or sub-block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . is available. If the determination in step <b>506</b> is that there is no memory block or sub-block available, processing may proceed to step <b>508</b> in which an out of memory error may be returned to communications engine <b>108</b> process or elsewhere. In step <b>510</b>, an error message may likewise be communicated to the initiating process or elsewhere.</p>
<p id="p-0036" num="0035">If the determination in step <b>506</b> is that a memory block or sub-block is available, processing may proceed to step <b>512</b> in which the initiating process, communications engine <b>108</b> or other entity may populate that open block or sub-block with data to be communicated to a destination process. In step <b>514</b>, the initiating process, communications engine <b>108</b> or other entity may generate or populate a location memory block within administrative memory <b>106</b>, which may be or include a memory block recording the relative address of the block or sub-block which has been populated with process data to be transferred.</p>
<p id="p-0037" num="0036">In step <b>516</b>, the communications engine <b>108</b> may signal the destination process that a communications event has been requested. In step <b>518</b>, the communications engine <b>108</b>, destination process or other entity may load the location memory block in administrative memory <b>106</b>. It may be noted in one regard that in embodiments, the API, dll or other interface into which the requesting or destination process or other entity calls may support or perform some or all tasks described as being executed by that process or entity. In embodiments, the API, dll or other interfaces may for example interface with the set of memory management objects <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . in administrative memory <b>106</b> to effectuate various memory and communications tasks.</p>
<p id="p-0038" num="0037">In step <b>520</b>, the logical address of the block or sub-block which has been populated with process source data to be transferred may be mapped to a physical memory address within address space <b>104</b>. In step <b>522</b>, the communications engine <b>108</b>, initiating process or other entity may process the data contained within the block or sub-block populated with source data, for instance to read or copy that data or a portion thereof. In step <b>524</b>, the block or sub-block populated with source data may be released back to the corresponding memory management object within the set of memory management objects <b>118</b><i>a</i>, <b>188</b><i>b </i>. . . . In step <b>526</b>, processing may end, repeat, return to a prior point or take other action.</p>
<p id="p-0039" num="0038">According to embodiments of the invention, communications engine <b>108</b>, set of memory management objects <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . and other resources may assign each memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . to a logical or physical address based on, for example, a structured allocation mechanism, such as a buddy system algorithm or other strict segregated fit or other technique. Buddy system algorithms may for example in embodiments be employed in which a given memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . may receive an assignment of one or both of two adjacent memory segments when a process requests new memory, or at other times. In embodiments a memory request by a process in the set of processes <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . may be rounded up to the next available size, such as 2 kilobytes, 4 kilobytes, or other sized segments or blocks.</p>
<p id="p-0040" num="0039">When a memory block with the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . or a segment thereof is released, the buddy of that block may be efficiently recaptured as well, by computation of the offset or other known relation to its associated buddy block or segment. Conversely, when an executing process terminates and releases a block or blocks, or a portion thereof, of the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . , paired adjacent segments or blocks may be coalesced and returned to an available status within the memory pool managed in the set of memory allocation tables <b>112</b><i>a</i>, <b>112</b><i>b </i>. . . . Other memory management techniques or enhancements, such as look-aside tables or other techniques, may also be used. The distribution of memory to each process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may done on a dynamic basis, so that memory blocks or the overall memory allocation for each process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may grow or shrink over time. Allocation and reallocation of memory in the shared memory space <b>104</b> may be triggered by different criteria or events, such as requests or releases by other processes in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . , data accesses by external clients, memory overflow or error conditions, or other events or factors.</p>
<p id="p-0041" num="0040">According to the interprocess communications architecture of the invention in one regard, an individual process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . may consequently not be able to gain direct access to the memory block of another process, but instead may only access blocks belonging to another process via administrative memory <b>106</b>, the set of memory manages <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . , communications engine <b>108</b> and other resources. Direct access to other memory blocks would introduce a security risk as well as increase the complexity of the communications infrastructure, since direct contention between processes could ensue. A direct access scheme would likewise reduce system stability and reduce performance, since a write lock condition on a memory block could occur and serialization of access would then be required.</p>
<p id="p-0042" num="0041">According to embodiments of the invention, when an individual process in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . desires to initiate communication with another process, that initiating process may create a communications session with that process, for instance by transmitting a message to that destination process. That initiation message may be copied into the memory block of the destination process via communications engine <b>108</b> and other resources. In the instance where both the initiating and destination processes are located on the same client machine or other shared resource, interprocess communications may be executed via memory-to-memory copies, which may be a particularly efficient channel.</p>
<p id="p-0043" num="0042">According to the invention in another regard, overall memory contention may be significantly reduced, since only two processes may contend for memory lock on one of the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . at the same time. More specifically, while a given process may contend with communications engine <b>108</b> for access to its associated memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . at the same time, and while another process may contend with communications engine <b>108</b> for access to that memory block as a destination, in general two processes in the set of processes <b>102</b><i>a</i>, <b>102</b><i>b </i>. . . themselves never contend for access to the same memory block in the set of memory blocks <b>114</b><i>a</i>, <b>114</b><i>b </i>. . . at the same time. Communication efficiency is therefore enhanced.</p>
<p id="p-0044" num="0043">The foregoing description of the invention is illustrative, and modifications in configuration and implementation will occur to persons skilled in the art. For instance, while the invention has generally been described in terms of a single or unitary shared memory space, in embodiments multiple shared memory spaces may be accessed or managed, together or independently. Processes accessing those one or more shared memory spaces may each be local to one client or other machine, distributed across a local area network or other network, or communicate remotely, for instance via the Internet, depending on implementation.</p>
<p id="p-0045" num="0044">Similarly, while the invention has generally been describe in terms of a unitary communications engine <b>108</b> interacting with a set of memory management objects <b>118</b><i>a</i>, <b>118</b><i>b </i>. . . , in embodiments one or more parts of the communications functions may be executed or distributed in different modules, machines or network locations. While generally illustrated as a singular or contiguous memory space, the administrative shared memory space <b>106</b> in which address translation and other data may be stored may likewise be divided or multiple, as long as logical separation from the shared memory space of executing processes is maintained. The shared memory space <b>104</b> in which active processes likewise in embodiments likewise need not be contiguous, or need not be all in the same electronic or other form. Other hardware, software or other resources described as singular may in embodiments be distributed, and similarly in embodiments resources described as distributed may be combined. The scope of the invention is accordingly intended to be limited only by the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A system for managing communication between processes, comprising:
<claim-text>a set of memory blocks, the set of memory blocks being accessible by a plurality of processes, wherein at least one process within the plurality of processes has at least one uniquely assigned memory block in the set of memory blocks; and</claim-text>
<claim-text>a communications engine, the communications engine communicating with the set of memory blocks, the communications engine directing a data access request from the at least one process to the corresponding uniquely assigned memory block based on memory management data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising an administrative memory, the administrative memory being separate from the shared memory space.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The system according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the memory management data is stored at least in the administrative memory.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The system according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the memory management data comprises a plurality of memory management objects associated with the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The system according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein each memory management object is uniquely associated with one of the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The system according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the plurality of memory management objects are instantiated by the communications engine.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the set of memory blocks comprises a first memory address space.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The system according to <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the administrative memory comprises a second memory address space.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the each of the processes register at least one uniquely assigned memory block in the set of memory blocks in the administrative memory.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the data access request comprises a modification to the data in the uniquely assigned memory block.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the data access request returns data from the uniquely assigned memory block.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system according to <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the communications engine accesses at least one of the data access request and the returned data.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communications engine comprises a cache module, the cache module maintaining a cache of data exchanged between the set of memory blocks.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communications engine assigns at least one memory block to each process based on a buddy system allocation.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communications engine terminates a connection to the set of memory blocks after completion of the data access request.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one memory block is dynamically assigned to each process.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each process further comprises a process interface to an application programming interface.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communications engine further comprises an interface to an application programming interface.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the corresponding uniquely assigned memory block in the set of memory blocks is accessible only by at least one of the communications engine and the at least one process.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a process of communication between two processes comprises copying data in one memory block to another memory block.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a process of communication between two processes comprises transmitting data from one memory block to a remote destination process.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The system according to <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the transmitted data is transmitted via an external network to the destination process.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communications engine is separate from an operating system supporting the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. A system for managing communication between processes, comprising:
<claim-text>one or more memory blocks, the one or more memory blocks being accessible by a plurality of processes each having at least one uniquely assigned memory block in the one or more memory blocks; and</claim-text>
<claim-text>a communications engine, the communications engine communicating with the one or more memory blocks to direct a data access request from at least one of the plurality of processes to the at least one corresponding uniquely assigned memory block based on memory management data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The system according to <claim-ref idref="CLM-00024">claim 24</claim-ref>, further comprising administrative memory, the administrative memory being separate from a shared memory space.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The system according to <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the memory management data is stored at least in the administrative memory.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The system according to <claim-ref idref="CLM-00024">claim 24</claim-ref>, further comprising an application programming interface, the application programming interface being callable by at least one of a process of the plurality of processes and the communications engine to perform defined tasks.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The system according to <claim-ref idref="CLM-00024">claim 24</claim-ref>, wherein the communications engine is separate from an operating system supporting the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. A computer readable medium with instructions stored thereon for executing a method for managing communication between processes, the method comprising:
<claim-text>uniquely assigning at least one memory block from a set of memory blocks to at least one process of a plurality of processes; and</claim-text>
<claim-text>directing a data access request from the at least one process to the corresponding uniquely assigned memory block based on memory management data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the memory management data comprises a plurality of memory management objects associated with the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the set of memory blocks comprises a first memory address space.</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein a communications engine is separate from an operating system supporting the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00033" num="00033">
<claim-text>33. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the method further comprises a step of storing the memory management data in at least an administrative memory, the administrative memory being separate from a shared memory space.</claim-text>
</claim>
<claim id="CLM-00034" num="00034">
<claim-text>34. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the step of uniquely assigning at least one memory block to the at least one process comprises a step of dynamically and uniquely assigning at least one memory to each of the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00035" num="00035">
<claim-text>35. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the method further comprises a step of presenting an application programming interface to at least one of a process of the plurality of processes and a communications engine.</claim-text>
</claim>
<claim id="CLM-00036" num="00036">
<claim-text>36. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the at least one memory block is accessible only by at least one of a communications engine and the at least one process.</claim-text>
</claim>
<claim id="CLM-00037" num="00037">
<claim-text>37. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the method further comprises a step of copying data in one memory block to another memory block.</claim-text>
</claim>
<claim id="CLM-00038" num="00038">
<claim-text>38. The computer readable medium according to <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the method further comprises a step of transmitting data from one memory block to a remote destination process.</claim-text>
</claim>
<claim id="CLM-00039" num="00039">
<claim-text>39. A computer-executable process with stored instructions on a computer readable medium, the computer-executable process being configured to communicate with other processes according to a method of:
<claim-text>registering a request to receive an assignment of at least one memory block from a set of memory blocks in a shared memory space shared by a plurality of processes;</claim-text>
<claim-text>receiving at least one uniquely assigned memory block in the shared memory space; and</claim-text>
<claim-text>processing a data access request for data to or from at least one of the plurality of processes via a communications engine, the communications engine directing the data access request to a corresponding uniquely assigned memory block based on memory management data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00040" num="00040">
<claim-text>40. The computer-executable process according to <claim-ref idref="CLM-00039">claim 39</claim-ref>, wherein the method further comprises a step of storing the memory management data in at least an administrative memory, the administrative memory being separate from the shared memory space.</claim-text>
</claim>
<claim id="CLM-00041" num="00041">
<claim-text>41. The computer-executable process according to <claim-ref idref="CLM-00039">claim 39</claim-ref>, wherein the method further comprises a step of instantiating a plurality of memory management objects associated with the plurality of processes.</claim-text>
</claim>
<claim id="CLM-00042" num="00042">
<claim-text>42. The computer-executable process according to <claim-ref idref="CLM-00039">claim 39</claim-ref>, wherein the method further comprises a step of copying data in one memory block to another memory block.</claim-text>
</claim>
</claims>
</us-patent-grant>
