<us-patent-grant lang="EN" dtd-version="v4.2 2006-08-23" file="US07299317-20071120.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20071106" date-publ="20071120">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>07299317</doc-number>
<kind>B1</kind>
<date>20071120</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10165572</doc-number>
<date>20020608</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1277</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>28</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20071120</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711108</main-classification>
<further-classification>365 49</further-classification>
</classification-national>
<invention-title id="d0e53">Assigning prefixes to associative memory classes based on a value of a last bit of each prefix and their use including but not limited to locating a prefix and for maintaining a Patricia tree data structure</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5088032</doc-number>
<kind>A</kind>
<name>Bosack</name>
<date>19920200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5319763</doc-number>
<kind>A</kind>
<name>Ho et al.</name>
<date>19940600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5481540</doc-number>
<kind>A</kind>
<name>Huang</name>
<date>19960100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5515370</doc-number>
<kind>A</kind>
<name>Rau</name>
<date>19960500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5528701</doc-number>
<kind>A</kind>
<name>Aref</name>
<date>19960600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5651099</doc-number>
<kind>A</kind>
<name>Konsella</name>
<date>19970700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>5721899</doc-number>
<kind>A</kind>
<name>Namba</name>
<date>19980200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>5740171</doc-number>
<kind>A</kind>
<name>Mazzola et al.</name>
<date>19980400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>5781772</doc-number>
<kind>A</kind>
<name>Wilkinson, III et al.</name>
<date>19980700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>5809501</doc-number>
<kind>A</kind>
<name>Noven</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>5829004</doc-number>
<kind>A</kind>
<name>Au</name>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>5842040</doc-number>
<kind>A</kind>
<name>Hughes et al.</name>
<date>19981100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>5848416</doc-number>
<kind>A</kind>
<name>Tikkanen</name>
<date>19981200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>5884297</doc-number>
<kind>A</kind>
<name>Noven</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>5898689</doc-number>
<kind>A</kind>
<name>Kumar et al.</name>
<date>19990400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>5920886</doc-number>
<kind>A</kind>
<name>Feldmeier</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>5930359</doc-number>
<kind>A</kind>
<name>Kempke et al.</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>6000008</doc-number>
<kind>A</kind>
<name>Simcoe</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>6018524</doc-number>
<kind>A</kind>
<name>Turner et al.</name>
<date>20000100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>6061368</doc-number>
<kind>A</kind>
<name>Hitzelberger</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>6067574</doc-number>
<kind>A</kind>
<name>Tzeng</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>6091725</doc-number>
<kind>A</kind>
<name>Cheriton et al.</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>6097724</doc-number>
<kind>A</kind>
<name>Kartalopoulos</name>
<date>20000800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>6115716</doc-number>
<kind>A</kind>
<name>Tikkanen et al.</name>
<date>20000900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>6141738</doc-number>
<kind>A</kind>
<name>Munter et al.</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>6148364</doc-number>
<kind>A</kind>
<name>Srinivasan et al.</name>
<date>20001100</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>6219748</doc-number>
<kind>B1</kind>
<name>Srinivasan et al.</name>
<date>20010400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>6236658</doc-number>
<kind>B1</kind>
<name>Essbaum et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>6237061</doc-number>
<kind>B1</kind>
<name>Srinivasan et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>6240485</doc-number>
<kind>B1</kind>
<name>Srinivasan et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>6243667</doc-number>
<kind>B1</kind>
<name>Kerr et al.</name>
<date>20010600</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>6285378</doc-number>
<kind>B1</kind>
<name>Duluk, Jr.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>6289414</doc-number>
<kind>B1</kind>
<name>Feldmeier et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>6295576</doc-number>
<kind>B1</kind>
<name>Ogura et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>6298339</doc-number>
<kind>B1</kind>
<name>Bjornson</name>
<date>20011000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00036">
<document-id>
<country>US</country>
<doc-number>6308219</doc-number>
<kind>B1</kind>
<name>Hughes</name>
<date>20011000</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00037">
<document-id>
<country>US</country>
<doc-number>6377577</doc-number>
<kind>B1</kind>
<name>Bechtolsheim et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00038">
<document-id>
<country>US</country>
<doc-number>6430190</doc-number>
<kind>B1</kind>
<name>Essbaum et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00039">
<document-id>
<country>US</country>
<doc-number>6434662</doc-number>
<kind>B1</kind>
<name>Greene et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by other</category>
</citation>
<citation>
<patcit num="00040">
<document-id>
<country>US</country>
<doc-number>6804744</doc-number>
<kind>B1</kind>
<name>Abbas</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711108</main-classification></classification-national>
</citation>
<citation>
<nplcit num="00041">
<othercit>Donald R. Morrison, “PATRICIA—Practical Algorithm to Retrieve Information Coded in Alphanumeric,” Journal of the ACM, vol. 15, No. 4, Oct. 1968, pp. 514-534.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00042">
<othercit>Waldvogel et al., “Scalable High Speed IP Routing Lookups,” Proc. SIGCOMM '97, ACM, 1997, pp. 25-36.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00043">
<othercit>Lampson et al., “IP Lookups Using Multiway and Multicolumn Search,” Proc. Infocom 98, Mar. 1998, 24 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00044">
<othercit>V. Srinivasan and George Varghese, “Faster IP Lookups using Controlled Prefix Expansion,” ACM SIGMETRICS Performance Evaluation Review, vol. 26 No. 1, Jun. 1998, p. 1-10.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00045">
<othercit>Stefan Nilsson and Gunnar Karlsson, “Fast Address Look-up for Internet Routers,” Proceedings of IEEE Broadband Communications, Apr. 1998, 12 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00046">
<othercit>William N. Eatherton, Hardware-Based Internet Protocol Prefix Lookups, Master's thesis, Sever Institute, Washington University, St. Louis, MO, May 1999, 109 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00047">
<othercit>Lampson et al., “IP Lookups Using Multiway and Multicolumn Search,” IEEE Transactions on Networking, vol. 7, No. 3, Jun. 1999, pp. 324-334.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00048">
<othercit>Lockwood et al., “Field Programmable Port Extender (FPX) for Distributed Routing and Queuing,” Proceedings of the ACM/SIGDA international symposium on Field programmable gate arrays, Feb. 2000, pp. 137-144.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00049">
<othercit>Ruiz-Sanchez et al., “Survey and Taxonomy of IP Address Lookup Algorithms,” IEEE Network Magazine, vol. 15, No. 2, Mar./Apr. 2001, pp. 8-23.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00050">
<othercit>Pankaj Gupta and Nick McKewon, “Algorithms for Packet Classification,” IEEE Network Magazine, vol. 15, No. 2, Mar./Apr. 2001, pp. 24-32.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00051">
<othercit>Iyer et al., “ClassiPI: An Architecture for Fast and Flexible Packet Classification,” IEEE Network Magazine, vol. 15, No. 2, Mar./Apr. 2001, pp. 33-41.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00052">
<othercit>Waldvogel et al., “Scalable High Speed Prefix Matching,” ACM Transactions on Computer Systems, vol. 19, No. 4, Nov. 2001, pp. 440-482.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00053">
<othercit>Devavrat Shah and Pankaj Gupta, “Fast Incremental Updates on Ternary-CAMs for Routing Lookups and Packet Classification,” Proc. Hot Interconnects VIII, Aug. 2000, Stanford. IEEE Micro, vol. 21, No. 1, Jan./Feb. 2001, 9 pages.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00054">
<othercit>Waldvogel et al., “Scalable Best Matching Prefix Lookups,” PODC 98, ACM 1998.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00055">
<othercit>Radia Perlman, Interconnections: Bridges, Routers, Switches, and Internetworking Protocols, Second Edition, Addison-Wesley, 2000, pp. 347-365.</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00056">
<othercit>Pankaj Gupta and Nick McKeown, “Algorithms for Packet Classification,” IEEE Network Special Issue, Mar./Apr. 2001, vol. 15, No. 2, pp. 24-32 (reprint 29 pages).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00057">
<othercit>Srinivasan et al., “Packet Classification Using Tuple Space Search,” ACM Computer Communication Review, 1999. ACM SIGCOMM'99, Sep. 1999 (12 pages).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00058">
<othercit>Srinivasan et al., “Fast and Scalable Layer Four Switching,” ACM Computer Communication Review, 28(4):191-202, 1998. ACM SIGCOMM'98, Sep. 1998 (12 pages).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
<citation>
<nplcit num="00059">
<othercit>Stefan Nilsson and Gunnar Karlsson, “IP-Address Lookup Using LC-Tries,” IEEE Journal on Selected Areas in Communications, Jun. 1999 (12 pages).</othercit>
</nplcit>
<category>cited by other</category>
</citation>
</references-cited>
<number-of-claims>39</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711108</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>13</number-of-figures>
</figures>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Panigrahy</last-name>
<first-name>Rina</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
<applicant sequence="002" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Sharma</last-name>
<first-name>Samar</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>The Law Office Of Kirk D. Williams</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>Cisco Technology, Inc.</orgname>
<role>02</role>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kim</last-name>
<first-name>Matthew</first-name>
<department>2186</department>
</primary-examiner>
<assistant-examiner>
<last-name>Dudek</last-name>
<first-name>Edward J</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Methods and apparatus are disclosed for maintaining and using entries in one or more associative memories. A last bit of a prefix is checked, and based on this result, the entry is placed into one of two classes of associative memory entries. The entry can then be identified within the associative memory by performing a lookup operation using the prefix padded with ones if the last bit of the prefix is zero or with zeros if the last bit is one to fill out the remaining bits of the lookup word. Entries of different classes of entries are typically either stored in different associative memories, or in the same associative memory with each of these entries including a class specific identifier. Among other applications, these entries can be used to locate a prefix and to store a tree data structure in the one or more associative memories.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="176.87mm" wi="128.69mm" file="US07299317-20071120-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="222.33mm" wi="154.26mm" file="US07299317-20071120-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="178.05mm" wi="130.05mm" file="US07299317-20071120-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="77.30mm" wi="144.02mm" file="US07299317-20071120-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="150.54mm" wi="131.83mm" file="US07299317-20071120-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="164.17mm" wi="142.49mm" file="US07299317-20071120-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="98.47mm" wi="144.36mm" file="US07299317-20071120-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="233.26mm" wi="166.20mm" orientation="landscape" file="US07299317-20071120-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="201.68mm" wi="166.45mm" orientation="landscape" file="US07299317-20071120-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="129.03mm" wi="84.33mm" file="US07299317-20071120-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="143.43mm" wi="91.10mm" file="US07299317-20071120-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="219.20mm" wi="183.05mm" file="US07299317-20071120-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="201.25mm" wi="155.53mm" file="US07299317-20071120-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">This invention especially relates to computer and communications systems, especially network routers and switches; and more particularly, the invention relates to assigning prefixes to associative memory classes based on a value of a last bit of each prefix, and their use, including, but not limited to locating a prefix and for maintaining a Patricia tree data structure.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">The communications industry is rapidly changing to adjust to emerging technologies and ever increasing customer demand. This customer demand for new applications and increased performance of existing applications is driving communications network and system providers to employ networks and systems having greater speed and capacity (e.g., greater bandwidth). In trying to achieve these goals, a common approach taken by many communications providers is to use packet switching technology. Increasingly, public and private communications networks are being built and expanded using various packet technologies, such as Internet Protocol (IP).</p>
<p id="p-0004" num="0003">A network device, such as a switch or router, typically receives, processes, and forwards or discards a packet based on one or more criteria, including the type of protocol used by the packet, addresses of the packet (e.g., source, destination, group), and type or quality of service requested. Additionally, one or more security operations are typically performed on each packet. But before these operations can be performed, a packet classification operation must typically be performed on the packet.</p>
<p id="p-0005" num="0004">Packet classification as required for, inter alia, access control lists (ACLs) and forwarding decisions, is a demanding part of switch and router design. The packet classification of a received packet is increasingly becoming more difficult due to ever increasing packet rates and number of packet classifications. For example, ACLs require matching packets on a subset of fields of the packet flow label, with the semantics of a sequential search through the ACL rules. IP forwarding requires a longest prefix match.</p>
<p id="p-0006" num="0005">Known approaches of packet classification include using custom application-specific integrated circuits (ASICs), custom circuitry, software or firmware controlled processors, binary and ternary content-addressable memories (CAMs). The use of programmable software or firmware have advantages as they provide some level of flexibility, which becomes especially important as new protocols and services are added to existing network. Customers typically desire to use their existing hardware (e.g., routers, switches etc.) to support these new protocols and services. However, known software and firmware implementations are relatively slow, and typically place a performance bound which may be incompatible with new requirements.</p>
<p id="p-0007" num="0006">A ternary CAM (TCAM) is a special type of fully associative memory which stores data with three logic values: ‘0’, ‘1’ or ‘*’ (don't care). Each TCAM entry includes a value and a mask. These entries are stored in the TCAM in decreasing order of priority, such as in a decreasing order of the length of prefixes. For a given input, the TCAM compares it against all of the entries in parallel, and returns the entry with the highest priority that matches the input lookup word. An entry matches the input lookup word if the input and the entry value are identical in the bits that are not masked out.</p>
<p id="p-0008" num="0007">When performing prefix inserts, deletes, and route updates, the exact location of the prefix in the TCAM must be known as the location cannot be determined by simply looking up the prefix in the TCAM, because the TCAM in this application is configured to produce a longest prefix match, so there is no guarantee that a lookup operation will produce the desired entry. For example, if a TCAM contains the three entries of “10101011”, “10101010”, and “1010101*” and the entry “1010101*” is to be deleted, a lookup operation will match either “10101011” or “10101010” rather than produce the location of the desired “1010101*” entry. Thus, a Patricia tree (or another variation of the tree/trie data structure) for prefix updates is stored in memory of the programming mechanism.</p>
<p id="p-0009" num="0008">Thus, in current implementations, the central processor managing these entries typically maintains a Patricia tree (or trie or some variation thereof) in a memory separate from the TCAM or other associative memory. When a prefix entry is inserted to the TCAM, a pointer is created in the Patricia tree node that points to the TCAM location of the prefix. While deleting a prefix, the Patricia tree is traversed to locate the prefix and find its location in the TCAM. This scheme requires up to L operations and a trie data structure needs to be maintained; where L=maximum prefix length (e.g., L=128 for IPv6). Moreover, it may be expensive to realize this in hardware. For example, in some switches, this scheme requires all TCAMs in the system to have identical prefix entries in each location. Otherwise, for each TCAM, the central processor maintains a pointer to the location of a prefix in that TCAM. In the first case, if there are several line cards with different size TCAMs (say, 64K, 128K, 256K and 512K), then they are all limited to contain only 64K prefix entries. In the second case, in order to delete a route table entry from the system, the central processor sends a message specifically for each TCAM. Alternatively, a trie data structure needs to be maintained with each TCAM.</p>
<p id="p-0010" num="0009">For the reasons presented herein and/or other reasons, new methods and apparatus are needed for using and updating associative memory entries.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0011" num="0010">Methods and apparatus are disclosed for maintaining and using entries in one or more associative memories, such as, but not limited to ternary content-addressable memories (TCAMs). In one embodiment, a last bit of a prefix to be stored in an associative memory entry is checked, and based on this result, the entry is placed into one of two classes of associative memory entries. The entry (e.g., a particular prefix) can then be located within the associative memory by performing a lookup operation using the prefix padded with ones if the last bit of the prefix is zero or with zeros if the last bit is one to fill out the remaining bits of the lookup word. In one embodiment, the entries of different classes of entries are stored in different associative memories. In one embodiment, the entries of different classes of entries are stored in the same associative memory, with each of these entries including a class specific identifier. In one embodiment, these entries are stored in an order to produce a longest prefix match. In one embodiment, these entries correspond to edges of a tree or trie data structure, with children of a edge stored in a corresponding entry in an adjunct memory.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011">The appended claims set forth the features of the invention with particularity. The invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of one embodiment maintaining and using classes of entries in one or more associative memories;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of one embodiment maintaining and using classes of entries in an associative memory;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3A</figref> is a block diagram of associative memory entries used in one embodiment;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 3B</figref> is a block diagram of associative memory entries used in one embodiment;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIGS. 3C-E</figref> are flow diagrams used in one embodiment for maintaining and using classes of associative memory entries;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4A</figref> is a block diagram of an exemplary Patricia tree illustrating prefixes and child nodes;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4B</figref> is a block diagram of data structures used in two different embodiments of an unlimited number of embodiments; and</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. 4C-F</figref> are flow diagrams used in one embodiment for maintaining and using classes of associative memory entries to store a tree data structure.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0021" num="0020">Systems and methods are disclosed for assigning prefixes to associative memory classes based on a value of a last bit of each prefix, and their use, including, but not limited to locating a prefix and for maintaining a tree data structure. Embodiments described herein include various elements and limitations, with no one element or limitation contemplated as being a critical element or limitation. Each of the claims individually recites an aspect of the invention in its entirety. Moreover, some embodiments described may include, but are not limited to, inter alia, systems, networks, integrated circuit chips, embedded processors, ASICs, methods, and computer-readable medium containing instructions. The embodiments described hereinafter embody various aspects and configurations within the scope and spirit of the invention, with the figures illustrating exemplary and non-limiting configurations.</p>
<p id="p-0022" num="0021">As used herein, the term “packet” refers to packets of all types or any other units of information or data, including, but not limited to, fixed length cells and variable length packets, each of which may or may not be divisible into smaller packets or cells. The term “packet” as used herein also refers to both the packet itself or a packet indication, such as, but not limited to all or part of a packet or packet header, a data structure value, pointer or index, or any other part or identification of a packet. Moreover, these packets may contain one or more types of information, including, but not limited to, voice, data, video, and audio information. The term “item” is used herein to refer to a packet or any other unit or piece of information or data. The phrases “processing a packet” and “packet processing” typically refer to performing some steps or actions based on the packet, and which may or may not include modifying and/or forwarding the packet.</p>
<p id="p-0023" num="0022">The term “system” is used generically herein to describe any number of components, elements, sub-systems, devices, packet switch elements, packet switches, routers, networks, computer and/or communication devices or mechanisms, or combinations of components thereof. The term “computer” is used generically herein to describe any number of computers, including, but not limited to personal computers, embedded processing elements and systems, control logic, ASICs, chips, workstations, mainframes, etc. The term “processing element” is used generically herein to describe any type of processing mechanism or device, such as a processor, ASIC, field programmable gate array, computer, etc. The term “device” is used generically herein to describe any type of mechanism, including a computer or system or component thereof. The terms “task” and “process” are used generically herein to describe any type of running program, including, but not limited to a computer process, task, thread, executing application, operating system, user process, device driver, native code, machine or other language, etc., and can be interactive and/or non-interactive, executing locally and/or remotely, executing in foreground and/or background, executing in the user and/or operating system address spaces, a routine of a library and/or standalone application, and is not limited to any particular memory partitioning technique. The steps, connections, and processing of signals and information illustrated in the figures, including, but not limited to any block and flow diagrams and message sequence charts, may be performed in the same or in a different serial or parallel ordering and/or by different components and/or processes, threads, etc., and/or over different connections and be combined with other functions in other embodiments in keeping within the scope and spirit of the invention.</p>
<p id="p-0024" num="0023">Moreover, the terms “network” and “communications mechanism” are used generically herein to describe one or more networks, communications mediums or communications systems, including, but not limited to the Internet, private or public telephone, cellular, wireless, satellite, cable, local area, metropolitan area and/or wide area networks, a cable, electrical connection, bus, etc., and internal communications mechanisms such as message passing, interprocess communications, shared memory, etc.</p>
<p id="p-0025" num="0024">The term “storage mechanism” includes any type of memory, storage device or other mechanism for maintaining instructions or data in any format. “Computer-readable medium” is an extensible term including any memory, storage device, storage mechanism, and other storage and signaling mechanisms including interfaces and devices such as network interface cards and buffers therein, as well as any communications devices and signals received and transmitted, and other current and evolving technologies that a computerized system can interpret, receive, and/or transmit. The term “memory” includes any random access memory (RAM), read only memory (ROM), flash memory, integrated circuits, and/or other memory components or elements. The term “storage device” includes any solid state storage media, disk drives, diskettes, networked services, tape drives, and other storage devices. Memories and storage devices may store computer-executable instructions to be executed a processing element and/or control logic, and data which is manipulated a processing element and/or control logic. The term “data structure” is an extensible term referring to any data element, variable, data structure, data base, and/or one or more or an organizational schemes that can be applied to data to facilitate interpreting the data or performing operations on it, such as, but not limited to memory locations or devices, sets, queues, trees, heaps, lists, linked lists, arrays, tables, pointers, etc. A data structure is typically maintained in a storage mechanism. The terms “pointer” and “link” are used generically herein to identify some mechanism for referencing or identifying another element, component, or other entity, and these may include, but are not limited to a reference to a memory or other storage mechanism or location therein, an index in a data structure, a value, etc. The term “associative memory” refers to all types of known or future developed associative memories, including, but not limited to binary and ternary content-addressable memories, hash tables, TRIE and other data structures, etc.</p>
<p id="p-0026" num="0025">The term “one embodiment” is used herein to reference a particular embodiment, wherein each reference to “one embodiment” may refer to a different embodiment, and the use of the term repeatedly herein in describing associated features, elements and/or limitations does not establish a cumulative set of associated features, elements and/or limitations that each and every embodiment must include, although an embodiment typically may include all these features, elements and/or limitations. In addition, the phrase “means for xxx” typically includes computer-readable medium containing computer-executable instructions for performing xxx.</p>
<p id="p-0027" num="0026">In addition, the terms “first,” “second,” etc. are typically used herein to denote different units (e.g., a first element, a second element). The use of these terms herein does not necessarily connote an ordering such as one unit or event occurring or coming before the another, but rather provides a mechanism to distinguish between particular units. Moreover, the phrases “based on x” and “in response to x” are used to indicate a minimum set of items x from which something is derived or caused, wherein “x” is extensible and does not necessarily describe a complete list of items on which the operation is performed, etc. Additionally, the phrase “coupled to” is used to indicate some level of direct or indirect connection between two elements or devices, with the coupling device or devices modify or not modifying the coupled signal or communicated information. The term “subset” is used to indicate a group of all or less than all of the elements of a set. Moreover, the term “or” is used herein to identify an alternative selection of one or more, including all, of the conjunctive items.</p>
<p id="p-0028" num="0027">Methods and apparatus are disclosed for maintaining and using entries in one or more associative memories. In one embodiment, a last bit of a prefix is checked, and based on this result, the entry is placed into one of two classes of associative memory entries. The entry can then be identified within the associative memory by performing a lookup operation using the prefix padded with ones if the last bit of the prefix is zero or with zeros if the last bit is one to fill out the remaining bits of the lookup word. Entries of different classes of entries are typically either stored in different associative memories, or in the same associative memory with each of these entries including a class specific identifier. In one embodiment, among other applications, these entries can be used to locate a prefix and to store a tree data structure in the one or more associative memories.</p>
<p id="p-0029" num="0028">Methods and apparatus are also disclosed for assigning prefixes to associative memory classes based on a value of a last bit of each prefix. In one embodiment, this allows prefix inserts and deletes to be performed without maintaining a Patricia tree or other data structure in a memory associated with a programming mechanism, as an entry can be readily identified using a single prefix lookup operation.</p>
<p id="p-0030" num="0029">One embodiment operates as follows. Let lsb(P) denote the least significant or last bit of prefix P, and length(P) denote the number of bits in a prefix that are not masked out. Prefixes are maintained in two associative memory classes: C<b>0</b> and C<b>1</b>. Prefixes ending in zero are stored in class C<b>0</b> and prefixes ending in one are stored in class C<b>1</b>. In this manner, each entry within a class is guaranteed to be unique, as well as its location uniquely identifiable based on a single lookup operation. For example, assume P is the prefix that needs to be looked up during an insert, delete or route update operation. If the lsb(P) is zero, then lookup P<b>1</b> . . . <b>1</b> in class C<b>0</b>. If the lsb(P) is one, then lookup P<b>0</b> . . . <b>0</b> in class C<b>1</b>. The result gives the location of P in the associative memory. In one embodiment, each class of entries is stored in a different associative memory. In one embodiment, multiple classes of entries are stored in the same associative memory, with each entry including a class specific identification vector (also referred to herein as a class identifier). In one embodiment, an associative memory lookup operation is performed on each entry class in determining a longest prefix match. In one embodiment, a copy of each of the entries in both classes is stored in an additional associative memory, or in a single associative memory and identified with a different class identifier. A longest prefix match can then be performed with a single lookup operation on this additional associative memory or using the different class identifier.</p>
<p id="p-0031" num="0030">One embodiment maintains a tree or trie data structure, such as, but not limited to a Patricia tree data structure in one or more associative memories and one or more adjunct memories. In one embodiment, each internal node in a Patricia tree is represented by a prefix obtained by walking from root to that node. For each internal node (prefix P) of Patricia tree, two prefix entries are stored in the associative memory: P<b>0</b>* in class C<b>0</b> and P<b>1</b>* in class C<b>1</b>. In one embodiment, these entries correspond to edges of the Patricia tree. The left edges are typically stored in class C<b>0</b> and the right edges in C<b>1</b> (of course this nomenclature could be reversed.) For example, in one embodiment, the entry P<b>0</b>* represents the left edge emanating from node P and P<b>1</b>* represents the right edge. The corresponding child for each node is maintained in a corresponding adjunct memory location. For example, the left child of P is stored in a memory location corresponding to P<b>0</b>*, and the right child of P is stored in a memory location corresponding to P<b>1</b>*. In one embodiment, these children are also prefixes because they represent Patricia tree nodes. In one embodiment an internal node of the Patricia or other tree could also be an inserted data element, such as if the Patricia tree is viewed as being used as a database of prefixes then a certain prefix maybe both a data element as well as an internal node. In one embodiment, to differentiate between these nodes, a data element flag is maintained in memory corresponding to each entry to indicate whether its child is a data or non-data element. Note, an internal node could also be a data element, and it is also possible that the internal node has only one child.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 1</figref> illustrates one embodiment of a system, which may be part of a router or other communications or computer system, for assigning prefixes to associative memory classes based on a value of a last bit of each prefix, and their use, including, but not limited to locating a prefix and for maintaining a tree data structure. In one embodiment, control logic <b>110</b> programs, updates and performs lookup operations on associative memory or memories <b>120</b> with classes of associative memory entries by providing updates and lookup words <b>115</b>. In one embodiment, control logic <b>110</b> includes custom circuitry, such as, but not limited to discrete circuitry, ASICs, memory devices, processors, etc. Control logic <b>110</b> also stores results (e.g., nodes, routing information, etc.) via updates <b>133</b> in memory or memories <b>130</b>. A hit result <b>125</b> is typically provided to control logic <b>110</b> and to memory or memories <b>130</b>, which produces result <b>135</b>.</p>
<p id="p-0033" num="0032">In one embodiment, packets <b>101</b> are received by packet processor <b>105</b>. In addition to other operations (e.g., packet routing, security, etc.), packet processor <b>105</b> typically generates one or more items, including, but not limited to one or more netflow identifiers (typically referred to herein as “netflows”) based on one or more fields of one or more of the received packets <b>101</b> and possibly from information stored in data structures or acquired from other sources. Packet processor <b>105</b> typically generates a lookup value <b>103</b> which is provided to control logic <b>110</b> for deriving a lookup word <b>115</b> and performing one or more associative memory lookup operations on associative memory or memories <b>120</b>. A result <b>107</b> (e.g., a next routing hop) is typically returned to packet processor <b>105</b>, and in response, one or more of the received packets are manipulated and forwarded as indicated by packets <b>109</b>.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 2</figref> illustrates a system used in one embodiment for assigning prefixes to associative memory classes based on a value of a last bit of each prefix, and their use, including, but not limited to locating a prefix and for maintaining a tree data structure. In one embodiment, system <b>200</b> includes a processing element <b>201</b>, memory <b>202</b>, storage devices <b>203</b>, and associative memory or memories <b>204</b>, which are coupled via one or more communications mechanisms <b>209</b> (shown as a bus for illustrative purposes).</p>
<p id="p-0035" num="0034">Various embodiments of system <b>200</b> may include more or less elements. The operation of system <b>200</b> is typically controlled by processing element <b>201</b> using memory <b>202</b> and storage devices <b>203</b> to perform one or more tasks or processes, such as programming or performing a lookup operation on associative memory or memories <b>204</b>. Memory <b>202</b> is one type of computer-readable medium, and typically comprises random access memory (RAM), read only memory (ROM), flash memory, integrated circuits, and/or other memory components. Memory <b>202</b> typically stores computer-executable instructions to be executed by processing element <b>201</b> and/or data which is manipulated by processing element <b>201</b> for implementing functionality in accordance with one embodiment of the invention. Storage devices <b>203</b> are another type of computer-readable medium, and typically comprise solid state storage media, disk drives, diskettes, networked services, tape drives, and other storage devices. Storage devices <b>203</b> typically store computer-executable instructions to be executed by processing element <b>201</b> and/or data which is manipulated by processing element <b>201</b> for implementing functionality in accordance with one embodiment of the invention.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 3A</figref> illustrates a configuration of associative memory entries used in one embodiment. TCAM <b>320</b> includes class zero associative memory entries and TCAM <b>322</b> includes class one associative memory entries. Adjunct SRAM memories <b>321</b> and <b>323</b> typically are used to store lookup results (e.g., forwarding information, a children nodes, etc.) In one embodiment, an additional TCAM <b>324</b> is used to store associative memory entries of both classes, and in this case, SRAMs <b>321</b> and <b>323</b> typically include a pointer or identifier for each entry for the corresponding associative memory entry in TCAM <b>324</b>. SRAM memory <b>325</b> typically is used to store lookup results corresponding to associative memory entries in TCAM <b>324</b>.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 3B</figref> illustrates a TCAM <b>330</b> used in one embodiment to store both class zero and class one associative memory entries <b>335</b>, with each the respective class of each of these entries being identified by a class identification portion <b>331</b>A with its TCAM entry portion <b>331</b>B of the stored entry <b>331</b>.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 3C</figref> illustrates a process used in one embodiment to insert a prefix P in one or more associative memories according to its determined associative memory class. Processing begins with process block <b>340</b>, and proceeds to process block <b>342</b>. If the entry is already inserted, then processing is complete as indicated by process block <b>344</b>. Otherwise, as determined in process block <b>346</b>, if the last bit of the prefix P is zero, then in process block <b>348</b>, prefix P is inserted into the class zero associative memory entries, either in a separate associative memory or one using class identifiers, and optionally in an associative memory having both classes of entries. Otherwise, in process block <b>350</b>, prefix P is inserted into the class one associative memory entries, either in a separate associative memory or one using class identifiers, and optionally in an associative memory having both classes of entries. Typically, these entries are stored in the associative memory used to produce a longest prefix match in an order based on the length of the prefix. Next, in process block <b>352</b>, the corresponding result is stored in the appropriate adjunct memory, which optionally includes a pointer to a location of the corresponding entry in an associative memory having both classes of entries. Processing is complete as indicated by process block <b>354</b>.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 3D</figref> illustrates a process used in one embodiment to perform a lookup operation. Processing begins with process block <b>360</b>, and proceeds to process block <b>362</b> wherein a lookup value V is received. If the last bit of V is zero as determined in process block <b>364</b>, then, in process block <b>366</b>, a lookup word is built using an optional class zero identifier with prefix V padded with ones in the remaining bits of lookup word. Otherwise, in process block <b>368</b>, a lookup word is built using an optional class one identifier with prefix V padded with ones in the remaining bits of lookup word. Next, in process block <b>370</b>, the lookup operation is initiated; and in process block <b>372</b> the result is returned, such as that produced directly from the associative memory or a memory read operation of an adjunct memory. Processing is complete as indicated by process block <b>374</b>.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 3E</figref> illustrates a process used in one embodiment to delete a particular entry. Processing begins with process block <b>380</b>, and proceeds to process block <b>382</b>, wherein a value is received. A lookup operation is performed on this value, such as via the process illustrated in <figref idref="DRAWINGS">FIG. 3D</figref>. As determined in process block <b>384</b>, if the received result matches the item desired to be deleted, then, in process block <b>386</b>, the corresponding associative memory entry or entries are deleted. Processing is complete as indicated by process block <b>388</b>.</p>
<p id="p-0041" num="0040">These and other constructs can be used to maintain and use trees and other data structures. <figref idref="DRAWINGS">FIG. 4A</figref> illustrates an example of a tree <b>400</b> stored in one embodiment assigning prefixes to associative memory classes based on a value of a last bit of each prefix. In one embodiment, tree <b>400</b> is converted to a Patricia tree <b>402</b>. Data structure <b>403</b>, used in one embodiment in programming one or more associative memories, illustrates corresponding class identifiers, prefixes, and children nodes.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 4B</figref> illustrates configurations of associative memories <b>410</b> and <b>414</b> and memories <b>412</b> and <b>416</b> used in one embodiment, and associative memory <b>420</b> and memory <b>424</b> used in one embodiment. Associative memory <b>410</b> is used to store a prefix corresponding to a class zero child edge of prefix P in entry <b>411</b>, and corresponding right child <b>412</b>A and data element flag <b>412</b>B in adjunct memory <b>412</b>. Associative memory <b>414</b> is used to store a prefix corresponding to a class one child edge of prefix P in entry <b>415</b>, and corresponding left child <b>416</b>A and data element flag <b>416</b>B in adjunct memory <b>416</b>.</p>
<p id="p-0043" num="0042">Associative memory <b>420</b> is used to store both class zero and class one associative memory entries, each having a class specific identifying vector. As illustrated, stored in entry <b>421</b> of associative memory <b>420</b> is the class zero edge of prefix P and its class zero identifier. At a corresponding location in adjunct memory <b>424</b> is the left child <b>425</b> of P and a data element flag <b>426</b>. Stored in entry <b>422</b> of associative memory <b>420</b> is the class one edge of prefix P and its class one identifier. At a corresponding location in adjunct memory <b>424</b> is the right child <b>427</b> of P and a data element flag <b>428</b>.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 4C</figref> illustrates a process used in one embodiment to search a Patricia tree to return the element with key P if it is present in the Patricia tree, otherwise it returns one of its neighboring elements in the sorted order. Processing begins with process block <b>430</b>, and proceeds to process block <b>432</b>, wherein a node P identifier is received. Next, in process block <b>434</b>, a lookup word containing P padded with ones is formed, and a lookup operation performed on the class zero entries. In process block <b>436</b>, a lookup word containing P padded with zeros is formed, and a lookup operation performed on the class one entries. In process block <b>438</b>, the longer of these two results is returned. Processing is complete as indicated by process block <b>439</b>.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 4D</figref> illustrates a process used in one embodiment to locate a parent of a prefix P. Processing begins with process block <b>440</b>, and proceeds to process block <b>442</b>, wherein the node P identifier is received. Next, in process block <b>444</b>, Q is set to the value of P without its last bit. Next, in process block <b>446</b>, a lookup word containing Q padded with ones is formed, and a lookup operation performed on the class zero entries. In process block <b>447</b>, a lookup word containing Q padded with zeros is formed, and a lookup operation performed on the class one entries. In process block <b>448</b>, the longer of these two results is returned. Processing is complete as indicated by process block <b>449</b>.</p>
<p id="p-0046" num="0045">To insert a prefix P in the Patricia tree, basically, in one embodiment, first a Patricia search is performed on the prefix P to be inserted to obtain V. This means while walking from the root to P, the last edge of the tree that was encountered is the edge just above V. To insert P, a new internal node U, which is essentially the longest common prefix of P and V, is created. To create this new internal node U, two entries, U<b>0</b>* and U<b>1</b>*, are inserted into the associative memory. However, if U is directly on the edge above V, then U has only one child namely V. In that case, only one of the entries U<b>0</b>* or U<b>1</b>* is inserted. So, U<b>0</b>* is inserted only if P or V matches U<b>0</b>*. Similarly, U<b>1</b>* is inserted only if P or V matches U<b>1</b>*.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 4E</figref> illustrates a process used in one embodiment to insert a prefix P in the Patricia tree. Processing begins with process block <b>450</b>, and proceeds to process block <b>452</b>, wherein the node P identifier is received. Next, in process block <b>454</b>, V is set to the value returned by a Patricia search operation, such as that illustrated in <figref idref="DRAWINGS">FIG. 4C</figref>, on the node P. In process block <b>456</b>, the variable U is set to the longest common prefix of P and V.</p>
<p id="p-0048" num="0047">Next, as determined in process block <b>458</b>, if V or P is a zero extension of U, then in process block <b>460</b>, the prefix U<b>0</b>* is inserted as a data element. Then, as determined in process block <b>462</b>, if V is a zero extension of U, then in process block <b>463</b> V is assigned to the child of U<b>0</b>; otherwise, in process block <b>464</b>, P is assigned to the child of U<b>0</b>.</p>
<p id="p-0049" num="0048">Next, as determined in process block <b>466</b>, if V or P is a one extension of U, then in process block <b>468</b>, the prefix U<b>1</b>* is inserted as a data element. Then, as determined in process block <b>470</b>, if V is a one extension of U, then in process block <b>471</b> V is assigned to the child of U<b>1</b>; otherwise, in process block <b>472</b>, P is assigned to the child of U<b>1</b>.</p>
<p id="p-0050" num="0049">Next, in process block <b>474</b>, Q set to the value returned by a locate parent operation, such as by that illustrated in <figref idref="DRAWINGS">FIG. 4D</figref>, of U. In process block <b>476</b>, the child of Q is set to U. Processing is complete as indicated by process block <b>479</b>.</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 4F</figref> illustrates a process used in one embodiment to delete a node. Processing begins with process block <b>480</b>, and proceeds to process block <b>482</b>, wherein an identifier of node P is received. Next, in process block <b>484</b>, U is set to the value returned by a Patricia search operation, such as that illustrated in <figref idref="DRAWINGS">FIG. 4C</figref>, on P. As determined in process block <b>486</b>, if both P<b>0</b> and P<b>1</b> are present in the associative memory or memories, then in process block <b>487</b>, P is marked as a non-data element. Otherwise, as determined in process block <b>488</b>, if only one of P<b>0</b> or P<b>1</b> is present, then in process block <b>489</b>, the child of U is set to the child of the present node and the present node is removed from the associative memory or memories.</p>
<p id="p-0052" num="0051">Otherwise, in process block <b>490</b>, U is deleted from the associative memory or memories. In process block <b>492</b>, V is set to the location of the parent of V, such as that derived using the process illustrated in <figref idref="DRAWINGS">FIG. 4D</figref>. As determined in process block <b>494</b>, if the child of V is not a data element, then in process block <b>496</b>, the sibling of U, if present, is deleted, and the child of V is updated to be the child of the sibling of U. Processing is complete as indicated by process block <b>499</b>.</p>
<p id="p-0053" num="0052">In view of the many possible embodiments to which the principles of our invention may be applied, it will be appreciated that the embodiments and aspects thereof described herein with respect to the drawings/figures are only illustrative and should not be taken as limiting the scope of the invention. For example and as would be apparent to one skilled in the art, many of the process block operations can be re-ordered to be performed before, after, or substantially concurrent with other operations. Also, many different forms of data structures could be used in various embodiments. The invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprising:
<claim-text>determining a state of a last bit of a storage prefix to be stored in an entry of a class zero associative memory or a class one associative memory;</claim-text>
<claim-text>providing the storage prefix to the class zero associative memory for storage therein if the state was determined to be a zero, or to the class one associative memory for storage therein if the state was determined to be a one; and</claim-text>
<claim-text>receiving a lookup prefix;</claim-text>
<claim-text>determining a value of a last bit of the lookup prefix; and</claim-text>
<claim-text>padding the lookup prefix with each of any remaining bit positions of an associative memory lookup word padded with either (a) ones to the class zero associative memory or (b) zeros to the class one associative memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, comprising initiating a lookup operation using said padded associative memory lookup word on (a) the class zero associative memory if the value is zero or (b) the class one associative memory if the value is one.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, comprising receiving a lookup result indicating the position of the storage prefix.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the storage prefix equals the lookup prefix.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, comprising:
<claim-text>storing a right child prefix of the prefix in a first memory entry; and</claim-text>
<claim-text>storing a left child prefix of the prefix in a second memory entry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, comprising storing a first data element identifier corresponding to the right child prefix; and
<claim-text>storing a second data element identifier corresponding to the left child prefix.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A method comprising:
<claim-text>determining a state of a last bit of a storage prefix to be stored in an entry of an associative memory;</claim-text>
<claim-text>providing to the associative memory the storage prefix and a class identifier of either (a) a first state if the state was determined to be a zero or (b) a second state if the state was determined to be a one; and</claim-text>
<claim-text>receiving a lookup prefix;</claim-text>
<claim-text>determining a value of a last bit of the lookup prefix; and</claim-text>
<claim-text>providing, in order to identify a matching position in the associative memory, to the associative memory as its lookup word either: (a) if the value was determined to be zero, the class identifier having the first state and the lookup prefix with each of any remaining bit positions of an associative memory lookup word padded with ones, or (b) if the value was determined to be one, the class identifier having the second state and the lookup prefix with each of any remaining bit positions of the associative memory lookup word padded with zeros.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the storage prefix equals the lookup prefix.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:
<claim-text>storing a right child prefix of the prefix in a first memory entry; and</claim-text>
<claim-text>storing a left child prefix of the prefix in a second memory entry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising storing a first data element identifier corresponding to the right child prefix; and
<claim-text>storing a second data element identifier corresponding to the left child prefix.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. An apparatus comprising:
<claim-text>a class zero associative memory including a plurality of class zero associative memory entries, each of the plurality of class zero associative memory entries including a prefix ending in zero;</claim-text>
<claim-text>a class one associative memory including a plurality of class one associative memory entries, each of the plurality of class one associative memory entries including a prefix ending in one;</claim-text>
<claim-text>control logic, coupled to the class zero and the class one associative memory memories, the control logic configured to receive a lookup prefix, to determine a value of a last bit of the lookup prefix, to generate a lookup word including the lookup prefix with each of any remaining bit positions padded with either ones if the value is zero or zeros if the value is one, and to initiate a lookup operation on the class zero associative memory using the lookup word if the value is zero, or to initiate a lookup operation on the class one associative memory using the lookup word if the value is one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The apparatus of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:
<claim-text>a class zero memory coupled to the class zero associative memory; and</claim-text>
<claim-text>a class one memory coupled to the class one associative memory;</claim-text>
<claim-text>wherein prefixes stored in the class zero and class one associative memory entries correspond to edges of a tree, and the control logic is further configured to store a left child of a particular one of said prefixes in the class zero memory and a right child of the particular one of said prefixes in the class one memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The apparatus of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the class zero memory includes a left child data element identifier corresponding to the left child; and
<claim-text>wherein the class one memory includes a right child data element identifier corresponding to the right child.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The apparatus of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the tree is a Patricia tree.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. An apparatus comprising:
<claim-text>means for determining a state of a last bit of a storage prefix to be stored in an entry of a class zero associative memory or a class one associative memory;</claim-text>
<claim-text>means for providing the storage prefix to the class zero associative memory for storage therein if the state was determined to be a zero, or to the class one associative memory for storage therein if the state was determined to be a one; and</claim-text>
<claim-text>means for receiving a lookup prefix;</claim-text>
<claim-text>means for determining a value of a last bit of the lookup prefix; and</claim-text>
<claim-text>means for padding the lookup prefix with each of any remaining bit positions of an associative memory lookup word padded with either (a) ones to the class zero associative memory or (b) zeros to the class one associative memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The apparatus of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising means for initiating a lookup operation on (a) the class zero associative memory if the value is zero or (b) the class one associative memory if the value is one.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The apparatus of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein a plurality of entries stored in the class zero and class one associative memories comprise a tree; and
<claim-text>wherein the apparatus further comprises means for storing children prefixes of the prefix in one or more memories.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising means for storing data elements corresponding to said children prefixes.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising means for searching for a particular node of the tree stored in the class zero or class one associative memory.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising means for locating a parent prefix of one of said children prefixes.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising means for inserting a particular node in the tree.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising means for deleting a particular node from the tree.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the tree is a Patricia tree.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. An apparatus comprising:
<claim-text>an associative memory including a plurality of class zero entries and a plurality of class one entries, each of the class zero entries including a class zero identifier and a prefix ending in zero, each of the class one entries including a class one identifier and a prefix ending in one; and</claim-text>
<claim-text>control logic coupled to the associative memory;</claim-text>
<claim-text>wherein the control logic is configured to receive a lookup prefix, to determine a value of a last bit of the lookup prefix, and to generate a lookup word including (a) if the value was determined to be zero, the class zero identifier and the lookup prefix with each of any remaining bit positions of an associative memory lookup word padded with ones, or (b) if the value was determined to be one, the class one identifier and the lookup prefix with each of any remaining bit positions of the associative memory lookup word padded with zeros.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The apparatus of <claim-ref idref="CLM-00024">claim 24</claim-ref>, further comprising a memory coupled to the associative memory; and
<claim-text>wherein prefixes stored in the class zero and class one entries correspond to edges of a tree, and the control logic is further configured to store a left child of a particular one of said prefixes in the memory in a position corresponding to a class zero entry, and a right child of the particular one of said prefixes in a second position corresponding to a class one entry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The apparatus of <claim-ref idref="CLM-00025">claim 25</claim-ref>, where the memory includes a data element identifier for each child stored therein.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The apparatus of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the tree is a Patricia tree.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. An apparatus comprising:
<claim-text>means for determining a state of a last bit of a storage prefix to be stored in an entry of an associative memory;</claim-text>
<claim-text>means for providing to the associative memory the storage prefix and a class identifier of either (a) a first state if the state was determined to be a zero or (b) a second state if the state was determined to be a one; and</claim-text>
<claim-text>means for receiving a lookup prefix;</claim-text>
<claim-text>means for determining a value of a last bit of the lookup prefix; and</claim-text>
<claim-text>means for providing, in order to identify a matching position in the associative memory, to the associative memory as its lookup word either: (a) if the value was determined to be zero, the class identifier having the first state and the lookup prefix with each of any remaining bit positions of an associative memory lookup word padded with ones, or (b) if the value was determined to be one, the class identifier having the second state and the lookup prefix with each of any remaining bit positions of the associative memory lookup word padded with zeros.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the matching position is the position of the storage prefix when the storage prefix equals the lookup prefix.</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The apparatus of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein a plurality of entries stored in the class zero and class one associative memories comprise a tree; and
<claim-text>wherein the apparatus further comprises means for storing children prefixes of the prefix in one or more memories.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The apparatus of <claim-ref idref="CLM-00030">claim 30</claim-ref>, further comprising means for storing data elements corresponding to said children prefixes.</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The apparatus of <claim-ref idref="CLM-00031">claim 31</claim-ref>, further comprising means for searching for a particular node of the tree stored in the class zero or class one associative memory.</claim-text>
</claim>
<claim id="CLM-00033" num="00033">
<claim-text>33. The apparatus of <claim-ref idref="CLM-00031">claim 31</claim-ref>, further comprising means for locating a parent prefix of one of said children prefixes.</claim-text>
</claim>
<claim id="CLM-00034" num="00034">
<claim-text>34. The apparatus of <claim-ref idref="CLM-00031">claim 31</claim-ref>, further comprising means for inserting a particular node in the tree.</claim-text>
</claim>
<claim id="CLM-00035" num="00035">
<claim-text>35. The apparatus of <claim-ref idref="CLM-00031">claim 31</claim-ref>, further comprising means for deleting a particular node from the tree.</claim-text>
</claim>
<claim id="CLM-00036" num="00036">
<claim-text>36. The apparatus of <claim-ref idref="CLM-00030">claim 30</claim-ref>, wherein the tree is a Patricia tree.</claim-text>
</claim>
<claim id="CLM-00037" num="00037">
<claim-text>37. A method for use with one or more associative memories including a plurality of class zero associative memory entries and a plurality of class one associative memory entries, the method comprising
<claim-text>storing a storage prefix in an entry of: (a) the plurality of class zero associative memory entries if the last bit of the storage prefix is a zero, or (b) the plurality of class one associative memory entries if the last bit of the storage prefix is a one; and</claim-text>
<claim-text>performing a longest matching prefix operation, in order to identify a position of the storage prefix subsequent to said storing operation, on either: (a) the class zero associative memory entries with a lookup word including the storage prefix padded with ones if the last bit of the storage prefix is zero, or (b) the class one associative memory entries with a lookup word including the storage prefix padded with zeros if the last bit of the storage prefix is one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00038" num="00038">
<claim-text>38. The method of <claim-ref idref="CLM-00037">claim 37</claim-ref>, wherein each of said one or more associative memories are a ternary content-addressable memory (TCAM); and wherein the storage prefix is stored in the plurality of class zero associative memory entries or in the plurality of class one associative memory entries in a position based on the length of the storage prefix.</claim-text>
</claim>
<claim id="CLM-00039" num="00039">
<claim-text>39. An apparatus comprising one or more processors and memory, wherein the memory stores one or more instructions that, when executed by said one or more processors, perform operations for use with one or more associative memories including a plurality of class zero associative memory entries and a plurality of class one associative memory entries, said operations comprising:
<claim-text>storing a storage prefix in an entry of: (a) the plurality of class zero associative memory entries if the last bit of the storage prefix is a zero, or (b) the plurality of class one associative memory entries if the last bit of the storage prefix is a one; and</claim-text>
<claim-text>performing a longest matching prefix operation, in order to identify a position of the storage prefix subsequent to said storing operation, on either: (a) the class zero associative memory entries with a lookup word including the storage prefix padded with ones if the last bit of the storage prefix is zero, or (b) the class one associative memory entries with a lookup word including the storage prefix padded with zeros if the last bit of the storage prefix is one.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
